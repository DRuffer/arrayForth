
[ASM HEX BITS-32
200000  ORG

BITS-16
\ This code actually starts running at 0x7C00   
( 00200000 )   :Boot0    JMPS, Boot1 RB, 
BITS-32
( 00200002 )   :SectorsPerTrack   dw 0000 
\ 0B40 = 2880 512-byte sectors = 1.44MB floppy   
( 00200004 )   :SectorsToLoad   dw 01F6 
( 00200006 )   :UnusedStore   dw 0000 
( 00200008 )   :NumberOfHeads   dw 0000 
( 0020000A )   :BootDrive   dw 0000 \ e.g. 80 is DOS C:, 01 is floppy B:
( 0020000C )   :LoadCX   dw 0000 
( 0020000E )   :CylindersAndSectors   dw 0000 
( 00200010 )   :StoreForDump   dw 0000 
( 00200012 )   :ScreenLoc   dw 0000 

( 00200014 )   :HexTable   d$  " 0123456789ABCDEF"

( 00200024 )   :RelocateGdt   dw 0000 0000 0000 0000 0000 0000 0000 0000 
( 00200034 )                 dw FFFF F000 9300 0000 FFFF 0000 9320 0000 
( 00200044 )                 dw 0000 0000 0000 0000 0000 0000 0000 0000 

BITS-16
( 00200054 )   :Relocate    PUSH|ALL, \ called with di = start of bootblock
( 00200055 )                  PUSH|ES, 
( 00200056 )                  MOVI|X, CX| 0200 IW, \ number of words to copy
( 00200059 )                  MOV, X| T| SI'| R| DI| 
\ point si to GDT for extended memory copy   
( 0020005B )                  ADDSI, R| SI| 24 IS, 
( 0020005E )                  XOR, X| T| AX'| R| AX| 
( 00200060 )                  MOV|SG, T| ES| R| AX| 
\ int 15 ah=87 copy extended memory   
( 00200062 )                  MOVI|B, AH| 87 IB, 
( 00200064 )                  INT, 15 IB, 
( 00200066 )                  XOR, X| T| AX'| R| AX| 
\ adjust low word of destination addr upwards   
( 00200068 )                  ADDI, X| BO| [DI]% 3E B, 0200 IW, 
\ add any carry to 3rd byte of destination   
( 0020006D )                  ADC, B| F| AL'| BO| [DI]% 40 B, 
( 00200070 )                  POP|ES, 
( 00200071 )                  POP|ALL, 
\ so adding 200 will bring it to zero   
( 00200072 )                  MOVI|X, BX| FE00 IW, 
( 00200075 )                  RET, 
( 00200076 )   :Boot1    JMPS, BootStart RB, 
( 00200078 )   :DumpToScreen    PUSH|ES, 
( 00200079 )                  PUSH|X, AX| 
( 0020007A )                  PUSH|X, CX| 
( 0020007B )                  PUSH|X, SI| 
( 0020007C )                  MOVI|X, AX| B800 IW, \ = video RAM (text mode)
( 0020007F )                  MOV|SG, T| ES| R| AX| 
( 00200081 )                  MOVI|X, CX| 4 IW, \ loop count
( 00200084 )   :DTSLoop    XOR, X| T| AX'| R| AX| 
( 00200086 )                  MOV, B| T| AL'| BO| [DI]% 11 B, \ high byte
( 00200089 )                  SHR, 1| X| R| AX| \ shift right to get high nybble
( 0020008B )                  SHR, 1| X| R| AX| 
( 0020008D )                  SHR, 1| X| R| AX| 
( 0020008F )                  SHR, 1| X| R| AX| 
( 00200091 )                  MOV, X| T| SI'| R| AX| 
( 00200093 )                  ADD, X| T| SI'| R| DI| 
( 00200095 )                  MOV, B| T| AL'| BO| [SI]% 14 B, \ index HexTable
\ load si with next screen location   
( 00200098 )                  MOV, X| T| SI'| BO| [DI]% 12 B, 
( 0020009B )                  ES:, 
( 0020009C )                  MOV, B| F| AL'| ZO| [SI]% \ write to screen
\ point to next screen location (odd byte is attribute)   
( 0020009E )                  ADDSI, BO| [DI]% 12 B, 2 IS, 
( 002000A2 )                  ANDI, X| BO| [DI]% 12 B, 07FF IW, \ keep on-screen
\ shift entire word to be displayed left 4 bits   
( 002000A7 )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000AA )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000AD )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000B0 )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000B3 )                  LOOP, DTSLoop RB, \ until word has been dumped
\ leave a space before next word is dumped   
( 002000B5 )                  ADDSI, BO| [DI]% 12 B, 2 IS, 
( 002000B9 )                  POP|X, SI| 
( 002000BA )                  POP|X, CX| 
( 002000BB )                  POP|X, AX| 
( 002000BC )                  POP|ES, 
( 002000BD )                  RET, 
\ boot starts here after two jumps   
( 002000BE )   :BootStart    SUB, X| T| DI'| R| DI| 
( 002000C0 )                  MOV|SG, T| DS| R| DI| \ zero out both DS and
( 002000C2 )                  MOV|SG, T| ES| R| DI| \ ES segment registers
( 002000C4 )                  MOVI|X, DI| 7C00 IW, 
( 002000C7 )                  STI, 
\ dl contains boot disk number,
\ see http://tldp.org/LDP/lki/lki-1.html   
( 002000C8 )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
( 002000CB )                  CALL, DumpToScreen RW, 
( 002000CE )                  OR, B| F| DL'| BO| [DI]% 0A B, 
( 002000D1 )                  MOV, B| T| DL'| BO| [DI]% 0A B, 
\ int 13 ah=08 read drive parameters   
( 002000D4 )                  MOVI|B, AH| 8 IB, 
( 002000D6 )                  PUSH|X, DI| \ does it mess with di?
( 002000D7 )                  INT, 13 IB, 
( 002000D9 )                  POP|X, DI| 
\ after BIOS call, dh is 0-based index of last head   
( 002000DA )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
( 002000DD )                  CALL, DumpToScreen RW, 
( 002000E0 )                  INC, B| R| DH| \ add 1 to get number of heads
\ store number of heads   
( 002000E2 )                  MOV, B| F| DH'| BO| [DI]% 8 B, 
( 002000E5 )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
\ dump number of heads in high byte   
( 002000E8 )                  CALL, DumpToScreen RW, 
\ after BIOS call, low 6 bits of cx are 1-based last track index,
\ high 10 bits 0-based last cylinder index   
( 002000EB )                  MOV, X| F| CX'| BO| [DI]% 10 B, 
( 002000EE )                  CALL, DumpToScreen RW, 
\ store number of cylinders and sectors   
( 002000F1 )                  MOV, X| F| CX'| BO| [DI]% 0E B, 
\ extract sectors per track   
( 002000F4 )                  ANDI, B| R| CL| 3F IB, 
\ store sectors per track   
( 002000F7 )                  MOV, B| F| CL'| BO| [DI]% 2 B, 
\ dump sectors per track (low byte)   
( 002000FA )                  MOV, X| F| CX'| BO| [DI]% 10 B, 
( 002000FD )                  CALL, DumpToScreen RW, 
\ es:bx is buffer address, adding 200 to FE00 zeroes bx   
( 00200100 )                  MOVI|X, BX| FE00 IW, 
\ ch=track, cl=sector to read   
( 00200103 )                  MOV, X| T| CX'| BO| [DI]% 0C B, 
\ dh=head, dl=drive to read   
( 00200106 )                  MOV, X| T| DX'| BO| [DI]% 0A B, 
\ total number of sectors to read   
( 00200109 )                  MOV, X| T| SI'| BO| [DI]% 4 B, 
( 0020010C )                  MOVI|X, AX| 0F00 IW, 
\ store sector data starting at F000   
( 0020010F )                  MOV|SG, T| ES| R| AX| 
( 00200111 )                  STI, 
\ have we reached number of sectors per track?   
( 00200112 )   :ReadCylinder    CMP, B| T| CL'| BO| [DI]% 2 B, 
( 00200115 )                  J, Z| N| ReadSector RB, \ continue if not, else...
( 00200117 )                  INC, B| R| DH| \ next head
( 00200119 )                  CMP, B| T| DH'| BO| [DI]% 8 B, \ reached # heads?
( 0020011C )                  J, Z| N| ReadTrack RB, \ continue if not, else...
( 0020011E )                  XOR, B| T| DH'| R| DH| \ back to head 0
( 00200120 )                  ADDI, B| R| CH| 1 IB, \ next track
\ start with first sector (only low 6 bits matter)   
( 00200123 )   :ReadTrack    ANDI, B| R| CL| 0C0 IB, 
\ next sector: sector is 1-based, so must be nonzero   
( 00200126 )   :ReadSector    INC|X, CX| 
\ es:bx is buffer address pointer for BIOS call   
( 00200127 )                  ADDI, X| R| BX| 0200 IW, 
\ int 13 ah=02 read sectors from drive   
( 0020012B )                  MOVI|X, AX| 0201 IW, 
( 0020012E )                  INT, 13 IB, 
\ ah=error code, al=actual number of sectors read   
( 00200130 )                  MOV, X| F| AX'| BO| [DI]% 10 B, 
\ check no error, and one sector read   
( 00200133 )                  DEC|X, AX| 
\ if all OK, just continue   
( 00200134 )                  J, Z| Y| NextSector RB, 
\ otherwise, show problem on screen   
( 00200136 )                  CALL, DumpToScreen RW, 
\ Relocate has side effect of resetting buffer address bx to zero   
( 00200139 )   :NextSector    CALL, Relocate RW, 
( 0020013C )                  DEC|X, SI| 
( 0020013D )                  J, Z| N| ReadCylinder RB, 
\ done loading colorForth, set es back to zero   
( 0020013F )                  XOR, X| T| AX'| R| AX| 
( 00200141 )                  MOV|SG, T| ES| R| AX| 
\ 3FB is Line Control Register (LCR) of first serial port   
( 00200143 )                  MOVI|X, DX| 03FB IW, 
\ 03 sets word length to 8 bits,
\ 80 sets ports 3F8 and 3F9 to be the baud rate divisor   
( 00200146 )                  MOVI|B, AL| 83 IB, 
( 00200148 )                  OUT|D, B'| 
\ divisor 03 sets baud rate to 38400,
\ see http://www.pelletiernet.com/helppc/8250.html   
( 00200149 )                  MOVI|B, AL| 3 IB, 
( 0020014B )                  SUBI, B| R| DL| 3 IB, \ LSBs of divisor
( 0020014E )                  OUT|D, B'| 
( 0020014F )                  XOR, X| T| AX'| R| AX| \ MSBs are 0
( 00200151 )                  INC|X, DX| \ MSBs of divisor
( 00200152 )                  OUT|D, B'| 
( 00200153 )                  MOVI|B, AL| 3 IB, \ word length 8 bits (again)
( 00200155 )                  ADDI, B| R| DL| 2 IB, \ point to LCR
\ clear bit 7, now we've set the baud rate;
\ this allows us to use 3F8 and 3F9 as transmit/receive buffer
\ and Interrupt Enable register (IER), respectively   
( 00200158 )                  OUT|D, B'| 
\ zero all interrupt-enable bits   
( 00200159 )                  XOR, X| T| AX'| R| AX| 
( 0020015B )                  SUBI, B| R| DL| 2 IB, \ point to 3F9, IER
( 0020015E )                  OUT|D, B'| \ disable all serial port interrupts
\ enable RTS (bit 1) and DTR (bit 0)   
( 0020015F )                  MOVI|B, AL| 3 IB, 
\ point dx to Modem Control Register (MCR)   
( 00200161 )                  ADDI, B| R| DL| 3 IB, 
( 00200164 )                  OUT|D, B'| \ set the bits
( 00200165 )                  JMPS, SetVideoMode RB, 
BITS-32
( 00200167 )                 db 0 

( 00200168 )   :GdtStruct   dw 0017 7D70 0000 0000 0000 0000 0000 0000 
( 00200178 )                 dw FFFF 0000 9A00 00CF FFFF 0000 9200 00CF 

BITS-16
\ int 10 ax=4f02 set supervga video mode   
( 00200188 )   :SetVideoMode    MOVI|X, AX| 4F02 IW, 
\ 118 means 1024x768 pixels at 24 bits per pixel,
\ 4000 sets linear framebuffer:
\ http://en.wikipedia.org/wiki/VESA_BIOS_Extensions   
( 0020018B )                  MOVI|X, BX| 4118 IW, 
( 0020018E )                  INT, 10 IB, 
( 00200190 )                  CLI, 
\ size override allows us to use 32-bit registers in real mode   
( 00200191 )                  OS:, 
( 00200192 )                  XOR, X| T| AX'| R| AX| 
( 00200194 )                  OS:, 
( 00200195 )                  MOV, X| T| BX'| R| AX| 
\ zero out segment registers cs, ds, es   
( 00200197 )                  MOV|SG, F| CS| R| BX| 
( 00200199 )                  MOV|SG, T| DS| R| BX| 
( 0020019B )                  MOV|SG, T| ES| R| AX| 
( 0020019D )                  OS:, 
\ zero out registers esi and edi   
( 0020019E )                  MOV, X| T| DI'| R| AX| 
( 002001A0 )                  OS:, 
( 002001A1 )                  MOV, X| T| SI'| R| AX| 
( 002001A3 )                  MOV|SG, T| DS| R| AX| 
\ load Global Descriptor Table   
( 002001A5 )                  LGDT, MEM|% 7D68 W, \ actually GdtStruct
( 002001AA )                  MOVI|B, AL| 1 IB, 
\ see http://en.wikipedia.org/wiki/Protected_mode   
( 002001AC )                  MOV|CD, T| CR0| AX| \ set PE bit
\ selector of 8 points cs to executable segment descriptor   
( 002001AF )                  JMPFAR, 7DB4 W, 8 SG, 
BITS-32
\ now we are in Protected Mode (PM)   
( 002001B4 )   :Start32    JMPS, SetupDataSegments RB, 
( 002001B6 )   :SendSerial    PUSH|X, AX| 
( 002001B7 )                  PUSH|X, DX| 
\ fetch byte pointed to by stack return pointer   
( 002001B8 )                  MOV, X| T| DX'| BO|    [SP +1* 0] 8 B, 
( 002001BC )                  MOV, B| T| AL'| ZO| [DX] 
( 002001BE )                  MOVI|X, DX| 03F8 IL, 
( 002001C3 )                  OUT|D, B'| \ send through serial port
( 002001C4 )                  POP|X, DX| 
( 002001C5 )                  POP|X, AX| 
\ real return address is one past data byte pointer   
( 002001C6 )                  INC, X| ZO|    [SP +1* 0] 
( 002001C9 )                  RET, 
\ selector 10 points to segment descriptor
\ with executable bit cleared   
( 002001CA )   :SetupDataSegments    MOVI|B, AL| 10 IB, 
( 002001CC )                  MOV|SG, T| DS| R| AX| 
( 002001CE )                  MOV|SG, T| ES| R| AX| 
( 002001D0 )                  MOV|SG, T| SS| R| AX| 
( 002001D2 )                  MOVI|X, SP| 000A0000 IL, \ set top of stack
( 002001D7 )                  XOR, X| T| CX'| R| CX| 
\ see http://www.win.tue.nl/~aeb/linux/kbd/A20.html   
( 002001D9 )                  MOVI|B, AL| 0D1 IB, \ enable address line 20
\ this just tells the keyboard controller we want to write to it   
( 002001DB )                  OUT|P, B'| 64 P, 
\ busy-wait until keyboard controller ready   
( 002001DD )   :WaitKbdReady    IN|P, B'| 64 P, 
( 002001DF )                  ANDI|A, B'| 2 IB, 
( 002001E1 )                  J, Z| N| WaitKbdReady RB, 
\ bit 1 (value 02) is set to enable A20 address line   
( 002001E3 )                  MOVI|B, AL| 4B IB, 
( 002001E5 )                  OUT|P, B'| 60 P, 
( 002001E7 )                  MOVI|X, SI| 0009F400 IL, \ set esi to 9F400
( 002001EC )                  CALL, SendSerial RL, 
\ send ASCII 'A' through serial port   
( 002001F1 )                 d$  " A"

\ by this point, all code has been relocated to 0x200000   
( 002001F2 )                  MOVI|X, DI| Init0 IL, 
( 002001F7 )                  JMPO, R| DI| 
( 002001F9 )                 db 0 0 0 0 0 55 0AA 

( 00200200 )   :Init0    JMPS, Init1 RB, 
\ see http://www.kwant.info/howto/mirror/ser-tr.html   
( 00200202 )   :SerialOut    PUSH|X, AX| 
( 00200203 )                  PUSH|X, DX| 
\ first serial port's Line Status Register [LSR]   
( 00200204 )                  MOVI|X, DX| 03FD IL, 
( 00200209 )   :SOWaitReady    IN|D, B'| 
\ check THRE, Transmitter Holding Register Empty   
( 0020020A )                  TESTI|A, B'| 20 IB, 
( 0020020C )                  J, Z| Y| SOWaitReady RB, 
\ now point to 03F8, transmit/receive buffer   
( 0020020E )                  SUBI, B| R| DL| 5 IB, 
\ fetch return address from stack   
( 00200211 )                  MOV, X| T| AX'| BO|    [SP +1* 0] 8 B, 
\ retrieve byte at return address   
( 00200215 )                  MOV, B| T| AL'| ZO| [AX] 
( 00200217 )                  OUT|D, B'| \ send the byte out serial line
( 00200218 )                  POP|X, DX| 
( 00200219 )                  POP|X, AX| 
\ adjust return address to the opcode following data byte   
( 0020021A )                  INC, X| ZO|    [SP +1* 0] 
( 0020021D )                  RET, 
\ same as SerialOut but uses byte in AL instead of from stack   
( 0020021E )   :SerialOutAL    PUSH|X, DX| 
( 0020021F )                  PUSH|X, AX| 
( 00200220 )                  MOVI|X, DX| 03FD IL, \ serial port address
( 00200225 )   :SOAWaitReady    IN|D, B'| 
( 00200226 )                  TESTI|A, B'| 20 IB, 
( 00200228 )                  J, Z| Y| SOAWaitReady RB, 
( 0020022A )                  SUBI, B| R| DL| 5 IB, 
( 0020022D )                  POP|X, AX| 
( 0020022E )                  OUT|D, B'| 
( 0020022F )                  POP|X, DX| 
( 00200230 )                  RET, 
\ convert word in eax to hexadecimal and send out serial port   
( 00200231 )   :SerialOutHexWord    PUSH|ALL, 
( 00200232 )                  MOVI|X, CX| 8 IL, 
( 00200237 )                  MOV, X| T| DX'| R| AX| 
\ rotate 4 MSBs into low nybble   
( 00200239 )   :SerialOutNybble    ROLI, X| R| DX| 4 IS, 
( 0020023C )                  MOV, X| T| AX'| R| DX| 
( 0020023E )                  ANDI|A, X'| 0F IL, \ mask off high bits
\ index into hexadecimal translation table binary->ASCII   
( 00200243 )                  MOV, B| T| AL'| XO| [AX] 7C14 L, 
( 00200249 )                  CALL, SerialOutAL RL, 
( 0020024E )                  LOOP, SerialOutNybble RB, 
\ follow output with a space   
( 00200250 )                  CALL, SerialOut RL, 
( 00200255 )                 d$  BL

( 00200256 )                  POP|ALL, 
\ load eax with next word from esi pointer, and increment pointer   
( 00200257 )                  LODS, X'| 
( 00200258 )                  RET, 
( 00200259 )   :Init1    JMPS, Initialize RB, 
\ send carriage return and linefeed out serial port   
( 0020025B )   :SerialOutCRLF    CALL, SerialOut RL, 
( 00200260 )                 d$  CTRL M

\ send linefeed out serial port   
( 00200261 )   :SerialOutLF    CALL, SerialOut RL, 
( 00200266 )                 d$  CTRL J

( 00200267 )                  RET, 
( 00200268 )   :X_serialDump    MOV, X| T| CX'| R| AX| 
( 0020026A )                  SHRI, X| R| CX| 2 IS, 
( 0020026D )                  LODS, X'| 
( 0020026E )                  MOV, X| T| DI'| R| AX| 
( 00200270 )                  XOR, X| T| DX'| R| DX| 
( 00200272 )   :X_serialDumpLoop    TESTI, B| R| DL| 0F IB, 
( 00200275 )                  J, Z| N| X_serialDump2 RB, 
( 00200277 )                  CALL, SerialOutCRLF RL, 
( 0020027C )                  MOV, X| T| AX'| R| DI| 
( 0020027E )                  ADD, X| T| AX'| R| DX| 
( 00200280 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200283 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200285 )                  CALL, SerialOutHexWord RL, 
( 0020028A )                  CALL, SerialOut RL, 
( 0020028F )                 d$  BL

( 00200290 )   :X_serialDump2    MOV, X| T| AX'| ZO|    [DI +1* DX] 
( 00200293 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200296 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200298 )                  CALL, SerialOutHexWord RL, 
( 0020029D )                  ADDSI, R| DX| 4 IS, 
( 002002A0 )                  LOOP, X_serialDumpLoop RB, 
( 002002A2 )                  CALL, SerialOutCRLF RL, 
( 002002A7 )                  LODS, X'| 
( 002002A8 )                  RET, 
\ this seems to be dead code, nothing calls it   
( 002002A9 )   :L002002A9    PUSH|ALL, 
( 002002AA )                  MOV, X| T| DI'| BO|    [SP +1* 0] 20 B, 
( 002002AE )                  LEA, SI'| BO| [SI] 0FC B, 
( 002002B1 )                  MOV, X| F| AX'| ZO| [SI] 
( 002002B3 )                  MOV, X| T| AX'| ZO| [DI] 
( 002002B5 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002002B8 )                  MOV, X| F| AX'| ZO| [SI] 
( 002002BA )                  MOV, X| T| AX'| BO| [DI] 4 B, 
( 002002BD )                  CALL, X_serialDump RL, 
( 002002C2 )                  POP|ALL, 
( 002002C3 )                  ADDSI, ZO|    [SP +1* 0] 8 IS, 
( 002002C7 )                  RET, 
( 002002C8 )   :Initialize    CALL, SerialOutCRLF RL, 
\ adding -4 to esi to push arg onto data stack   
( 002002CD )                  LEA, SI'| BO| [SI] 0FC B, 
\ though eax doesn't contain anything useful at this point   
( 002002D0 )                  MOV, X| F| AX'| ZO| [SI] 
\ checking SerialOutHexWord before sending any real data   
( 002002D2 )                  MOVI|X, AX| 12345678 IL, 
( 002002D7 )                  CALL, SerialOutHexWord RL, 
( 002002DC )                  CALL, SerialOutCRLF RL, 
( 002002E1 )                  JMP, Start0 RL, 
( 002002E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002002F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200306 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200316 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200326 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200336 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200346 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200356 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200366 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200376 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200386 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200396 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003F6 )                 db 0 0 0 0 0 0 0 0 0 0 

( 00200400 )   :Start0    JMP, 1B12 (RL,) 
( 00200405 )                 d$  0  0  0  0E9  5  1B  0  0  0  0  0 
( 00200410 )   :Version   d$  " cmcf 4.2b-pd"

( 0020041C )   :X_pause    LEA, SI'| BO| [SI] 0FC B, 
( 0020041F )                  MOV, X| F| AX'| ZO| [SI] 
( 00200421 )                  PUSH|X, SI| 
( 00200422 )                  MOV|TA, X'| L00202800 L, 
( 00200427 )                  MOV, X| F| SP'| ZO| [AX] 
( 00200429 )                  ADDSI, R| AX| 4 IS, 
( 0020042C )                  JMPO, R| AX| 
( 0020042E )   :L0020042E    POP|X, AX| 
( 0020042F )                  MOV, X| T| SP'| ZO| [AX] 
( 00200431 )                  MOV|FA, X'| L00202800 L, 
( 00200436 )                  POP|X, SI| 
( 00200437 )                  LODS, X'| 
( 00200438 )                  RET, 
( 00200439 )   :X_pauseFixed    PUSH|X, DI| 
( 0020043A )                  CALL, X_pause RL, 
( 0020043F )                  POP|X, DI| 
( 00200440 )                  RET, 
( 00200441 )   :L00200441    CALL, L0020042E RL, 
( 00200445 )                 db 0FF 
( 00200446 )   :L00200446   db 0F8 0FF 9 0 

( 0020044A )   :L0020044A    CALL, L0020042E RL, 
( 0020044E )                 db 0FF 
( 0020044F )   :L0020044F   db 0F8 0DB 9 0 

( 00200453 )   :L00200453    CALL, L0020042E RL, 
( 00200457 )                 db 0FF 
( 00200458 )   :L00200458   db 0F8 0B7 9 0 

( 0020045C )   :L0020045C    JMPS, L00200441 RB, 
( 0020045E )   :L0020045E    MOVI|X, DX| 0009CFFC IL, 
( 00200463 )                  MOV, X| F| CX'| ZO| [DX] 
( 00200465 )                  MOVI|X, CX| 0009DBFC IL, 
( 0020046A )                  POP, ZO| [CX] 
( 0020046C )                  LEA, CX'| BO| [CX] 0FC B, 
( 0020046F )                  MOV, X| F| DX'| ZO| [CX] 
( 00200471 )                  MOV, X| F| CX'| MEM| L0020044F L, 
( 00200477 )                  RET, 
( 00200478 )   :L00200478    MOVI|X, DX| 0009ABFC IL, 
( 0020047D )                  MOV, X| F| CX'| ZO| [DX] 
( 0020047F )                  MOVI|X, CX| 0009B7FC IL, 
( 00200484 )                  POP, ZO| [CX] 
( 00200486 )                  LEA, CX'| BO| [CX] 0FC B, 
( 00200489 )                  MOV, X| F| DX'| ZO| [CX] 
( 0020048B )                  MOV, X| F| CX'| MEM| L00200458 L, 
( 00200491 )                  RET, 
( 00200492 )   :X_nul    RET, 
( 00200493 )   :X_show    POP, MEM| L00202804 L, 
( 00200499 )                  CALL, L0020045E RL, 
( 0020049E )   :L0020049E    CALLO, MEM| L0020280C L, 
( 002004A4 )                  CALLO, MEM| L00202804 L, 
( 002004AA )                  CALLO, MEM| L00202810 L, 
( 002004B0 )                  JMPS, L0020049E RB, 
( 002004B2 )   :L002004B2    CALL, X_show RL, 
( 002004B7 )                  RET, 
( 002004B8 )   :X_freeze    POP, MEM| L00202804 L, 
( 002004BE )                  CALL, L0020045E RL, 
( 002004C3 )                  CALLO, MEM| L00202804 L, 
( 002004C9 )                  JMPS, -8 (RB,) 
( 002004CB )   :X_serve    POP, MEM| L00202808 L, 
( 002004D1 )                  CALL, L00200478 RL, 
( 002004D6 )   :X_serveLoop    CALL, X_pauseFixed RL, 
( 002004DB )                  CALLO, MEM| L00202808 L, 
( 002004E1 )                  JMPS, X_serveLoop RB, 
( 002004E3 )   :L002004E3    CALL, X_serve RL, 
( 002004E8 )                  RET, 
( 002004E9 )   :X_c    MOVI|X, SI| 0009F404 IL, 
( 002004EE )                  RET, 
( 002004EF )   :X_mark    MOV, X| T| CX'| MEM| L002027BC L, 
( 002004F5 )                  MOV, X| F| CX'| MEM| L00202798 L, 
( 002004FB )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 00200501 )                  MOV, X| F| CX'| MEM| L0020279C L, 
( 00200507 )                  MOV, X| T| CX'| MEM| L002027A4 L, 
( 0020050D )                  MOV, X| F| CX'| MEM| L002027A0 L, 
( 00200513 )                  RET, 
( 00200514 )   :X_empt    MOV, X| T| CX'| MEM| L002027A0 L, 
( 0020051A )                  MOV, X| F| CX'| MEM| L002027A4 L, 
( 00200520 )                  MOV, X| T| CX'| MEM| L0020279C L, 
( 00200526 )                  MOV, X| F| CX'| MEM| ForthMacros L, 
( 0020052C )                  MOV, X| T| CX'| MEM| L00202798 L, 
( 00200532 )                  MOV, X| F| CX'| MEM| L002027BC L, 
( 00200538 )                  MOVI, X| MEM| L002027AC L, 0 IL, 
( 00200542 )                  RET, 
( 00200543 )   :L00200543    MOV, X| T| CX'| MEM| L002027BC L, 
( 00200549 )                  PUSH|X, DI| 
( 0020054A )                  LEA, DI'| ZO|    [MEM +4* CX] L0020283C L, 
( 00200551 )                  JMPS, L00200561 RB, 
( 00200553 )   :L00200553    MOV, X| T| CX'| MEM| ForthMacros L, 
( 00200559 )                  PUSH|X, DI| 
( 0020055A )                  LEA, DI'| ZO|    [MEM +4* CX] 004CFFFC L, 
( 00200561 )   :L00200561    STD, 
( 00200562 )                  REPNZ, 
( 00200563 )                  SCAS, X'| 
( 00200564 )                  CLD, 
( 00200565 )                  POP|X, DI| 
( 00200566 )                  RET, 
( 00200567 )   :X_abort    JMPO, MEM| L00202758 L, 
( 0020056D )   :X_drop    MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200573 )                  MOV, X| F| DX'| MEM| L002027B0 L, 
( 00200579 )                  MOVI, B| ZO| [DX] 0AD IB, 
( 0020057C )                  INC, X| MEM| L002027A4 L, 
( 00200582 )                  RET, 
( 00200583 )   :X_?dup    MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200589 )                  DEC|X, DX| 
( 0020058A )                  CMP, X| F| DX'| MEM| L002027B0 L, 
( 00200590 )                  J, Z| N| X_dup RB, 
( 00200592 )                  CMPI, B| ZO| [DX] 0AD IB, 
( 00200595 )                  J, Z| N| X_dup RB, 
( 00200597 )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 0020059D )                  RET, 
( 0020059E )   :X_dup    MOV, X| T| DX'| MEM| L002027A4 L, 
( 002005A4 )                  MOVI, X| ZO| [DX] 89FC768D IL, 
( 002005AA )                  MOVI, B| BO| [DX] 4 B, 6 IB, 
( 002005AE )                  ADDSI, MEM| L002027A4 L, 5 IS, 
( 002005B5 )                  RET, 
( 002005B6 )   :L002005B6    LEA, SI'| BO| [SI] 0FC B, 
( 002005B9 )                  MOV, X| F| AX'| ZO| [SI] 
( 002005BB )                  RET, 
( 002005BC )   :L002005BC    POP, MEM| L002027CC L, 
( 002005C2 )                  RET, 
( 002005C3 )   :X_macro    CALL, L002005BC RL, 
( 002005C8 )                  PUSH|X, AX| 
( 002005C9 )                  MOV, X| T| CX'| MEM| L002027BC L, 
( 002005CF )                  INC, X| MEM| L002027BC L, 
( 002005D5 )                  LEA, CX'| ZO|    [MEM +4* CX] 00202840 L, 
( 002005DC )                  MOVI|X, AX| 0218 IL, 
( 002005E1 )                  JMPS, L00200601 RB, 
( 002005E3 )   :X_forth    CALL, L002005BC RL, 
( 002005E8 )   :L002005E8    PUSH|X, AX| 
( 002005E9 )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 002005EF )                  INC, X| MEM| ForthMacros L, 
( 002005F5 )                  LEA, CX'| ZO|    [MEM +4* CX] 004D0000 L, 
( 002005FC )                  MOVI|X, AX| 2800 IL, 
( 00200601 )   :L00200601    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 00200608 )                  ANDSI, R| DX| 0F0 IS, 
( 0020060B )                  MOV, X| F| DX'| ZO| [CX] 
( 0020060D )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200613 )                  MOV, X| F| DX'| ZO|    [CX +1* AX] 
( 00200616 )                  LEA, DX'| ZO|    [CX +1* AX] 
( 00200619 )                  SHRI, X| R| DX| 2 IS, 
( 0020061C )                  MOV, X| F| DX'| MEM| L002027A8 L, 
( 00200622 )                  POP|X, AX| 
( 00200623 )                  MOV, X| F| SP'| MEM| L002027B0 L, 
( 00200629 )                  MOVI, X| MEM| L00202794 L, L002005B6 IL, 
( 00200633 )                  TESTI, X| MEM| L002027AC L, -1 IL, 
( 0020063D )                  J, Z| Y| L00200645 RB, 
( 0020063F )                  JMPO, MEM| L002027AC L, 
( 00200645 )   :L00200645    RET, 
( 00200646 )   :L00200646    LEA, SI'| BO| [SI] 0FC B, 
( 00200649 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020064B )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D0004 L, 
( 00200652 )                  RET, 
( 00200653 )   :L00200653    CALL, L002005E8 RL, 
( 00200658 )                  MOVI, X| XO| [CX] 2800 L, L00200646 IL, 
( 00200662 )                  INC, X| MEM| ForthMacros L, 
( 00200668 )                  MOV, X| F| DI'| BO| [CX] 4 B, 
( 0020066B )                  INC|X, DI| 
( 0020066C )                  RET, 
( 0020066D )   :L0020066D    MOVI, X| MEM| L00202794 L, L002005B6 IL, 
( 00200677 )   :L00200677    CALL, X_?dup RL, 
( 0020067C )                  MOV, X| T| DX'| MEM| L002027B0 L, 
( 00200682 )                  MOV, X| F| DX'| MEM| ForthWords L, 
( 00200688 )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 0020068E )                  MOV, X| F| DX'| MEM| L002027B0 L, 
( 00200694 )                  MOVI, B| ZO| [DX] 0B8 IB, 
( 00200697 )                  MOV, X| F| AX'| BO| [DX] 1 B, 
( 0020069A )                  ADDSI, MEM| L002027A4 L, 5 IS, 
( 002006A1 )                  RET, 
( 002006A2 )   :L002006A2    CALLO, MEM| L00202794 L, 
( 002006A8 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] 0 L, 
( 002006AF )                  INC|X, DI| 
( 002006B0 )                  JMPS, L002006C2 RB, 
( 002006B2 )   :L002006B2    CALLO, MEM| L00202794 L, 
( 002006B8 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002006BF )                  SARI, X| R| AX| 5 IS, 
( 002006C2 )   :L002006C2    CALL, L00200677 RL, 
( 002006C7 )                  LODS, X'| 
( 002006C8 )                  RET, 
( 002006C9 )   :L002006C9    XOR, X| T| DI'| R| DI| 
( 002006CB )   :L002006CB    DEC, X| MEM| L00202788 L, 
( 002006D1 )                  J, Z| Y| L002006EF RB, 
( 002006D3 )                  LODS, X'| 
( 002006D4 )                  JMPS, L002006CB RB, 
( 002006D6 )   :L002006D6    MOVI, X| MEM| L00202794 L, L0020066D IL, 
( 002006E0 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002006E3 )                  MOV, X| F| AX'| ZO| [SI] 
( 002006E5 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002006EC )                  ANDSI, R| AX| 0F0 IS, 
( 002006EF )   :L002006EF    CALL, L00200553 RL, 
( 002006F4 )                  J|X, Z| N| X_abort RL, 
( 002006FA )                  LODS, X'| 
( 002006FB )                  JMPO, ZO|    [MEM +4* CX] 004D2800 L, 
( 00200702 )   :L00200702    CALLO, MEM| L00202794 L, 
( 00200708 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020070F )                  ANDSI, R| AX| 0F0 IS, 
( 00200712 )                  CALL, L00200543 RL, 
( 00200717 )                  J, Z| N| L00200721 RB, 
( 00200719 )                  LODS, X'| 
( 0020071A )                  JMPO, ZO|    [MEM +4* CX] 00202A58 L, 
( 00200721 )   :L00200721    CALL, L00200553 RL, 
( 00200726 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D2800 L, 
( 0020072D )   :L0020072D    J|X, Z| N| X_abort RL, 
( 00200733 )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200739 )                  MOV, X| F| DX'| MEM| L002027B0 L, 
( 0020073F )                  MOVI, B| ZO| [DX] 0E8 IB, 
( 00200742 )                  ADDSI, R| DX| 5 IS, 
( 00200745 )                  SUB, X| T| AX'| R| DX| 
( 00200747 )                  MOV, X| F| AX'| BO| [DX] 0FC B, 
( 0020074A )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 00200750 )                  LODS, X'| 
( 00200751 )                  RET, 
( 00200752 )   :L00200752    CALLO, MEM| L00202794 L, 
( 00200758 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020075F )                  ANDSI, R| AX| 0F0 IS, 
( 00200762 )                  CALL, L00200543 RL, 
( 00200767 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 00202A58 L, 
( 0020076E )                  JMPS, L0020072D RB, 
( 00200770 )   :L00200770    MOVI, X| MEM| L00202794 L, L0020066D IL, 
( 0020077A )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020077D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020077F )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 00200786 )                  SARI, X| R| AX| 5 IS, 
( 00200789 )                  RET, 
( 0020078A )   :L0020078A    MOVI, X| MEM| L00202794 L, L0020066D IL, 
( 00200794 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200797 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200799 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] 0 L, 
( 002007A0 )                  INC|X, DI| 
( 002007A1 )                  RET, 
( 002007A2 )   :X_,    MOVI|X, CX| 4 IL, 
( 002007A7 )   :L002007A7    MOV, X| T| DX'| MEM| L002027A4 L, 
( 002007AD )                  MOV, X| F| AX'| ZO| [DX] 
( 002007AF )                  MOV, X| T| AX'| ZO| [SI] 
( 002007B1 )                  LEA, DX'| ZO|    [CX +1* DX] 
( 002007B4 )                  LEA, SI'| BO| [SI] 4 B, 
( 002007B7 )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 002007BD )                  RET, 
( 002007BE )   :X_1,    MOVI|X, CX| 1 IL, 
( 002007C3 )                  JMPS, L002007A7 RB, 
( 002007C5 )   :X_2,    MOVI|X, CX| 2 IL, 
( 002007CA )                  JMPS, L002007A7 RB, 
( 002007CC )   :X_3,    MOVI|X, CX| 3 IL, 
( 002007D1 )                  JMPS, L002007A7 RB, 
( 002007D3 )   :X_;    MOV, X| T| DX'| MEM| L002027A4 L, 
( 002007D9 )                  SUBSI, R| DX| 5 IS, 
( 002007DC )                  CMP, X| F| DX'| MEM| L002027B0 L, 
( 002007E2 )                  J, Z| N| L002007EC RB, 
( 002007E4 )                  CMPI, B| ZO| [DX] 0E8 IB, 
( 002007E7 )                  J, Z| N| L002007EC RB, 
( 002007E9 )                  INC, B| ZO| [DX] 
( 002007EB )                  RET, 
( 002007EC )   :L002007EC    MOVI, B| BO| [DX] 5 B, 0C3 IB, 
( 002007F0 )                  INC, X| MEM| L002027A4 L, 
( 002007F6 )                  RET, 
( 002007F7 )   :X_then    MOV, X| F| SP'| MEM| L002027B0 L, 
( 002007FD )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200803 )                  SUB, X| T| DX'| R| AX| 
( 00200805 )                  MOV, B| F| DL'| BO| [AX] 0FF B, 
( 00200808 )                  LODS, X'| 
( 00200809 )                  RET, 
( 0020080A )   :X_begin    MOV, X| F| SP'| MEM| L002027B0 L, 
( 00200810 )   :X_here    LEA, SI'| BO| [SI] 0FC B, 
( 00200813 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200815 )                  MOV|TA, X'| L002027A4 L, 
( 0020081A )                  RET, 
( 0020081B )   :X_?lit    MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200821 )                  LEA, DX'| BO| [DX] 0FB B, 
( 00200824 )                  CMP, X| F| DX'| MEM| L002027B0 L, 
( 0020082A )                  J, Z| N| X_?lit2 RB, 
( 0020082C )                  CMPI, B| ZO| [DX] 0B8 IB, 
( 0020082F )                  J, Z| N| X_?lit2 RB, 
( 00200831 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200834 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200836 )                  MOV|TA, X'| ForthWords L, 
( 0020083B )                  MOV|FA, X'| L002027B0 L, 
( 00200840 )                  MOV, X| T| AX'| BO| [DX] 1 B, 
( 00200843 )                  CMPI, X| BO| [DX] 0FB B, 89FC768D IL, 
( 0020084A )                  J, Z| Y| X_?lit1 RB, 
( 0020084C )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 00200852 )                  JMP, X_drop RL, 
( 00200857 )   :X_?lit1    ADDSI, MEM| L002027A4 L, 0F6 IS, 
( 0020085E )                  RET, 
( 0020085F )   :X_?lit2    XOR, X| T| DX'| R| DX| 
( 00200861 )                  RET, 
( 00200862 )   :X_less    CMP, X| F| AX'| ZO| [SI] 
( 00200864 )                  J, S| Y| X_less1 RB, 
( 00200866 )                  XOR, X| T| CX'| R| CX| 
( 00200868 )   :X_less1    RET, 
( 00200869 )   :L00200869    TESTI, X| ZO|    [MEM +4* DI] -4 L, -10 IL, 
( 00200874 )                  J, Z| N| L00200878 RB, 
( 00200876 )                  POP|X, DI| 
( 00200877 )                  POP|X, DI| 
( 00200878 )   :L00200878    RET, 
( 00200879 )   :X_jump    POP|X, DX| 
( 0020087A )                  ADD, X| T| DX'| R| AX| 
( 0020087C )                  LEA, DX'| BO|    [DX +4* AX] 5 B, 
( 00200880 )                  ADD, X| T| DX'| BO| [DX] 0FC B, 
( 00200883 )                  LODS, X'| 
( 00200884 )                  JMPO, R| DX| 
( 00200886 )   :X_load    ADD, X| T| AX'| MEM| 00202748 L, 
( 0020088C )                  SHLI, X| R| AX| 8 IS, 
( 0020088F )                  PUSH|X, DI| 
( 00200890 )                  MOV, X| T| DI'| R| AX| 
( 00200892 )                  LODS, X'| 
( 00200893 )   :X_load1    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 0020089A )                  INC|X, DI| 
( 0020089B )                  ANDSI, R| DX| 0F IS, 
( 0020089E )                  CALLO, ZO|    [MEM +4* DX] 002027C0 L, 
( 002008A5 )                  JMPS, X_load1 RB, 
( 002008A7 )                 d$  0 

( 002008A8 )   :X_top    MOV, X| T| CX'| MEM| L00202818 L, 
( 002008AE )                  SHLI, X| R| CX| 10 IS, 
( 002008B1 )                  ADDSI, R| CX| 3 IS, 
( 002008B4 )                  MOV, X| F| CX'| MEM| L00202814 L, 
( 002008BA )                  MOV, X| F| CX'| MEM| 00202820 L, 
( 002008C0 )                  RET, 
( 002008C1 )   :L002008C1    OS:, 
( 002008C2 )                  MOV, X| T| CX'| MEM| 00202816 L, 
( 002008C8 )                  OS:, 
( 002008C9 )                  CMP, X| T| CX'| MEM| L0020281C L, 
( 002008CF )                  J, S| Y| X_cr1 RB, 
( 002008D1 )   :X_cr    MOV, X| T| CX'| MEM| L00202818 L, 
( 002008D7 )                  SHLI, X| R| CX| 10 IS, 
( 002008DA )                  OS:, 
( 002008DB )                  MOV, X| T| CX'| MEM| L00202814 L, 
( 002008E1 )                  ADDSI, R| CX| 1E IS, 
( 002008E4 )                  MOV, X| F| CX'| MEM| L00202814 L, 
( 002008EA )   :X_cr1    RET, 
( 002008EB )   :L002008EB    LEA, SI'| BO| [SI] 0FC B, 
( 002008EE )                  MOV, X| F| AX'| ZO| [SI] 
( 002008F0 )                  MOVI|X, AX| 00FFFFFF IL, 
( 002008F5 )   :X_color    MOV|FA, X'| L00202834 L, 
( 002008FA )                  LODS, X'| 
( 002008FB )                  RET, 
\ pci [a - n] fetches a cell from PCI configuration space
\ given address. uses config mechanism as defined by PCI
\ local bus spec 2.0   
( 002008FC )   :X_pci    MOVI|X, DX| 0CF8 IL, 
( 00200901 )                  OUT|D, X'| 
( 00200902 )                  LEA, DX'| BO| [DX] 4 B, 
( 00200905 )                  IN|D, X'| 
( 00200906 )                  RET, 
\ device [n - a] given class number in high byte of n,
\ return configuration register for first device,
\ searching downwards, matching it. if none found,
\ returns configuration register for last device examined   
( 00200907 )   :X_devic    LEA, SI'| BO| [SI] 0FC B, 
( 0020090A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020090C )                  MOVI|X, AX| 80080008 IL, 
( 00200911 )                  MOVI|X, CX| 0FE IL, 
( 00200916 )   :X_devic1    LEA, SI'| BO| [SI] 0FC B, 
( 00200919 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020091B )                  CALL, X_pci RL, 
( 00200920 )                  ANDI|A, X'| FF000000 IL, 
( 00200925 )                  XOR, X| T| AX'| BO| [SI] 4 B, 
( 00200928 )                  LODS, X'| 
( 00200929 )                  J, Z| Y| X_devic2 RB, 
( 0020092B )                  SUBI|A, X'| 0800 IL, 
( 00200930 )                  DEC|X, CX| 
( 00200931 )                  J, Z| N| X_devic1 RB, 
( 00200933 )   :X_devic2    LEA, SI'| BO| [SI] 4 B, 
( 00200936 )                  LEA, AX'| BO| [AX] 0F8 B, 
( 00200939 )                  RET, 
\ 03 is PCI class code for display device   
( 0020093A )   :InitDisplay    MOVI|X, AX| 03000000 IL, 
( 0020093F )                  CALL, X_devic RL, 
( 00200944 )                  LEA, AX'| BO| [AX] 10 B, 
( 00200947 )                  MOVI|B, CL| 6 IB, 
( 00200949 )   :L00200949    LEA, SI'| BO| [SI] 0FC B, 
( 0020094C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020094E )                  CALL, X_pci RL, 
( 00200953 )                  ANDI|A, B'| 0FB IB, 
( 00200955 )                  XORI|A, B'| 8 IB, 
( 00200957 )                  J, Z| Y| L0020096F RB, 
( 00200959 )                  LODS, X'| 
( 0020095A )                  LEA, AX'| BO| [AX] 4 B, 
( 0020095D )                  DEC|X, CX| 
( 0020095E )                  J, Z| N| L00200949 RB, 
( 00200960 )                  LEA, AX'| BO| [AX] 0E8 B, 
( 00200963 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200966 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200968 )                  CALL, X_pci RL, 
( 0020096D )                  ANDI|A, B'| 0F0 IB, 
( 0020096F )   :L0020096F    MOV|FA, X'| L00202830 L, 
( 00200974 )                  LODS, X'| 
( 00200975 )                  RET, 
( 00200976 )   :X_fifo    LODS, X'| 
( 00200977 )   :X_graph    RET, 
( 00200978 )   :X_switch    PUSH|X, SI| 
( 00200979 )                  MOV, X| T| SI'| MEM| L0020282C L, 
( 0020097F )                  PUSH|X, DI| 
( 00200980 )                  MOV, X| T| DI'| MEM| L00202830 L, 
( 00200986 )                  MOVI|X, CX| 000C0000 IL, 
( 0020098B )                  REPZ, 
( 0020098C )                  MOVS, X'| 
( 0020098D )                  POP|X, DI| 
( 0020098E )                  POP|X, SI| 
( 0020098F )                  RET, 
( 00200990 )   :L00200990    CALL, X_switch RL, 
( 00200995 )                  JMP, X_pauseFixed RL, 
( 0020099A )   :L0020099A    MOV, X| T| DI'| MEM| L00202814 L, 
( 002009A0 )                  MOV, X| T| CX'| R| DI| 
( 002009A2 )                  OS:, 
( 002009A3 )                  TEST, X| CX'| R| CX| 
( 002009A5 )                  J, S| N| L002009A9 RB, 
( 002009A7 )                  XOR, X| T| CX'| R| CX| 
( 002009A9 )   :L002009A9    ANDI, X| R| CX| FFFF IL, 
( 002009AF )                  MOV, X| F| CX'| MEM| L0020283C L, 
( 002009B5 )                  IMULI, CX'| R| CX| 1000 IL, 
( 002009BB )                  SARI, X| R| DI| 10 IS, 
( 002009BE )                  J, S| N| L002009C2 RB, 
( 002009C0 )                  XOR, X| T| DI'| R| DI| 
( 002009C2 )   :L002009C2    MOV, X| F| DI'| MEM| L00202838 L, 
( 002009C8 )                  LEA, DI'| ZO|    [CX +4* DI] 
( 002009CB )                  ADD, X| T| DI'| MEM| L00202828 L, 
( 002009D1 )                  RET, 
( 002009D2 )   :L002009D2    OS:, 
( 002009D3 )                  LODS, X'| 
( 002009D4 )                  XCHG, B| AL'| R| AH| 
( 002009D6 )                  MOVI|X, CX| 10 IL, 
( 002009DB )   :L002009DB    OS:, 
( 002009DC )                  SHL, 1| X| R| AX| 
( 002009DE )                  J, C| N| L002009E2 RB, 
( 002009E0 )                  MOV, X| F| DX'| ZO| [DI] 
( 002009E2 )   :L002009E2    ADDSI, R| DI| 4 IS, 
( 002009E5 )                  DEC|X, CX| 
( 002009E6 )                  J, Z| N| L002009DB RB, 
( 002009E8 )                  RET, 
( 002009E9 )   :L002009E9    OS:, 
( 002009EA )                  LODS, X'| 
( 002009EB )                  XCHG, B| AL'| R| AH| 
( 002009ED )                  MOVI|X, CX| 10 IL, 
( 002009F2 )   :L002009F2    SHL, 1| X| R| AX| 
( 002009F4 )                  J, C| N| L00200A07 RB, 
( 002009F6 )                  MOV, X| F| DX'| ZO| [DI] 
( 002009F8 )                  MOV, X| F| DX'| BO| [DI] 4 B, 
( 002009FB )                  MOV, X| F| DX'| XO| [DI] 1000 L, 
( 00200A01 )                  MOV, X| F| DX'| XO| [DI] 1004 L, 
( 00200A07 )   :L00200A07    ADDSI, R| DI| 8 IS, 
( 00200A0A )                  DEC|X, CX| 
( 00200A0B )                  J, Z| N| L002009F2 RB, 
( 00200A0D )                  RET, 
( 00200A0E )   :X_emit    CALL, L002008C1 RL, 
( 00200A13 )                  PUSH|X, SI| 
( 00200A14 )                  PUSH|X, DI| 
( 00200A15 )                  PUSH|X, DX| 
( 00200A16 )                  IMULSI, AX'| R| AX| 30 IS, 
( 00200A19 )                  LEA, SI'| XO| [AX] IconImages L, 
( 00200A1F )                  CALL, L0020099A RL, 
( 00200A24 )                  MOV, X| T| DX'| MEM| L00202834 L, 
( 00200A2A )                  MOVI|X, CX| 18 IL, 
( 00200A2F )   :X_emit1    PUSH|X, CX| 
( 00200A30 )                  CALL, L002009D2 RL, 
( 00200A35 )                  ADDI, X| R| DI| 0FC0 IL, 
( 00200A3B )                  POP|X, CX| 
( 00200A3C )                  DEC|X, CX| 
( 00200A3D )                  J, Z| N| X_emit1 RB, 
( 00200A3F )                  POP|X, DX| 
( 00200A40 )                  POP|X, DI| 
( 00200A41 )                  POP|X, SI| 
( 00200A42 )                  LODS, X'| 
( 00200A43 )   :X_space    ADDI, X| MEM| L00202814 L, 00160000 IL, 
( 00200A4D )                  RET, 
( 00200A4E )   :X_2emit    PUSH|X, SI| 
( 00200A4F )                  PUSH|X, DI| 
( 00200A50 )                  PUSH|X, DX| 
( 00200A51 )                  IMULSI, AX'| R| AX| 30 IS, 
( 00200A54 )                  LEA, SI'| XO| [AX] IconImages L, 
( 00200A5A )                  CALL, L0020099A RL, 
( 00200A5F )                  MOV, X| T| DX'| MEM| L00202834 L, 
( 00200A65 )                  MOVI|X, CX| 18 IL, 
( 00200A6A )   :X_2emit1    PUSH|X, CX| 
( 00200A6B )                  CALL, L002009E9 RL, 
( 00200A70 )                  ADDI, X| R| DI| 1F80 IL, 
( 00200A76 )                  POP|X, CX| 
( 00200A77 )                  DEC|X, CX| 
( 00200A78 )                  J, Z| N| X_2emit1 RB, 
( 00200A7A )                  POP|X, DX| 
( 00200A7B )                  POP|X, DI| 
( 00200A7C )                  POP|X, SI| 
( 00200A7D )                  ADDI, X| MEM| L00202814 L, 002C0000 IL, 
( 00200A87 )                  LODS, X'| 
( 00200A88 )                  RET, 
( 00200A89 )   :X_text    CALL, L002008EB RL, 
( 00200A8E )                  MOVI, X| MEM| L00202818 L, 3 IL, 
( 00200A98 )                  MOVI, X| MEM| L0020281C L, 03F4 IL, 
( 00200AA2 )                  JMP, X_top RL, 
( 00200AA7 )   :X_line    CALL, L0020099A RL, 
( 00200AAC )                  MOV, X| T| CX'| ZO| [SI] 
( 00200AAE )                  SHL, 1| X| R| CX| 
( 00200AB0 )                  SHL, 1| X| R| CX| 
( 00200AB2 )                  SUB, X| T| DI'| R| CX| 
( 00200AB4 )                  MOV, X| T| CX'| R| AX| 
( 00200AB6 )                  MOV|TA, X'| L00202834 L, 
( 00200ABB )                  REPZ, 
( 00200ABC )                  STOS, X'| 
( 00200ABD )                  INC, X| MEM| L00202814 L, 
( 00200AC3 )                  LODS, X'| 
( 00200AC4 )                  LODS, X'| 
( 00200AC5 )                  RET, 
( 00200AC6 )   :X_box    CALL, L0020099A RL, 
( 00200ACB )                  CMPI|A, X'| 0301 IL, 
( 00200AD0 )                  J, S| Y| X_box1 RB, 
( 00200AD2 )                  MOVI|X, AX| 0300 IL, 
( 00200AD7 )   :X_box1    MOV, X| T| CX'| R| AX| 
( 00200AD9 )                  SUB, X| T| CX'| MEM| L0020283C L, 
( 00200ADF )                  J, LE| Y| X_box4 RB, 
( 00200AE1 )                  CMPI, X| ZO| [SI] 0401 IL, 
( 00200AE7 )                  J, S| Y| X_box2 RB, 
( 00200AE9 )                  MOVI, X| ZO| [SI] 0400 IL, 
( 00200AEF )   :X_box2    MOV|TA, X'| L00202838 L, 
( 00200AF4 )                  SUB, X| F| AX'| ZO| [SI] 
( 00200AF6 )                  J, LE| Y| X_box4 RB, 
( 00200AF8 )                  MOVI|X, DX| 0400 IL, 
( 00200AFD )                  SUB, X| T| DX'| ZO| [SI] 
( 00200AFF )                  SHLI, X| R| DX| 2 IS, 
( 00200B02 )                  MOV|TA, X'| L00202834 L, 
( 00200B07 )   :X_box3    PUSH|X, CX| 
( 00200B08 )                  MOV, X| T| CX'| ZO| [SI] 
( 00200B0A )                  REPZ, 
( 00200B0B )                  STOS, X'| 
( 00200B0C )                  ADD, X| T| DI'| R| DX| 
( 00200B0E )                  POP|X, CX| 
( 00200B0F )                  DEC|X, CX| 
( 00200B10 )                  J, Z| N| X_box3 RB, 
( 00200B12 )   :X_box4    LODS, X'| 
( 00200B13 )                  LODS, X'| 
( 00200B14 )                  RET, 
( 00200B15 )   :X_color0FF    LEA, SI'| BO| [SI] 0FC B, 
( 00200B18 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B1A )                  MOVI|X, AX| FFFF IL, 
( 00200B1F )                  JMP, X_color RL, 
( 00200B24 )   :X_colorF0F    LEA, SI'| BO| [SI] 0FC B, 
( 00200B27 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B29 )                  MOVI|X, AX| 00FF00FF IL, 
( 00200B2E )                  JMP, X_color RL, 
( 00200B33 )   :X_colorCCC    LEA, SI'| BO| [SI] 0FC B, 
( 00200B36 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B38 )                  MOVI|X, AX| 00C0C0C0 IL, 
( 00200B3D )                  JMP, X_color RL, 
( 00200B42 )   :X_color44F    LEA, SI'| BO| [SI] 0FC B, 
( 00200B45 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B47 )                  MOVI|X, AX| 004040FF IL, 
( 00200B4C )                  JMP, X_color RL, 
( 00200B51 )   :X_colorF00    LEA, SI'| BO| [SI] 0FC B, 
( 00200B54 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B56 )                  MOVI|X, AX| 00FF0000 IL, 
( 00200B5B )                  JMP, X_color RL, 
( 00200B60 )   :X_color80F0    LEA, SI'| BO| [SI] 0FC B, 
( 00200B63 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B65 )                  MOVI|X, AX| 8000FF00 IL, 
( 00200B6A )                  JMP, X_color RL, 
( 00200B6F )   :L00200B6F   db 0 0 0 0 0 0 0 0 0 0 
( 00200B79 )   :L00200B79   db 0 

( 00200B7A )   :L00200B7A    PUSH|X, SI| 
( 00200B7B )                  MOVI|X, CX| 0A IL, 
( 00200B80 )                  LEA, DI'| MEM| L00200B6F L, 
( 00200B86 )                  LEA, SI'| BO| [DI] 1 B, 
( 00200B89 )                  REPZ, 
( 00200B8A )                  MOVS, B'| 
( 00200B8B )                  POP|X, SI| 
( 00200B8C )                  MOV|FA, B'| L00200B79 L, 
( 00200B91 )                  LODS, X'| 
( 00200B92 )                  RET, 
( 00200B93 )   :L00200B93    LEA, SI'| BO| [SI] 0FC B, 
( 00200B96 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B98 )                  MOVI|X, CX| 0B IL, 
( 00200B9D )                  LEA, DI'| MEM| L00200B6F L, 
( 00200BA3 )                  XOR, X| T| AX'| R| AX| 
( 00200BA5 )                  REPZ, 
( 00200BA6 )                  STOS, B'| 
( 00200BA7 )                  LODS, X'| 
( 00200BA8 )                  RET, 
( 00200BA9 )   :X_down    LEA, SI'| BO| [SI] 0FC B, 
( 00200BAC )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BAE )                  XOR, X| T| DX'| R| DX| 
( 00200BB0 )                  MOVI|X, CX| 1E IL, 
( 00200BB5 )                  DIV|AD, X| R| CX| 
( 00200BB7 )                  MOV, X| T| AX'| R| DX| 
( 00200BB9 )                  ADDI, X| R| DX| 00037FE5 IL, 
( 00200BBF )                  MOV, X| F| DX'| MEM| L00202814 L, 
( 00200BC5 )                  TEST, X| AX'| R| AX| 
( 00200BC7 )                  MOVI|X, AX| 0 IL, 
( 00200BCC )                  J, Z| N| X_down1 RB, 
( 00200BCE )                  INC|X, AX| 
( 00200BCF )   :X_down1    RET, 
( 00200BD0 )   :L00200BD0    LEA, SI'| BO| [SI] 0FC B, 
( 00200BD3 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BD5 )                  XOR, X| T| AX'| R| AX| 
( 00200BD7 )                  MOV|FA, X'| L00202814 L, 
( 00200BDC )                  CALL, X_color RL, 
( 00200BE1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200BE4 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BE6 )                  MOVI|X, AX| 0400 IL, 
( 00200BEB )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200BEE )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BF0 )                  MOVI|X, AX| 0300 IL, 
( 00200BF5 )                  JMP, X_box RL, 
( 00200BFA )   :X_lm    MOV|FA, X'| L00202818 L, 
( 00200BFF )                  LODS, X'| 
( 00200C00 )                  RET, 
( 00200C01 )   :X_rm    MOV|FA, X'| L0020281C L, 
( 00200C06 )                  LODS, X'| 
( 00200C07 )                  RET, 
( 00200C08 )   :X_at    OS:, 
( 00200C09 )                  MOV|FA, X'| L00202814 L, 
( 00200C0E )                  LODS, X'| 
( 00200C0F )                  OS:, 
( 00200C10 )                  MOV|FA, X'| 00202816 L, 
( 00200C15 )                  LODS, X'| 
( 00200C16 )                  RET, 
( 00200C17 )   :X_+at    OS:, 
( 00200C18 )                  ADD, X| F| AX'| MEM| L00202814 L, 
( 00200C1E )                  LODS, X'| 
( 00200C1F )                  OS:, 
( 00200C20 )                  ADD, X| F| AX'| MEM| 00202816 L, 
( 00200C26 )                  LODS, X'| 
( 00200C27 )                  RET, 
( 00200C28 )   :X_octant    LEA, SI'| BO| [SI] 0FC B, 
( 00200C2B )                  MOV, X| F| AX'| ZO| [SI] 
( 00200C2D )                  MOVI|X, AX| 43 IL, 
( 00200C32 )                  MOV, X| T| DX'| BO| [SI] 4 B, 
( 00200C35 )                  TEST, X| DX'| R| DX| 
( 00200C37 )                  J, S| N| X_octant1 RB, 
( 00200C39 )                  NEG, X| R| DX| 
( 00200C3B )                  MOV, X| F| DX'| BO| [SI] 4 B, 
( 00200C3E )                  XORI|A, B'| 1 IB, 
( 00200C40 )   :X_octant1    CMP, X| T| DX'| ZO| [SI] 
( 00200C42 )                  J, S| N| X_octant2 RB, 
( 00200C44 )                  XORI|A, B'| 4 IB, 
( 00200C46 )   :X_octant2    RET, 
( 00200C47 )   :digitChars   db 18 19 1A 1B 1C 1D 1E 1F 20 21 5 13 0A 10 4 0E 

( 00200C57 )   :L00200C57    LEA, SI'| BO| [SI] 0FC B, 
( 00200C5A )                  MOV, X| F| AX'| ZO| [SI] 
( 00200C5C )   :X_digit    PUSH|X, CX| 
( 00200C5D )                  MOV, B| T| AL'| XO| [AX] digitChars L, 
( 00200C63 )                  CALL, X_emit RL, 
( 00200C68 )                  POP|X, CX| 
( 00200C69 )                  RET, 
( 00200C6A )   :L00200C6A    ROLI, X| R| AX| 4 IS, 
( 00200C6D )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200C70 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200C72 )                  ANDSI, R| AX| 0F IS, 
( 00200C75 )                  RET, 
( 00200C76 )   :X_h.n    MOV, X| T| DX'| R| AX| 
( 00200C78 )                  NEG, X| R| AX| 
( 00200C7A )                  LEA, CX'| ZO|    [MEM +4* AX] 20 L, 
( 00200C81 )                  LODS, X'| 
( 00200C82 )                  ROL, V| X| R| AX| 
( 00200C84 )                  MOV, X| T| CX'| R| DX| 
( 00200C86 )                  JMPS, X_h.1 RB, 
( 00200C88 )   :X_h.    MOVI|X, CX| 8 IL, 
( 00200C8D )   :X_h.1    CALL, L00200C6A RL, 
( 00200C92 )                  CALL, X_digit RL, 
( 00200C97 )                  DEC|X, CX| 
( 00200C98 )                  J, Z| N| X_h.1 RB, 
( 00200C9A )                  LODS, X'| 
( 00200C9B )                  RET, 
( 00200C9C )   :L00200C9C    MOVI|X, CX| 7 IL, 
( 00200CA1 )   :L00200CA1    CALL, L00200C6A RL, 
( 00200CA6 )                  J, Z| N| L00200CC1 RB, 
( 00200CA8 )                  LODS, X'| 
( 00200CA9 )                  DEC|X, CX| 
( 00200CAA )                  J, Z| N| L00200CA1 RB, 
( 00200CAC )                  INC|X, CX| 
( 00200CAD )   :L00200CAD    CALL, L00200C6A RL, 
( 00200CB2 )   :L00200CB2    CALL, X_digit RL, 
( 00200CB7 )                  DEC|X, CX| 
( 00200CB8 )                  J, Z| N| L00200CAD RB, 
( 00200CBA )                  CALL, X_space RL, 
( 00200CBF )                  LODS, X'| 
( 00200CC0 )                  RET, 
( 00200CC1 )   :L00200CC1    INC|X, CX| 
( 00200CC2 )                  JMPS, L00200CB2 RB, 
( 00200CC4 )   :L00200CC4    CMPSI, MEM| L00202770 L, 0A IS, 
( 00200CCB )                  J, Z| N| L00200C9C RB, 
( 00200CCD )   :X_.    MOV, X| T| DX'| R| AX| 
( 00200CCF )                  TEST, X| DX'| R| DX| 
( 00200CD1 )                  J, S| N| X_.1 RB, 
( 00200CD3 )                  NEG, X| R| DX| 
( 00200CD5 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200CD8 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200CDA )                  MOVI|X, AX| 23 IL, 
( 00200CDF )                  CALL, X_emit RL, 
( 00200CE4 )   :X_.1    MOVI|X, CX| 8 IL, 
( 00200CE9 )   :X_.2    MOV, X| T| AX'| R| DX| 
( 00200CEB )                  XOR, X| T| DX'| R| DX| 
( 00200CED )                  DIV|AD, X| ZO|    [MEM +4* CX] L00202700 L, 
( 00200CF4 )                  TEST, X| AX'| R| AX| 
( 00200CF6 )                  J, Z| N| X_.4 RB, 
( 00200CF8 )                  DEC|X, CX| 
( 00200CF9 )                  J, S| N| X_.2 RB, 
( 00200CFB )                  JMPS, X_.5 RB, 
( 00200CFD )   :X_.3    MOV, X| T| AX'| R| DX| 
( 00200CFF )                  XOR, X| T| DX'| R| DX| 
( 00200D01 )                  DIV|AD, X| ZO|    [MEM +4* CX] L00202700 L, 
( 00200D08 )   :X_.4    CALL, L00200C57 RL, 
( 00200D0D )                  DEC|X, CX| 
( 00200D0E )                  J, S| N| X_.3 RB, 
( 00200D10 )   :X_.5    MOV, X| T| AX'| R| DX| 
( 00200D12 )                  CALL, L00200C57 RL, 
( 00200D17 )                  CALL, X_space RL, 
( 00200D1C )                  LODS, X'| 
( 00200D1D )                  RET, 
( 00200D1E )   :L00200D1E    ADDSI, R| DI| 0C IS, 
( 00200D21 )                  CALL, L00200D2E RL, 
( 00200D26 )                  CALL, X_space RL, 
( 00200D2B )                  SUBSI, R| DI| 10 IS, 
( 00200D2E )   :L00200D2E    MOVI|X, CX| 4 IL, 
( 00200D33 )   :L00200D33    PUSH|X, CX| 
( 00200D34 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200D37 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200D39 )                  XOR, X| T| AX'| R| AX| 
( 00200D3B )                  MOV, B| T| AL'| BO| [DI] 4 B, 
( 00200D3E )                  INC|X, DI| 
( 00200D3F )                  CALL, X_emit RL, 
( 00200D44 )                  POP|X, CX| 
( 00200D45 )                  DEC|X, CX| 
( 00200D46 )                  J, Z| N| L00200D33 RB, 
( 00200D48 )                  RET, 
( 00200D49 )   :L00200D49    MOVI|X, DI| 0009F3FC IL, 
( 00200D4E )   :L00200D4E    MOV, X| T| DX'| MEM| L00200446 L, 
( 00200D54 )                  CMP, X| F| DI'| ZO| [DX] 
( 00200D56 )                  J, C| N| 11 (RB,) 
( 00200D58 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200D5B )                  MOV, X| F| AX'| ZO| [SI] 
( 00200D5D )                  MOV, X| T| AX'| ZO| [DI] 
( 00200D5F )                  SUBSI, R| DI| 4 IS, 
( 00200D62 )                  CALL, L00200CC4 RL, 
( 00200D67 )   :L00200D67    JMPS, L00200D4E RB, 
( 00200D69 )                  RET, 
( 00200D6A )   :X_keybo    CALL, X_text RL, 
( 00200D6F )                  MOV, X| T| DI'| MEM| L00202768 L, 
( 00200D75 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200D78 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200D7A )                  MOV|TA, X'| L00202778 L, 
( 00200D7F )                  CALL, X_color RL, 
( 00200D84 )                  MOV|TA, X'| L00202760 L, 
( 00200D89 )                  ADDSI, R| AX| 0 IS, 
( 00200D8C )                  MOV|FA, X'| L00202818 L, 
( 00200D91 )                  MOV, X| T| DX'| R| AX| 
( 00200D93 )                  ADDI, X| R| DX| 0C6 IL, 
( 00200D99 )                  MOV, X| F| DX'| MEM| L0020281C L, 
( 00200D9F )                  SHLI, X| R| AX| 10 IS, 
( 00200DA2 )                  ADD, X| T| AX'| MEM| L00202764 L, 
( 00200DA8 )                  MOV|FA, X'| L00202814 L, 
( 00200DAD )                  CALL, L00200D1E RL, 
( 00200DB2 )                  CALL, L00200D1E RL, 
( 00200DB7 )                  CALL, L00200D1E RL, 
( 00200DBC )                  CALL, X_cr RL, 
( 00200DC1 )                  ADDI, X| MEM| L00202814 L, 00580000 IL, 
( 00200DCB )                  MOV, X| T| DI'| MEM| L0020276C L, 
( 00200DD1 )                  ADDSI, R| DI| 0C IS, 
( 00200DD4 )                  MOVI|X, CX| 3 IL, 
( 00200DD9 )                  CALL, L00200D33 RL, 
( 00200DDE )                  MOVI, X| MEM| L00202818 L, 3 IL, 
( 00200DE8 )                  OS:, 
( 00200DE9 )                  MOVI, X| MEM| 00202816 L, 3 IW, 
( 00200DF1 )                  CALL, L00200D49 RL, 
( 00200DF6 )                  OS:, 
( 00200DF7 )                  MOVI, X| MEM| 00202816 L, 024B IW, 
( 00200DFF )                  LEA, DI'| MEM| L00200B6B L, 
( 00200E05 )                  MOVI|X, CX| 0B IL, 
( 00200E0A )                  JMP, L00200D33 RL, 
( 00200E0F )                 db 0D 0A 1 0C 14 2 6 8 13 9 0F 11 12 0B 0E 7 
( 00200E1F )                 db 5 3 4 16 
( 00200E23 )   :L00200E23   db 17 24 15 10 19 1A 1B 0 1C 1D 1E 18 
( 00200E2F )                 db 1F 20 21 2F 29 28 2A 2C 26 22 25 2E 
( 00200E3B )   :L00200E3B   db 2D 27 2B 23 
( 00200E3F )                 db 19 1A 1B 0 1C 1D 1E 18 1F 20 21 0 0 0 0 0 
( 00200E4F )                 db 0 0 0 0 
( 00200E53 )   :L00200E53   db 0 0 0 0 19 1A 1B 0 1C 1D 1E 18 
( 00200E5F )                 db 1F 20 21 0 0 5 13 0A 0 10 4 0E 0 0 
( 00200E6D )   :L00200E6D   db 0 0 

( 00200E6F )   :L00200E6F    CMPI|A, B'| 4 IB, 
( 00200E71 )                  J, S| Y| L00200E7C RB, 
( 00200E73 )                  MOV, X| T| DX'| MEM| L00202768 L, 
( 00200E79 )                  MOV, B| T| AL'| ZO|    [AX +1* DX] 
( 00200E7C )   :L00200E7C    RET, 
( 00200E7D )                 dl 13121110 05040000 0706 15140000 
( 00200E8D )                 dl 1716 0B0A0908 0 1B1A1918 
( 00200E9D )                 dl 0D0C0100 0F0E 768D0203 

( 00200EA7 )   :L00200EA7    LEA, SI'| BO| [SI] 0FC B, 
( 00200EAA )                  MOV, X| F| AX'| ZO| [SI] 
( 00200EAC )                  XOR, X| T| AX'| R| AX| 
( 00200EAE )                  CALL, X_pauseFixed RL, 
( 00200EB3 )   :L00200EB3    IN|P, B'| 64 P, 
( 00200EB5 )                  TESTI|A, B'| 1 IB, 
( 00200EB7 )                  J, Z| Y| L00200EB3 RB, 
( 00200EB9 )                  IN|P, B'| 60 P, 
( 00200EBB )                  TESTI|A, B'| 0F0 IB, 
( 00200EBD )                  J, Z| Y| L00200EB3 RB, 
( 00200EBF )                  CMPI|A, B'| 3A IB, 
( 00200EC1 )                  J, C| N| L00200EB3 RB, 
( 00200EC3 )                  MOV, B| T| AL'| XO| [AX] L00200E6D L, 
( 00200EC9 )                  RET, 
( 00200ECA )                 db 90 0 
( 00200ECC )   :L00200ECC   db 0B 18 2 19 3 1A 4 1B 5 1C 6 1D 7 1E 
( 00200EDA )                 db 8 1F 9 20 0A 21 1E 5 30 13 2E 0A 20 10 12 4 
( 00200EEA )                 db 21 0E 22 0D 23 14 17 7 24 22 25 24 26 0C 32 9 
( 00200EFA )                 db 31 6 18 3 19 12 10 17 13 1 1F 8 14 2 16 16 
( 00200F0A )                 db 2F 11 11 0F 2D 15 15 0B 2C 26 0C 23 34 25 35 27 
( 00200F1A )                 db 27 28 28 29 82 2A 8D 2B 83 2C 89 2D 33 2E 0B5 2F 
( 00200F2A )                 db 39 80 1C 81 0E 82 1 83 3B 84 29 30 

( 00200F36 )   :X_qkey    LEA, SI'| BO| [SI] 0FC B, 
( 00200F39 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200F3B )                  XOR, X| T| AX'| R| AX| 
( 00200F3D )                  CALL, X_pauseFixed RL, 
( 00200F42 )   :X_qkey1    IN|P, B'| 64 P, 
( 00200F44 )                  TESTI|A, B'| 1 IB, 
( 00200F46 )                  J, Z| Y| X_qkey1 RB, 
( 00200F48 )                  IN|P, B'| 60 P, 
( 00200F4A )                  MOV, X| T| CX'| R| AX| 
( 00200F4C )                  ANDI, B| R| CL| 7F IB, 
( 00200F4F )                  CMPI, B| R| CL| 2A IB, 
( 00200F52 )                  J, Z| Y| X_qkey2 RB, 
( 00200F54 )                  CMPI, B| R| CL| 36 IB, 
( 00200F57 )                  J, Z| N| X_qkey3 RB, 
( 00200F59 )   :X_qkey2    ANDI|A, B'| 80 IB, 
( 00200F5B )                  XORI|A, B'| 80 IB, 
( 00200F5D )                  MOV|FA, X'| L0020278C L, 
( 00200F62 )                  JMPS, X_qkey1 RB, 
( 00200F64 )   :X_qkey3    OR, B| T| AL'| R| AL| 
( 00200F66 )                  J, S| Y| X_qkey1 RB, 
( 00200F68 )                  ANDI|A, B'| 7F IB, 
( 00200F6A )                  OR, X| T| AX'| MEM| L0020278C L, 
( 00200F70 )                  MOVI|X, DX| L00200ECC IL, 
( 00200F75 )                  MOVI|X, CX| 35 IL, 
( 00200F7A )   :X_qkey4    CMP, B| F| AL'| ZO| [DX] 
( 00200F7C )                  J, Z| Y| X_qkey5 RB, 
( 00200F7E )                  ADDSI, R| DX| 2 IS, 
( 00200F81 )                  LOOP, X_qkey4 RB, 
( 00200F83 )                  XOR, X| T| AX'| R| AX| 
( 00200F85 )                  RET, 
( 00200F86 )   :X_qkey5    MOV, B| T| AL'| BO| [DX] 1 B, 
( 00200F89 )                  SUBI, X| R| DX| L00200ECC IL, 
( 00200F8F )                  SHR, 1| X| R| DX| 
( 00200F91 )                  MOV, X| F| DX'| MEM| L00202790 L, 
( 00200F97 )                  TESTI|A, X'| 80 IL, 
( 00200F9C )                  RET, 
( 00200F9D )   :L00200F9D   db 0D7 11 20 0 0D7 11 20 0 0D7 11 20 0 29 12 20 0 
( 00200FAD )                 db 0 0 5 0 
( 00200FB1 )   :L00200FB1   db 0E4 10 20 0 7C 10 20 0 22 10 20 0 
( 00200FBD )                 db 4E 12 20 0 15 25 5 0 
( 00200FC5 )   :L00200FC5   db 0D7 11 20 0 
( 00200FC9 )   :L00200FC9   db 0D7 11 20 0 
( 00200FCD )                 db 15 11 20 0 3B 12 20 0 
( 00200FD5 )   :L00200FD5   db 0 21 2D 0 
( 00200FD9 )   :L00200FD9   db 0E4 10 20 0 
( 00200FDD )                 db 7C 10 20 0 22 10 20 0 60 12 20 0 15 25 2D 0 
( 00200FED )   :L00200FED   db 0D7 11 20 0 0B 11 20 0 28 12 20 0 
( 00200FF9 )   :L00200FF9   db 0B3 11 20 0 
( 00200FFD )                 db 23 5 
( 00200FFF )   :L00200FFF   db 0E 0 
( 00201001 )   :L00201001   db 12 11 20 0 0CF 11 20 0 68 11 20 0 
( 0020100D )                 db 12 11 20 0 15 25 0 0 
( 00201015 )   :L00201015   db 1C 

( 00201016 )   :L00201016    MOV, B| T| CL'| MEM| L00201015 L, 
( 0020101C )                  ADDI, B| R| CL| 4 IB, 
( 0020101F )                  SHL, V| X| ZO| [SI] 
( 00201021 )                  RET, 
( 00201022 )   :L00201022    CALL, L00201016 RL, 
( 00201027 )                  LODS, X'| 
( 00201028 )                  RET, 
( 00201029 )   :L00201029    CALL, L00201016 RL, 
( 0020102E )                  INC, X| MEM| L00202788 L, 
( 00201034 )                  MOVI, B| MEM| L00201015 L, 1C IB, 
( 0020103B )                  SUB, B| F| CH'| MEM| L00201015 L, 
( 00201041 )                  MOV, X| T| AX'| R| DX| 
( 00201043 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201046 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201048 )                  RET, 
( 00201049 )   :L00201049    ADDSI, R| AX| 50 IS, 
( 0020104C )                  MOVI|B, CL| 7 IB, 
( 0020104E )                  JMPS, L0020105D RB, 
( 00201050 )   :L00201050    CMPI|A, B'| 10 IB, 
( 00201052 )                  J, C| N| L00201049 RB, 
( 00201054 )                  MOVI|B, CL| 4 IB, 
( 00201056 )                  TESTI|A, B'| 8 IB, 
( 00201058 )                  J, Z| Y| L0020105D RB, 
( 0020105A )                  INC|X, CX| 
( 0020105B )                  XORI|A, B'| 18 IB, 
( 0020105D )   :L0020105D    MOV, X| T| DX'| R| AX| 
( 0020105F )                  MOV, B| T| CH'| R| CL| 
( 00201061 )   :L00201061    CMP, B| F| CL'| MEM| L00201015 L, 
( 00201067 )                  J, C| N| L00201071 RB, 
( 00201069 )                  SHR, 1| B| R| AL| 
( 0020106B )                  J, C| Y| L00201029 RB, 
( 0020106D )                  DEC, B| R| CL| 
( 0020106F )                  JMPS, L00201061 RB, 
( 00201071 )   :L00201071    SHL, V| X| ZO| [SI] 
( 00201073 )                  XOR, X| F| AX'| ZO| [SI] 
( 00201075 )                  SUB, B| F| CL'| MEM| L00201015 L, 
( 0020107B )                  RET, 
( 0020107C )   :L0020107C    CALL, L00200B93 RL, 
( 00201081 )                  MOV|TA, X'| L00202788 L, 
( 00201086 )                  LEA, SI'| ZO|    [SI +4* AX] 
( 00201089 )                  LODS, X'| 
( 0020108A )                  JMPO, MEM| L00202750 L, 
( 00201090 )   :L00201090    CALL, L00200B93 RL, 
( 00201095 )                  MOVI, X| MEM| L00202788 L, 1 IL, 
( 0020109F )                  MOVI, X| MEM| L0020277C L, 1 IL, 
( 002010A9 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002010AC )                  MOV, X| F| AX'| ZO| [SI] 
( 002010AE )                  MOVI, X| ZO| [SI] 0 IL, 
( 002010B4 )                  MOVI, B| MEM| L00201015 L, 1C IB, 
( 002010BB )   :L002010BB    CALL, L00200E6F RL, 
( 002010C0 )                  J, S| N| L002010CB RB, 
( 002010C2 )                  MOV, X| T| DX'| MEM| L0020276C L, 
( 002010C8 )                  JMPO, ZO|    [DX +4* AX] 
( 002010CB )   :L002010CB    TEST, B| AL'| R| AL| 
( 002010CD )                  J, Z| Y| 15 (RB,) 
( 002010CF )                  LEA, SI'| BO| [SI] 0FC B, 
( 002010D2 )                  MOV, X| F| AX'| ZO| [SI] 
( 002010D4 )                  CALL, L00200B7A RL, 
( 002010D9 )                  CALL, L00201050 RL, 
( 002010DE )                  INC, X| MEM| L0020277C L, 
( 002010E4 )                  LODS, X'| 
( 002010E5 )                  CALL, L00200EA7 RL, 
( 002010EA )                  JMPS, L002010BB RB, 
( 002010EC )                 db 0E 0A 0 0 0 0 0C 0 0 0 0F 0 0D 0 0 0B 
( 002010FC )                 db 0 0 0 0 0 1 2 3 4 5 6 7 8 9 
( 0020110A )   :L0020110A   db 0 

( 0020110B )   :L0020110B    MOV|FA, B'| L0020110A L, 
( 00201110 )                  JMPS, L0020115B RB, 
( 00201112 )   :L00201112    LODS, X'| 
( 00201113 )                  JMPS, L00201124 RB, 
( 00201115 )   :L00201115    CALLO, MEM| L00202774 L, 
( 0020111B )                  MOVI, B| MEM| L0020110A L, 0 IB, 
( 00201122 )                  XOR, X| T| AX'| R| AX| 
( 00201124 )   :L00201124    CALL, L00200EA7 RL, 
( 00201129 )                  CALL, L00200E6F RL, 
( 0020112E )                  J, S| N| L00201139 RB, 
( 00201130 )                  MOV, X| T| DX'| MEM| L0020276C L, 
( 00201136 )                  JMPO, ZO|    [DX +4* AX] 
( 00201139 )   :L00201139    TEST, B| AL'| R| AL| 
( 0020113B )                  J, Z| Y| L00201112 RB, 
( 0020113D )                  MOV, B| T| AL'| XO| [AX] L002010E8 L, 
( 00201143 )                  TESTI, B| MEM| L0020110A L, 1F IB, 
( 0020114A )                  J, Z| Y| L0020114E RB, 
( 0020114C )                  NEG, X| R| AX| 
( 0020114E )   :L0020114E    MOV, X| T| DX'| ZO| [SI] 
( 00201150 )                  IMUL, DX'| MEM| L00202770 L, 
( 00201157 )                  ADD, X| T| DX'| R| AX| 
( 00201159 )                  MOV, X| F| DX'| ZO| [SI] 
( 0020115B )   :L0020115B    LODS, X'| 
( 0020115C )                  MOVI, X| MEM| L0020276C L, L00201001 IL, 
( 00201166 )                  JMPS, L00201124 RB, 
( 00201168 )   :L00201168    LODS, X'| 
( 00201169 )                  CALLO, MEM| L00202784 L, 
( 0020116F )                  JMPO, MEM| L00202750 L, 
( 00201175 )   :L00201175    MOVI, X| MEM| L00202770 L, 0A IL, 
( 0020117F )                  MOVI, X| MEM| L0020276C L, L00200FED IL, 
( 00201189 )                  MOVI, X| MEM| L00202768 L, L00200E3B IL, 
( 00201193 )                  RET, 
( 00201194 )   :L00201194    MOVI, X| MEM| L00202770 L, 10 IL, 
( 0020119E )                  MOVI, X| MEM| L0020276C L, L00200FED IL, 
( 002011A8 )                  MOVI, X| MEM| L00202768 L, L00200E53 IL, 
( 002011B2 )                  RET, 
( 002011B3 )   :L002011B3    XORI, X| MEM| L00202774 L, 0E1 IL, 
( 002011BD )                  XORI, B| MEM| L00200FFF L, 2F IB, 
( 002011C4 )                  CALLO, MEM| L00202774 L, 
( 002011CA )                  JMP, L00201112 RL, 
( 002011CF )   :L002011CF    LODS, X'| 
( 002011D0 )                  LODS, X'| 
( 002011D1 )                  JMPO, MEM| L00202750 L, 
( 002011D7 )   :L002011D7    LODS, X'| 
( 002011D8 )                  JMPS, X_accept2 RB, 
( 002011DA )   :X_accept    MOVI, X| MEM| L0020276C L, L00200FC5 IL, 
( 002011E4 )                  LEA, DI'| MEM| L00200E0B L, 
( 002011EA )   :X_accept1    MOV, X| F| DI'| MEM| L00202768 L, 
( 002011F0 )   :X_accept2    TESTI, X| MEM| L00202754 L, -1 IL, 
( 002011FA )                  J, Z| Y| X_accept3 RB, 
( 002011FC )                  JMPO, MEM| L00202754 L, 
( 00201202 )   :X_accept3    CALL, L00200EA7 RL, 
( 00201207 )                  CMPI|A, B'| 4 IB, 
( 00201209 )                  J, S| N| X_accept4 RB, 
( 0020120B )                  MOV, X| T| DX'| MEM| L0020276C L, 
( 00201211 )                  JMPO, ZO|    [DX +4* AX] 
( 00201214 )   :X_accept4    ADDSI, MEM| L0020276C L, 14 IS, 
( 0020121B )                  CALL, L00201090 RL, 
( 00201220 )                  CALLO, MEM| L00202780 L, 
( 00201226 )                  JMPS, X_accept RB, 
( 00201228 )   :L00201228    LODS, X'| 
( 00201229 )   :L00201229    MOVI, X| MEM| L0020276C L, L00200FC5 IL, 
( 00201233 )                  LEA, DI'| MEM| L00200E0B L, 
( 00201239 )                  JMPS, L0020124B RB, 
( 0020123B )   :L0020123B    MOVI, X| MEM| L0020276C L, L00200F9D IL, 
( 00201245 )                  LEA, DI'| MEM| L00200E23 L, 
( 0020124B )   :L0020124B    LODS, X'| 
( 0020124C )                  JMPS, X_accept1 RB, 
( 0020124E )   :L0020124E    MOVI, X| MEM| L0020276C L, L00200FD9 IL, 
( 00201258 )                  LEA, DI'| MEM| L00200E0B L, 
( 0020125E )                  JMPS, L00201270 RB, 
( 00201260 )   :L00201260    MOVI, X| MEM| L0020276C L, L00200FB1 IL, 
( 0020126A )                  LEA, DI'| MEM| L00200E23 L, 
( 00201270 )   :L00201270    MOV, X| F| DI'| MEM| L00202768 L, 
( 00201276 )                  JMP, -197 (RL,) 
( 0020127B )   :X_unpac    LEA, SI'| BO| [SI] 0FC B, 
( 0020127E )                  MOV, X| F| AX'| ZO| [SI] 
( 00201280 )                  TEST, X| AX'| R| AX| 
( 00201282 )                  J, S| Y| X_unpac1 RB, 
( 00201284 )                  SHLI, X| ZO| [SI] 4 IS, 
( 00201287 )                  ROLI, X| R| AX| 4 IS, 
( 0020128A )                  ANDSI, R| AX| 7 IS, 
( 0020128D )                  RET, 
( 0020128E )   :X_unpac1    SHL, 1| X| R| AX| 
( 00201290 )                  J, S| Y| X_unpac2 RB, 
( 00201292 )                  SHLI, X| ZO| [SI] 5 IS, 
( 00201295 )                  ROLI, X| R| AX| 4 IS, 
( 00201298 )                  ANDSI, R| AX| 7 IS, 
( 0020129B )                  XORI|A, B'| 8 IB, 
( 0020129D )                  RET, 
( 0020129E )   :X_unpac2    SHLI, X| ZO| [SI] 7 IS, 
( 002012A1 )                  ROLI, X| R| AX| 6 IS, 
( 002012A4 )                  ANDSI, R| AX| 3F IS, 
( 002012A7 )                  SUBI|A, B'| 10 IB, 
( 002012A9 )                  RET, 
( 002012AA )   :L002012AA    LEA, SI'| BO| [SI] 0FC B, 
( 002012AD )                  MOV, X| F| AX'| ZO| [SI] 
( 002012AF )                  INC, X| ZO| [SI] 
( 002012B1 )                  CMP, X| F| DI'| MEM| L00202734 L, 
( 002012B7 )                  J, Z| N| L002012BE RB, 
( 002012B9 )                  MOV|FA, X'| L00202734 L, 
( 002012BE )   :L002012BE    CMP, X| T| AX'| MEM| L00202734 L, 
( 002012C4 )                  J, Z| Y| 10 (RB,) 
( 002012C6 )                  J, S| N| C (RB,) 
( 002012C8 )                  MOV, X| F| DI'| MEM| L0020273C L, 
( 002012CE )   :L002012CE    MOV, X| F| DI'| MEM| L00202738 L, 
( 002012D4 )                  LODS, X'| 
( 002012D5 )                  RET, 
( 002012D6 )                  MOV, X| F| DI'| MEM| L00202738 L, 
( 002012DC )                  SUBI, X| MEM| L00202814 L, 00160000 IL, 
( 002012E6 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002012E9 )                  MOV, X| F| AX'| ZO| [SI] 
( 002012EB )                  MOVI|X, AX| 00E04000 IL, 
( 002012F0 )                  CALL, X_color RL, 
( 002012F5 )                  MOVI|X, AX| 30 IL, 
( 002012FA )                  OS:, 
( 002012FB )                  MOV, X| T| CX'| MEM| 00202816 L, 
( 00201301 )                  OS:, 
( 00201302 )                  CMP, X| T| CX'| MEM| L0020281C L, 
( 00201308 )                  J, S| Y| 10 (RB,) 
( 0020130A )                  CALL, X_emit RL, 
( 0020130F )                  SUBI, X| MEM| L00202814 L, 00160000 IL, 
( 00201319 )   :L00201319    RET, 
( 0020131A )                  JMP, X_emit RL, 
( 0020131F )   :L0020131F    CALL, L002008EB RL, 
( 00201324 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201327 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201329 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 00201330 )                  ANDSI, R| AX| 0F0 IS, 
( 00201333 )                  CALL, X_unpac RL, 
( 00201338 )                  J, Z| Y| 7 (RB,) 
( 0020133A )                  CALL, X_emit RL, 
( 0020133F )                  JMPS, -E (RB,) 
( 00201341 )                  CALL, X_space RL, 
( 00201346 )                  LODS, X'| 
( 00201347 )                  LODS, X'| 
( 00201348 )                  RET, 
( 00201349 )   :L00201349    OS:, 
( 0020134A )                  MOV, X| T| CX'| MEM| 00202816 L, 
( 00201350 )                  OS:, 
( 00201351 )                  CMP, X| T| CX'| MEM| L00202818 L, 
( 00201357 )                  J, Z| Y| 5 (RB,) 
( 00201359 )                  CALL, X_cr RL, 
( 0020135E )                  CALL, X_colorF00 RL, 
( 00201363 )                  JMPS, -41 (RB,) 
( 00201365 )   :L00201365    CALL, X_color80F0 RL, 
( 0020136A )                  JMPS, -48 (RB,) 
( 0020136C )   :L0020136C    CALL, X_color0FF RL, 
( 00201371 )                  JMPS, -4F (RB,) 
( 00201373 )   :L00201373    LEA, SI'| BO| [SI] 0FC B, 
( 00201376 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201378 )                  MOVI|X, AX| 00FFFF00 IL, 
( 0020137D )                  CALL, X_color RL, 
( 00201382 )                  JMPS, -60 (RB,) 
( 00201384 )   :L00201384    CALL, L002008EB RL, 
( 00201389 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020138C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020138E )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 00201395 )                  ANDSI, R| AX| 0F0 IS, 
( 00201398 )                  CALL, X_unpac RL, 
( 0020139D )                  ADDI|A, B'| 30 IB, 
( 0020139F )                  CALL, X_emit RL, 
( 002013A4 )                  JMPS, -73 (RB,) 
( 002013A6 )   :L002013A6    CALL, L002008EB RL, 
( 002013AB )                  LEA, SI'| BO| [SI] 0FC B, 
( 002013AE )                  MOV, X| F| AX'| ZO| [SI] 
( 002013B0 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002013B7 )                  ANDSI, R| AX| 0F0 IS, 
( 002013BA )                  CALL, X_unpac RL, 
( 002013BF )                  J, Z| Y| -80 (RB,) 
( 002013C1 )                  ADDI|A, B'| 30 IB, 
( 002013C3 )                  CALL, X_emit RL, 
( 002013C8 )                  JMPS, -10 (RB,) 
( 002013CA )   :L002013CA    SUBI, X| MEM| L00202814 L, 00160000 IL, 
( 002013D4 )                  TESTI, X| ZO|    [MEM +4* DI] -4 L, -10 IL, 
( 002013DF )                  J|X, Z| N| -C1 (RL,) 
( 002013E5 )                  DEC|X, DI| 
( 002013E6 )                  MOV, X| F| DI'| MEM| L00202740 L, 
( 002013EC )                  CALL, X_space RL, 
( 002013F1 )                  CALL, L002012AA RL, 
( 002013F6 )                  POP|X, DX| 
( 002013F7 )                  LODS, X'| 
( 002013F8 )                  RET, 
( 002013F9 )   :L002013F9    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 00201400 )                  SARI, X| R| DX| 5 IS, 
( 00201403 )                  JMPS, 1C (RB,) 
( 00201405 )   :L00201405    MOVI, X| MEM| L00202724 L, X_. IL, 
( 0020140F )                  CALL, X_colorF0F RL, 
( 00201414 )                  CALL, -F5 (RL,) 
( 00201419 )   :L00201419    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 00201420 )                  INC|X, DI| 
( 00201421 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201424 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201426 )                  MOVI|X, AX| F800 IL, 
( 0020142B )                  CMPI, X| MEM| L00202724 L, X_. IL, 
( 00201435 )                  J, Z| Y| 36 (RB,) 
( 00201437 )                  MOVI|X, AX| C000 IL, 
( 0020143C )                  JMPS, 2F (RB,) 
( 0020143E )   :L0020143E    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 00201445 )                  SARI, X| R| DX| 5 IS, 
( 00201448 )                  JMPS, 8 (RB,) 
( 0020144A )   :L0020144A    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 00201451 )                  INC|X, DI| 
( 00201452 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201455 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201457 )                  MOVI|X, AX| 00FFFF00 IL, 
( 0020145C )                  CMPI, X| MEM| L00202724 L, X_. IL, 
( 00201466 )                  J, Z| Y| 5 (RB,) 
( 00201468 )                  MOVI|X, AX| 00C0C000 IL, 
( 0020146D )                  CALL, X_color RL, 
( 00201472 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201475 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201477 )                  MOV, X| T| AX'| R| DX| 
( 00201479 )   :L00201479    JMPO, MEM| L00202724 L, 
( 0020147F )                  MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 00201486 )                  SARI, X| R| DX| 5 IS, 
( 00201489 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020148C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020148E )                  MOVI|X, AX| 00FFFFFF IL, 
( 00201493 )                  CMPI, X| MEM| L00202724 L, X_. IL, 
( 0020149D )                  J, Z| Y| 5 (RB,) 
( 0020149F )                  MOVI|X, AX| 00C0C0C0 IL, 
( 002014A0 )   :L002014A0   dl 00C0C0C0 C7EB L002013CA L00201373 
( 002014B0 )                 dl L0020144A L00201349 L00201365 L00201419 
( 002014C0 )                 dl L002013F9 L0020136C L0020143E L0020131F 
( 002014D0 )                 dl L00201384 L002013A6 L00201405 X_nul 

( 002014E0 )   :X_+list    XCHG|AX, DX| 
( 002014E1 )                  ADDI|A, B'| 20 IB, 
( 002014E3 )                  ADD, B| F| BH'| BO| [DI] 14 B, 
( 002014E6 )                  AND, B| F| AL'| ZO| [AX] 
( 002014E8 )   :L002014E8    CALL, X_text RL, 
( 002014ED )                  LEA, SI'| BO| [SI] 0FC B, 
( 002014F0 )                  MOV, X| F| AX'| ZO| [SI] 
( 002014F2 )                  XOR, X| T| AX'| R| AX| 
( 002014F4 )                  MOV, X| T| DI'| MEM| L00202728 L, 
( 002014FA )                  ADD, X| T| DI'| MEM| 00202748 L, 
( 00201500 )                  SHLI, X| R| DI| 8 IS, 
( 00201503 )                  MOV, X| F| DI'| MEM| L0020273C L, 
( 00201509 )                  MOV, X| F| DI'| MEM| L00202738 L, 
( 0020150F )                  TESTI, X| ZO|    [MEM +4* DI] 0 L, 0F IL, 
( 0020151A )                  J, Z| Y| 5 (RB,) 
( 0020151C )                  CALL, L002012AA RL, 
( 00201521 )                  MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 00201528 )                  INC|X, DI| 
( 00201529 )                  MOVI, X| MEM| L00202724 L, X_. IL, 
( 00201533 )                  TESTI, B| R| DL| 10 IB, 
( 00201536 )                  J, Z| Y| A (RB,) 
( 00201538 )                  MOVI, X| MEM| L00202724 L, L00200C9C IL, 
( 00201542 )                  ANDSI, R| DX| 0F IS, 
( 00201545 )                  CALLO, ZO|    [MEM +4* DX] 002014A8 L, 
( 0020154C )                  JMPS, -3F (RB,) 
( 0020154E )   :L0020154E    CALL, X_show RL, 
( 00201553 )                  CALL, L00200BD0 RL, 
( 00201558 )                  CALL, L002014E8 RL, 
( 0020155D )                  JMP, X_keybo RL, 
( 0020155E )                 db 8 0F8 0FF 0FF 0 0 0 0FF 0FF 0 0 0 0 0 0 0 
( 0020156E )                 db 0FF 0 0 0C0 0 0 0 0 0 0 0 0 0 0 0FF 0FF 
( 0020157E )                 db 0 0 0 0 0 0 0FF 0FF 0FF 0 0FF 0FF 0FF 0 0FF 0FF 
( 0020158E )                 db 0FF 0 0FF 80 80 0 0C0 0C0 0C0 0 0FF 0 0 0 
( 0020159C )   :L0020159C   db 0 0 
( 0020159E )                 db 0 0 
( 002015A0 )   :L002015A0   db 0 

( 002015A1 )                  ADD, B| F| AL'| ZO| [AX] 
( 002015A3 )                  ADD, B| F| AL'| ZO| [CX] 
( 002015A5 )   :L002015A5    DEC, X| MEM| L00202734 L, 
( 002015AB )                  J, S| N| 6 (RB,) 
( 002015AD )   :L002015AD    INC, X| MEM| L00202734 L, 
( 002015B3 )                  RET, 
( 002015B4 )   :L002015B4    SUBSI, MEM| L00202734 L, 8 IS, 
( 002015BB )                  J, S| N| A (RB,) 
( 002015BD )                  MOVI, X| MEM| L00202734 L, 0 IL, 
( 002015C7 )                  RET, 
( 002015C8 )   :L002015C8    ADDSI, MEM| L00202734 L, 8 IS, 
( 002015CF )                  RET, 
( 002015D0 )   :L002015D0    ADDSI, MEM| L00202728 L, 2 IS, 
( 002015D7 )                  RET, 
( 002015D8 )   :L002015D8    CMPSI, MEM| L00202728 L, 14 IS, 
( 002015DF )                  J, S| Y| 7 (RB,) 
( 002015E1 )                  SUBSI, MEM| L00202728 L, 2 IS, 
( 002015E8 )                  RET, 
( 002015E9 )   :L002015E9    MOV, X| T| CX'| MEM| L00202728 L, 
( 002015EF )                  XCHG, X| CX'| MEM| L0020272C L, 
( 002015F5 )                  MOV, X| F| CX'| MEM| L00202728 L, 
( 002015FB )                  RET, 
( 002015FC )   :L002015FC    XORSI, MEM| L00202728 L, 1 IS, 
( 00201603 )                  RET, 
( 00201604 )                  MOV, X| T| CX'| MEM| L00202740 L, 
( 0020160A )                  ADD, X| T| CX'| MEM| L00202788 L, 
( 00201610 )                  XOR, X| T| CX'| MEM| L00202740 L, 
( 00201616 )                  ANDI, X| R| CX| FFFFFF00 IL, 
( 0020161C )                  J, Z| Y| B (RB,) 
( 0020161E )                  MOV, X| T| CX'| MEM| L00202788 L, 
( 00201624 )                  LODS, X'| 
( 00201625 )   :L00201625    DEC|X, CX| 
( 00201626 )                  J, Z| N| -4 (RB,) 
( 00201628 )                  RET, 
( 00201629 )                  PUSH|X, SI| 
( 0020162A )                  MOV, X| T| SI'| MEM| L00202740 L, 
( 00201630 )                  MOV, X| T| CX'| R| SI| 
( 00201632 )                  DEC|X, SI| 
( 00201633 )                  MOV, X| T| DI'| R| SI| 
( 00201635 )                  ADD, X| T| DI'| MEM| L00202788 L, 
( 0020163B )                  SHLI, X| R| DI| 2 IS, 
( 0020163E )                  SUB, X| T| CX'| MEM| L00202738 L, 
( 00201644 )                  J, S| Y| 7 (RB,) 
( 00201646 )                  SHLI, X| R| SI| 2 IS, 
( 00201649 )   :L00201649    STD, 
( 0020164A )                  REPZ, 
( 0020164B )                  MOVS, X'| 
( 0020164C )                  CLD, 
( 0020164D )                  POP|X, SI| 
( 0020164E )                  SHRI, X| R| DI| 2 IS, 
( 00201651 )                  INC|X, DI| 
( 00201652 )                  MOV, X| F| DI'| MEM| L00202734 L, 
( 00201658 )                  MOV, X| T| CX'| MEM| L00202788 L, 
( 0020165E )                  DEC|X, DI| 
( 0020165F )                  MOV, X| F| AX'| ZO|    [MEM +4* DI] 0 L, 
( 00201666 )                  LODS, X'| 
( 00201667 )   :L00201667    DEC|X, CX| 
( 00201668 )                  J, Z| N| -C (RB,) 
( 0020166A )                  RET, 
( 0020166B )                  CALL, -6C (RL,) 
( 00201670 )                  MOV, B| T| CL'| MEM| 002015A4 L, 
( 00201676 )                  XOR, B| F| CL'| ZO|    [MEM +4* DI] 0 L, 
( 0020167D )                  CMPI, B| R| CL| 3 IB, 
( 00201680 )                  J, Z| N| 11 (RB,) 
( 00201682 )                  MOVI, B| MEM| 002015A4 L, 4 IB, 
( 00201689 )                  MOVI, X| MEM| L00202778 L, C000 IL, 
( 00201693 )                  RET, 
( 00201694 )                  POP, MEM| L00202780 L, 
( 0020169A )                  MOVI, X| MEM| L00202780 L, L002006C9 IL, 
( 002016A4 )                  RET, 
( 002016A5 )   :L002016A5    MOVI, X| MEM| L00202780 L, 00201694 IL, 
( 002016AF )                  JMP, X_accept RL, 
( 002016B4 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002016B7 )                  MOV, X| F| AX'| ZO| [SI] 
( 002016B9 )                  MOVI|X, AX| 1 IL, 
( 002016BE )                  CMPI, B| MEM| 002015A4 L, 4 IB, 
( 002016C5 )   :L002016C5    J, Z| Y| 2 (RB,) 
( 002016C7 )                  MOVI|B, AL| 3 IB, 
( 002016C9 )                  CMPSI, MEM| L00202770 L, 0A IS, 
( 002016D0 )   :L002016D0    J, Z| Y| 2 (RB,) 
( 002016D2 )                  XORI|A, B'| 10 IB, 
( 002016D4 )                  XCHG, X| AX'| ZO| [SI] 
( 002016D6 )                  MOVI, X| MEM| L00202788 L, 2 IL, 
( 002016E0 )                  JMPS, -77 (RB,) 
( 002016E2 )                  TESTI, B| MEM| 002015A4 L, 0A IB, 
( 002016E9 )                  J, Z| N| 3C (RB,) 
( 002016EB )                  MOV, X| T| DX'| R| AX| 
( 002016ED )                  ANDI, X| R| DX| FC000000 IL, 
( 002016F3 )                  J, Z| Y| 8 (RB,) 
( 002016F5 )                  CMPI, X| R| DX| FC000000 IL, 
( 002016FB )                  J, Z| N| -49 (RB,) 
( 002016FD )                  SHLI, X| R| AX| 5 IS, 
( 00201700 )                  XORI|A, B'| 2 IB, 
( 00201702 )                  CMPI, B| MEM| 002015A4 L, 4 IB, 
( 00201709 )   :L00201709    J, Z| Y| 2 (RB,) 
( 0020170B )                  XORI|A, B'| 0B IB, 
( 0020170D )                  CMPSI, MEM| L00202770 L, 0A IS, 
( 00201714 )   :L00201714    J, Z| Y| 2 (RB,) 
( 00201716 )                  XORI|A, B'| 10 IB, 
( 00201718 )                  MOVI, X| MEM| L00202788 L, 1 IL, 
( 00201722 )                  JMP, -BC (RL,) 
( 00201727 )                  CMPI, B| MEM| 002015A4 L, 9 IB, 
( 0020172E )                  J, Z| N| C (RB,) 
( 00201730 )                  MOV, X| T| DX'| R| AX| 
( 00201732 )                  SHLI, X| R| DX| 5 IS, 
( 00201735 )                  SARI, X| R| DX| 5 IS, 
( 00201738 )   :L00201738    CMP, X| T| DX'| R| AX| 
( 0020173A )   :L0020173A    J, Z| Y| 2 (RB,) 
( 0020173C )                  LODS, X'| 
( 0020173D )                  RET, 
( 0020173E )                  SHLI, X| R| AX| 5 IS, 
( 00201741 )   :L00201741    XORI|A, B'| 6 IB, 
( 00201743 )                  JMPS, -38 (RB,) 
( 00201745 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201748 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020174A )                  MOV|TA, X'| L00202738 L, 
( 0020174F )                  SUB, X| T| AX'| MEM| L0020273C L, 
( 00201755 )                  J, Z| Y| 27 (RB,) 
( 00201757 )                  MOV, X| T| CX'| R| AX| 
( 00201759 )                  XCHG|AX, DX| 
( 0020175A )                  PUSH|X, SI| 
( 0020175B )                  MOV, X| T| SI'| MEM| L00202738 L, 
( 00201761 )                  LEA, SI'| ZO|    [MEM +4* SI] -4 L, 
( 00201768 )                  MOV, X| T| DI'| MEM| L00202744 L, 
( 0020176E )                  STD, 
( 0020176F )                  LODS, X'| 
( 00201770 )                  CLD, 
( 00201771 )                  STOS, X'| 
( 00201772 )                  DEC|X, CX| 
( 00201773 )                  J, Z| N| -7 (RB,) 
( 00201775 )                  XCHG|AX, DX| 
( 00201776 )                  STOS, X'| 
( 00201777 )                  MOV, X| F| DI'| MEM| L00202744 L, 
( 0020177D )                  POP|X, SI| 
( 0020177E )                  LODS, X'| 
( 0020177F )                  RET, 
( 00201780 )   :L00201780    CALL, -40 (RL,) 
( 00201785 )                  MOV, X| T| DI'| MEM| L0020273C L, 
( 0020178B )                  MOV, X| T| CX'| MEM| L00202740 L, 
( 00201791 )                  SUB, X| T| CX'| R| DI| 
( 00201793 )                  SHLI, X| R| DI| 2 IS, 
( 00201796 )                  PUSH|X, SI| 
( 00201797 )                  MOV, X| T| SI'| MEM| L00202738 L, 
( 0020179D )                  SHLI, X| R| SI| 2 IS, 
( 002017A0 )                  REPZ, 
( 002017A1 )                  MOVS, X'| 
( 002017A2 )                  POP|X, SI| 
( 002017A3 )                  JMP, L002015A5 RL, 
( 002017A8 )   :L002017A8    CALL, -68 (RL,) 
( 002017AD )                  JMP, L002015A5 RL, 
( 002017B2 )   :L002017B2    MOVI|B, AL| 1 IB, 
( 002017B4 )                  JMPS, 1E (RB,) 
( 002017B6 )   :L002017B6    MOVI|B, AL| 3 IB, 
( 002017B8 )                  JMPS, 1A (RB,) 
( 002017BA )   :L002017BA    MOVI|B, AL| 4 IB, 
( 002017BC )                  JMPS, 16 (RB,) 
( 002017BE )   :L002017BE    MOVI|B, AL| 9 IB, 
( 002017C0 )                  JMPS, 12 (RB,) 
( 002017C2 )   :L002017C2    MOVI|B, AL| 0A IB, 
( 002017C4 )                  JMPS, E (RB,) 
( 002017C6 )   :L002017C6    MOVI|B, AL| 0B IB, 
( 002017C8 )                  JMPS, A (RB,) 
( 002017CA )   :L002017CA    MOVI|B, AL| 0D IB, 
( 002017CC )                  JMPS, 6 (RB,) 
( 002017CE )   :L002017CE    MOVI|B, AL| 0E IB, 
( 002017D0 )   :L002017D0    JMPS, 2 (RB,) 
( 002017D2 )   :L002017D2    MOVI|B, AL| 7 IB, 
( 002017D4 )                  MOV|FA, B'| 002015A4 L, 
( 002017D9 )                  MOVI, X| MEM| L00202780 L, 0020166B IL, 
( 002017E3 )                  MOV, X| T| AX'| ZO|    [MEM +4* AX] 00201560 L, 
( 002017EA )                  MOV|FA, X'| L00202778 L, 
( 002017EF )                  POP|X, AX| 
( 002017F0 )                  LODS, X'| 
( 002017F1 )                  JMP, X_accept RL, 
( 002017F6 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002017F9 )                  MOV, X| F| AX'| ZO| [SI] 
( 002017FB )                  XOR, X| T| AX'| R| AX| 
( 002017FD )                  INC, X| MEM| L00202788 L, 
( 00201803 )                  JMP, -19D (RL,) 
( 00201808 )   :L00201808    MOVI, B| MEM| 002015A4 L, 0C IB, 
( 0020180F )                  MOVI|X, AX| 00FF00FF IL, 
( 00201814 )                  MOVI, X| MEM| L00202780 L, 002017F6 IL, 
( 0020181E )                  JMPS, -36 (RB,) 
( 00201820 )   :L00201820    POP|X, AX| 
( 00201821 )                  LODS, X'| 
( 00201822 )                  MOVI, X| MEM| L00202780 L, L002006C9 IL, 
( 0020182C )                  MOVI, X| MEM| L00202784 L, X_nul IL, 
( 00201836 )                  MOVI, B| MEM| L00200FD5 L, 0 IB, 
( 0020183D )                  MOVI, X| MEM| L00202730 L, 0 IL, 
( 00201847 )                  MOVI, X| MEM| L00200FC9 L, L002011D7 IL, 
( 00201851 )                  MOVI, X| MEM| L00202778 L, 00FFFF00 IL, 
( 0020185B )                  JMP, X_accept RL, 
( 00201860 )   :L00201860    MOV, X| T| DX'| MEM| L00202744 L, 
( 00201866 )                  CMPI, X| R| DX| 00094C00 IL, 
( 0020186C )                  J, Z| N| 1 (RB,) 
( 0020186E )                  RET, 
( 0020186F )                  SUBSI, R| DX| 8 IS, 
( 00201872 )                  MOV, X| T| CX'| BO| [DX] 4 B, 
( 00201875 )                  MOV, X| F| CX'| MEM| L00202788 L, 
( 0020187B )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020187E )                  MOV, X| F| AX'| ZO| [SI] 
( 00201880 )                  MOV, X| T| AX'| ZO| [DX] 
( 00201882 )                  SUBSI, R| DX| 4 IS, 
( 00201885 )                  DEC|X, CX| 
( 00201886 )                  J, Z| N| -D (RB,) 
( 00201888 )   :L00201888   dl 8904C283 20274415 FD6EE900 FFFF 
( 00201898 )                 dl X_nul L00201780 L00201820 L00201860 
( 002018A8 )                 dl L002017B2 L002017B6 L002017BA L002015FC 
( 002018B8 )                 dl L002015A5 L002015B4 L002015C8 L002015AD 
( 002018C8 )                 dl L002015D8 L00201808 L002017D2 L002015D0 
( 002018D8 )                 dl X_nul L002017C6 L002017C2 L002017BE 
( 002018E8 )   :L002018E8   dl X_nul X_nul X_nul L002015E9 
( 002018F8 )   :L002018F8   dl L002017CA L002017CE X_nul L002017A8 
( 00201908 )                 dl 00072515 2D0D010B 0110160C 
( 00201914 )   :L00201914   dl 2B0A0923 

( 00201918 )   :L00201918    ADD, B| F| BH'| ZO| [AX] 
( 0020191A )                  CMP, B| T| AL'| ZO| [DX] 
( 0020191C )                  ADD, B| F| DL'| ZO| [AX] 
( 0020191E )                  PUSH|CS, 
( 0020191F )                  AND, B| T| AL'| MEM| 4C240013 L, 
( 00201925 )                  SBBI|A, B'| 20 IB, 
( 00201927 )                  ADD, B| F| CH'| XO| [BP] 0D8B42EB L, 
( 0020192D )   :X_e    SUB, B| F| AH'| ZO| [DI] 
( 0020192F )                  AND, B| F| AL'| ZO| [AX] 
( 00201931 )                  MOV, X| F| CX'| MEM| L0020272C L, 
( 00201937 )                  MOV|FA, X'| L00202728 L, 
( 0020193C )                  LODS, X'| 
( 0020193D )   :L0020193D    CALL, L0020154E RL, 
( 00201942 )   :L00201942    CALLO, MEM| 00201924 L, 
( 00201948 )                  MOVI, X| MEM| L00202784 L, 002016E2 IL, 
( 00201952 )                  MOVI, X| MEM| L00202730 L, 1 IL, 
( 0020195C )                  MOVI, B| MEM| L00200FD5 L, 25 IB, 
( 00201963 )                  MOVI, X| MEM| L00200FC9 L, 00201928 IL, 
( 0020196D )                  MOVI, X| MEM| L0020276C L, L002018F8 IL, 
( 00201977 )                  MOVI, X| MEM| L00202768 L, 00201908 IL, 
( 00201981 )                  MOVI, X| MEM| L00202778 L, 00FFFF00 IL, 
( 0020198B )                  CALL, L00200EA7 RL, 
( 00201990 )                  CALLO, ZO|    [MEM +4* AX] 00201898 L, 
( 00201997 )                  LODS, X'| 
( 00201998 )                  JMPS, -F (RB,) 
( 0020199A )   :L0020199A    POP|X, DX| 
( 0020199B )                  MOV, X| F| DX'| MEM| L002015A0 L, 
( 002019A1 )                  ADDI, X| R| DX| 8C IL, 
( 002019A7 )                  MOV, X| F| DX'| MEM| L00202768 L, 
( 002019AD )                  SUBSI, R| DX| 10 IS, 
( 002019B0 )                  MOV, X| F| DX'| MEM| L0020276C L, 
( 002019B5 )   :L002019B5   db 0 0E8 0EC 0F4 
( 002019B9 )   :L002019B9   db 0FF 0FF 8B 15 0A0 15 20 0 3 0D0 8D 54 
( 002019C5 )                 db 82 5 3 52 0FC 0AD 
( 002019CB )   :L002019CB   db 0FF 0D2 

( 002019CD )   :L002019CD    JMPS, -19 (RB,) 
( 002019CF )                  ADD, B| F| AL'| ZO| [AX] 
( 002019D1 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019D3 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019D5 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019D7 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019D9 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019DB )                  POP|SS, 
( 002019DC )                  [DI +1* CX] 
( 002019DD )                  ADDI|A, B'| 1 IB, 
( 002019DF )                  ADD, B| F| AL'| ZO| [AX] 
( 002019E1 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019E3 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019E5 )                  ADD, B| F| AL'| ZO| [AX] 
( 002019E7 )                  XORI, X| MEM| L00202774 L, 0E1 IL, 
( 002019F1 )                  XORI, B| MEM| L00200FF9 L, 2F IB, 
( 002019F8 )                  CALLO, MEM| L00202774 L, 
( 002019FE )                  MOVI, X| MEM| 002019CF L, 0 IL, 
( 00201A08 )                  CMPSI, MEM| L00202770 L, 10 IS, 
( 00201A0F )                  J, Z| N| A (RB,) 
( 00201A11 )                  MOVI, X| MEM| 002019CF L, 00150414 IL, 
( 00201A1B )                  MOVI, X| MEM| L00202768 L, L002019CB IL, 
( 00201A1D )                 dl L00202768 L002019CB 276C05C7 19CF0020 
( 00201A2D )                 dl E8C30020 

( 00201A31 )   :L00201A31    MOVI|B, DL| 0FF IB, 
( 00201A33 )                  [DI +8* DI] 
( 00201A34 )                  FF  C, 
( 00201A35 )                  JMPS, 79 (RB,) 
( 00201A37 )                  PUSHI|X, 68002011 IL, 
( 00201A3C )                  ADC, X| F| SP'| ZO| [AX] 
( 00201A3E )                  ADD, B| F| CL'| R| BH| 
( 00201A40 )                  ADC, X| F| SP'| ZO| [AX] 
( 00201A42 )                  ADD, B| F| DH'| XO| [AX] 3000201A L, 
( 00201A48 )                  SBB, B| T| AH'| ZO| [AX] 
( 00201A4A )                  ADD, B| F| CH'| R| AL| 
( 00201A4C )                  INC|X, BX| 
( 00201A4D )                  [CX +8* SI] 
( 00201A4E )                  [DI +8* DI] 
( 00201A4F )                  INC, X| R| DI| 
( 00201A51 )   :L00201A51    ADDI|A, X'| 002019D3 IL, 
( 00201A56 )                  PUSH|ES, 
( 00201A57 )                  PUSH|SS, 
( 00201A58 )                  OR, X| F| AX'| ZO| [AX] 
( 00201A5A )                  CALL, -67 (RL,) 
( 00201A5F )   :L00201A5F    MOVI, B| MEM| L0020110A L, 0 IB, 
( 00201A66 )                  MOV|TA, X'| L00202790 L, 
( 00201A6B )                  CALL, X_qkey RL, 
( 00201A70 )                  J, Z| Y| 7 (RB,) 
( 00201A72 )                  JMPO, ZO|    [MEM +4* AX] 00201837 L, 
( 00201A79 )                  TEST, X| AX'| R| AX| 
( 00201A7B )                  J, LE| Y| 33 (RB,) 
( 00201A7D )                  CMPI|A, B'| 23 IB, 
( 00201A7F )   :L00201A7F    J, Z| Y| 27 (RB,) 
( 00201A81 )                  MOV|TA, X'| L00202790 L, 
( 00201A86 )                  CMP, X| T| AX'| MEM| L00202770 L, 
( 00201A8C )                  J, S| N| 18 (RB,) 
( 00201A8E )   :L00201A8E    TESTI, B| MEM| L0020110A L, 0FF IB, 
( 00201A95 )                  J, Z| Y| 2 (RB,) 
( 00201A97 )                  NEG, X| R| AX| 
( 00201A99 )                 dl AF0F168B 20277015 89D00300 

( 00201AA5 )   :L00201AA5    PUSH|SS, 
( 00201AA6 )                  JMPS, 8 (RB,) 
( 00201AA8 )                  XOR, X| F| AX'| MEM| L0020110A L, 
( 00201AAE )                  NEG, X| ZO| [SI] 
( 00201AB0 )                  LODS, X'| 
( 00201AB1 )                  JMPS, -48 (RB,) 
( 00201AB3 )                  AND, B| T| DL'| ZO| [AX] 
( 00201AB5 )                  AND, B| F| AL'| ZO| [AX] 
( 00201AB7 )                  AND, B| T| DL'| ZO| [AX] 
( 00201AB9 )                  AND, B| F| AL'| ZO| [AX] 
( 00201ABB )                  J, L| Y| 10 (RB,) 
( 00201ABD )                  AND, B| F| AL'| ZO| [AX] 
( 00201ABF )                  MOVI, X| MEM| 002019D3 L, 02150402 IL, 
( 00201AC9 )                  CALL, L00200B93 RL, 
( 00201ACE )                  MOVI, X| MEM| L00202788 L, 1 IL, 
( 00201AD8 )                  MOVI, X| MEM| L0020277C L, 1 IL, 
( 00201AE2 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201AE5 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201AE7 )                  MOVI, X| ZO| [SI] 0 IL, 
( 00201AED )                  MOVI, B| MEM| L00201015 L, 1C IB, 
( 00201AF4 )                  J, Z| Y| E (RB,) 
( 00201AF6 )                  CMPI|A, X'| 83 IL, 
( 00201AFB )                  J, S| N| 7 (RB,) 
( 00201AFD )                  JMPO, ZO|    [MEM +4* AX] 002018B3 L, 
( 00201B04 )                  TEST, X| AX'| R| AX| 
( 00201B06 )                  J, LE| Y| 1C (RB,) 
( 00201B08 )                  CMPI|A, X'| 30 IL, 
( 00201B0D )                  J, S| N| 15 (RB,) 
( 00201B0F )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201B12 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201B14 )                  CALL, L00200B7A RL, 
( 00201B19 )                  CALL, L00201050 RL, 
( 00201B1E )                  INC, X| MEM| L0020277C L, 
( 00201B24 )                  LODS, X'| 
( 00201B25 )                  CALL, X_qkey RL, 
( 00201B2A )                  JMPS, -38 (RB,) 
( 00201B2C )                  CALL, -14A (RL,) 
( 00201B31 )                  JMP, L002011D7 RL, 
( 00201B36 )   :L00201B36    JMPO, MEM| L00200FC9 L, 
( 00201B3C )                  XLAT, 
( 00201B3D )                  ADC, X| F| SP'| ZO| [AX] 
( 00201B3F )                  ADD, B| F| DL'| R| BH| 
( 00201B41 )                  ADC, X| F| SP'| ZO| [AX] 
( 00201B43 )                  ADD, B| F| DL'| R| BH| 
( 00201B45 )                  ADC, X| F| SP'| ZO| [AX] 
( 00201B47 )                  ADD, B| F| DH'| ZO| [SI] 
( 00201B49 )                  SBB, X| T| SP'| ZO| [AX] 
( 00201B4B )                  ADD, B| F| CH'| ZO|    [BX +1* BX] 
( 00201B4E )                  AND, B| F| AL'| ZO| [AX] 
( 00201B50 )                  MOVI, X| MEM| 002019D3 L, 0 IL, 
( 00201B5A )                  MOVI, X| MEM| L0020276C L, 002019CF IL, 
( 00201B64 )                  MOVI, X| MEM| L00202768 L, L002019CB IL, 
( 00201B6E )                  CALL, X_qkey RL, 
( 00201B73 )   :L00201B73    J, Z| Y| 7 (RB,) 
( 00201B75 )                  JMPO, ZO|    [MEM +4* AX] 0020193C L, 
( 00201B7C )                  CMPI|A, B'| 30 IB, 
( 00201B7E )                  J, Z| N| D (RB,) 
( 00201B80 )                  MOVI, X| MEM| 002019D3 L, 02150402 IL, 
( 00201B8A )                  LODS, X'| 
( 00201B8B )                  JMPS, -1F (RB,) 
( 00201B8D )                  TEST, X| AX'| R| AX| 
( 00201B8F )                  J, LE| Y| 30 (RB,) 
( 00201B91 )                  TESTI, X| MEM| 002019D3 L, -1 IL, 
( 00201B9B )                  J, Z| N| D (RB,) 
( 00201B9D )                  CMPI, B| MEM| L00202790 L, 0A IB, 
( 00201BA4 )                  J|X, S| Y| -15F (RL,) 
( 00201BAA )                  CMPI|A, X'| 30 IL, 
( 00201BAF )                  J, S| N| 10 (RB,) 
( 00201BB1 )                  CALL, -F7 (RL,) 
( 00201BB6 )                  CALLO, MEM| L00202780 L, 
( 00201BBC )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201BBF )                  MOV, X| F| AX'| ZO| [SI] 
( 00201BC1 )                  LODS, X'| 
( 00201BC2 )                  JMP, X_accept RL, 
( 00201BC7 )   :L00201BC7    MOVI, X| MEM| L00202754 L, 00201B50 IL, 
( 00201BD1 )                  RET, 
( 00201BD2 )   :L00201BD2    SUBI, X| R| DI| 00081200 IL, 
( 00201BD8 )                  J, C| Y| 29 (RB,) 
( 00201BDA )                  ADDI, X| R| DI| 1200 IL, 
( 00201BE0 )                  MOV, X| T| AX'| R| DI| 
( 00201BE2 )                  ANDI|A, X'| 0FF IL, 
( 00201BE7 )                  SHRI, X| R| DI| 8 IS, 
( 00201BEA )                  CMPI, X| R| DI| 05A0 IL, 
( 00201BF0 )                  J, C| N| 11 (RB,) 
( 00201BF2 )                  MOV|FA, X'| L00202734 L, 
( 00201BF7 )                  MOV, X| F| DI'| MEM| L00202728 L, 
( 00201BFD )                  CALLO, MEM| L0020275C L, 
( 00201C03 )                  MOVI|X, SP| 000A0000 IL, 
( 00201C08 )                  CMPI, X| R| SI| 0009F400 IL, 
( 00201C0E )                  J, C| Y| 5 (RB,) 
( 00201C10 )                  MOVI|X, SI| 0009F400 IL, 
( 00201C15 )                  MOVI, X| MEM| L002027CC L, L002005E8 IL, 
( 00201C1F )                  MOVI, X| MEM| L002027D0 L, L00200702 IL, 
( 00201C29 )                  MOVI, X| MEM| L002027D4 L, L002006A2 IL, 
( 00201C33 )                  MOVI, X| MEM| 002027D8 L, L002006B2 IL, 
( 00201C3D )                  MOVI|X, AX| 2F IL, 
( 00201C42 )                  CALL, L00200B7A RL, 
( 00201C47 )                  JMP, X_accept RL, 
( 00201C4C )   :L00201C4C    POP|X, CX| 
( 00201C4D )                  MOVI|X, SP| 000A0000 IL, 
( 00201C52 )                  JMPO, R| CX| 
( 00201C54 )   :L00201C54    LEA, SI'| BO| [SI] 0FC B, 
( 00201C57 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201C59 )                  MOVI|X, AX| 000A0000 IL, 
( 00201C5E )                  SUB, X| T| AX'| R| SP| 
( 00201C60 )                  SHR, 1| X| R| AX| 
( 00201C62 )                  SHR, 1| X| R| AX| 
( 00201C64 )   :X_copy    RET, 
( 00201C65 )   :L00201C65    MOVI|B, AL| 0FE IB, 
( 00201C67 )                  OUT|P, B'| 64 P, 
( 00201C69 )                  JMPS, -2 (RB,) 
( 00201C6B )   :L00201C6B    MOV, X| T| CX'| R| AX| 
( 00201C6D )                  SHLI, X| R| CX| 8 IS, 
( 00201C70 )                  LODS, X'| 
( 00201C71 )                  PUSH|X, DI| 
( 00201C72 )                  MOV, X| T| DI'| R| AX| 
( 00201C74 )                  SHLI, X| R| DI| 0A IS, 
( 00201C77 )                  XOR, X| T| AX'| R| AX| 
( 00201C79 )                  REPZ, 
( 00201C7A )                  STOS, X'| 
( 00201C7B )                  POP|X, DI| 
( 00201C7C )                  LODS, X'| 
( 00201C7D )                  RET, 
( 00201C7E )   :L00201C7E    CMPSI, R| AX| 0C IS, 
( 00201C81 )                  J|X, C| Y| X_abort RL, 
( 00201C87 )                  PUSH|X, DI| 
( 00201C88 )                  MOV, X| T| DI'| R| AX| 
( 00201C8A )                  SHLI, X| R| DI| 0A IS, 
( 00201C8D )   :X_debu    PUSH|X, SI| 
( 00201C8E )                  MOV, X| T| SI'| MEM| L00202728 L, 
( 00201C94 )                  SHLI, X| R| SI| 0A IS, 
( 00201C97 )                  MOVI|X, CX| 0200 IL, 
( 00201C9C )                  REPZ, 
( 00201C9D )                  MOVS, X'| 
( 00201C9E )                  POP|X, SI| 
( 00201C9F )                  POP|X, DI| 
( 00201CA0 )                  MOV|FA, X'| L00202728 L, 
( 00201CA5 )                  LODS, X'| 
( 00201CA6 )                  RET, 
( 00201CA7 )   :L00201CA7    MOVI, X| MEM| L00202814 L, 000302B5 IL, 
( 00201CB1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201CB4 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201CB6 )                  MOV|TA, X'| L00200446 L, 
( 00201CBB )                  PUSH, ZO| [AX] 
( 00201CBD )                  CALL, L00200C9C RL, 
( 00201CC2 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201CC5 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201CC7 )                  POP|X, AX| 
( 00201CC8 )                  CALL, L00200C9C RL, 
( 00201CCD )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201CD0 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201CD2 )                  MOV|TA, X'| L0020044F L, 
( 00201CD7 )                  CALL, L00200C9C RL, 
( 00201CDC )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201CDF )                  MOV, X| F| AX'| ZO| [SI] 
( 00201CE1 )                  MOV, X| T| AX'| R| SI| 
( 00201CE3 )                  JMP, L00200C9C RL, 
( 00201CE8 )                  DEC, X| MEM| L00202788 L, 
( 00201CEE )                  J, Z| Y| 3 (RB,) 
( 00201CF0 )                  LODS, X'| 
( 00201CF1 )                  JMPS, -B (RB,) 
( 00201CF3 )                  RET, 
( 00201CF4 )   :L00201CF4    CALL, L002016A5 RL, 
( 00201CF9 )                  CALL, -16 (RL,) 
( 00201CFE )                  CALL, L00200553 RL, 
( 00201D03 )                  J|X, Z| N| X_abort RL, 
( 00201D09 )   :X_winver    MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D2800 L, 
( 00201D10 )                  RET, 
( 00201D11 )   :L00201D11    ANDI|A, X'| -10 IL, 
( 00201D16 )                 db 0E8 38 
( 00201D18 )   :L00201D18   db 0E8 0FF 
( 00201D1A )   :L00201D1A   db 0FF 
( 00201D1B )   :L00201D1B   db 8B 
( 00201D1C )   :L00201D1C   db 4 8D 0 28 4D 0 0C3 
( 00201D23 )   :L00201D23   db 8D 

( 00201D24 )   :L00201D24    J, CZ| Y| -4 (RB,) 
( 00201D26 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201D28 )   :L00201D28    MOVI|X, AX| 0 IL, 
( 00201D2D )                  OR, X| T| AX'| R| AX| 
( 00201D2F )                  RET, 
( 00201D30 )                  ADD, X| F| AX'| ZO| [AX] 
( 00201D32 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201D34 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201D36 )                  ADD, X| F| AX'| ZO| [DX] 
( 00201D38 )                  ADC, B| T| BL'| ZO| [BX] 
( 00201D3A )                  INC, X| ZO| [AX] 
( 00201D3C )                  OS:, 
( 00201D3D )                  MOVI|X, DX| 03F4 IW, 
( 00201D40 )                  IN|D, B'| 
( 00201D41 )                  OUT|P, B'| 0E1 P, 
( 00201D43 )                  SHL, 1| B| R| AL| 
( 00201D45 )                  J, C| N| -7 (RB,) 
( 00201D47 )                  INC|X, DX| 
( 00201D48 )                  TEST, B| AL'| R| AL| 
( 00201D4A )   :L00201D4A    RET, 
( 00201D4B )                  LEA, DX'| MEM| 00201D32 L, 
( 00201D51 )                  MOV, B| F| AL'| ZO| [DX] 
( 00201D53 )                  PUSH|X, SI| 
( 00201D54 )                  MOV, X| T| SI'| R| DX| 
( 00201D56 )                  CALL, -1F (RL,) 
( 00201D5B )                  J, S| N| 5 (RB,) 
( 00201D5D )                  IN|D, B'| 
( 00201D5E )                  OUT|P, B'| 0E1 P, 
( 00201D60 )                  JMPS, -C (RB,) 
( 00201D62 )                  LODS, B'| 
( 00201D63 )                  MOVI|B, AH| 1E IB, 
( 00201D65 )                  OUT|D, B'| 
( 00201D66 )                  OUT|P, B'| 0E1 P, 
( 00201D68 )                  DEC, B| R| AH| 
( 00201D6A )                  J, Z| N| -6 (RB,) 
( 00201D6C )   :L00201D6C    LOOP, -18 (RB,) 
( 00201D6E )   :L00201D6E    POP|X, SI| 
( 00201D6F )                  RET, 
( 00201D70 )                  MOVI|B, AL| 8 IB, 
( 00201D72 )                  MOVI|B, CL| 1 IB, 
( 00201D74 )                  CALL, -2E (RL,) 
( 00201D79 )   :L00201D79    CALL, -42 (RL,) 
( 00201D7E )   :L00201D7E    IN|D, B'| 
( 00201D7F )                  OUT|P, B'| 0E1 P, 
( 00201D81 )                  CMPI|A, B'| 80 IB, 
( 00201D83 )                  RET, 
( 00201D84 )                  OUT|P, B'| 0B P, 
( 00201D86 )   :L00201D86    CALL, -1B (RL,) 
( 00201D8B )                  J, Z| N| L00201D86 RB, 
( 00201D8D )                  MOVI|B, AL| 0F IB, 
( 00201D8F )                  MOVI|B, CL| 3 IB, 
( 00201D91 )                  CALL, -4B (RL,) 
( 00201D96 )                  CALL, -2B (RL,) 
( 00201D9B )                  J, Z| Y| -7 (RB,) 
( 00201D9D )                  RET, 
( 00201D9E )                  MOVI, X| MEM| L00202744 L, 00094C00 IL, 
( 00201DA8 )                  MOVI|B, AL| 0C IB, 
( 00201DAA )                  OS:, 
( 00201DAB )                  MOVI|X, DX| 03F2 IW, 
( 00201DAE )                  MOVI|B, AH| 0F IB, 
( 00201DB0 )                  OUT|D, B'| 
( 00201DB1 )                  OUT|P, B'| 0E1 P, 
( 00201DB3 )                  DEC, B| R| AH| 
( 00201DB5 )                  J, Z| N| -6 (RB,) 
( 00201DB7 )                  RET, 
( 00201DB8 )                  MOVI|B, AL| 1C IB, 
( 00201DBA )                  CALL, -15 (RL,) 
( 00201DBF )                  MOVI|X, CX| 047868C0 IL, 
( 00201DC4 )                  LOOP, -2 (RB,) 
( 00201DC6 )                  MOVI|B, AL| 7 IB, 
( 00201DC8 )                  MOVI|B, CL| 2 IB, 
( 00201DCA )                  JMPS, -3B (RB,) 
( 00201DCC )                  OUT|P, B'| 5 P, 
( 00201DCE )                  MOV, B| T| AL'| R| AH| 
( 00201DD0 )                  OUT|P, B'| 5 P, 
( 00201DD2 )                  MOVI|X, AX| 00094C00 IL, 
( 00201DD7 )                  OUT|P, B'| 4 P, 
( 00201DD9 )                  MOV, B| T| AL'| R| AH| 
( 00201DDB )                  OUT|P, B'| 4 P, 
( 00201DDD )                  SHRI, X| R| AX| 10 IS, 
( 00201DE0 )                  OUT|P, B'| 81 P, 
( 00201DE2 )                  MOVI|B, AL| 0B IB, 
( 00201DE4 )                  OUT|P, B'| 0F P, 
( 00201DE6 )                  OS:, 
( 00201DE7 )                  MOVI, X| MEM| L00201D33 L, 02A1 IW, 
( 00201DEF )                  MOVI|B, AL| 3 IB, 
( 00201DF1 )   :L00201DF1    MOVI|B, CL| 3 IB, 
( 00201DF3 )                  CALL, -AD (RL,) 
( 00201DF8 )                  OS:, 
( 00201DF9 )                  MOVI, X| MEM| L00201D33 L, 0 IW, 
( 00201E01 )                  MOVI, B| MEM| 00201D30 L, 0 IB, 
( 00201E08 )                  RET, 
( 00201E09 )                  MOVI|B, CL| 9 IB, 
( 00201E0B )                  CALL, -C5 (RL,) 
( 00201E10 )                  INC, B| MEM| 00201D34 L, 
( 00201E16 )                  CALL, -DF (RL,) 
( 00201E1B )                  J, S| N| -7 (RB,) 
( 00201E1D )                  RET, 
( 00201E1E )                  MOVI|B, AL| 16 IB, 
( 00201E20 )                  CALL, -A1 (RL,) 
( 00201E25 )                  MOVI|B, AL| 0E6 IB, 
( 00201E27 )                  CALL, -23 (RL,) 
( 00201E2C )                  PUSH|X, SI| 
( 00201E2D )                  MOVI|X, SI| 00094C00 IL, 
( 00201E32 )                  MOVI|X, CX| 1200 IL, 
( 00201E37 )                  REPZ, 
( 00201E38 )                  MOVS, X'| 
( 00201E39 )                  POP|X, SI| 
( 00201E3A )   :L00201E3A    RET, 
( 00201E3B )                  MOVI|X, DI| 00094C00 IL, 
( 00201E40 )                  MOVI|X, CX| 1200 IL, 
( 00201E45 )                  REPZ, 
( 00201E46 )                  MOVS, X'| 
( 00201E47 )                  MOVI|B, AL| 1A IB, 
( 00201E49 )                  CALL, -CA (RL,) 
( 00201E4E )                  MOVI|B, AL| 0C5 IB, 
( 00201E50 )                  JMPS, -49 (RB,) 
( 00201E52 )                  MOV|FA, B'| 00201D34 L, 
( 00201E57 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201E5A )                  MOV, X| F| AX'| ZO| [SI] 
( 00201E5C )                  OS:, 
( 00201E5D )                  MOVI|X, DX| 03F2 IW, 
( 00201E60 )                  IN|D, B'| 
( 00201E61 )                  OUT|P, B'| 0E1 P, 
( 00201E63 )                  TESTI|A, B'| 10 IB, 
( 00201E65 )                  J, Z| N| 5 (RB,) 
( 00201E67 )                  JMP, -B4 (RL,) 
( 00201E6C )                  RET, 
( 00201E6D )                  XOR, X| T| CX'| R| CX| 
( 00201E6F )                  TESTI, B| MEM| 00201D30 L, 0FF IB, 
( 00201E76 )                  J, Z| Y| X_read1 RB, 
( 00201E78 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201E7B )                  MOV, X| F| AX'| ZO| [SI] 
( 00201E7D )                  MOVI|X, AX| 47FF IL, 
( 00201E82 )                  CALL, -BB (RL,) 
( 00201E87 )                  LODS, X'| 
( 00201E88 )   :X_read1    RET, 
( 00201E89 )   :L00201E89    CALL, -21 (RL,) 
( 00201E8E )                  CALL, -41 (RL,) 
( 00201E93 )                  PUSH|X, DI| 
( 00201E94 )                  MOV, X| T| DI'| BO| [SI] 4 B, 
( 00201E97 )                  SHLI, X| R| DI| 2 IS, 
( 00201E9A )                  CALL, -81 (RL,) 
( 00201E9F )                  POP|X, DI| 
( 00201EA0 )                  LODS, X'| 
( 00201EA1 )                  INC|X, AX| 
( 00201EA2 )                  ADDI, X| ZO| [SI] 1200 IL, 
( 00201EA8 )                  RET, 
( 00201EA9 )   :L00201EA9    CALL, -41 (RL,) 
( 00201EAE )                  CALL, -61 (RL,) 
( 00201EB3 )                  PUSH|X, SI| 
( 00201EB4 )                  MOV, X| T| SI'| BO| [SI] 4 B, 
( 00201EB7 )                  SHLI, X| R| SI| 2 IS, 
( 00201EBA )                  CALL, -84 (RL,) 
( 00201EBF )                  POP|X, SI| 
( 00201EC0 )                  JMPS, -22 (RB,) 
( 00201EC2 )   :L00201EC2    LEA, SI'| BO| [SI] 0FC B, 
( 00201EC5 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201EC7 )                  CALL, -12E (RL,) 
( 00201ECC )                  LODS, X'| 
( 00201ECD )                  RET, 
( 00201ECE )   :X_format    MOVI|B, AL| 1A IB, 
( 00201ED0 )                  CALL, -151 (RL,) 
( 00201ED5 )                  MOV, X| T| DX'| R| SI| 
( 00201ED7 )                  MOVI|B, CL| 6 IB, 
( 00201ED9 )                  CALL, -18B (RL,) 
( 00201EDE )                  CALL, -1A7 (RL,) 
( 00201EE3 )                  J, S| N| -7 (RB,) 
( 00201EE5 )                  RET, 
( 00201EE6 )   :L00201EE6    PUSH|X, AX| 
( 00201EE7 )                  MOVI|X, AX| 47 IL, 
( 00201EEC )                  XOR, X| T| CX'| R| CX| 
( 00201EEE )                  CALL, -127 (RL,) 
( 00201EF3 )                  POP|X, AX| 
( 00201EF4 )                  CALL, -A7 (RL,) 
( 00201EF9 )                  PUSH|X, SI| 
( 00201EFA )   :X_warm    MOV, X| T| SI'| BO| [SI] 4 B, 
( 00201EFD )                  SHLI, X| R| SI| 2 IS, 
( 00201F00 )                  CALL, X_format RL, 
( 00201F05 )                  POP|X, SI| 
( 00201F06 )                  MOVI|X, AX| 47FF IL, 
( 00201F0B )                  CALL, -144 (RL,) 
( 00201F10 )                  LODS, X'| 
( 00201F11 )                  RET, 
( 00201F12 )   :L00201F12    LEA, SI'| BO| [SI] 0FC B, 
( 00201F15 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201F17 )                  CALL, InitDisplay RL, 
( 00201F1C )                  CALL, L002004B2 RL, 
( 00201F21 )                  CALL, L002004E3 RL, 
( 00201F26 )                  CALL, L00201EC2 RL, 
( 00201F2B )                  MOVI, B| MEM| 00201D30 L, 1 IB, 
( 00201F32 )                  MOVI, X| MEM| ForthMacros L, 60 IL, 
( 00201F3C )                  MOVI, X| MEM| L002027BC L, 6 IL, 
( 00201F46 )                  MOVI, X| MEM| L00202744 L, 00094C00 IL, 
( 00201F50 )                  PUSH|X, SI| 
( 00201F51 )                  LEA, SI'| MEM| 00202C70 L, 
( 00201F57 )                  MOVI|X, DI| 004D0000 IL, 
( 00201F5C )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 00201F62 )                  REPZ, 
( 00201F63 )                  MOVS, X'| 
( 00201F64 )                  LEA, SI'| MEM| 00202DF0 L, 
( 00201F6A )                  MOVI|X, DI| 004D2800 IL, 
( 00201F6F )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 00201F75 )                  REPZ, 
( 00201F76 )                  MOVS, X'| 
( 00201F77 )                  POP|X, SI| 
( 00201F78 )                  MOVI, X| MEM| L002027A4 L, 004D5000 IL, 
( 00201F82 )                  MOVI, X| MEM| L0020275C L, X_nul IL, 
( 00201F8C )                  MOVI, X| MEM| L00202754 L, 0 IL, 
( 00201F96 )                  MOVI, X| MEM| 00202748 L, 0800 IL, 
( 00201F97 )                 db 5 48 27 20 0 0 8 0 0 0B8 12 0 0 0 0E8 0DC 
( 00201FA7 )                 db 0E8 0FF 0FF 0E9 2B 0F2 0FF 0FF 0 0 0 0 0 0 0 0 
( 00201FB7 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 

( 00201FC4 )   :X_nc/tsim    ADD, B| F| AL'| ZO| [AX] 
( 00201FC6 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FC8 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FCA )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FCC )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FCE )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FD0 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FD2 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FD4 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FD6 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FD8 )                  ADD, B| F| AL'| ZO| [AX] 
( 00201FDA )   :X_fov    ADD, B| F| AL'| ZO| [AX] 
( 00201FDC )   :L00201FDC    LEA, SI'| BO| [SI] 0FC B, 
( 00201FDF )                  MOV, X| F| AX'| ZO| [SI] 
( 00201FE1 )                  MOVI|X, AX| 000809D3 IL, 
( 00201FE6 )                  RET, 
( 00201FE7 )   :L00201FE7    LEA, SI'| BO| [SI] 0FC B, 
( 00201FEA )                  MOV, X| F| AX'| ZO| [SI] 
( 00201FEC )                  MOVI|X, AX| 00080A05 IL, 
( 00201FF1 )                  RET, 
( 00201FF2 )   :L00201FF2    LEA, SI'| BO| [SI] 0FC B, 
( 00201FF5 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201FF7 )                  MOVI|X, AX| 00080A09 IL, 
( 00201FFC )                  RET, 
( 00201FFD )   :L00201FFD    LEA, SI'| BO| [SI] 0FC B, 
( 00202000 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202002 )                  MOVI|X, AX| 000809F0 IL, 
( 00202007 )                  RET, 
( 00202008 )   :L00202008    LEA, SI'| BO| [SI] 0FC B, 
( 0020200B )                  MOV, X| F| AX'| ZO| [SI] 
( 0020200D )                  MOVI|X, AX| 000809EA IL, 
( 00202012 )                  RET, 
( 00202013 )   :L00202013    LEA, SI'| BO| [SI] 0FC B, 
( 00202016 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202018 )                  MOVI|X, AX| 000809CA IL, 
( 0020201D )                  RET, 
( 0020201E )   :L0020201E    LEA, SI'| BO| [SI] 0FC B, 
( 00202021 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202023 )                  MOVI|X, AX| 000809CD IL, 
( 00202028 )                  RET, 
( 00202029 )   :L00202029    LEA, SI'| BO| [SI] 0FC B, 
( 0020202C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020202E )                  MOVI|X, AX| 00080626 IL, 
( 00202033 )                  RET, 
( 00202034 )   :L00202034    LEA, SI'| BO| [SI] 0FC B, 
( 00202037 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202039 )                  MOVI|X, AX| 000809D7 IL, 
( 0020203E )                  RET, 
( 0020203F )   :L0020203F    LEA, SI'| BO| [SI] 0FC B, 
( 00202042 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202044 )                  MOVI|X, AX| 000809E2 IL, 
( 00202049 )                  RET, 
( 0020204A )   :L0020204A    LEA, SI'| BO| [SI] 0FC B, 
( 0020204D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020204F )                  MOVI|X, AX| 000809E4 IL, 
( 00202054 )                  RET, 
( 00202055 )   :L00202055    LEA, SI'| BO| [SI] 0FC B, 
( 00202058 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020205A )                  MOVI|X, AX| 00080559 IL, 
( 0020205F )                  RET, 
( 00202060 )   :L00202060    LEA, SI'| BO| [SI] 0FC B, 
( 00202063 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202065 )                  MOVI|X, AX| 000809E9 IL, 
( 0020206A )                  RET, 
( 0020206B )   :L0020206B    LEA, SI'| BO| [SI] 0FC B, 
( 0020206E )                  MOV, X| F| AX'| ZO| [SI] 
( 00202070 )                  MOVI|X, AX| 000809D2 IL, 
( 00202075 )                  RET, 
( 00202076 )   :L00202076    LEA, SI'| BO| [SI] 0FC B, 
( 00202079 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020207B )                  MOVI|X, AX| 00080A0B IL, 
( 00202080 )                  RET, 
( 00202081 )   :L00202081    LEA, SI'| BO| [SI] 0FC B, 
( 00202084 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202086 )                  MOVI|X, AX| 00080063 IL, 
( 0020208B )                  RET, 
( 0020208C )   :L0020208C    LEA, SI'| BO| [SI] 0FC B, 
( 0020208F )                  MOV, X| F| AX'| ZO| [SI] 
( 00202091 )                  MOVI|X, AX| 000809D1 IL, 
( 00202096 )                  RET, 
( 00202097 )   :L00202097    LEA, SI'| BO| [SI] 0FC B, 
( 0020209A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020209C )                  MOVI|X, AX| 00025300 IL, 
( 002020A1 )                  RET, 
( 002020A2 )   :L002020A2    LEA, SI'| BO| [SI] 0FC B, 
( 002020A5 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020A7 )                  MOVI|X, AX| 000809CE IL, 
( 002020AC )                  RET, 
( 002020AD )   :L002020AD    LEA, SI'| BO| [SI] 0FC B, 
( 002020B0 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020B2 )                  MOVI|X, AX| 000809CF IL, 
( 002020B6 )                 db 0 0C3 
( 002020B8 )   :L002020B8   db 8D 76 0FC 89 6 0B8 0EC 7 8 0 0C3 
( 002020C3 )   :L002020C3   db 8D 76 0FC 
( 002020C6 )                 db 89 6 0B8 2A 5 8 0 0C3 
( 002020CE )   :L002020CE   db 8D 76 0FC 89 6 0B8 0EE 9 
( 002020D6 )                 db 8 0 0C3 
( 002020D9 )   :L002020D9   db 8D 76 0FC 89 6 0B8 0EF 9 8 0 0C3 0 0 
( 002020E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002020F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202106 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202116 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202126 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202136 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202146 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202156 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202166 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202176 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202186 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202196 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202206 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202216 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202226 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202236 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202246 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202256 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202266 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202276 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202286 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202296 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202306 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202316 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202326 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202336 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202346 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202356 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202366 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202376 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202386 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202396 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202406 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202416 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202426 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202436 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202446 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202456 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202466 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202476 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202486 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202496 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202506 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202516 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202526 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202536 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202546 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202556 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202566 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202576 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202586 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202596 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202606 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202616 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202626 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202636 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202646 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202656 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202666 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202676 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202686 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202696 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026F6 )                 db 0 0 0 0 0 0 0 0 0 0 

( 00202700 )   :L00202700 names re rc r! rom 
( 00202710 )               names rs2 rkte rort0 ri3v 
( 00202720 )               names owoacs 

( 00202724 )   :L00202724   dl X_. 
( 00202728 )   :L00202728   dl 12 
( 0020272C )   :L0020272C   dl 0288 
( 00202730 )   :L00202730   dl 0 
( 00202734 )   :L00202734   dl 0 
( 00202738 )   :L00202738   dl 0 
( 0020273C )   :L0020273C   dl 0 
( 00202740 )   :L00202740   dl 0 
( 00202744 )   :L00202744   dl 00094C00 0 
( 0020274C )   :L0020274C   dl 50 
( 00202750 )   :L00202750   dl X_accept 
( 00202754 )   :L00202754   dl 0 
( 00202758 )   :L00202758   dl L00201BD2 
( 0020275C )   :L0020275C   dl 0 
( 00202760 )   :L00202760   dl 033D 
( 00202764 )   :L00202764   dl 028B 
( 00202768 )   :L00202768   dl L00200E0B 
( 0020276C )   :L0020276C   dl L00200FC5 
( 00202770 )   :L00202770   dl 0A 
( 00202774 )   :L00202774   dl L00201175 
( 00202778 )   :L00202778   dl 00FFFF00 
( 0020277C )   :L0020277C   dl 1 
( 00202780 )   :L00202780   dl L002006C9 
( 00202784 )   :L00202784   dl X_nul 
( 00202788 )   :L00202788   dl 1 
( 0020278C )   :L0020278C   dl 0 
( 00202790 )   :L00202790   dl 0 
( 00202794 )   :L00202794   dl L002005B6 
( 00202798 )   :L00202798   dl 6 
( 0020279C )   :L0020279C   dl 60 
( 002027A0 )   :L002027A0   dl 00100000 
( 002027A4 )   :L002027A4   dl 00100000 
( 002027A8 )   :L002027A8   dl 0 
( 002027AC )   :L002027AC   dl 0 
( 002027B0 )   :L002027B0   dl 0 
( 002027B4 )   :ForthWords   dl 0 
( 002027B8 )   :ForthMacros   dl 60 
( 002027BC )   :L002027BC   dl 6 L00200869 
( 002027C4 )                 dl L002006D6 
( 002027C8 )   :L002027C8   dl L0020078A 
( 002027CC )   :L002027CC   dl L002005E8 
( 002027D0 )   :L002027D0   dl L00200702 
( 002027D4 )   :L002027D4   dl L002006A2 L002006B2 L00200752 L00200770 
( 002027E4 )                 dl X_nul X_nul X_nul L00200653 
( 002027F4 )                 dl X_nul X_nul 
( 002027FC )   :L002027FC   dl X_nul 
( 00202800 )   :L00202800   dl L00200446 
( 00202804 )   :L00202804   dl X_nul 
( 00202808 )   :L00202808   dl X_nul 
( 0020280C )   :L0020280C   dl X_graph 
( 00202810 )   :L00202810   dl L00200990 
( 00202814 )   :L00202814   dl 00030003 
( 00202818 )   :L00202818   dl 3 
( 0020281C )   :L0020281C   dl 03F4 0 
( 00202824 )   :L00202824   dl 4B00 
( 00202828 )   :L00202828   dl 01F00000 
( 0020282C )   :L0020282C   dl 01F00000 
( 00202830 )   :L00202830   dl 0 
( 00202834 )   :L00202834   dl F7DE 
( 00202838 )   :L00202838   dl 0 

( 0020283C )   :L0020283C names _ ; dup ?dup 
( 0020284C )               names drop then begin _ 
( 0020285C )               names _ _ _ _ 
( 0020286C )               names _ _ _ _ 
( 0020287C )               names _ _ _ _ 
( 0020288C )               names _ _ _ _ 
( 0020289C )               names _ _ _ _ 
( 002028AC )               names _ _ _ _ 
( 002028BC )               names _ _ _ _ 
( 002028CC )               names _ _ _ _ 
( 002028DC )               names _ _ _ _ 
( 002028EC )               names _ _ _ _ 
( 002028FC )               names _ _ _ _ 
( 0020290C )               names _ _ _ _ 
( 0020291C )               names _ _ _ _ 
( 0020292C )               names _ _ _ _ 
( 0020293C )               names _ _ _ _ 
( 0020294C )               names _ _ _ _ 
( 0020295C )               names _ _ _ _ 
( 0020296C )               names _ _ _ _ 
( 0020297C )               names _ _ _ _ 
( 0020298C )               names _ _ _ _ 
( 0020299C )               names _ _ _ _ 
( 002029AC )               names _ _ _ _ 
( 002029BC )               names _ _ _ _ 
( 002029CC )               names _ _ _ _ 
( 002029DC )               names _ _ _ _ 
( 002029EC )               names _ _ _ _ 
( 002029FC )               names _ _ _ _ 
( 00202A0C )               names _ _ _ _ 
( 00202A1C )               names _ _ _ _ 
( 00202A2C )               names _ _ _ _ 
( 00202A3C )               names _ _ _ _ 
( 00202A4C )               names _ _ 

( 00202A54 )   :L00202A54   dl 0 X_; X_dup X_?dup 
( 00202A64 )                 dl X_drop X_then X_begin 0 
( 00202A74 )                 dl 0 0 0 0 
( 00202A84 )                 dl 0 0 0 0 
( 00202A94 )                 dl 0 0 0 0 
( 00202AA4 )                 dl 0 0 0 0 
( 00202AB4 )                 dl 0 0 0 0 
( 00202AC4 )                 dl 0 0 0 0 
( 00202AD4 )                 dl 0 0 0 0 
( 00202AE4 )                 dl 0 0 0 0 
( 00202AF4 )                 dl 0 0 0 0 
( 00202B04 )                 dl 0 0 0 0 
( 00202B14 )                 dl 0 0 0 0 
( 00202B24 )                 dl 0 0 0 0 
( 00202B34 )                 dl 0 0 0 0 
( 00202B44 )                 dl 0 0 0 0 
( 00202B54 )                 dl 0 0 0 0 
( 00202B64 )                 dl 0 0 0 0 
( 00202B74 )                 dl 0 0 0 0 
( 00202B84 )                 dl 0 0 0 0 
( 00202B94 )                 dl 0 0 0 0 
( 00202BA4 )                 dl 0 0 0 0 
( 00202BB4 )                 dl 0 0 0 0 
( 00202BC4 )                 dl 0 0 0 0 
( 00202BD4 )                 dl 0 0 0 0 
( 00202BE4 )                 dl 0 0 0 0 
( 00202BF4 )                 dl 0 0 0 0 
( 00202C04 )                 dl 0 0 0 0 
( 00202C14 )                 dl 0 0 0 0 
( 00202C24 )                 dl 0 0 0 0 
( 00202C34 )                 dl 0 0 0 0 
( 00202C44 )                 dl 0 0 0 0 
( 00202C54 )                 dl 0 0 0 0 
( 00202C64 )                 dl 0 0 

( 00202C6C )   :EncodedWords names _ forths macros boot 
( 00202C7C )               names warm pause macro forth 
( 00202C8C )               names c stop read write 
( 00202C9C )               names nc format show serve 
( 00202CAC )               names load here ?lit 3, 
( 00202CBC )               names 2, 1, , less 
( 00202CCC )               names jump pci devic accept 
( 00202CDC )               names pad erase copy mark 
( 00202CEC )               names empt emit digit 2emit 
( 00202CFC )               names . h. h.n cr 
( 00202D0C )               names space down edit e 
( 00202D1C )               names lm rm graph switch 
( 00202D2C )               names freeze text top keybo 
( 00202D3C )               names debu at +at xy 
( 00202D4C )               names fov fifo box line 
( 00202D5C )               names color octant sp last 
( 00202D6C )               names unpac blk curs word 
( 00202D7C )               names ekt abort h buffe 
( 00202D8C )               names offset tic winver aper 
( 00202D9C )               names vesa trash hsvv tsim 
( 00202DAC )               names cpoint words qkey digin 
( 00202DBC )               names qwert no-ret r? nul 
( 00202DCC )               names cad pcad displ actc 
( 00202DDC )               names +list itick 

( 00202DE4 )   :CodePointers   dl A3C00000 F6800000 0 L002020CE 
( 00202DF4 )                 dl L002020D9 L00201C65 L00201F12 X_pauseFixed 
( 00202E04 )                 dl X_macro X_forth X_c L00201EC2 
( 00202E14 )                 dl L00201E89 L00201EA9 L00201FDC L00201EE6 
( 00202E24 )                 dl X_show X_serve X_load X_here 
( 00202E34 )                 dl X_?lit X_3, X_2, X_1, 
( 00202E44 )                 dl X_, X_less X_jump X_pci 
( 00202E54 )                 dl X_devic X_accept L0020199A L00201C6B 
( 00202E64 )                 dl L00201C7E X_mark X_empt X_emit 
( 00202E74 )                 dl X_digit X_2emit X_. X_h. 
( 00202E84 )                 dl X_h.n X_cr X_space X_down 
( 00202E94 )                 dl L0020192B L0020193D X_lm X_rm 
( 00202EA4 )                 dl X_graph X_switch X_freeze X_text 
( 00202EB4 )                 dl X_top X_keybo L00201CA7 X_at 
( 00202EC4 )                 dl X_+at L00201FE7 L00201FF2 X_fifo 
( 00202ED4 )                 dl X_box X_line X_color X_octant 
( 00202EE4 )                 dl L00201FFD L00202008 X_unpac L00202013 
( 00202EF4 )                 dl L0020201E L002016A5 L00202029 X_abort 
( 00202F04 )                 dl L00202060 L00202097 L0020206B L00201CF4 
( 00202F14 )                 dl L00201D23 L00202076 L00202081 L0020208C 
( 00202F24 )                 dl L002020B8 L00201FDC L00202034 L0020203F 
( 00202F34 )                 dl X_qkey L0020204A L00201BC7 L00201C4C 
( 00202F44 )                 dl L00201C54 X_nul L002020A2 L002020AD 
( 00202F54 )                 dl L002020C3 L00202055 L002014E8 L00201D11 
( 00202F64 )                 dl L0020154E L00201942 0 0 
( 00202F74 )                 dl 0 0 0 0 
( 00202F84 )                 dl 0 0 0 0 
( 00202F94 )                 dl 0 0 0 0 
( 00202FA4 )                 dl 0 0 0 0 
( 00202FB4 )                 dl 0 0 0 0 
( 00202FC4 )                 dl 0 0 0 0 
( 00202FD4 )                 dl 0 0 0 0 
( 00202FE4 )                 dl 0 0 0 0 
( 00202FF4 )                 dl 0 0 0 

( 00203000 )   :IconImages icons{ 
0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000000000000000 
0 0000000000000000 1 0000000000000000 2 0000001110000000 3 0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   1110001111111000   0011111111111100   0001111111111000 
  0000000000000000   1111011111111110   0011111111111100   0111111111111110 
  0000000000000000   1111111111111111   0011111111111100   0111111111111110 
  0000000000000000   1111110000000111   0000001111000000   1111100000011111 
  0000000000000000   1111100000000001   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111100000011111 
  0000000000000000   1111000000000000   0000001111000000   0111111111111110 
  0000000000000000   1111000000000000   0000001111000000   0111111111111110 
  0000000000000000   1111000000000000   0000001111000000   0001111111111000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000001111000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0001111111111000   0001111111111000   1110001111111000   0000000000000000 
  0111111111111110   0111111111111110   1111011111111110   0000001111000000 
  0111111111111111   0111111111111110   1111111111111110   0000001111000000 
  1111000000001111   0000000000011111   1111110000011111   0000001111000000 
  1111000000001111   0000000000001111   1111100000001111   0000001111000000 
  1111000000011111   0000000000001111   1111000000001111   0000001111000000 
  1111111111111110   0011111111111111   1111000000001111   0000001111000000 
  1111111111111100   0111111111111111   1111000000001111   0000001111000000 
  1111000000000000   1111100000001111   1111000000001111   0000001111000000 
  1111000000000000   1111000000001111   1111000000001111   0000001111000000 
  1111100000000000   1111000000011111   1111000000001111   0000001111000000 
  0111111111111110   0111111111111111   1111000000001111   0000001111000000 
  0111111111111110   0111111111111111   1111000000001111   0000001111000000 
  0001111111111000   0001111111110111   1111000000001111   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0001111111111000   1101110000111100   0001111111111000   1111000000001111 
  0111111111111110   1111111001111110   0111111111111110   1111000000001111 
  0111111111111110   1111111111111111   0111111111111110   1111000000001111 
  1111100000000010   1111111111111111   1111100000001111   1111000000001111 
  1111000000000000   1111001111001111   1111000000000001   1111000000001111 
  1111000000000000   1110000110000111   1111000000000000   1111000000001111 
  0111111111111100   1110000000000111   1111000000000000   1111000000001111 
  0011111111111110   1110000000000111   1111000000000000   1111000000001111 
  0000000000001111   1110000000000111   1111000000000000   1111100000011111 
  0000000000001111   1110000000000111   1111000000000001   0111110000111111 
  0100000000011111   1110000000000111   1111100000001111   0111111111111111 
  0111111111111110   1110000000000111   0111111111111110   0001111111111111 
  0111111111111110   1110000000000111   0111111111111110   0000011111101111 
  0001111111111000   1110000000000111   0001111111111000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0110000000011111 
  0000000000000000   0000000000000000   0000000000000000   0111111111111110 
  0000000000000000   0000000000000000   0000000000000000   0111111111111110 
  0000000000000000   0000000000000000   0000000000000000   0011111111111000 

0 0000111100000000 0 0000000000000000 0 0000000111111000 0 0000000000000000 
C 0000011110000000 D 0000000000000000 E 0000001111111100 F 0000000000000000 
  0000011110000000   0000000000000000   0000011110001100   0000000000000000 
  0000011110000000   0000000000000000   0000011110000000   0000000000000000 
  0000011110000000   0000000000000000   0000011110000000   0000000000000000 
  0000011110000000   0001111111100111   0011111111110000   1100000000000011 
  0000011110000000   0111111111110111   0011111111110000   1110000000000111 
  0000011110000000   0111111111111111   0011111111110000   1110000000000111 
  0000011110000000   1111100000011111   0000011110000000   1110000000000111 
  0000011110000000   1111000000001111   0000011110000000   1111000110001111 
  0000011110000000   1111000000001111   0000011110000000   0111000110001110 
  0000011110000000   1111000000001111   0000011110000000   0111000110001110 
  0000011110000000   1111000000001111   0000011110000000   0111101111011110 
  0000011110000000   1111000000001111   0000011110000000   0011101111011100 
  0000011110000000   1111100000011111   0000011110000000   0011111111111100 
  0000011110000000   0111111111111111   0000011110000000   0001111001111000 
  0000011111000000   0111111111111111   0000011110000000   0001111001111000 
  0000011111000000   0001111111111111   0000011110000000   0000110000110000 
  0000001111100000   0000000000001111   0000011110000000   0000110000110000 
  0000000000000000   0000000000001111   0000000000000000   0000000000000000 
  0000000000000000   0110000000011111   0000000000000000   0000000000000000 
  0000000000000000   0111111111111110   0000000000000000   0000000000000000 
  0000000000000000   0111111111111110   0000000000000000   0000000000000000 
  0000000000000000   0001111111111000   0000000000000000   0000000000000000 

1 0000000000001111 1 0000000000000000 1 0000000000000000 1 1111000000000000 
0 0000000000001111 1 0000000000000000 2 0000000000000000 3 1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0001111111101111   1110000000000111   1110011111111000   1111011111111000 
  0111111111111111   1110000000000111   1111111111111110   1111111111111110 
  0111111111111111   1111000000001111   1111111111111110   1111111111111110 
  1111100000011111   0111000000001110   1111100000011111   1111100000011111 
  1111000000001111   0111100000011110   1111000000001111   1111000000001111 
  1111000000001111   0011100000011100   1111000000001111   1111000000001111 
  1111000000001111   0011110000111100   1111000000001111   1111000000001111 
  1111000000001111   0001110000111000   1111000000001111   1111000000001111 
  1111000000001111   0001111001111000   1111000000001111   1111000000001111 
  1111000000001111   0000111001110000   1111000000001111   1111000000001111 
  1111100000011111   0000111111110000   1111100000011111   1111100000011111 
  0111111111111111   0000011111100000   1111111111111110   1111111111111110 
  0111111111111111   0000001111000000   1111111111111110   1110111111111110 
  0001111111101111   0000000110000000   1111011111111000   1110011111111000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 

1 1111000000000000 1 0000000000000000 1 0000000000000000 1 0000000000000000 
4 1111000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111011111111000   1111000000001111   1111000000001111   0001111111100111 
  1111111111111110   1111100000011111   1111000000001111   0111111111110111 
  1111111111111110   0111110000111110   1111000000001111   0111111111111111 
  1111100000011111   0011111001111100   1111000000001111   1111100000011111 
  1111000000001111   0001111111111000   1111000000001111   1111000000001111 
  1111000000001111   0000111111110000   1111000000001111   1111000000001111 
  1111000000001111   0000011111100000   1111000000001111   1111000000001111 
  1111000000001111   0000011111100000   1111000000001111   1111000000001111 
  1111000000001111   0000111111110000   1111000000001111   1111000000001111 
  1111000000001111   0001111111111000   1111000000001111   1111000000001111 
  1111000000001111   0011111001111100   1111100000011111   1111100000011111 
  1111000000001111   0111110000111110   0111111111111110   0111111111111111 
  1111000000001111   1111100000011111   0111111111111110   0111111111111111 
  1111000000001111   1111000000001111   0001111111111000   0001111111101111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001110 

1 0001111111111000 1 0000000111100000 1 0001111111111000 1 0001111111111000 
8 0111111111111110 9 0000001111100000 A 0111111111111110 B 0111111111111110 
  0111111111111110   0000011111100000   0111111111111110   0111111111111110 
  1111100000011111   0000111111100000   1111000000011111   1111000000011111 
  1111000000001111   0000111111100000   0000000000001111   0000000000001111 
  1111000000001111   0000110111100000   0000000000001111   0000000000001111 
  1111000000001111   0000100111100000   0000000000001111   0000000000001111 
  1111000000001111   0000000111100000   0000000000011111   0000000000011111 
  1111000000001111   0000000111100000   0001111111111110   0000011111111110 
  1111000000001111   0000000111100000   0111111111111110   0000011111111100 
  1111000000001111   0000000111100000   0111111111111000   0000011111111110 
  1111000000001111   0000000111100000   1111100000000000   0000000000011111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111100000011111   0000000111100000   1111000000000000   1111000000011111 
  0111111111111110   0000000111100000   1111111111111111   0111111111111110 
  0111111111111110   0000000111100000   1111111111111111   0111111111111110 
  0001111111111000   0000000111100000   1111111111111111   0001111111111000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

1 1111000011110000 1 1111111111111111 1 0001111111111000 1 1111111111111111 
C 1111000011110000 D 1111111111111111 E 0111111111111110 F 1111111111111111 
  1111000011110000   1111111111111111   0111111111111111   1111111111111111 
  1111000011110000   1111000000000000   1111100000001111   0000000000000111 
  1111000011110000   1111000000000000   1111000000000000   0000000000001111 
  1111000011110000   1111000000000000   1111000000000000   0000000000011111 
  1111000011110000   1111000000000000   1111000000000000   0000000000111110 
  1111000011110000   1111000000000000   1111000000000000   0000000001111100 
  1111111111111111   1111111111111000   1111011111111000   0000000011111000 
  1111111111111111   1111111111111110   1111111111111110   0000000111110000 
  1111111111111111   1111111111111110   1111111111111111   0000001111100000 
  0000000011110000   0000000000011111   1111100000011111   0000011111000000 
  0000000011110000   0000000000001111   1111000000001111   0000111110000000 
  0000000011110000   0000000000001111   1111000000001111   0001111100000000 
  0000000011110000   0000000000001111   1111000000001111   0011111000000000 
  0000000011110000   1111000000011111   1111100000011111   0111110000000000 
  0000000011110000   1111111111111110   0111111111111110   1111100000000000 
  0000000011110000   0111111111111110   0111111111111110   1111000000000000 
  0000000011110000   0001111111111000   0001111111111000   1110000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

2 0001111111111000 2 0001111111111000 2 0000000001111000 2 0000000000000000 
0 0111111111111110 1 0111111111111110 2 0000000001111000 3 0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  1111100000011111   1111100000011111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000001111000   0000000000000000 
  1111100000011111   1111100000011111   0000000001111000   0000000000000000 
  0111111111111110   1111111111111111   0000000001111000   0001111111111100 
  0011111111111100   0111111111111111   0000000001111000   0011111111111100 
  0111111111111110   0001111111101111   0000000001111000   0011111111111000 
  1111100000011111   0000000000001111   0000000001111000   0000000000000000 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111100000011111   1111000000011111   0000000001111000   0000000000000000 
  0111111111111110   1111111111111110   0000000001111000   0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  0001111111111000   0001111111111000   0000000001111000   0000000000000000 
  0000000000000000   0000000000000000   0000000001111000   0000000000000000 
  0000000000000000   0000000000000000   0011110011111000   0000000000000000 
  0000000000000000   0000000000000000   0011111111110000   0000000000000000 
  0000000000000000   0000000000000000   0001111111110000   0000000000000000 
  0000000000000000   0000000000000000   0000111111000000   0000000000000000 

2 1111000000000000 2 0000000000000000 2 0000000000000000 2 0000000000001111 
4 1111000000000000 5 0000000000000000 6 0000000000000000 7 0000000000011111 
  1111000000000000   0000000000000000   0000000000000000   0000000000011111 
  1111000000000000   0000000000000000   0000000000000000   0000000000111110 
  1111000000000000   0000000000000000   0000000000000000   0000000001111100 
  1111000000111100   0000000000000000   0000000000000000   0000000001111100 
  1111000011111100   0000000000000000   1111111111111111   0000000011111000 
  1111001111111100   0000000000000000   1111111111111111   0000000111110000 
  1111111111100000   0000000000000000   1111111111111111   0000000111110000 
  1111111110000000   0000000000000000   0000000000011111   0000001111100000 
  1111111100000000   0000000000000000   0000000000111111   0000011111000000 
  1111111100000000   0000000000000000   0000000011111110   0000011111000000 
  1111111111000000   0000000000000000   0000001111111000   0000111110000000 
  1111111111110000   0000011100000000   0000111111100000   0001111100000000 
  1111001111111100   0000111110000000   0011111110000000   0001111100000000 
  1111000111111111   0001111111000000   1111111000000000   0011111000000000 
  1111000001111111   0001111111000000   1111111111111111   0111110000000000 
  1111000000011111   0001111111000000   1111111111111111   1111110000000000 
  1111000000000111   0000111110000000   1111111111111111   1111100000000000 
  0000000000000000   0000011100000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

2 0000000000000000 2 0000000011110000 2 0000000110000000 2 0000000000000000 
8 0000000000000000 9 0000000011110000 A 0000000110000000 B 0000000000000000 
  0000000000000000   0000000111100000   0000001111000000   0000000000000000 
  0000011100000000   0000000111100000   0000001111000000   0000000000000000 
  0000111110000000   0000000111000000   0000001111000000   0000001111000000 
  0001111111000000   0000000111000000   0000011111100000   0000001111000000 
  0001111111000000   0000001110000000   0000011111100000   0000001111000000 
  0001111111000000   0000001110000000   0000011111100000   0000001111000000 
  0000111110000000   0000001100000000   0000011111100000   0011111111111100 
  0000011100000000   0000001100000000   0000001111000000   0011111111111100 
  0000000000000000   0000001000000000   0000001111000000   0011111111111100 
  0000000000000000   0000001000000000   0000000110000000   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000001111000000 
  0000011100000000   0000000000000000   0000000000000000   0000001111000000 
  0000111110000000   0000000000000000   0000000110000000   0000001111000000 
  0001111111000000   0000000000000000   0000001111000000   0000000000000000 
  0001111111000000   0000000000000000   0000011111100000   0000000000000000 
  0001111111000000   0000000000000000   0000011111100000   0000000000000000 
  0000111111000000   0000000000000000   0000001111000000   0000000000000000 
  0000011111000000   0000000000000000   0000000110000000   0000000000000000 
  0000001110000000   0000000000000000   0000000000000000   0000000000000000 
  0000011100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111000000000   0000000000000000   0000000000000000   0000000000000000 
  0001110000000000   0000000000000000   0000000000000000   0000000000000000 

2 0001111111111000 2 0000000000000000 2 0000000000000000 2 0001111111111000 
C 0111111111111110 D 0000000000000000 E 0000000000000000 F 0111111111111110 
  0111111111111110   0000000000000000   0000000000000000   0111111111111110 
  1111000000001111   0000000000000000   0000000000000000   1111000000001111 
  1110000000000111   0000100000010000   0000000000000000   1111000000000111 
  1110000000000111   0001110000111000   0000000000000000   0000000000000111 
  1110000110000111   0011111001111100   0000000000000000   0000000000001111 
  1110001111000111   0001111111111000   0000000000000000   0000000000111110 
  1110001111000111   0000111111110000   0000000000000000   0000000011111000 
  1110001111000111   0000011111100000   0000000000000000   0000001111100000 
  1110001111111110   0000111111110000   0000000000000000   0000001111000000 
  1110001111111110   0001111111111000   0000000000000000   0000001111000000 
  1110000111111000   0011111001111100   0000000000000000   0000000000000000 
  1110000000000000   0001110000111000   0000011100000000   0000000000000000 
  1110000000000000   0000100000010000   0000111110000000   0000000110000000 
  1111000000001111   0000000000000000   0001111111000000   0000001111000000 
  0111111111111110   0000000000000000   0001111111000000   0000011111100000 
  0111111111111110   0000000000000000   0001111111000000   0000011111100000 
  0001111111111000   0000000000000000   0000111111000000   0000001111000000 
  0000000000000000   0000000000000000   0000011111000000   0000000110000000 
  0000000000000000   0000000000000000   0000001110000000   0000000000000000 
  0000000000000000   0000000000000000   0000011100000000   0000000000000000 
  0000000000000000   0000000000000000   0000111000000000   0000000000000000 
  0000000000000000   0000000000000000   0001110000000000   0000000000000000 

3 1111111111110000 3 0000000000000000 3 0000000000000000 3 0000000000000000 
0 1111111111111100 1 0000000000000000 2 0001100000000000 3 0000000000000000 
  1111111111111110   0000000000000000   0001100000000000   0000000000000000 
  0111111111111110   0110111000000000   0111111000000000   0011111000000000 
  0011111111111111   0111111100000000   0111111000000000   0111111100000000 
  0001111111111111   0111000100000000   0001100000000000   0110001100000000 
  0000111111111111   0110000000000000   0001100000000000   0110001100000000 
  0000011111111111   0110000000000000   0001100000000000   0110001100000000 
  0000001111111111   0110000000000000   0001100000000000   0110001100000000 
  0000000111111111   0110000000000000   0001100000000000   0111111100000000 
  0000000011111111   0110000000000000   0001110000000000   0011111000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000111111111   0000000000000000   0000000000000000   0000000000000000 
  0000001111111111   0000000000000000   0000000000000000   0000000000000000 
  0000011111111111   0000000000000000   0000000000000000   0000000000000000 
  0000111111111111   0000000000000000   0000000000000000   0000000000000000 
  0001111111111111   0000000000000000   0000000000000000   0000000000000000 
  0011111111111111   0000000000000000   0000000000000000   0000000000000000 
  0111111111111110   0000000000000000   0000000000000000   0000000000000000 
  1111111111111110   0000000000000000   0000000000000000   0000000000000000 
  1111111111111100   0000000000000000   0000000000000000   0000000000000000 
  1111111111110000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000000000000000 3 0001100000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0001100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0011111000000000   0001111000000000   0110111000000000   0000000000000000 
  0111111100000000   0011111100000000   0111111100000000   0011100000000000 
  0110001100000000   0000001100000000   0111001100000000   0001100000000000 
  0111111100000000   0011111100000000   0110001100000000   0001100000000000 
  0111111000000000   0111111100000000   0110001100000000   0001100000000000 
  0110000000000000   0110001100000000   0110001100000000   0001100000000000 
  0111111100000000   0111111100000000   0110001100000000   0001100000000000 
  0011111000000000   0011101110000000   0110001100000000   0001110000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000000000000000 3 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0011111000000000   0110001100000000   0011111000000000   0110001100000000 
  0111111100000000   0111011100000000   0111111100000000   0110001100000000 
  0110000000000000   0111111100000000   0110000100000000   0110001100000000 
  0111111000000000   0110101100000000   0110000000000000   0110001100000000 
  0011111100000000   0110001100000000   0110000000000000   0111111100000000 
  0000001100000000   0110001100000000   0110000100000000   0011111100000000 
  0111111100000000   0110001100000000   0111111100000000   0000001100000000 
  0011111000000000   0110001100000000   0011111000000000   0100001100000000 
  0000000000000000   0000000000000000   0000000000000000   0111111100000000 
  0000000000000000   0000000000000000   0000000000000000   0011111000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000111000000000 3 0000000000000000 
C 0011100000000000 D 0000000000000000 E 0001101000000000 F 0000000000000000 
  0001100000000000   0000000000000000   0001100000000000   0000000000000000 
  0001100000000000   0011101100000000   0111111000000000   1110001110000000 
  0001100000000000   0111111100000000   0111111000000000   0110001100000000 
  0001100000000000   0110001100000000   0001100000000000   0110001100000000 
  0001100000000000   0110001100000000   0001100000000000   0110101100000000 
  0001100000000000   0111111100000000   0001100000000000   0111111100000000 
  0001100000000000   0011111100000000   0001100000000000   0111111100000000 
  0001100000000000   0000001100000000   0001100000000000   0111011100000000 
  0001110000000000   0100001100000000   0001100000000000   0110001100000000 
  0000000000000000   0111111100000000   0000000000000000   0000000000000000 
  0000000000000000   0011111000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0000001100000000 4 0000000000000000 4 0000000000000000 4 0110000000000000 
0 0000001100000000 1 0000000000000000 2 0000000000000000 3 0110000000000000 
  0000001100000000   0000000000000000   0000000000000000   0110000000000000 
  0011101100000000   0110001100000000   0110111000000000   0110111000000000 
  0111111100000000   0110001100000000   0111111100000000   0111111100000000 
  0110001100000000   0110001100000000   0110001100000000   0110001100000000 
  0110001100000000   0110001100000000   0110001100000000   0110001100000000 
  0110001100000000   0111011100000000   0110001100000000   0110001100000000 
  0110001100000000   0011111000000000   0110001100000000   0110001100000000 
  0111111100000000   0001110000000000   0111111100000000   0111111100000000 
  0011101100000000   0000100000000000   0110111000000000   0110111000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0110000000000000 4 0000000000000000 4 0000000000000000 4 0000000000000000 
4 0110000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0110000000000000   0000000000000000   0000000000000000   0000000000000000 
  0110111000000000   0110001100000000   0110001100000000   0011101100000000 
  0111111100000000   0111011100000000   0110001100000000   0111111100000000 
  0111001100000000   0011011000000000   0110001100000000   0110001100000000 
  0110001100000000   0001110000000000   0110001100000000   0110001100000000 
  0110001100000000   0001110000000000   0110001100000000   0110001100000000 
  0110001100000000   0011011000000000   0110001100000000   0110001100000000 
  0110001100000000   0111011100000000   0111111100000000   0111111100000000 
  0110001100000000   0110001100000000   0011111000000000   0011101100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0011111000000000 4 0000110000000000 4 0011111000000000 4 0011111000000000 
8 0111111100000000 9 0001110000000000 A 0111111100000000 B 0111111100000000 
  0110001100000000   0011110000000000   0110001100000000   0110001100000000 
  0110001100000000   0000110000000000   0000001100000000   0000001100000000 
  0110001100000000   0000110000000000   0000011100000000   0000111100000000 
  0110001100000000   0000110000000000   0000111000000000   0000111100000000 
  0110001100000000   0000110000000000   0001110000000000   0000001100000000 
  0110001100000000   0000110000000000   0011100000000000   0110001100000000 
  0110001100000000   0000110000000000   0111000000000000   0110001100000000 
  0111111100000000   0011111100000000   0111111100000000   0111111100000000 
  0011111000000000   0011111100000000   0111111100000000   0011111000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0000011000000000 4 0111111100000000 4 0011111000000000 4 0111111100000000 
C 0110011000000000 D 0111111100000000 E 0111111100000000 F 0111111100000000 
  0110011000000000   0110000000000000   0110001100000000   0000001100000000 
  0110011000000000   0110000000000000   0110000000000000   0000001100000000 
  0110011000000000   0111111000000000   0111111000000000   0000011100000000 
  0111111100000000   0111111100000000   0111111100000000   0000111000000000 
  0111111100000000   0000001100000000   0110001100000000   0001110000000000 
  0000011000000000   0000001100000000   0110001100000000   0001100000000000 
  0000011000000000   0110001100000000   0110001100000000   0001100000000000 
  0000011000000000   0111111100000000   0111111100000000   0001100000000000 
  0000011000000000   0011111000000000   0011111000000000   0001100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0011111000000000 5 0011111000000000 5 0000011000000000 5 0000000000000000 
0 0111111100000000 1 0111111100000000 2 0000011000000000 3 0000000000000000 
  0110001100000000   0110001100000000   0000000000000000   0000000000000000 
  0110001100000000   0110001100000000   0000000000000000   0000000000000000 
  0111111100000000   0111111100000000   0000111000000000   0001111100000000 
  0111111100000000   0011111100000000   0000011000000000   0011111000000000 
  0110001100000000   0000001100000000   0000011000000000   0000000000000000 
  0110001100000000   0000001100000000   0000011000000000   0000000000000000 
  0110001100000000   0110001100000000   0000011000000000   0000000000000000 
  0111111100000000   0111111100000000   0000011000000000   0000000000000000 
  0011111000000000   0011111000000000   0000011000000000   0000000000000000 
  0000000000000000   0000000000000000   0110011000000000   0000000000000000 
  0000000000000000   0000000000000000   0111111000000000   0000000000000000 
  0000000000000000   0000000000000000   0011110000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0110000000000000 5 0000000000000000 5 0000000000000000 5 0000001100000000 
4 0110000000000000 5 0000000000000000 6 0000000000000000 7 0000011100000000 
  0110000000000000   0000000000000000   0000000000000000   0000011000000000 
  0110011000000000   0000000000000000   0000000000000000   0000111000000000 
  0110111000000000   0000000000000000   0111111100000000   0000110000000000 
  0111110000000000   0000000000000000   0111111100000000   0001110000000000 
  0111100000000000   0000000000000000   0000111000000000   0001100000000000 
  0111100000000000   0001100000000000   0001110000000000   0011100000000000 
  0111110000000000   0011110000000000   0011100000000000   0011000000000000 
  0110111000000000   0011110000000000   0111111100000000   0111000000000000 
  0110011100000000   0001100000000000   0111111100000000   0110000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0000000000000000 5 0000111100000000 5 0001100000000000 5 0000000000000000 
8 0000000000000000 9 0000111000000000 A 0001100000000000 B 0000000000000000 
  0001100000000000   0001110000000000   0011110000000000   0000000000000000 
  0011110000000000   0001100000000000   0011110000000000   0000000000000000 
  0011110000000000   0011000000000000   0011110000000000   0001100000000000 
  0001100000000000   0000000000000000   0001100000000000   0001100000000000 
  0000000000000000   0000000000000000   0001100000000000   0111111000000000 
  0001100000000000   0000000000000000   0000000000000000   0111111000000000 
  0011110000000000   0000000000000000   0000000000000000   0001100000000000 
  0011110000000000   0000000000000000   0001100000000000   0001100000000000 
  0001100000000000   0000000000000000   0001100000000000   0000000000000000 
  0011000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0011111000000000 5 0000000000000000 5 0000000000000000 5 0011111000000000 
C 0111111100000000 D 0000000000000000 E 0000000000000000 F 0111111100000000 
  0110001100000000   0000000000000000   0000000000000000   0110001100000000 
  0110001100000000   0000000000000000   0000000000000000   0000011100000000 
  0110101100000000   0110011000000000   0000000000000000   0000111000000000 
  0110111100000000   0111111000000000   0000000000000000   0001110000000000 
  0110111000000000   0011110000000000   0000000000000000   0001100000000000 
  0110000000000000   0011110000000000   0001100000000000   0000000000000000 
  0110001100000000   0111111000000000   0011110000000000   0000000000000000 
  0111111100000000   0110011000000000   0011110000000000   0001100000000000 
  0011111000000000   0000000000000000   0001100000000000   0001100000000000 
  0000000000000000   0000000000000000   0011000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0111111000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
0 0111111100000000 1 0000000000000000 2 0000000000000000 3 0000000000000000 
  0011111100000000   0000000000000000   0000000000000000   0000000000000000 
  0001111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0001111100000000   0000000000000000   0000000000000000   0000000000000000 
  0011111100000000   0000000000000000   0000000000000000   0000000000000000 
  0111111100000000   0000000000000000   0000000000000000   0000000000000000 
  0111111000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
C 0000000000000000 D 0000000000000000 E 0000000000000000 F 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
0 0000000000000000 1 0000000000000000 2 0000000000000000 3 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
C 0000000000000000 D 0000000000000000 E 0000000000000000 F 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
}icons

( 00204800 )               D# 18 code{ 
 :# ns -502 :# nblk 1440 :# nc 14 ( 144a12 01e 42b/01w/22a copyright
 UNKNOWN 2009-2011 greenarrays,inc ) { , }
 [ d# 20 load d# 22 load d# 24 load ] ( colors ) [ d# 28 load ]
 UNKNOWN: abuf [ d# 10000 ] ; { * }
 UNKNOWN: cbuf [ d# 29000 ] ; { , }
 ( decompress ) [ mark d# 30 load restore empt ]
 UNKNOWN: env [ d# 34 ] winver 2* + ; [ env ] ( ironment ) [ load ] { , }
 UNKNOWN [ d# 46 load d# 62 d# 5 loads d# 88 load d# 84 load ] { ,
 UNKNOWN , }
 UNKNOWN UNKNOWN: floppy [ d# 52 ] ; { * . }
 UNKNOWN: dump [ d# 48 ] load ; { * }
: flush save ;
 UNKNOWN: icons { . }
 UNKNOWN [ d# 54 ] ; { * }
 UNKNOWN: audit [ d# 90 ] ; { * }
 UNKNOWN: index [ d# 76 ] ; { * }
 UNKNOWN UNKNOWN: html [ d# 176 ] ; { , , }
 UNKNOWN [ mark empty ] ( arrayforth ) [ d# 144 load qwerty seeb ] { , }
 UNKNOWN ( application tools ) [ d# 202 d# 2 loads mark empty ] { ,
 UNKNOWN , }
 [ exit ] ( or compile any following... )
: q { 0000584F } [ d# 660 ] load ; [ mark empty ] }block

( 00204C00 )               D# 19 shadow{ 
 ( x86 colorforth and arrayforth tm )
: ns ( number of sectors compressed if neg, ) { cr }
 ( last compressed if pos. )
: nblk ( number of uncompressed blocks. )
: nc ( no. of compressed cylinders, deprecated ) { cr }
 [ these vars must be first things in block! ] { br }

: abuf ( starting block of { 0000006F } mb audit buffer )
: cbuf ( starting block of { 0000006F } mb compression buffer )
: floppy ( utilities for floppy format and ops. )
: dump ( compile memory display background task )
: flush ( eases concurrent use of pf/ef. )
: icons ( compile icon editor )
: audit ( utility for reconciliation and merging )
: index ( file listing first lines of blocks )
 UNKNOWN UNKNOWN: html ( colorforth source to 2-up html file ) { , , }
 ( saying ) [ qwerty ] enables ( the qwerty keyboard mode till next
 boot. ) { cr }
 [ seeb ] ( toggles blue word display ) on. }block

( 00205000 )               D# 20 code{ 
 ( macros ) [ macro ]
: swap h# 0000168B 2, H# C28B0689 , ;
: 0 < ?dup > h# 0000C031 2, ; { -cr } : if h# 00000074 2, here ;
: -if h# 00000079 2, here ; { -cr } : while ( n-nn ) < if > swap ;
: -while ( n-nn ) < -if > swap ; { -cr } : a < ?dup > h# 0000C28B 2,
 ;
: a! ?lit if h# 000000BA 1, , ; then h# 0000D08B 2, < drop > ;
 UNKNOWN: 2* h# 0000E0D1 2, ; { * }
: 4@ ( b-n ) h# 0000008B 2, ; [ forth ]
: a, 2* 2* , ; [ macro ]
: @ ?lit if < ?dup > h# 0000058B 2, a, ; then h# 0085048B 3, 0 , ;
: ! ?lit if ?lit if h# 000005C7 2, swap a, , ; then h# 00000589 2,
 a, < drop > ; then < a! > h# 00950489 3, 0 , < drop > ;
: nip h# 0004768D 3, ;
: + ?lit if h# 00000005 1, , ; then h# 00000603 2, < nip > ;
: or h# 00000633
: binary ?lit if swap d# 2 + 1, , ; then 2, < nip > ;
: and h# 00000623 < binary > ; { -cr } : +or h# 0000060B < binary >
 ;
: u+ ?lit if h# 00000681 2, , ; then h# 00044601 3, < drop > ;
: ? ?lit h# 000000A9 1, , ; { -cr } : over < ?dup > h# 0004468B 3,
 ; }block

( 00205400 )               D# 21 shadow{ 
 ( pentium macros' 1, 2, 3, , compile 1-4 bytes )
: drop ( lodsd, flags unchanged, why sp is in esi - in kernel )
: then ( fix address - in kernel )
: swap ( sp xchg )
: 0 ( 0 0 xor, macro 0 identical to number 0 )
: if ( jz, flags set, max 127 bytes, leave address )
: -if ( jns, same )
: a ( 2 0 mov, never used? )
: a! ( 0 2 mov, unoptimized )
: 2* ( shift left )
: 4@ ( fetch word on byte boundary. )
: a, ( compile word address )
: @/! ( fetch/store from/to word address, or eax )
: nip swap drop
: +/or/and ( number or sp with eax )
: u+ ( add to 2nd number, number or sp )
: ? ( test bits, set flags, literal only! )
: over ( sp 4 + @ ) }block

( 00205800 )               D# 22 code{ 
 ( - macros )
: push ?lit if h# 00000068 1, , ; then h# 00000050 1, < drop > ;
: pop < ?dup > h# 00000058 1, ;
: - h# 0000D0F7 2, ;
: *end swap
: end h# 000000EB
: loop 1, here - + 1, ;
: until h# 00000074 < loop > ;
: -until h# 00000079 < loop > ;
: for < push begin > ;
: *next swap
: next H# 75240CFF
: 0next , here - + 1, h# 0004C483 3, ;
: -next H# 79240CFF < 0next > ;
: i < ?dup > h# 0024048B 3, ;
: +! ?lit if ?lit if h# 00000581 2, swap a, , ; then h# 00000501 2,
 a, < drop > ; then < a! > h# 00950401 3, 0 , < drop > ;
: nop h# 00000090 1, ;
: align here - d# 3 and drop if < nop align > ; then ;
: or! < a! > h# 00950409 3, 0 , < drop > ;
: * h# 0006AF0F 3, < nip > ;
: */ h# 0000C88B 2, < drop > H# F9F72EF7 , < nip > ;
: /mod < swap > h# 00000099 1, H# 16893EF7 , ;
: / < /mod nip > ;
: mod < /mod drop > ; }block

( 00205C00 )               D# 23 shadow{ 
: push ( lit to sp; eax to sp )
: pop ( sp to eax )
: - ( ones-complement )
: begin -a ( current code address - byte )
: while a-aa ( if-escape from any structure usage example begin xxx
 while xxx next xxx then )
: for n ( push count onto return stack, ) begin
: *next aa-aa ( swap ) for ( and ) if ( addresses )
: next a ( decrement count, jnz to ) for, ( pop return stack when done )
: -next a ( same, jns - loop includes 0 )
: i -n ( copy loop index to data stack )
: *end aa-aa ( swap ) end ( and ) if ( addresses )
: end a ( jmp to ) begin
: +! na ( add to memory, 2 literals optimized )
: align ( next call to end on word boundary )
: or! na ( inclusive-or to memory, unoptimized )
: * mm-p ( 32-bit product )
: */ mnd-q ( 64-bit product, then quotient )
: /mod nd-rq ( remainder and quotient )
: / nd-q ( quotient )
: mod nd-r ( remainder ) }block

( 00206000 )               D# 24 code{ 
 ( - compiled macros )
: 2/ ( n-n ) h# 0000F8D1 2, ; { -cr } : time ( -n ) < ?dup > h# 0000310F
 2, ;
: 7push h# 00000057 1, ; { -cr } : 7pop h# 0000005F 1, ; [ forth ]
: @ @ ; { -cr } : ! ! ; { -cr } : + + ; { -cr } : - - ;
: */ */ ; { -cr } : * * ; { -cr } : / / ; { -cr } : 2/ 2/ ;
: dup dup ; { -cr } : drop drop ; { -cr } : nip ( ab-b ) nip ;
: over over ; { -cr } : swap swap ; { -cr } : and and ;
: or or ; { -cr } : +or +or ; { -cr } : +! +! ;
: exit 7pop 7pop ; { -cr } : negate ( n-n ) - d# 1 + ;
: min ( nn-n ) less if drop ; then swap drop ;
: abs ( n-u ) dup negate
: max ( nn-n ) less if swap then drop ;
: v+ ( vv-v ) push u+ pop + ;
: loads ( bn ) for dup push load pop d# 2 + next drop ;
: writes ( acn ) for write next drop drop ;
: reads ( acn ) for read next drop drop ; [ macro ]
: dann < then > ;
: then ( a-a ) here over negate + d# 128 + { cr }
 d# -256 and drop if abort dann < dann > ; [ forth ] }block

( 00206400 )               D# 25 shadow{ 
: 2/ ( arithmetic right shift )
: time ( pentium cycle counter, calibrate to actual clock rate )
: 7push/7pop ( save/restore save register 7, edi )
: @-drop ( these macros redefined in ) forth ( so they may be executed )
: +or ( and ) negate ( when you just can't use - )
: min ( and ) max ( minimum and maximum )
: abs ( absolute value )
: v+ ( add 2-vectors )
: exit ( terminates interpretation of a block. )
: loads ( load successive blocks )
: nc ( number of cylinders booted and saved )
: writes ( address, cylinder, cylinder count )
: reads ( address, cylinder, count. ) [ floppy access note do not hit
 any keys while floppy is being written - wait for light to go out ]
: then ( aborts on jump out of range. ) }block

( 00206800 )               D# 26 code{ 
 }block

( 00206C00 )               D# 27 shadow{ 
 }block

( 00207000 )               D# 28 code{ 
 ( colors etc )
: -offset ( n-n ) [ offset ] @ negate + ;
: block [ offset ] @ +
: blks h# 00000100 * ;
: wrtboot [ d# 0 block ] d# 0 d# 1 writes stop ;
: white h# 00FFFFFF color ;
: red h# 00FF0000 color ;
: green h# 0000FF00 color ;
: blue h# 000000FF color ;
: silver h# 00BFBFBF color ;
: black d# 0 color ;
: 5* d# 5 for 2emit next ;
: cf d# 25 dup at red h# 0000000B h# 00000005 h# 00000001 h# 00000001
 h# 00000005 5* green h# 00000014 h# 00000002 h# 00000001 h# 00000003
 h# 0000000E 5* ( chip ) d# 25 d# 550 at red h# 0000001C h# 0000001C
 h# 00000019 h# 00000005 h# 0000000D 5* ;
: fill ( nan ) for over over ! d# 1 + next drop drop ;
: move ( sdn ) for over @ over ! d# 1 + d# 1 u+ next drop drop ;
: erase ( bn ) push d# 0 swap block pop blks fill ;
: copy ( n ) [ blk ] @ block over block d# 512 move [ blk ] ! ; }block

( 00207400 )               D# 29 shadow{ 
: block n-a ( block number to word address )
: wrtboot ( write boot and kernel )
: colors ( specified as rgb' 888 bits )
: at xy ( set current screen position - in kernel )
: box xy ( lower-right of colored rectangle - in kernel )
: 5* emit ( five characters in reverse order )
: cf ( display double-size colorforth )
: fill n an ( writes n into a cell string )
: move sdn ( copies a cell string from s to d )
: erase bn ( zeroes a string of blocks )
: copy n ( copies current editor block and its shadow to the given
 block ) }block

( 00207800 )               D# 30 code{ 
 ( decompress ) [ empt d# 32 load ]
: char ( -n ) 0 b! ( ?new ) d# 4 bits b d# 8 and drop if b d# 4 and
 drop if d# 3 bits d# 7 ; then d# 1 bits d# 5 ; then d# 4 b h# 0000000F
 and drop if ; then
: eob ( n ) drop pop drop ;
: chars ( n-n ) char ?full c! 2*c b or chars ;
: word ( n ) d# 28 [ nb ] ! dup chars tbits ;
: short ( n ) d# 28 bits
: t, d# -4 [ nb ] ! b tbits ;
: number ( n ) 0 b! d# 1 bits t,
: 32bits d# 16 bits d# 16 bits b , ;
: variable ( n ) word 32bits ;
: tag ( -n ) b h# 0000000F and dup jump eob word number word word number
 short word short word word word variable short word short
: words ( ?new ) d# 4 bits tag words ;
: range ( ann ) over block [ h ] ! dup push erase [ aa ] ! 0 [ na ]
 ! begin words [ h ] @ d# 256 + d# -256 and [ h ] ! next ;
: restore [ ns ] @ dup and -if abs [ ns ] ! d# 36 block [ cbuf ] block
 [ d# 18 blks nc @ d# -2 + * ] move [ cbuf block ] d# 36 [ nblk @ d# -36
 + ] range ; then drop ; }block

( 00207C00 )               D# 31 shadow{ 
: char ( examine high bits; shift 4, 5 or 7 bits )
: eob ( end of block )
: chars ( shift characters until 0 )
: word ( shift characters, then tag )
: short ( 28-bit value+tag )
: number ( 1-bit base+tag, value in next word )
: 32bits ( for values )
: variable ( word, value )
: tag ( vector )
: words ( examine tags )
: range ( process each block )
: move ( blocks 72 thru 1419 to 3000 )
: res ( restore compressed blocks ) }block

( 00208000 )               D# 32 code{ 
 ( - more ) [ macro ] ( uses ebx )
: b < ?dup > h# 0000C38B 2, ;
: b! h# 0000D88B 2, < drop > ;
: c! h# 0000C88B 2, < drop > ;
: 2*d h# 00C3A50F 3, ;
: 2*c h# 0000E0D3 2, ; [ forth ] :# na 31 :# nb 9 :# h 70070272 :# an 0
 :# aa 74622566 :# nz 4
: ?new [ na ] @ dup and drop if ; then
: new [ aa ] @ @ [ an ] ! d# 1 [ aa ] +! d# 32 [ na ] ! ;
: shift ( n-n ) dup negate dup [ nb ] +! [ na ] +! c! [ an ] @ 2*d
 2*c [ an ] ! ;
: bits ( n ) ?new dup negate [ na ] @ + -if dup push + shift new pop
 negate shift ; then drop shift ;
: tbits ( nn ) [ nb ] @ d# 8 + c! 2*c or
: , [ h ] @ ! d# 1 [ h ] +! ;
: tz ( nn-n ) over [ nz ] ! dup negate push + b begin dup d# 1 and
 drop if drop drop pop drop [ nz ] @ ; then 2/ next b! dup [ nz ] @
 - + - [ nb ] +! pop drop ;
: ?full ( n-n ) [ nb ] @ dup and -if tz dup push d# -4 + [ nb ] +!
 tbits 0 dup pop dup - d# 29 + [ nb ] ! ; then drop ; }block

( 00208400 )               D# 33 shadow{ 
: b ( pop ebx, register 3, into eax )
: c! ( push eax into register 1, ecx )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: na ( bits remaining in source word )
: nb ( bits remaining in ebx )
: h ( destination address )
: , ( store at destination )
: ?new ( fetch new word if necessary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: tbits ( fill ebx with tag )
: ?full ( is there room in ebx? )
: bits ( shift bits into ebx. overflow into next word ) }block

( 00208800 )               D# 34 code{ 
 ( native system dependencies ) [ macro ]
: p@ < a! ?dup > h# 000000EC 1, ; [ forth ]
: key? h# 00000064 p@ d# 1 and drop if h# 00000060 p@ h# 00000080 and
 drop if ; then pop drop then ;
: clock [ d# 40 ] load ;
: altfrm ( -b ) [ aper @ d# 1024 d# 768 * d# -4 * + ] ;
: topram ( -b ) [ H# 30000000 ] ;
: !work ( n ) block d# 0 over [ d# 1 ] + @ [ d# 35 ] + [ d# 36 ] /
 writes stop ;
: @rest ( nn ) push [ d# 36 ] + block [ d# 2 ] pop reads stop ;
: @back ( n ) dup block d# 0 [ d# 2 ] reads dup [ d# 18 ] + block dup
 @ [ d# 18 block @ ] or drop if drop [ d# 78 ] @rest ; then dup [ d# 1 ]
 + @ dup and -if nip abs [ d# 35 ] + [ d# 36 ] / [ d# -2 ] + @rest
 ; then drop drop [ d# 78 ] @rest ;
: !back ( n ) block d# 0 [ nblk ] @ [ d# 18 ] / writes stop ;
: @cyls ( acn ) reads stop ;
: screen d# 0 dup at d# 1024 d# 768 box ;
: utime ( -n ) d# 0 ; { br }

: serial ( -n ) [ d# 108 ] ; }block

( 00208C00 )               D# 35 shadow{ 
: key? ( exits calling defn if key struck )
: clock ( loads time of day suppt )
: altfrm ( byte addr of alternate frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads
 only active part of compressed ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color )
: utime ( null definition for now for compatability ) }block

( 00209000 )               D# 36 code{ 
 ( windows system dependencies )
: key? [ keych ] @ d# 0 or drop if pop drop ; then ;
 UNKNOWN: beep ; { * }
: clock d# 38 load ;
 UNKNOWN: topram { * }
: altfrm ( -b ) [ endram d# -4096 d# 768 * + ] ;
: !work ( n ) dup block [ d# 1 ] + @ [ d# 1 ] + 2/ wwork ;
 UNKNOWN: @back ( n ) dup d# 19 rback dup [ d# 18 ] + block dup @ { , }
 UNKNOWN [ d# 18 block @ ] or drop if drop [ d# 1440 ] rback ; then { , }
 UNKNOWN dup [ d# 1 ] + @ dup and -if nip abs [ d# 1 ] + 2/ rback ; { , }
 then drop [ d# 3 ] + @ rback ;
: !back ( n ) [ nblk ] @ wback ;
 UNKNOWN: @cyls ( acn ) [ abuf ] @back push [ d# 18 ] * [ abuf ] + block { , }
 swap pop [ d# 18 d# 256 * ] * move ;
 UNKNOWN: screen d# 0 dup at d# 868 for d# 0 d# 1024 line next { , }
 UNKNOWN d# 0 dup at ; { * }
: serial ( -n ) [ d# 112 ] ;
: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 3 d# 0 { 0000000F }
 UNKNOWN [ d# 3 ] { , }
 UNKNOWN pop pop swap [ d# 4 ] * fcreate ; { , }
 :# flng 14756 [ flng d# 4 * dup ]
 UNKNOWN: frd ( anh-n ) push push push [ d# 0 + ] pop pop swap { , }
 UNKNOWN pop fread { * }
: frw? ( ok-n ) if drop [ flng ] @ then ;
 UNKNOWN: fwr ( anh-n ) push push push [ d# 0 + ] pop pop swap { , }
 UNKNOWN pop fwrite frw? ; { * }
: r/o [ H# 80000000 ] ;
 UNKNOWN UNKNOWN: w/o [ H# 40000000 ] ; { * ... }
: r/w [ r/o w/o + ] ; }block

( 00209400 )               D# 37 shadow{ 
: key? ( exits calling defn if key struck )
: save ( writes full disk image )
: beep ( alert in hardsim )
: clock ( loads time of day suppt )
: altfrm ( byte adr of alt frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads
 only active part of compressed, and only active part of straight disks
 with vars ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color ) { br }

: fopen ( opens an existing win32 file given word adr of name and access
 code of ) r/o w/o ( or ) r/w. ( returns handle, indicators nz if it's
 good. the alternate value { 0000006F } enables sharing for read and
 write; necessary to open a file sf has open with clib. )
: frd ( and ) fwr ( read and write on things with win32 handles. )
 }block

( 00209800 )               D# 38 code{ 
 ( - clock )
: sec ( -n ) utime [ d# 60 d# 60 * d# 24 * ] mod ;
: minute ( -n ) sec d# 60 / ; }block

( 00209C00 )               D# 39 shadow{ 
: utime ( returns unix time in sec since epoch 0000z fri 1/01/1970 )
: sec ( seconds since midnight needs unsigned mod by time we are all
 dead )
: min ( minutes past midnight ) }block

( 0020A000 )               D# 40 code{ 
 ( native clock ) [ macro ] ( pentium timer )
: p@ < a! ?dup > h# 000000EC 1, ;
: p! < a! > h# 000000EE 1, < drop > ; [ forth ]
: ms d# 100000 * for next ;
: ca h# 00000070 p! h# 00000071 ;
: c@ ca p@ ;
: c! ca p! ;
: !bcd push d# 10 /mod d# 16 * + pop c! ;
: !hm d# 100 /mod d# 4 !bcd d# 2 !bcd 0 dup c! ;
: bcd c@ d# 16 /mod d# 10 * + ;
: sec0 d# 4 bcd d# 60 * d# 2 bcd + d# 60 * d# 0 bcd + ;
: sec sec0 d# 2 ms dup sec0 or drop if drop sec ; then ;
: minute sec d# 60 / ;
: hms sec d# 60 /mod d# 60 /mod d# 100 * + d# 100 * + ;
: ymd d# 9 bcd d# 100 * d# 8 bcd + d# 100 * d# 7 bcd + ;
: day d# 6 c@ d# -1 + ;
: hi d# 10 c@ h# 00000080 and drop if ; then hi ;
: lo d# 10 c@ h# 00000080 and drop if lo ; then ;
: cal hi lo time - hi lo time + ( 748 ) ;
: beep h# 000000B6 h# 00000043 p! h# 000000EE h# 00000042 p! 0 h# 00000042
 p! ( on ) h# 00000061 p@ d# 3 or h# 00000061 p! d# 50000000 for next
 ( off ) h# 00000061 p@ d# 3 or h# 00000061 p! ; }block

( 0020A400 )               D# 41 shadow{ 
 }block

( 0020A800 )               D# 42 code{ 
 }block

( 0020AC00 )               D# 43 shadow{ 
 }block

( 0020B000 )               D# 44 code{ 
 }block

( 0020B400 )               D# 45 shadow{ 
 }block

( 0020B800 )               D# 46 code{ 
 ( logo, etc )
: !dict ( fmh ) [ h ] ! [ macros ] ! [ forths ] ! ;
 UNKNOWN UNKNOWN: +buf ( n-n ) [ blk ] @ over or if { , ... }
 over or [ blk d# 1 + ] ! ; then drop ;
 UNKNOWN: list ( n ) +buf [ blk ] ! lis ; { * }
: l [ blk ] @ list ;
: interp ( b ) align load ; ( temp ) [ d# 9 here d# 4 / d# -1 + +! ]
: finish [ cad ] @ interp ;
: logo show black screen d# 800 d# 710 blue box d# 600 d# 50 at d# 1024
 d# 620 red box d# 200 d# 100 at d# 700 d# 500 green box { 0000024F }
 ( list ) text cf keyboard ;
 UNKNOWN UNKNOWN: empty empt logo ; { , , }
: 2u.r ( nw ) d# -1 + dup push for d# 10 /mod next h# 0000000F and
 UNKNOWN { , }
 UNKNOWN begin [ d# 0 ] + if pop [ d# 1 ] + { * }
: .lo for [ d# 24 ] + 2emit next ; then drop space space next [ d# 1 ]
 .lo ;
: ?ec blk d# 2 + @ d# 0 + drop if red ; then silver ;
 UNKNOWN: watermark show black screen d# 765 d# 603 at { , }
 [ blk ] @ ?ec d# 6 2u.r +list keyboard ;
 UNKNOWN: edit ( n ) +buf [ blk ] ! { * }
 UNKNOWN UNKNOWN: e watermark +e ; { , , }
: -kbd ( -t ) 7push pop dup and drop ;
 UNKNOWN: fh ( n-b ) -kbd if 7push pop [ d# 0 block ] { , }
 [ negate ] + d# 256 / + ; then [ blk ] @ + ; }block

( 0020BC00 )               D# 47 shadow{ 
 ( logo, etc )
: !dict ( resets dictionary to a saved state )
: +buf ( preserves ) blk ( if new block is different )
: list ( displays the given block without entering the editor. )
: l ( lists the current editor block. )
: interp ( is a temp patch for missing interpreter entry point. )
: finish ( executes at same stack level as load but starts interpreting
 at editor's current cursor position. )
: logo ( displays colorforth logo )
: empty ( empty dictionary and display logo ) { br }

: -kbd ( returns true/nonzero flag if a word that calls it is being
 interpreted from a block as opposed to from the keyboard. use with
 caution from deep within an app that might have monkeyed with register { 000000EF } )
: fh ( from here, block number relative to editor or interpreter block
 as appropriate. ) }block

( 0020C000 )               D# 48 code{ 
 ( dump ) [ empty ] :# x 75678960 :# y -79635296
: 5-8 d# 8 /mod d# 32 /mod d# 32 /mod h# 00000100 * + h# 00000100 *
 + h# 00000100 * swap d# 4 * + ;
: one dup @ dup 5-8 h. space h. space dup h. cr ;
: lines for one d# -1 + next drop ;
: dump [ x ] !
: r show black screen [ x ] @ d# 15 + d# 16 text lines keyboard ;
: it @ + @ dup h. space ;
: lines for white i [ x ] it i [ y ] it or drop if red then i . cr
 -next ;
: cmp show blue screen text d# 19 lines red [ x ] @ h. space [ y ]
 @ h. keyboard ;
: u d# 16
: +xy dup [ x ] +! [ y ] +! ;
: d d# -16 +xy ;
: ati H# F4100000 ( ff7fc000 ) or ( agp graphics reg )
: byte d# 4 / dump ;
: fix for d# 0 over ! d# 1 + next ; [ dump ] }block

( 0020C400 )               D# 49 shadow{ 
 ( does not say empty, compiles on top of application )
: x -a ( current address )
: one a-a ( line of display )
: lines an
: dump a ( background task continually displays memory --- takes address
 -- displays three cols with address on right contents in middle and-
 the left col is f18 instruction view )
: u ( increment address )
: d ( decrement )
: ati ( address of agp graphic registers )
: byte a ( byte address dump )
: fix an-a ( test word ) }block

( 0020C800 )               D# 50 code{ 
 ( timing ) :# tmt 286630312 :# tmn -162350156 :# tmp 64245270 :# secs 0
: tmclr d# 0 [ tmt ] ! d# 0 [ tmn ] ! d# 0 [ tmp ] ! d# 0 [ secs ]
 ! ;
: tms ( a ) time - [ d# 1 ] + swap +! ;
: tme ( a ) time swap +! ;
: tare [ tmt ] tms pause [ tmt ] tme ;
: 0tare [ tmn ] tms switch [ tmn ] tme ;
: counter utime negate [ secs ] +! ;
: timer utime [ secs ] +! ; }block

( 0020CC00 )               D# 51 shadow{ 
 }block

( 0020D000 )               D# 52 code{ 
 ( floppy utility ) [ empty ] :# hd 1 :# ad 152338
: array pop 2/ 2/ ;
: com align array [ H# 1202004D , h# 0000006C 2, ]
: word ( n ) [ ad ] @ ! d# 1 [ ad ] +! ;
: sectors ( cs-c ) buffer [ ad ] ! d# 18 for over [ hd ] @ h# 00000100
 * + over d# 18 mod d# 1 + h# 00010000 * + h# 02000000 + word d# 1
 + next drop ;
: head ( ch-c ) dup [ hd ] ! h# 00000400 * H# 1202004D + [ com ] !
 dup 2* - d# 1801 + sectors format ;
: cylinders ( n ) push [ com ] d# 0 pop for d# 0 head d# 1 head d# 1
 + next ( stop ) drop drop ;
: format ( nc @ ) d# 80 cylinders stop ;
: archive [ d# 0 block ] d# 0 [ nc ] @ writes stop ;
: check [ abuf block ] d# 0 [ nc ] @ reads stop ;
: ati H# 10CD4123 [ vesa ] ! ; ( setup for ati video card )
: nvidia H# 10CD4118 [ vesa ] ! ; ( for nvidia card then save ) }block

( 0020D400 )               D# 53 shadow{ 
: format ( issue format command 30 cyl - in kernel )
: hd ( disk head )
: ad ( current address in ) buffer
: buffer ( usual floppy cylinder buffer )
: array ( return word address )
: com ( format command )
: word ( store word into command string )
: sectors ( build sector table )
: head ( build sectors for selected head )
: cylinders ( sectors advance 1 for each cylinder - to allow time for
 head step )
: format ( only desired cylinders to save time )
: bytes ( arguments for crc )
: archive ( verify save' compute crc, save, read-back, recompute crc
 - first 64 bytes used by floppy read/write -- the two crc numbers
 should be the same ! ) }block

( 0020D800 )               D# 54 code{ 
 ( icons ) [ empty macro ]
: @w h# 00008B66 3, ;
: !w < a! > h# 00028966 3, < drop > ;
: *byte h# 0000C486 2, ; [ forth ] :# ic 11 :# cu 167
: sq [ xy ] @ h# 00010000 /mod d# 16 + swap d# 16 + box { cr }
 d# 17 d# 0 +at ;
: loc [ ic ] @ [ d# 16 d# 24 d# 8 */ ] * [ d# 12 block d# 4 * ] + ;
: 0/1 h# 00008000 ? if green sq ; then blue sq ;
: row dup @w *byte d# 16 for 0/1 2* next drop { cr }
 [ d# -17 d# 16 * ] d# 17 +at ;
: ikon loc d# 24 for row d# 2 + next drop ;
: adj d# 17 * swap ;
: cursor [ cu ] @ d# 16 /mod adj adj over over at { cr }
 red d# 52 u+ d# 52 + box ;
: line ( i-in ) for dup emit d# 1 + next ;
: set ( xy ) over lm at d# 0 d# 10 for d# 12 line cr next { cr }
 d# 8 line drop ;
: ok show black screen cursor d# 18 dup at ikon { cr }
 text [ ic ] @ dup . h. d# 400 d# 60 set keyboard ; [ d# 56 load ok
 h ] }block

( 0020DC00 )               D# 55 shadow{ 
 ( draw big-bits icon )
: @w a-n ( fetch 16-bit word from byte address )
: !w na ( store same )
: *byte n-n ( swap bytes )
: ic -a ( current icon )
: cu -a ( cursor )
: sq ( draw small square )
: xy -a ( current screen position, set by ) at
: loc -a ( location of current icons bit-map )
: 0/1 n-n ( color square depending on bit 15 )
: row a-a ( draw row of icon )
: ikon ( draw big-bits icon )
: adj nn-nn ( magnify cursor position )
: cursor ( draw red box for cursor )
: ok ( background task to continually draw icon, icon number at top )
 }block

( 0020E000 )               D# 56 code{ 
 ( - control panel )
: +ic d# 1 [ ic ] +! ;
: -ic [ ic ] @ d# -1 + d# 0 max [ ic ] ! ;
: bit [ cu ] @ 2/ 2/ 2/ 2/ 2* loc + h# 00010000 [ cu ] @ h# 0000000F
 and d# 1 + for 2/ next *byte ;
: toggle bit over @w or swap !w ;
: td toggle
: d d# 16
: wrap [ cu ] @ + [ d# 16 d# 24 * ] dup u+ /mod drop [ cu ] ! ;
: tu toggle
: u d# -16 wrap ;
: tr toggle
: r d# 1 wrap ;
: tl toggle
: l d# -1 wrap ;
: h pad nul nul accept nul tl tu td tr l u d r -ic nul nul +ic nul
 nul nul nul nul nul nul nul nul nul nul nul [ h# 00002500 , h# 0110160C
 dup , , H# 2B000023 , d# 0 , d# 0 , d# 0 , ] }block

( 0020E400 )               D# 57 shadow{ 
 ( edit icon ) }block

( 0020E800 )               D# 58 code{ 
 }block

( 0020EC00 )               D# 59 shadow{ 
 }block

( 0020F000 )               D# 60 code{ 
 ( serial 3f8 2e8 1050 ) [ macro ]
: p@ < a! dup > h# 000000EC 1, ;
: p! < a! > h# 000000EE 1, < drop > ;
: 1@ h# 0000008A 2, ;
: 1! < a! > h# 00000288 2, < drop > ; [ forth ]
: r [ d# 0 + ] + ;
: 9600 d# 12 ;
: 115200 d# 1 ;
: b/s h# 00000083 [ d# 3 r ] p! d# 115200 [ d# 0 r ] p! d# 0 [ d# 1
 r ] p! d# 3 [ d# 3 r ] p! ;
: init b/s ( 16550 ) d# 1 [ d# 2 r ] p! d# 0 [ d# 4 r ] p! ;
: xmit ( n ) [ d# 5 r ] p@ h# 00000020 and drop if [ d# 0 r ] p! ;
 then ( pause ) xmit ;
: cts [ d# 6 r ] p@ h# 00000030 and h# 00000030 or drop if cts ; then
 xmit ;
: st [ d# 6 r ] p@
: xbits h# 00000030 and h# 00000010 / dup d# 1 and 2* 2* + 2/ ;
: st! [ d# 4 r ] p! ;
: ?rcv [ d# 5 r ] p@ d# 1 and drop if [ d# 0 r ] p@ then ;
: rcv ?rcv if ; then ( pause ) rcv ; }block

( 0020F400 )               D# 61 shadow{ 
: p@ p-n ( fetch byte from port )
: p! np ( store byte to port )
: 1@ a-n ( fetch byte from byte address )
: 1! na ( store byte to byte address )
: r n-p ( convert relative to absolute port address. base port on stack
 at compile time. compiled as literal at yellow-green transition )
: 9600
: 115200 ( baud-rate divisors. these are names, not numbers )
: b/s ( set baud rate. edit to change )
: init ( initialize uart )
: xmit n ( wait for ready and transmit byte )
: cts n ( wait for clear-to-send then xmit )
: st -n ( fetch status byte )
: xbits n-n ( exchange status bits )
: st! n ( store control byte )
: ?rcv ( fetch byte if ready. set flag to be tested by ) if
: rcv -n ( wait for ready and fetch byte ) }block

( 0020F800 )               D# 62 code{ 
 ( word search ) [ macro ]
: bt ( nm-n ) [ H# 068BD08B ] , [ H# 0F04768D ] , [ H# D21BC2A3 ] ,
 ; [ forth ]
: tag? ( nm-n ) over h# 0000000F and swap bt drop ;
: red? ( n-nm ) [ h# 00001008 ] tag? if [ h# 00004092 ] ; then [ h# 00001008 ]
 ;
: t2 ( nn-nn ) d# 1 +
: t1 ( nn-nn ) d# 1 [ curs ] +!
: t0 ( nn-nn ) d# 1 + ;
: map ( nnn-nn ) h# 0000000F and jump { indent }
      t0 t1 t2 t1 t1 t2 t1 t1 { indent }
      t1 t1 t1 t1 t2 t1 t1 t1
: tcurs ( nn-n ) over block push d# -1 [ curs ] ! d# 0
: tcu1 ( nnn-n ) dup i + @ map over over negate + drop -if t1 drop
 drop pop drop ; then tcu1 ;
: -curs ( - ) [ curs ] @ d# -1 + d# 0 max [ curs ] ! ; [ here ]
: tpoint [ blk ] @ [ curs ] @ tcurs drop -curs ; [ cpoint ! ] }block

( 0020FC00 )               D# 63 shadow{ 
 ( word search tcurs )
: bt ( returns nz and less if bit n of m is set. pops t to 2, bit test
 index t mask 2, 2-2-sbb to set nz if carry. )
: tag? ( nz and less if bit in m indexed by tag of token n is 1. )
: t2 nn-nn ( 2 cell - big nums, var )
: t1 nn-nn ( 1 cell )
: t0 nn-nn ( extensions, undefined )
: map end n wrd-end n ( inc n and maybe curs )
: tcurs blk offset-blk ( convert offset to tokens in curs )
: -curs - ( decrement curs to zero )
: tpoint - ( fix abort to point cursor correctly, except if last word
 in block ) }block

( 00210000 )               D# 64 code{ 
 ( - more ) :# fmask -16 :# fnn -276299760 { cr }
 :# fna 67146240 :# fbits 4104 [ d# 18 block fna ! ]
: +shad ( a-a ) dup [ fna ] @ or d# 256 and + ;
: 1word ( -n ) word [ words ] @
: 1wz d# 2 less drop if drop ; then nip d# -1 + 1wz ;
: want? ( nm-n ) tag? if or ; then drop drop d# -1 ;
: -found ( na ) @ [ fbits ] @ want? [ fmask ] @ and drop ;
: reedit ( fna ) nip dup d# 1 + [ fna ] ! { indent }
      h# 00000100 /mod -offset swap tcurs swap { indent }
      dup and drop if dup [ blk ] ! then edit ;
: find 1word h# 00005E9A { -cr } : fnd+ d# 18 block d# -16
: fnd ( nbam ) [ fmask ] ! [ fna ] ! [ fbits ] ! d# 16 or [ fnn ] !
 d# 0
: f ( f ) [ fnn ] @ d# 16 or [ fna ] @ begin { indent }
      +shad [ nblk ] @ block less drop while { indent }
      over over -found while d# 1 + end { indent }
      then reedit ; then drop drop drop ;
: def 1word [ h# 00001008 ] fnd+ ; [ here ekt d# 21 + ! ]
: fkc drop [ pcad ] @ @ [ h# 00000140 ] tag? if [ d# 32 ] / edit ;
 { cr }
 then red? fnd+ ( blk @ ) dup ; [ here ekt d# 22 + ! ]
: fk drop ( drop ) [ cad ] @ [ fna ] ! d# 1 f ( blk @ ) dup ;
: from ( n ) 1word swap [ h# 00005E9A ] swap block [ d# -16 ] fnd ;
: literal ( n ) h# 00000020 * [ h# 00000140 ] d# 18 block [ d# -32 ]
 fnd ; }block

( 00210400 )               D# 65 shadow{ 
 ( word search )
: +shad ( skips shadows if in one and skipping. )
: 1word -n ( return 1st cell of word from kbd. )
: find ( finds following short word, starting in block 18, regardless
 of color. )
: def ( finds only definitions. )
: f ( find next occurrence of word last found )
: fk ( 'f' key in edit keyboard. drops key and block number and behaves
 like f except continues search from current editor position in current
 kind of block src/shad. )
: fkc ( if word left of cursor is a number, list that block. if red
 or magenta definition, searches for references. otherwise searches
 for definitions. )
: from n- ( like find but start from block number )
: literal n- ( finds any equivalent literal ) }block

( 00210800 )               D# 66 code{ 
 ( editor recolor ) [ d# 8 display + @ d# 13 display + ! ]
: array pop 2/ 2/ + @ ; ( 1-4-9 2-5 8-6-15 )
: reclr align array { cr }
 [ d# 0 , d# 4 , d# 5 , d# 3 , d# 9 , d# 2 , d# 15 , d# 7 , ] { cr }
 [ d# 6 , d# 1 , d# 10 , d# 11 , d# 12 , d# 13 , d# 14 , d# 8 , ]
: wadr ( -a ) [ pcad ] @ [ blk ] @ max ; [ here ekt d# 20 + ! ]
: change wadr @ h# 0000000F and reclr wadr @ h# FFFFFFF0 and or wadr
 ! ; [ H# 220E100A ekt d# 33 + ! ] { br }

 ( obsolete comment cases ) [ H# 0F000000 ekt d# 32 + ! ] { cr }
 [ ekt d# 16 + @ dup ekt d# 17 + ! ekt d# 18 + ! ] }block

( 00210C00 )               D# 67 shadow{ 
 ( tags ) { cr }
 ( extend ) [ execute 32-bit ] ( define ) { cr }
 compile 32-bit [ 27-bit ] < immediate > { cr }
 27-bit ( comment cap caps ) { cr }
 ( variable address blue 27-bit ) { br }

: array ( fetch new tag )
: reclr ( table of color cycles )
: wadr -a ( address of word to left of cursor )
: change ( color of word to left of cursor )
: 220e100a ( 0a-c 10-d 0e-f 22-j ) }block

( 00211000 )               D# 68 code{ 
 ( blue words ) :# ?blu 255 [ d# 0 ?blu ! ]
 UNKNOWN: -w@ ( -n ) 7push pop d# -1 + @ ; { * }
: .blu [ ?blu ] @ color
 UNKNOWN UNKNOWN: type1 [ d# 9 display + @ d# 5 + ] push ; { , , }
 UNKNOWN [ here ] { * }
 UNKNOWN: blu ; { * }
 UNKNOWN UNKNOWN: -blue ( b-t ) dup d# 1 + 4@ + [ d# -5 + ] or { , ... }
 UNKNOWN UNKNOWN drop ; { , , }
 UNKNOWN UNKNOWN UNKNOWN: d03 ( -a ) [ d# 3 display + ] ; { . . . }
 [ here ]
: exr [ d03 @ ] nop [ d03 ] ! red type1 ;
 UNKNOWN: -cr blu [ d# 0 + ] nop [ d03 ] ! ; { * }
 UNKNOWN UNKNOWN: sp/2 h# 000B0000 [ xy ] +! ; { , , }
 UNKNOWN: bs [ xy d# 1 + ] @ d# 21 + h# 00010000 * [ xy ] @ less { ,
 UNKNOWN ... }
 drop drop if h# FFEA0000 [ xy ] +! then ;
 UNKNOWN UNKNOWN: wd ( nn-/n ) over or if d# 0 and drop ; { , ... }
 then nip pop pop drop push d# 1 or drop ;
 UNKNOWN: simple ( -w ) -w@ d# -16 and { , }
 UNKNOWN ( * ) H# FA000000 wd if bs .blu -cr bs ; then { , }
 UNKNOWN ( , ) h# FC000000 wd if bs .blu cr ; then { , }
 UNKNOWN ( . ) H# EA000000 wd if .blu bs ; then { , }
 UNKNOWN ( .. ) H# EBD40000 wd if .blu bs ; then { , }
 ( ... ) H# EBD7A800 wd if .blu bs ; then ; }block

( 00211400 )               D# 69 shadow{ 
 UNKNOWN ( blue and grey words ) { * }
 UNKNOWN UNKNOWN: must ( fit into one cell! ) { , , }
: -w@ ( returns word being interpreted by display )
: .blu ( display blue word )
 UNKNOWN UNKNOWN: type1 ( displays word with color already set ) { , , }
: exr ( one-shot red display suppressing cr )
: -cr ( arms exr for next red word encountered. )
 UNKNOWN UNKNOWN: s/2 ( halfspace for reports. ) { , , }
: bs ( backspace protecting left margin )
: wd ( is a factor of ) simple ( to test shannon codes )
: simple ( returns regular blue word for execution but handles special
 UNKNOWN UNKNOWN words internally. ) { , , }
: exb ( display and execute blue word iff found in dictionary. ) }block

( 00211800 )               D# 70 code{ 
 UNKNOWN UNKNOWN ( - blue and grey ) { , , }
 [ here d# 14 display + ! ]
 UNKNOWN: exb simple .blu itick if drop ; then { , }
 UNKNOWN UNKNOWN dup -blue if drop ; then push ( drop ) ; { , , }
: seeb [ ?blu ] @ h# 000000FF or [ ?blu ] ! ;
 UNKNOWN UNKNOWN: ?seeb ( -t ) [ ?blu ] @ [ d# 0 ] + drop ; { , , }
: @lit -w@ d# 32 / ; ( grey ) [ here display d# 13 + ! ]
 UNKNOWN UNKNOWN: tadr h# 00C0C0C0 color @lit d# 3 h.n space ; { , , }
 ( old blue words )
 UNKNOWN: br blu cr cr ; { * }
: tab ( n ) for space next ;
 UNKNOWN: indent blu cr d# 3 tab ; { * }
 UNKNOWN: kr cr ; { * }
: cr blu kr ; }block

( 00211C00 )               D# 71 shadow{ 
: seeb ( toggle display of blue words )
 UNKNOWN UNKNOWN: ?seeb ( set flag non-zero if blue words visible ) { , , }
: @lit ( fetch 27-bit literal from current word )
 UNKNOWN UNKNOWN: tadr ( display target address ) { , , }
: br ( blank line )
: tab ( advance n spaces )
: indent ( 5 spaces ) }block

( 00212000 )               D# 72 code{ 
 ( convert cf character to/from ascii ) { cr }
 [ macro ]
: 1@ h# 0000008A 2, ; { -cr } : 1! < a! > h# 00000288 2, < drop > ;
 [ forth ]
: string pop ;
: cf-ii align string { cr }
 [ H# 6F747200 , H# 696E6165 , H# 79636D73 , H# 7766676C , ] { cr }
 [ H# 62707664 , H# 71757868 , H# 33323130 , H# 37363534 , ] { cr }
 [ H# 2D6A3938 , H# 2F7A2E6B , H# 2B21273B , H# 3F2C2A40 , ]
: ch h# FFFFFFF0 and unpack [ cf-ii ] + 1@ h# 000000FF and ; { br }

: ii-cf string { cr }
 [ h# 00002A00 , h# 0000002B , H# 2B2D0000 , H# 2725232E , ] { cr }
 [ H# 1B1A1918 , H# 1F1E1D1C , H# 28292120 , H# 2F000000 , ] { cr }
 [ H# 3A43355C , H# 3D3E3440 , H# 54523744 , H# 3336393C , ] { cr }
 [ H# 38314742 , H# 3F414632 , h# 00563B45 , H# 23000000 , ] { cr }
 [ H# 0A13052C , H# 0D0E0410 , H# 24220714 , h# 0306090C , ] { cr }
 [ H# 08011712 , H# 0F111602 , h# 00260B15 , ]
: chc h# FFFFFFE0 + [ ii-cf ] + 1@ h# 000000FF and ; { br }

: set1 H# 3D21223A H# 3E2C203C
: !8 ( nn- ) [ cf-ii h# 0000002C + 2/ 2/ ] ! [ cf-ii h# 00000028 +
 2/ 2/ ] ! ;
: set0 H# 2B21273B H# 3F2C2A40 !8 ; }block

( 00212400 )               D# 73 shadow{ 
 ( colorforth to ascii and ascii to colorforth )
: cf-ii ( otr inae ycms wfgl bpvd quxh ) { indent }
      ( 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? ) { indent }
      ( cba@ gfed 02ih onml srqp wvut 1yx ) { indent }
      ( cba@ gfed 02ih onml srqp wvut 1yx ) { br }

 [ to facilitate pathnames and html strings... ]
: set1 ( modifies cf-ii table. ) { cr }
 ; ( to colon, ) ' ( to doublequote, ) + ( to equal, ) { cr }
 @ ( to lessthan, ) * ( to blank, ) ? ( to greaterthan )
: set0 ( restores original cf-ii table. ) }block

( 00212800 )               D# 74 code{ 
 ( pathname input ) [ -nat d# 72 load set1 ]
: strng ( n-a ) pop + ;
: fnam ( n-a ) align strng [ here d# 80 + h ! ] :# hld 28
: emt ( n- ) [ hld ] @ fnam 1! d# 1 [ hld ] +! ;
: +shan ch emt dup and if +shan ; then drop ; { br }

: ,src 7@+ @
: xx dup and if +shan 7@+ @ dup d# 15 and drop { cr }
 while then [ d# 0 ] and emt 7dec ; then xx ;
: named ( string ) d# 0 [ hld ] ! -kbd if ,src ; { cr }
 then ( keyboard ) d# 0 word d# 0 { cr }
 begin push dup and while end then drop { cr }
 begin pop dup and while +shan end then emt ; { cr }
: onam ( n-a ) align strng [ here d# 80 + h ! ]
: bnam ( n-a ) align strng [ here d# 80 + h ! ]
: !str ( b ) push named [ d# 0 fnam ] d# 4 / pop d# 4 / [ d# 20 ] move
 ;
: onamed d# 0 onam !str ; [ onamed ] ( okadwork.cf )
: bnamed d# 0 bnam !str ; [ bnamed ] ( okadback.cf ) { cr }
 [ d# 0 onam 'ofn ! d# 0 bnam 'bfn ! ] }block

( 00212C00 )               D# 75 shadow{ 
 ( filename input )
: strng ( defines an array of bytes. )
: fnam ( is a zero terminated ascii string consisting of ) hld ( chars
 including the null. ) emt ( appends a character to this string. )
: +shan ( appends a shannon word to fnam. ) { br }

: named ( returns the byte address of a null terminated ascii string
 representing the following colorforth string, which may follow in
 either source code or in keyboard input. ) { cr }
 ( example ) [ named ] ( //./a; ) { br }

: onamed ( and ) bnamed ( override the default .cf ) { cr }
 ( filenames used by save and audit ) }block

( 00213000 )               D# 76 code{ 
 ( index ) [ empty -nat d# 74 load set0 ] { cr }
 :# pad 278806528 [ abuf block d# 4 * pad ! ] { cr }
 :# hld 278821284 [ pad @ hld ! ] :# pos 2 [ d# 0 pos ! ]
: nxt ( a-an ) dup d# 1 + swap @ ;
: -eol? [ pos ] @ [ d# 47 ] or drop ;
: .sp d# 32
: .ch ( c ) -eol? if [ hld ] @ 1! d# 1 [ hld ] +! d# 1 [ pos ] +! ;
 { indent }
      then drop ;
: crlf d# 0 [ pos ] ! d# 13 .ch d# 10 .ch ; { br }

: .hd ( n ) [ d# -10 ] + -if [ h# 0000003A ] + .ch ; then [ h# 00000041 ]
 + .ch ;
: .dec ( n ) [ d# 0 ] + -if h# 0000002D .ch negate then [ d# -1 ] swap
 { cr }
 begin [ d# 10 ] /mod dup and while end then drop
: spit ( -1 ... ) begin .hd [ d# 0 ] + -until drop ; { br }

: hd ( n-nn ) dup [ h# 0000000F ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n ) [ d# -1 ] swap begin hd H# 0FFFFFFF and while end then
 drop spit ; { cr }
 [ d# 78 load ] { br }

 [ named ] ( index.txt ) [ exit d# 18 d# 1440 run ] }block

( 00213400 )               D# 77 shadow{ 
 ( index )
: hld ( place in file )
: spot ( in line )
: nxt ( fetch next word )
: emit ( ascii character, won't go past column { 0000090F } )
: space ( written to file )
: crlf ( to file )
: digit ( hex digit to file )
: .h ( print hex number )
: .d ( decimal number ) { br }

 [ usage example in bottom line. ] }block

( 00213800 )               D# 78 code{ 
 ( - more )
: word ( n ) .sp [ h# FFFFFFF0 ] and
: cont ( n ) dup and if ch .ch cont ; then drop ;
: short ( n ) .sp 2/ 2/ 2/ 2/ dup d# 1 and drop { indent }
      if 2/ .hex ; then 2/ .dec ;
: variable ( an-a ) word d# 0
: long ( an-a ) .sp push nxt pop h# 00000010 and drop { indent }
      if .hex ; then .dec ;
: eol ( n ) begin drop d# 47 [ pos ] ! ;
: tag ( a-a ) dup and until dup h# 0000000F and jump { cr }
 cont word long eol word long short word { cr }
 short word word word variable short eol short
: ?sp ( nl-n ) + -if .sp then ;
: line ( n ) d# -100 ?sp d# -900 ?sp d# 1000 + { indent }
      dup .dec space block d# 0 [ pos ] ! { indent }
      begin -eol? while nxt tag end { indent }
      then drop crlf ;
: run ( 1st lst+1 ) [ pad ] @ [ hld ] ! over negate + 2/ { indent }
      for dup line [ d# 2 ] + next drop
: sav d# 0 d# 32 d# 2 d# 0 d# 0 w/o [ d# 0 fnam ] fcreate dup push
 { cr }
 [ pad ] @ [ hld ] @ over negate + pop fwr drop fclose ; }block

( 00213C00 )               D# 79 shadow{ 
 ( index.1 )
: short ( number )
: literal ( long number )
: word ( text, not number )
: cont ( inuation word )
: variable ( name and value )
: eol ( red word means end of line )
: tag ( vector table )
: words ( print maximum n words or to eol )
: run [ first-block last+1 ] { cr }
 ( prints first line of each block in range ) { cr }
 ( to a log file ) [ in windows ] }block

( 00214000 )               D# 80 code{ 
 ( qx ) :# ?qxc 271553418 :# qb 1080 [ d# 82 load ]
: ?c ( n-n ) green dup [ blk ] @ or drop if white then ;
 UNKNOWN UNKNOWN: !qx [ ?qxc ] assign ?c ; [ !qx ] { , , }
 UNKNOWN: nx [ qb ] @ d# 120 + { * }
 UNKNOWN UNKNOWN: qx ( n !qx ) d# 0 max abuf /mod { , ... }
 UNKNOWN push d# 2 /mod d# 60 / d# 120 * + pop abuf * + [ qb ] ! { , }
 UNKNOWN show black screen white d# 0 d# 60 for dup d# 30 /mod { ,
 UNKNOWN ... }
 UNKNOWN UNKNOWN d# 42 * swap tab/2 [ qb ] @ over 2* + [ ?qxc ] xqt { , ... }
 dup .r .cmt d# 1 + next drop keyboard ;
: bx [ qb ] @ d# -120 + qx ; { -cr } : ax [ blk ] @ qx ;
: sx [ qb ] @ d# 1 or qx ;
: ox [ qb ] @ [ abuf ] /mod d# 1 or [ abuf ] * + qx ; }block

( 00214400 )               D# 81 shadow{ 
 ( index page overview display ) { br }

: qx ( shows the heading comments of the index page in which block )
 [ n ] ( lies, source or shadow. ) { br }

: nx ( shows the next page and ) bx ( the preceding. )
: sx ( toggles between source and shadows for the current page. ) { br }

: ax ( shows the page in which the current editor block lies. ) this
 block is displayed in green }block

( 00214800 )               D# 82 code{ 
 ( - formatting ) :# ws 271547285
: tab/2 ( xy ) push [ d# 11 ] * [ d# 3 ] + pop [ d# 15 ] * [ d# 3 ]
 + { cr }
 over lm at ; { -cr } : emit/2 ( c ) [ d# 48 ] + emit
: -sp/2 [ d# -11 h# 00010000 * ] nop [ xy ] +! ; { br }

: /bl [ ws ] assign nop ; { -cr } : /sp [ ws ] assign sp/2 ;
: .r ( n ) [ d# 4 ] for d# 10 /mod next h# 0000000F and [ d# 4 ] for
 [ d# 0 ] + if { cr }
 pop [ d# 1 ] + { -cr } : .lo for [ d# 24 ] + emit/2 next ; { cr }
 then drop [ ws ] xqt next [ d# 1 ] .lo ; [ /sp ]
: .n ( n ) [ d# 32 ] / /bl .r /sp ;
: .s/2 ( n ) [ d# 0 ] + if unpack emit/2 .s/2 ; then drop ;
: .wd ( n ) [ h# 00008200 ] tag? if sp/2 then [ h# 00008000 ] tag?
 if .n ; then d# -16 and .s/2 ;
: .cmt ( n ) d# 18 less drop if drop ; then block d# 7 for dup @ [
 d# 0 ] + while [ h# 00008201 ] tag? while .wd { cr }
 [ d# 1 ] + next drop ; then then pop drop drop drop ; }block

( 00214C00 )               D# 83 shadow{ 
 ( index page overview display ) { br }

 ( these definitions are necessary due to the way in which colorforth
 kernel is factored. ) }block

( 00215000 )               D# 84 code{ 
 ( resident compress ) [ d# 86 load ]
: short d# 4 rbits d# 28 bits ;
: lit d# 4 rbits 2/ 2/ 2/ 2/ d# 1 rbits
: 32bits drop d# 1 + dup @ d# 16 bits d# 16 bits ;
: variable 1word 32bits ;
: /whit ( n-n ) d# -16 and d# 9 or atom ;
: tag ( an-an ) dup h# 0000000F and jump cont atom lit atom atom lit
 short atom short atom /whit /whit variable short atom short
: atoms ( a ) dup @ dup and if tag drop d# 1 + atoms ; then d# 4 bits
 drop drop ;
: range ( nn-an ) here/4 here4 push new for dup block atoms d# 1 +
 next drop 0 d# 31 bits drop pop here4 over negate + ;
: !lng ( nw ) [ d# 127 ] + [ d# 128 ] / [ d# 72 ] + dup ( nsec ) [
 d# 0 ] block [ d# 1 ] + ! dup negate [ ns ] ! [ d# 35 ] + [ d# 36 ]
 / [ nc ] ! ;
: save 7push [ h ] @ push [ cbuf d# 36 + block d# 4 * ] h ! d# 36 [ nblk
 @ d# -36 + ] range ( an ) !lng drop 0 block [ cbuf ] block [ d# 36
 blks ] move [ cbuf ] !work [ ns ] @ abs [ ns ] ! pop [ h ] ! 7pop
 ; }block

( 00215400 )               D# 85 shadow{ 
: short ( tag, then 28bit value+base )
: lit ( tag, then base )
: 32bits ( from next word. 2 chunks )
: variable ( single word, then 32-bits )
: /whit ( replaces a word's tag with 9, making it a lowercase comment. )
: tag ( identify kind of word ) [ note /whit used for tags h# 0000000A
 and h# 0000000B to convert these deprecated capitalized comments to
 lower case. when all source of interest has been compressed at least
 once this may be removed. ]
: atoms ( scan thru block. 8 0s eob )
: range ( process blocks, number and count. 31 0s eof )
: sve ( compress blocks 72 thru 1419 )
: flop ( write floppy; save number of cylinders ) }block

( 00215800 )               D# 86 code{ 
 ( - more ) [ macro ] ( uses ebx )
: r3@ < ?dup > h# 0000C38B 2, ;
: r1! h# 0000C88B 2, < drop > ;
: 2*d h# 00C3A50F 3, ;
: 2*c h# 0000E0D3 2, ;
: 2/r h# 0000C8D3 2, ; [ forth ] :# nb 14
: here/4 here d# 3 and if 1, here/4 ; then drop ;
: here4 here 2/ 2/ ;
: new d# 32 [ nb ] ! ;
: shift ( nn-n ) dup negate [ nb ] +! r1! 2*d 2*c ;
: rbits dup r1! swap 2/r swap
: bits ( nn-n ) dup negate [ nb ] @ + -if dup push + shift r3@ , new
 pop negate shift ; then drop shift ;
: char -if 2* -if 2/ d# 7 bits ; then 2/ H# 80000000 or d# 5 bits ;
 then d# 4 bits ;
: chars dup and if char chars ; then ;
: 1word d# 4 rbits chars d# 4 bits ;
: atom ( an-an ) d# 4 rbits
: cont chars over d# 1 + @ dup and if h# 0000000F and drop if d# 4
 bits ; then ; then drop d# 4 bits ; }block

( 00215C00 )               D# 87 shadow{ 
: r3@ ( fetches register { 0000006F } onto stack. )
: r1! ( stores top of stack to register 1. )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: 2/r ( rotate eax right by ecx )
: nb ( number of bits remaining in word )
: here/4 ( align to word boundary )
: here4 ( word address in dictionary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: rbits ( rotate bits to high-order position )
: bits ( shift bits into ebx; cross word boundary )
: char ( examine high bits. shift 4, 5 or 7 bits )
: chars ( shift all non-zero characters )
: 1word ( short word without continuation for variable )
: atom ( shift tag, then characters )
: cont ( continue without tag ) }block

( 00216000 )               D# 88 code{ 
 ( display text ) [ macro ]
: 7@+ ( -a ) < ?dup > h# 0000C78B 2, h# 00000047 1, ; { -cr } : 7dec
 h# 0000004F 1, ;
: @ret ( -b ) < ?dup > h# 0024048B 3, H# 05240483 , ;
: 4@ ( b-n ) h# 0000008B 2, ; [ forth ]
: tick ( b-b ) dup [ d# 1 ] + 4@ + d# 5 + ;
: call h# 000000E8 { -cr } : dst 1, @ret tick here d# 3 + - + , ;
: jmp h# 000000E9 dst ; { br }

: .shan ( n- ) dup and if unpack emit .shan ; then drop ; { -cr } 
: +str ( a-a ) + ; [ macro ]
: ,lit ( n ) < ?dup > h# 000000B8 1, , ;
: strings ( i-a ) 7push pop < ,lit > jmp +str nop ;
: .' ( comment ) 7@+ @ d# -16 and < ,lit > call .shan nop ;
: remember [ forths ] @ < ,lit > [ macros ] @ < ,lit > [ h ] @ [ d# 15 ]
 + < ,lit > ( call ) jmp !dict nop ; [ forth ] { br }

: ' ( -b ) -kbd if 7@+ @ itick if abort then ; { cr }
 then tic ;
: execute ( b ) push ;
: eval ( a ) 7push [ d# 1 ] + push 7pop [ sp d# 1 + ] @ execute 7pop
 ; }block

( 00216400 )               D# 89 shadow{ 
 ( various useful extensions. ) { br }

: 7@+ ( interpret only, returns adr of next word in block and skips
 over it ... 7-0-mov 7-inc )
: 7dec ( used to correct address after 7@+ )
: @ret ( fetch return address, skip bytes of code. )
: 4@ ( cell fetch on byte boundary )
: tick ( given adr of call instr, return tgt adr )
: call ( and ) jmp ( generate xfers to next word ) { br }

: .shan ( displays a shannon coded string )
: ,lit ( compiles a literal. )
: .' ( displays the following one-word comment. )
: remember used ( in a containing word to make that word restore dictionary
 to what immedately follows it. ) { br }

: strings ( starts an array of words in source. )
: ' ( interp only, returns next word's code addr. )
: execute ( is a call to the given routine adr. )
: eval ( interprets the source word whose address is given. ) }block

( 00216800 )               D# 90 code{ 
 UNKNOWN ( disk audit utility ) [ empty d# 30 load ] :# bias 0 { , }
 :# sep 10000 [ abuf sep ! ] :# head 1439 [ d# 1439 head ! ]
: +blocks ( sdn ) 2* ( bloks ; )
: bloks ( sdn ) push swap block swap block pop [ d# 256 ] * move ;
 UNKNOWN { * }
: n18 ( i-a ) [ abuf d# 18 + block ] + ;
 UNKNOWN: wipe [ blk ] @ d# 1 erase ( e ) lis ; { * }
: to ( n ) [ head ] ! ;
: obliterate ( lh ) over negate + erase ;
 UNKNOWN: matching ( sd ) less if swap then { , }
 dup [ bias ] ! negate + [ sep ] ! ;
: cast ( nn-n ) dup push /mod d# 1 or pop * + ;
: other ( n-n' ) [ bias ] @ negate + [ sep ] @ cast [ bias ] @ + ;
 UNKNOWN { * }
: lesser ( n-n ) dup other min ; [ d# 92 load ]
: ?blk ( n-n?n+ ) lesser dup block over other block [ d# 256 ] for
 over @ over @ or drop if drop drop dup [ d# 1 ] + pop drop ; then
 UNKNOWN [ d# 1 ] + [ d# 1 ] u+ next drop drop [ d# 1 ] + ; { * }
: ?blks ( sn-? ) for ?blk next drop ;
: ?bin ( kernel ) d# 0 d# 12 ?blks ( icons ) d# 12 d# 6 ?blks ;
 UNKNOWN: unpk abs [ d# 1 n18 ] ! { , }
 UNKNOWN [ abuf d# 36 + ] block [ cbuf ] block [ d# 1404 ] blks move { , }
 [ cbuf block ] abuf d# 36 + [ d# 3 n18 ] @ [ d# -36 ] + range ;
 UNKNOWN: check [ abuf ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or { , }
 UNKNOWN drop if ; then [ d# 1 n18 ] @ { , }
 dup and -if unpk ; then drop ; }block

( 00216C00 )               D# 91 shadow{ 
 ( disk mgmt and reconciliation utility. )
: bloks ( copies n blocks from s to d, front to back so only moves
 overlap downward safely. )
: +blocks ( copies n blocks and their shadows. )
: obliterate ( wipes from block l to block h. )
: matching ( sets up to match s to d. )
: to ( sets block no. past end of source area. )
: other ( given a block number in one of the areas returns the corresponding
 block no. in the other area. )
: lesser ( given a block number returns the lesser of the pair it is
 a member of )
: ?blks ( scans a range of blks leaving nos of any differing blks on
 the stack. )
: ?bin ( scans the binary parts of okad disk. )
: check ( reads backup to { 0001770F } and decompresses if appropriate )
 }block

( 00217000 )               D# 92 code{ 
 ( - compare ) :# cvec 271552824
: blink [ cvec ] assign ( n ) dup other [ blk ] ! edit ;
: var ( nnxx-nnd ) push push d# 1 + d# 1 u+ pop pop
: *1 ( nnxx-nnd ) or ;
: *2 ( nnxx-nnd ) var push over @ over @ or pop + ;
 UNKNOWN UNKNOWN: tag ( nn-n ) dup h# 0000000F and jump *1 *1 *2 *1 { , ... }
 UNKNOWN *1 *2 *1 *1 { .. }
 UNKNOWN *1 *1 *1 *1 { .. }
 var *1 *1 *1
: ?nul ( nnxx-nnxx ) over over +or drop if ; then drop drop pop drop
 drop drop ;
 UNKNOWN UNKNOWN: co ( naa-n ) over @ over @ ?nul tag drop if { , ... }
 drop drop [ cvec ] xqt ; then d# 1 + d# 1 u+ co ;
: com ( n-n ) dup block over other block co ;
: g [ blk ] @ lesser
 UNKNOWN: gg ( n ) blink [ head ] @ over - + drop -if drop ; { , }
 then [ d# 1 ] + com gg ;
: v [ blk ] @ other edit ;
: give [ blk ] @ dup other d# 1 bloks ;
: take [ blk ] @ dup other swap d# 1 bloks ;
: all d# 0 [ abuf ] matching [ nblk ] @ [ d# -1 ] + to [ d# 17 ] gg
 ;
: diff [ cvec ] assign red ;
 UNKNOWN: !cx [ ?qxc ] assign ( n-n ) ?c diff com ; { , }
 UNKNOWN [ !cx ] { * }
: empty empt !qx ; }block

( 00217400 )               D# 93 shadow{ 
: blink ( displays the given block with its other set as the editor's
 'other' block )
: var ( compares a variable name, advancing pointers to skip its value. )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compares source cells given, true if diff, advancing ptrs and
 ignoring variable vals. )
: ?nul ( ends loop in co if nuls hit in both blks. )
: co ( does work of com given adrs of both blks. )
: com ( invokes editor to blink the given block if it differs from
 the other, otherwise returns. )
: g ( scans for diffs after current editor block. )
: v ( shows the other block )
: give ( writes current editor block over its twin )
: take ( writes twin over current editor block. )
: check ( reads backup to 3000 for matching. )
: all ( scans the whole usable area of the disk. )
: cvec ( is behavior on com finding difference; )
: diff ( makes it just set color for qx. )
: !cx ( makes qx aware of us, )
: empty ( redefined to kill that awareness. ) }block

( 00217800 )               D# 94 code{ 
 }block

( 00217C00 )               D# 95 shadow{ 
 }block

( 00218000 )               D# 96 code{ 
 }block

( 00218400 )               D# 97 shadow{ 
 }block

( 00218800 )               D# 98 code{ 
 }block

( 00218C00 )               D# 99 shadow{ 
 }block

( 00219000 )               D# 100 code{ 
 }block

( 00219400 )               D# 101 shadow{ 
 }block

( 00219800 )               D# 102 code{ 
 }block

( 00219C00 )               D# 103 shadow{ 
 }block

( 0021A000 )               D# 104 code{ 
 }block

( 0021A400 )               D# 105 shadow{ 
 }block

( 0021A800 )               D# 106 code{ 
 }block

( 0021AC00 )               D# 107 shadow{ 
 }block

( 0021B000 )               D# 108 code{ 
 ( ide native async ) [ d# 0 fh orgn ! macro ]
: 1@ ( b-c ) h# 0000008A 2, ;
: 1! ( cb ) < a! > h# 00000288 2, < drop > ;
: 2@ ( b-h ) h# 00008B66 3, ;
: 2! ( hb ) < a! > h# 00028966 3, < drop > ;
: 4@ ( b-n ) h# 0000008B 2, ;
: 4! ( nb ) < a! > h# 00000289 2, < drop > ;
: swab ( h-h ) h# 0000C486 2, ;
: swa4 ( n-n ) h# 0000C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ;
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ;
: rez ( n ) h +! ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }

 :# act 0 :# vport 373 :# 0tg 1 :# 1tg 1 :# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] !
 ; { br }

 ( ser ) [ d# 110 load d# 118 load ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load d# 142 load ] ( creeper ) [ d# 140 load ] { cr }
 [ canon load ] }block

( 0021B400 )               D# 109 shadow{ 
 ( talk to chip via native rs232. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure
 given byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
 in dictionary. ) [ note that writing into such allocations invalidates
 nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. )
 { br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021B800 )               D# 110 code{ 
 ( - umbilical ) [ h# 000003F8 ] ( serial ) [ d# 60 load ]
: !nam ; :# sport 0 :# bps 0
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 24576 rez ] :# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }

: @18 ( -n ) /str 4@ [ h# 0003FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 0003FFFF ] or [ h# 00000040 ] * [ h# 00000012 ] +
 /str 4! +wd ; { br }

: +ser ( -ok ) init d# 1 [ d# 0 ] + ;
: -ser ;
: reset [ d# 1 ] st! [ d# 100000 ] for next [ d# 3 ] st! ;
: toser ( bn ) for dup 1@ xmit [ d# 1 ] + next drop ;
: inser ( w ) stream swap [ d# 3 ] * for { indent }
      rcv over 1! [ d# 1 ] + next drop ; }block

( 0021BC00 )               D# 111 shadow{ 
 ( async data are 18 bits per 3 bytes. to chip word inverted, shifted
 up 6, '12' inserted, then sent low order byte first. from chip are
 tbd. ) { br }

: !nam sport ( and ) bps ( dummies for compatibility )
: 4@ ( and ) 4! ( full cell on byte address. )
: +ser ( opens serial; true if good, handle in dh. )
: -ser ( closes the handle. )
: reset ( resets the chip. )
: toser ( transmits n bytes to chip. )
: inser ( receives w f18 words from the chip. ) { br }

: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be
 present! ) }block

( 0021C000 )               D# 112 code{ 
 ( ide windows async ) [ d# 0 fh orgn ! macro ]
: 1@ ( b-c ) h# 0000008A 2, ; { -cr } : 1! ( cb ) < a! > h# 00000288
 2, < drop > ;
: 2@ ( b-h ) h# 00008B66 3, ; { -cr } : 2! ( hb ) < a! > h# 00028966
 3, < drop > ;
: 4@ ( b-n ) h# 0000008B 2, ; { -cr } : 4! ( nb ) < a! > h# 00000289
 2, < drop > ;
: swab ( h-h ) h# 0000C486 2, ;
: swa4 ( n-n ) h# 0000C80F 2, ; [ forth ] { br }

: a-b ( a-b ) 2* 2* ; { -cr } : b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ; { -cr } : rez ( n ) h +! ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }

 :# act 0 :# vport 277 :# 0tg 1 :# 1tg 1 :# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] !
 ; { br }

 ( ser ) [ d# 114 d# 3 loads ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load d# 142 load ] ( creeper ) [ d# 140 load ] { cr }
 [ canon load ] }block

( 0021C400 )               D# 113 shadow{ 
 ( talk to chip via onspec usb. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure
 given byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
 in dictionary. ) [ note that writing into such allocations invalidates
 nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. )
 { br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021C800 )               D# 114 code{ 
 ( - umbilical ) :# sport 3 [ d# 1 sport ! ]
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 24576 rez ] :# bi 381
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }

: @18 ( -n ) /str 4@ [ h# 0003FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 0003FFFF ] or [ h# 00000040 ] * [ h# 00000012 ] +
 /str 4! +wd ; { br }

: snam ( -a ) align create ( //./ ) [ H# 2F2E2F2F , ] ( com ) [ h# 006D6F63
 , h# 00000000 , ]
: !nam [ sport ] @ d# 10 over - + drop -if d# 256 * d# 2560 /mod +
 h# 00003000 + then h# 00000030 + snam a-b d# 7 + 4! ; [ !nam ]
: toser ( bn ) [ dh ] @ fwr drop ;
: inser ( w ) stream swap [ d# 3 ] * [ dh ] @ frd drop ; }block

( 0021CC00 )               D# 115 shadow{ 
 ( async data are 18 bits per 3 bytes. to chip word inverted, shifted
 up 6, '12' inserted, then sent low order byte first. from chip are
 tbd. ) { br }

: sport ( comp com port number )
: snam ( null terminated string //./comx )
: !nam ( sets port number in snam. )
: +ser ( opens serial; true if good, handle in dh. )
: -ser ( closes the handle. )
: reset ( resets chip. no inversion in rx line. )
: toser ( transmits ) [ n ] ( bytes from byteadr ) [ b ]
: inser ( receives w f18 words from the sync boot node. ) { br }

: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be
 present! ) }block

( 0021D000 )               D# 116 code{ 
 ( - com port management ) { cr }
 :# dflg 4113 [ h# 00001011 dflg ! ] { cr }
 :# bps 921600 [ d# 115200 bps ! ]
: dcb ( n-a ) align strng [ here d# 32 + h ! ]
: @dcb d# 0 dcb [ dh ] @ rdcb drop ; [ d# 0 d# 0 dcb b-a d# 8 fill ]
: !dcb [ dflg ] @ [ d# 8 dcb ] 4! d# 0 dcb [ dh ] @ wdcb drop ;
: /dcb @dcb !dcb ;
: baud ( n ) @dcb [ d# 4 dcb ] 4! ( bits ) d# 8 [ d# 18 dcb ] 1! { cr }
 ( np/1sb ) d# 0 [ d# 19 dcb ] 2! !dcb ; { br }

: +ser ( -ok ) snam r/w fopen [ dh ] ! if { cr }
 [ bps ] @ baud d# 1 ; then d# 0 ;
: -ser [ dh ] @ [ d# 0 ] + if fclose d# 0 then [ dh ] ! ;
: ctl! ( n ) [ dh ] @ fesc drop ;
: reset ( lo ) [ d# 4 ] ctl! [ d# 500000 ] for next ( hi ) [ d# 3 ]
 ctl! ; }block

( 0021D400 )               D# 117 shadow{ 
: dcb ( structure controls mode of a com port. )
: dflg ( flags sent every time we control com port { 0000003F } binary
 always, { 0000021F } dtr on, { 0000201F } rts on. )
: @dcb ( and ) !dcb ( read and write com port control. ) [ dflg ] ( is
 always included in the setting. )
: /dcb ( sets dflg without changing anything else )
: baud ( sets baud rate and character framing. ) { br }

: +ser ( opens serial; true if good, handle in dh. )
: -ser ( closes the handle. )
: reset ( resets chip. no inversion in rx line. ) }block

( 0021D800 )               D# 118 code{ 
 ( - node { 0000588F } boot frames )
: wos ( -n ) d# 0 ;
: /frame ( nw xfr jmp ) -stream [ h# 00010000 ] + !18 !18 [ d# 1 ]
 + 2/ ( words ) 2* ( actual { FFFFFFEF } + ) !18 ;
: +frame ( wn ) for dup @ !18 [ d# 1 ] + next drop ;
: +ram ( w n node ) nn-n 2* [ h# 00008000 ] + block u+ for dup @ [
 h# 00015555 ] or !18 [ d# 1 ] + next drop ;
: !frame ( f ) drop stream [ bi ] @ toser ; { br }

: exec [ h# 000000AE ] ;
: talk cold -ser +ser if drop reset h# 00000040 d# 0 [ exec ] /frame
 h# 00000000 h# 00000040 [ d# 1600 ] +ram [ wos ] !frame ( good ) ;
 then ( bad ) -ser drop h# 00000BAD dup abort ; { cr }
: exch ( w n f n ) push push dup [ h# 00000002 ] + [ d# -2 ] and [ vport ]
 @ pop /frame [ vport ] @ [ h# 00012000 ] + !18 dup - [ h# 00000001 ]
 and drop if [ vport ] @ [ h# 00010000 ] + !18 then +frame [ wos ]
 !frame pop inser -stream ; { br }

: ok [ h# 00000012 ] ;
: fet [ h# 00000015 ] ;
: stat [ h# 0000001B ] ;
: bstk [ h# 0000001D ] ; }block

( 0021DC00 )               D# 119 shadow{ 
 ( boot frames begin with a 3 word header; ) { indent }
      100xx ( jump to xx when done ) { indent }
      ddd ( mem/port adr to store payload ) { indent }
      n ( transfer length ) { indent }
      [ n ] ( words of payload, none if ) [ n ] ( is 0. )
: /frame ( heads a new given ) [ even ] ( words of payload, destination
 addr, final jump addr. )
: +frame ( appends words to payload. )
: +ram ( appends a string of code from binary produced by ) compile
 ( for the given ) [ node. ]
: !frame ( transmits frame given ) [ wos ] ( or ) [ wos! ] { br }

: talk ( prepares chip for control thru node 19. )
: exch ( performs a transaction with target given addr and length of
 port stream, stream end action in boot node, and number of words reply. )
 { cr }
: ok ( stream end to simply ack completion; ) fet ( pumps one word
 from target; ) bstk ( shepherds stack dump; ) stat ( pumps ten. )
 exec ( is next boot frame. ) }block

( 0021E000 )               D# 120 code{ 
 ( - node { 0000588F } paths )
: line ( ncd ) swap push swap { indent }
      begin dup , over + -next drop drop ;
: count ( nc-ncd ) dup [ d# 100 ] mod [ d# 0 ] + if { cr }
 ( horz ) swap drop [ d# 1 ] ; ( vert ) then drop [ d# 100 ] / [ d# 100 ]
 ;
: to ( nn ) over negate + -if { cr }
 ( back ) negate count negate line ; { cr }
 ( forw ) then count line ; { br }

: 0pa align create [ d# 708 d# 700 to d# 600 d# 0 to ] { cr }
 [ d# 1 d# 17 to d# 117 d# 717 to d# 716 d# 708 to d# -1 , ]
: 1pa align create [ d# 708 , d# 608 , d# -1 , ]
: 2pa align create [ d# 708 d# 717 to d# 617 d# 17 to ] { cr }
 [ d# 16 d# 0 to d# 100 , d# 101 d# 116 to d# 216 d# 200 to ] { cr }
 [ d# 300 d# 316 to d# 416 d# 400 to d# 500 d# 516 to ] { cr }
 [ d# 616 d# 600 to d# 700 d# 708 to d# -1 , ] }block

( 0021E400 )               D# 121 shadow{ 
: 0pth 1pth 2pth ( are manually set route lists for using the north,
 south, and west ports of node 19. end list is marked by -1 ) { br }

 ( customize these paths by replacing entries in ) paths ( table after
 loading ide. ) }block

( 0021E800 )               D# 122 code{ 
 ( - boot target adjacent ) :# 'wall 270103196
: swall ( nn-i ) over over or [ d# 1 ] and drop if or [ d# 2 ] and
 ; then { 0000014F } [ d# 100 ] / swap { 0000014F } [ d# 100 ] / or
 [ d# 2 ] and [ d# 1 ] + ;
: wall ( nn-i ) [ 'wall ] xqt ; [ ' swall 'wall ! ] { br }

: do! align create ( @p+a!.@p+ ) [ h# 00004AB7 , ] { indent }
      [ h# 00000000 , h# 00000000 , ] ( !;;; ) [ h# 0000B555 , ]
: do@ align create ( ...@p+ ) [ h# 0002C9B7 , ] { indent }
      [ h# 00000000 , ] ( a!@!p+; ) [ h# 0002BE35 , ]
: doi align create [ h# 00010000 , ]
: dopu align create ( @p+; ) [ h# 00005555 , h# 00000000 , ]
: dostk align create ( !p+dup-push!p+ ) [ h# 0000CDBE , ] { br }

: aa@ ( a-n ) [ do@ d# 1 + ] ! do@ [ d# 3 ] fet [ d# 1 ] exch @18 ;
: aa! ( na ) [ do! d# 1 + ] ! [ do! d# 2 + ] ! do! [ d# 4 ] ok [ d# 1 ]
 exch ;
: acall ( a ) [ h# 00010000 ] +
: ains ( w ) [ doi ] ! doi [ d# 1 ] ok [ d# 1 ] exch ;
: apsh ( n ) [ dopu d# 1 + ] ! dopu [ d# 2 ] ok [ d# 1 ] exch ;
: astk dostk [ d# 1 ] bstk [ d# 10 ] exch ; }block

( 0021EC00 )               D# 123 shadow{ 
 ( this code supports boot node controlling one of its immediate neighbors
 directly. ) [ these all begin with focusing call and each must return! ]
 { cr }
: port ( returns port for 0-3 rdlu ndx, then edges )
: wall ( is index for port between two nodes )
: 'wall ( vectors the active ) wall ( definition )
: swall ( is standard ) wall ( definition ) { br }

: doxxx ( port execution templates for target. )
: aa@ ( fetches from memory or port in target onto our stack here. )
: aa! ( stores a value from our stack here to port or memory in target. )
: ains ( executes an arbitrary instruction word which must end by returning. )
: acall ( executes a target word which must return or jump to ports. )
: apsh ( pushes a number onto target stack. )
: astk ( queries target stack nondestructively. ) }block

( 0021F000 )               D# 124 code{ 
 ( - stream components ) :# 'pth 67525653
: nstream ( an-n'w ) swap [ 'pth ] ! [ d# -2 ] + -if [ d# 0 ] pop drop
 ; then ( pre ) [ d# 2 ] ;
: ?path ( i-n ) [ 'pth ] @ + @ ;
: side ( n-a ) [ 'pth ] @ + dup @ swap [ d# 1 ] + @ wall port ;
: /hdr ( w-w ) dup [ d# -2 ] and [ d# 0 ] side [ exec ] /frame ( pre )
 [ d# 0 ] side [ h# 00012000 ] + !18 [ d# -1 ] + dup [ d# 1 ] and drop
 if [ d# 0 ] side [ h# 00010000 ] + !18 then [ d# -1 ] + ; { br }

: +pump ( nw-nw ) [ d# -8 ] + ( @p+b!@p+@p+ ) [ h# 00004B17 ] !18 { cr }
 [ h# 00000001 ] side dup !18 dup [ h# 00010000 ] + !18 [ h# 00012000 ]
 + !18 { cr }
 ( !b!b.@p+ ) [ h# 00009BB7 ] !18 ( w ) dup [ d# -1 ] + !18 { cr }
 ( dup-push-if ) [ h# 00024861 ] !18 ( @p+!b.unext ) [ h# 00005BB4 ]
 !18 ;
: +load ( w n nb nd ) push push ( @p+a!.@p+ ) [ h# 00004AB7 ] !18 ( a )
 over !18 ( n ) [ d# -1 ] + !18 ( dup-push-if ) [ h# 00024861 ] !18
 { cr }
 ( @p+!+.unxt ) [ h# 000058B4 ] !18 pop pop +ram ;
: +post ( p @p+b!.@p+ ) [ h# 00004BB7 ] !18 [ d# 1 ] side !18 [ d# 0 ]
 side !18 ( a!@p+push; ) [ h# 0002BDBD ] !18 ( p ) !18 ; }block

( 0021F400 )               D# 125 shadow{ 
 ( templates and load streams )
: 'pth ( current posn in path list of nodes. )
: nstream ( given addr of path tbl, nodes away, gives no of wire nodes
 and total stream length )
: ?path ( returns node number relative to current posn in selected
 path. )
: side ( gives adr of ) 0 ( near, ) 1 ( far side next node )
: /hdr ( starts a stream of given length; if odd, we leave out jump
 after waking 1st node. ) { br }

: +pump ( makes port pump thru next node; its ram load and init postamble
 must be out of w. )
: +load ( builds a program load from binary given node ram addr, word
 count, words to take from binary, and node number. caller must append
 any words not taken from binary. )
: +post ( follows a node's ram load to set b to out, a to in, and jump
 to ) p. }block

( 0021F800 )               D# 126 code{ 
 ( - umbilical plumbing ) :# 'foc 270105066
: using ( nn ) wall port [ vport ] ! ;
: avail ( n-p ) [ d# 1000 ] mod nn-n idle ; { br }

: +path ( n'wn-n'w ) dup [ 'pth ] +! negate u+ ; { br }

: unfoc ( -a ) [ 'foc ] assign [ d# 1 ] ?path avail ; [ unfoc ]
: foc ( -a ) [ 'foc ] assign [ d# 0 ] side ; { br }

: rip ( nw-nw ) [ d# 0 ] u+ if ( post ) [ d# -5 ] + +pump [ d# 1 ]
 +path rip [ d# -1 ] +path then [ 'foc ] xqt +post ;
: rips ( an-n'w ) nstream over [ d# 13 ] * + [ d# 5 ] + /hdr rip
: hose ( nw ) drop drop d# 0 ?path d# 1 ?path using [ wos ] !frame
 ; { br }

: wire ( nw-nw ) [ d# 0 ] u+ if ( wire ) [ h# 00000016 d# 10 + negate ]
 + +pump [ d# 1 ] +path wire [ d# -1 ] +path ( wire ) h# 00000000 [
 h# 00000016 ] dup [ d# 1602 ] +load [ d# 0 ] side +post ; then ( last )
 UNKNOWN h# 00000000 [ h# 00000020 ] dup [ d# -1 ] + { , }
 [ d# 1603 ] +load [ d# 1 ] side [ h# 00012000 ] + !18 [ d# 0 ] side
 +post ;
: wires ( an-n'w ) nstream over [ d# 18 ] ( lwire ) [ h# 00000016 + ]
 * + [ d# 10 ] ( llast ) [ h# 00000020 + ] + nop /hdr wire hose ; }block

( 0021FC00 )               D# 127 shadow{ 
 ( this block creates and destroys umbilical wiring within the chip. )
 { br }

: using ( sets ) vport ( between given pair of nodes. )
: avail ( is idle pc val for given node. the initial mod is to support
 multichip ide. ) { br }

: +path ( steps ) pos ( to, ) neg ( away from target. ) { br }

: wires ( builds wire for path table ) [ a. ] ( entry zero is boot
 node. ) [ n ] ( is number of nodes away from boot in path; ) 0 ( no
 uut, ) 1 ( no wire, uut is meighbor, ) 2 ( neighbor is last guy, )
 3 [ n-2 ] ( wire nodes then last guy. generates call at end of last
 guy pgm that last guy sends target for focus. )
: rips ( rips out a wire built by ) wire
: foc ( sets ) [ 'foc ] ( to leave ripped wires focused on ide boot
 node; ) unfoc ( restores ) [ 'foc ] ( to default. ) }block

( 00220000 )               D# 128 code{ 
 ( - routing control )
: targets ( -a ) [ act ] @ align tbl [ 0tg , 1tg , 2tg , ]
: paths ( -a ) [ act ] @ align tbl [ here 0pa , 1pa , 2pa , ] { -cr } 
: 'pths [ d# 0 + b-a ] ; { br }

: path ( i ) [ act ] ! paths dup @ swap [ d# 1 ] + @ wall port [ vport ]
 ! ;
: node ( n ) [ d# 3 ] for i [ d# -1 ] + path paths targets @ + @ over
 or drop while next drop ; then pop drop drop ; { br }

: -hook ( i ) path targets @ [ d# 1 ] or drop if paths targets @ rips
 [ d# 1 ] targets ! then ;
: hook ( i n ) swap -hook [ d# 2 ] begin over over paths + @ or drop
 while dup paths + @ [ d# 0 ] + drop -if drop drop ; then [ d# 1 ]
 + end then dup targets ! paths swap wires drop ; { br }

: ?adj pop [ d# 1 ] + dup 4@ swap [ d# 4 ] + targets @ d# 1 or drop
 if push drop ; then + push ; }block

( 00220400 )               D# 129 shadow{ 
 ( these functions support route setup and selection for internal wiring. )
 { br }

: targets ( table of target index variables. )
: paths ( table of route lists. ) { br }

: path ( selects active path ) [ i ] ( 0,1,2 )
: node ( selects path whose target is node ) [ n ] { br }

: -hook ( rips out any wiring on path ) [ i ]
: hook ( hooks up path ) [ i ] ( to node ) [ n ] ( ripping out any
 old wiring on that path. ) { br }

: ?adj ( executes following word and exits defn if selected path is
 to adjacent node, otherwise skips following word. ) }block

( 00220800 )               D# 130 code{ 
 ( - target anywhere )
: dor! align create [ h# 00012005 , h# 00000000 , h# 00000000 , ]
: dor@ align create [ h# 00012000 , h# 00000000 , ]
: dori align create [ h# 0001200A , h# 00000000 , ]
: dorp align create [ h# 0001200D , h# 00000000 , ]
: dorst align create [ h# 00012010 , ]
: stak align create [ d# 40 rez ] { br }

: r@ ( a-n ) ?adj aa@ [ dor@ d# 1 + ] ! dor@ [ d# 2 ] fet [ d# 1 ]
 exch @18 ;
: r! ( na ) ?adj aa! [ dor! d# 1 + ] ! [ dor! d# 2 + ] ! dor! [ d# 3 ]
 ok [ d# 1 ] exch ;
: call ( a ) [ h# 00010000 ] +
: rins ( w ) ?adj ains [ dori d# 1 + ] ! dori [ d# 2 ] ok [ d# 1 ]
 exch ;
: lit' ( n ) ?adj apsh [ dorp d# 1 + ] ! dorp [ d# 2 ] ok [ d# 1 ]
 exch ;
: aupd astk
: @stk @18 ( s ) [ stak d# 1 + ] ! @18 ( t ) [ stak ] ! [ stak d# 2
 + ] d# 8 for @18 over ! [ d# 1 ] + next drop ;
: upd ?adj aupd dorst [ d# 1 ] stat [ d# 10 ] exch @stk ;
: lit lit' upd ;
: boot ( a n nd ) nn-n swap push 2* d# 32768 + block over + swap begin
 over @ [ h# 00015555 ] or over r! [ d# 1 ] + [ d# 1 ] u+ next drop
 drop ; }block

( 00220C00 )               D# 131 shadow{ 
 ( these operations work on any target node. ) { br }

: dorx ( port templates for remote target. ) { br }

: r@ r! rins lit call ( are the specific names for the primitives using
 appropriate sequences for adjacent or remote target nodes. ) { br }

: boot ( loads code into current remote node from binary image for
 node ) [ nd ] ( from addr ) [ a ] ( in both image and ram for ) [ n ]
 ( words. ) }block

( 00221000 )               D# 132 code{ 
 ( - remote instructions )
: compile recompile ; { -cr } : canon [ d# 138 ] ;
: focus paths targets @ + dup @ swap d# -1 + @ wall port call ;
: virgin paths targets @ + @ avail call ; { br }

: rop ( n ) [ h# 0000000A ] or [ d# 13 ] for 2* next ( ;s ) [ h# 00001555 ]
 + rins upd ;
: @b [ h# 0000000A ] rop ; { -cr } : @a [ h# 0000000B ] rop ; { -cr } 
: @+ [ h# 00000009 ] rop ;
: !b [ h# 0000000E ] rop ; { -cr } : !a [ h# 0000000F ] rop ; { -cr } 
: !+ [ h# 0000000D ] rop ;
: r+* [ h# 00000010 ] rop ;
: r2* [ h# 00000011 ] rop ; { -cr } : r2/ [ h# 00000012 ] rop ;
: r- [ h# 00000013 ] rop ; { -cr } : r+ [ h# 00000014 ] rop ;
: rand [ h# 00000015 ] rop ; { -cr } : ror [ h# 00000016 ] rop ;
: rdrop [ h# 00000017 ] rop ; { -cr } : rdup [ h# 00000018 ] rop ;
: rover [ h# 0000001A ] rop ;
: ra! [ h# 0000001F ] rop ; { -cr } : ra@ [ h# 0000001B ] rop ;
: rb! [ h# 0000001E ] rop ; { br }

: up h# 00000145 ; { -cr } : data h# 00000141 ; { -cr } : down h# 00000115
 ;
: left h# 00000175 ; { -cr } : ldata h# 00000171 ; { -cr } : right
 h# 000001D5 ;
: io h# 0000015D ; }block

( 00221400 )               D# 133 shadow{ 
 ( single instruction words that may be executed by the target. these
 must end with return for s40 restriction compliance. ) { br }

 ( the following won't work on s40 due to bug 1. )
: r@p+ [ h# 0000000C ] rop ;
: psh ( n ) r@p+ ( value ) rins ; }block

( 00221800 )               D# 134 code{ 
 UNKNOWN ( indicator panel ) [ d# 135 load ] ( node stack / upd ) { .s
 br }

 UNKNOWN ( path, via, hops, tgt - green selected ) { .pth br }

 UNKNOWN ( mem dump / ?ram or ?rom ) { .ram }
 }block

( 00221C00 )               D# 135 shadow{ 
 ( code for panel )
: panel [ d# 134 ] list ;
: .s blu silver cr cr [ stak d# 6 + ] d# 4 for dup @ d# 5 h.n space
 [ d# 1 ] + next [ d# -5 ] + cr d# 6 for dup @ d# 5 h.n space [ d# -1 ]
 + next drop ;
: ?color ( nn-nn ) over over or drop if silver ; then green ;
: .pth blu [ act ] @ cr d# 3 for cr i [ d# -1 ] + path [ act ] @ ?color
 . paths dup [ d# 1 ] + @ . targets @ dup . + @ . next path ; { br }

: /ram align create [ d# 64 a-b rez ]
: rsp ( n dup ) d# 1 and drop if sp/2 then ;
: .ram blu silver cr [ /ram ] d# 64 for i [ d# 7 ] and ?zero drop if
 cr space then i rsp dup @ d# 5 h.n i d# 1 and drop if space then [
 d# 1 ] + next drop ; }block

( 00222000 )               D# 136 code{ 
 ( - tester )
: ent d# 0 ;
: n6tst d# 0 d# 64 d# 6 boot ent call d# 0 r@ dup d# 123 + dup d# 0
 r! d# 0 r@ or if abort then drop d# 0 r! ( upd ) ;
: rot ( n-n ) [ h# 0003FFFF ] and 2* [ h# 00040000 ] /mod + ;
: sto ( n ) dup [ d# 63 ] for rot dup i r! -next drop { cr }
 [ d# 63 ] for rot i r@ over over or { indent }
      drop if i abort then drop -next drop ;
: pat ( n ) [ d# 18 ] for dup sto rot next drop ;
: ramtst d# 0 sto h# 0003FFFF sto d# 1 pat h# 0003FFFE pat ;
: one ( n ) [ d# 2 ] swap hook pause ( n6tst ) ramtst ;
: ?ok ( n-t ) [ 2pa @ nn-n ] or ;
: all ( n ) nn-n [ d# 1 ] + for i [ d# -1 ] + ?ok drop if i [ d# -1 ]
 + n-nn one then next ;
: !dac ( n i ) d# 2 swap hook h# 00000155 or io r! ;
: !dacs ( n ) dup d# 709 !dac dup d# 713 !dac dup d# 717 !dac dup d# 617
 !dac d# 117 !dac ;
: nn ( n-n ) d# -1 + dup !dacs ;
: ms d# 100000 * for next ;
: watch begin upd pause d# 1000 ms key? end ;
: ?ram d# 0 { -cr } : suck ( a ) ra@ [ /ram ] d# 64 for over r@ over
 ! [ d# 1 ] + [ d# 1 ] u+ next drop drop ra! ;
: ?rom [ h# 00000080 ] suck ; }block

( 00222400 )               D# 137 shadow{ 
 ( this test routine tester loads and runs the code compiled for node
 6 on all other nodes except the root, stopping if a node crashes or,
 possibly, other failure criteria are met ) { br }

: one ( runs the test routine from node 6 compilation, entry point )
 ent ( , on node ) [ n ] ( . aborts if we cannot write and read back
 memory. ) [ select desired path at start. ]
: all ( tries the test starting with node n and going down to node
 zero, skipping node 19. ) { br }

: watch ( displays live stack from current node. this and other interactive
 functions can be enabled in a running program by placing a definition
 like this in outer loop... )
: poll @b h# 00000200 and if up b! @b push ;' h# 0000015D b! then drop
 ; { br }

: !dac ( sets given output value in node i )
: !dacs ( sets given value in all dacs. ) }block

( 00222800 )               D# 138 code{ 
 ( - canonical words )
: -canon remember
: @ ( a-n ) r@ ;
: ! ( na ) r! ; ( call lit upd rins boot !b already ok )
: +* r+* ;
: 2* r2* ;
: 2/ r2/ ;
: - r- ;
: + r+ ;
: and rand ;
: or ror ;
: drop rdrop ;
: dup rdup ;
: over rover ;
: a! ra! ;
: a ra@ ;
: b! rb! ; }block

( 00222C00 )               D# 139 shadow{ 
 ( the final step in loading the ide is to redefine the canonical forth
 words to operate on the target node. this is done as a separate step
 so that you may define any sort of exerciser before losing access
 to host colorforth words. ) }block

( 00223000 )               D# 140 code{ 
 ( - ide ats support )
: zxch ( w n f n ) push push dup { 0000005F } ( + { FFFFFFCF } and )
 [ vport ] @ pop /frame ( vport @ { 0024001F } + !18 dup - { 0000003F }
 and drop if vport @ { 0020001F } + !18 then ) +frame [ wos ] !frame
 pop inser -stream ; { br }

: dox align create ( @p call ) [ h# 000056A9 , ] ( arg ) [ h# 00000000
 , ]
: xchg ( cmd arg - result ) [ dox d# 1 + ] ! [ dox ] ! dox [ h# 00000002 ]
 fet [ d# 1 ] ( exch ) zxch @18 ; { br }

: pfocus paths targets @ + dup @ swap d# -1 + @ wall port dup call
 lit rb! ;
: vtest ( arg.ent-ans ) h# 00005600 or swap xchg ;
: test ( arg-ans ) h# 00000004 vtest ;
: tfocus ( port ) h# 00005636 swap [ h# 00010000 ] + xchg drop ;
: creep h# 0000563A [ d# 67 ] xchg drop ;
: rip h# 00005602 h# 00020000 xchg drop ; { br }

: zfocus ( node ) paths targets @ + @ wall port { cr }
 h# 00010000 or dup dup r! h# 00005636 over r! dup dup r! { cr }
 lit' ra! ; }block

( 00223400 )               D# 141 shadow{ 
 ( this block interchanges ats commands with any node adjacent to the
 ide boot node. ) { br }

: pfocus ( must be used after booting package into an adjacent node
 and before using the following words. focuses that node properly on
 the boot node with both ) p ( and ) b ( - ) [ note! after pfocus regular
 ide functions may not be done against nodes in this path until ] rip
 [ has restored them to ] warm [ state. ] { br }

: tfocus ( performs ats focus function to select port thru which test
 and creep operate. use ide port names. )
: test ( executes test w/ ) [ arg ] ( giving positive ) [ ans. ]
: creep ( creeps into focused node, making it active and changing current
 active to wire. )
: rip ( tears out ats connection to active node returning it and all
 wire nodes to warm states. ) { cr }
: zfocus ( used by hand in ide to effectively tfocus the ide node under
 test on a given tgt node ) [ works whether or not r! preserves a ]
 }block

( 00223800 )               D# 142 code{ 
 ( - all-nodes tester )
: fwall ( -n ) paths targets @ + dup @ swap [ d# -1 ] + @ wall ;
: fport ( -a ) fwall port ;
: fbit ( -n ) fwall align tbl { cr }
 ( r ) [ h# 00008000 , ] ( d ) [ h# 00002000 , ] ( l ) [ h# 00000800
 , ] ( u ) [ h# 00000200 , ]
: nodes ( -n ) d# 0 begin [ d# 1 ] + { cr }
 dup paths + [ d# 1 ] + @ [ d# 0 ] + drop -until paths @ { cr }
 over paths + @ or drop if ; then [ d# -1 ] + ;
: !one ( i ) [ d# 2 ] path d# 2 swap paths + @ hook { cr }
 d# 0 d# 64 [ d# 1604 ] boot fbit d# 2 r! { 000000CF } d# 14 call ;
: !all [ d# 2 ] path nodes { 0000050F } for pause i !one next ;
: ?one ( i-f ) [ d# 2 ] path d# 2 swap paths + @ hook pause { cr }
 h# 0000003E r@ { 003C201F } h# 00008D00 or h# 0000003F r@ { 00002FBF }
 h# 0000430E or +or drop if upd ?ram d# 0 dup or drop ; then d# 1 dup
 and drop ;
: ?all [ d# 2 ] path d# 0 nodes { 0000050F } for d# 1 + pause dup ?one
 while next drop ; then pop drop ;
: zz for i next ;
: z d# 1 ?one upd ; }block

( 00223C00 )               D# 143 shadow{ 
 ( manage running a test in all nodes )
: fwall ( returns rdlu for feeding node )
: fport ( returns port from feeding node. )
: fbit ( returns io mask bit for feed node write. )
: nodes ( returns number of nodes in current path. )
: !one ( programs and starts the node whose index is given in 1..nodes )
: !all ( programs all nodes in the current path. ) }block

( 00224000 )               D# 144 code{ 
 ( arrayforth tm and okad tools and designs ) { cr }
 ( copyright 2009-2012 greenarrays, inc. ) { cr }
 :# cuco 5 :# testb 0 :# dh 0 [ d# 0 dh ! ] { cr }
 :# first -1 [ d# -1 first ! ] :# orgn 0 [ d# 0 orgn ! ]
: compile [ d# 146 ] load ;
: recompile compile [ orgn ] @ load lis ;
: softsim { -cr } : so [ d# 148 ] load ; { br }

: -nat winver drop if ; then exit ;
: tbl ( i-n ) pop 2/ 2/ + @ ;
: xqt ( a ) @ push ; { -cr } : assign ( a ) pop swap ! ;
: ray ( i-a ) pop 2/ 2/ + ;
: aray ( n ) < align > call ray [ d# 4 ] * [ h ] +! ; { br }

 ( ascii file names ) [ d# 74 load ] { cr }
 ( png screen capture ) [ d# 168 load ] { cr }
 ( qx ) [ d# 80 load ]
: -tape [ d# 1 ] d# 1 and ; ( for redacted systems ) { br }

 ( chip design ) [ d# 190 d# 3 loads mark empty ] { cr }
 ( okad tools { 000018CF } load { 0000708F } load ) }block

( 00224400 )               D# 145 shadow{ 
 ( main load block for okad2 applications )
: testb ( nonzero to enable testbeds. )
: dh ( holds drive handle we are responsible for. )
: first ( execution of hardsim or softsim. initializes variables in
 either. )
: recompile ( compiles f18 code then reloads tool that depends on it
 like ide from load block in ) orgn.
: compile ( compiles relevant f18 code. ) { br }

: -nat ( exits a block if running on native system )
: tbl ( self fetching cell array. usage... )
: squared ( i-n ) align tbl [ d# 0 , d# 1 , d# 4 , d# 9 , d# 16 , ]
: xqt ( calls the code whose adr is in the var given. )
: assign ( places addr of following code in the location given and
 exits current definition. ) { br }

: ray ( defines i-a array usage ) align ray
: aray ( use after red to make ray of n cells ) }block

( 00224800 )               D# 146 code{ 
 ( f18 compiler ) [ empty c ] { cr }
 [ d# 0 d# 0 laid nns fill d# 0 d# 0 kinds nns fill ] { br }

 [ d# 1400 load ] { br }

: reset ( a ) ?rst [ com ] @ resets ! ;
: kind ( n ) [ com ] @ kinds ! ;
: node ( nn ) nn-n nns mod dup [ com ] ! { cr }
 node's d# 64 eras n-nn @rom load ;
: bin ( nn ) d# 0 memory swap nn-n [ com ] ! d# 0 memory d# 64 move
 ; { br }

: program [ nns d# -1 + ] for i [ com ] ! { cr }
 i idle reset i n-nn @rom load -next { cr }
 ( special rom's ) [ d# 1304 ] load { cr }
 -tape drop if [ d# 150 ] load then ; { br }

 [ d# 1402 d# 6 loads target d# 1380 load host ]
: h' ' ; { -cr } : ' h' d# 6 + 4@ ;
: reclaim remember [ target program empty ] }block

( 00224C00 )               D# 147 shadow{ 
 ( compiles all relevant f18 code. ) { br }

: laid ( is cleared for setting as nodes laid out )
: resets ( is set to default multiport executes for all nodes and may
 be overridden in source code using ) reset
: kinds ( is set to default testbed none and may be overridden with )
 kind ( to 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers )
: node ( starts random compilation for node ) [ nn ] ( by compiling
 node ) [ nn's ] ( rom )
: bin ( saves the binary just generated in the bin for node ) [ nn, ]
 ( which must be outside chip { 0000000F } { 0000000F } . )
: program ( compile code for multicomputers. always compiles standard
 rom; if not tapeout, the load block at { 0000A28F } defines test environment
 which may be in rom, ram, or both. )
: reclaim ( remembers and restores dictionary ) }block

( 00225000 )               D# 148 code{ 
 ( f18 software simulator ) { cr }
 [ compile ] ( bootstream { 00009B4F } load empty ) { cr }
 ( prelude ) [ d# 1250 load ] ( engine ) [ d# 1252 d# 8 loads ] { cr }
 ( opcodes ) [ d# 1268 d# 4 loads ] { cr }
 ( display ) [ d# 1276 d# 6 loads d# 1248 load d# 1288 d# 2 loads ]
 { cr }
 ( preserve variables ) :# nmem 0 :# n2mem 0
: nm2m [ nod ] @ !node [ nmem ] @ mem ! { indent }
      [ nod2 ] @ !node [ n2mem ] @ mem ! ; :# big 100
: puka ( nn-a ) nn-n 2* h# 00008000 + block ;
: code ( nn nn ) puka push puka pop d# 64 move ; { cr }
 ( keyboard ) [ d# 1292 d# 2 loads ] { cr }
 ( ports and pins ) [ d# 1296 d# 2 loads ] { cr }
 ( spi flash testbed { 00009B8F } { 0000004F } loads spi ) { cr }
 ( interactive ) [ d# 1238 d# 2 loads ] { cr }
 ( smtm ) [ d# 0 d# 0 enter ] { br }

: /softsim power [ first ] @ d# 1 + if { cr }
 drop nm2m ; then { 0000000F } [ first ] ! d# 100 [ big ] ! { cr }
 d# 0 [ time ] ! d# 1 [ gap ] ! d# -1 [ wind? ] ! default ; { br }

 ( start ) [ /softsim ok h ] }block

( 00225400 )               D# 149 shadow{ 
 }block

( 00225800 )               D# 150 code{ 
 ( test code for chip ) [ reclaim ] { br }

 ( ide parts ) [ d# 1372 d# 5 loads reclaim ] { cr }
 ( all nodes ) [ d# 1350 load reclaim ] { br }

 ( ats tests ) [ d# 480 load reclaim ] { br }

 ( polyforth ) [ d# 360 load reclaim ] { cr }
 ( eforth ) [ d# 1080 load reclaim ] { br }

 ( applic code ) [ d# 200 load ] { br }

 }block

( 00225C00 )               D# 151 shadow{ 
 ( this block defines what ) compile ( does. ) { cr }
 ( the system code loaded at the start is used by common development
 tools and should generally be left alone. it goes into bins 1600..2317
 as follow ) { br { 0000C80F } }

 UNKNOWN ( ide code code; spi r/w/boot ) { , { 0000D48F } }
 UNKNOWN ( polyforth ) { , { 0000E10F } }
 UNKNOWN ( ---; temp sram for eforth. ) { , { 0000ED8F } }
 UNKNOWN ( ats/ide; --- ) { , { 0000FA0F } }
 UNKNOWN ( creeper modules { 0000002F } full ) { , { 0001068F } }
 UNKNOWN ( creeper modules { 0000004F } full ) { , { 0001130F } }
 UNKNOWN ( creeper modules { 0000006F } half ) { , { 00011F8F } }
 UNKNOWN UNKNOWN ( creeper modules { 0000008F } reserved ) { , , }
 ( note that special rom leaves residue in 008 and 106. ) }block

( 00226000 )               D# 152 code{ 
 ( redact okad disk ) [ audit load ] { br }

 ( to arm this block, make ) { cr }
 ( this word white... ) [ exit ] { br }

 ( okad ) [ d# 196 d# 1244 obliterate ] { br }

 ( type save to commit changes ) }block

( 00226400 )               D# 153 shadow{ 
 ( load this block to redact an okad disk for public release or extensive
 programming. ) { br }

 additional housekeeping... { cr }
 [ d# 144 ] ( comment loading of okad application. ) { cr }
 [ d# 18 ] ( uncomment loading of application tools. ) { cr }
 [ 196ff ] ( merge in released pd software. ) }block

( 00226800 )               D# 154 code{ 
 ( c-a-c - ascii for gds only! ) [ macro ]
: 1@ h# 0000008A 2, ; [ forth ]
: string pop ;
: cf-ii string [ H# 6F747200 , H# 696E6165 , H# 79636D73 , H# 7766676C
 , H# 62707664 , H# 71757868 , ] ( 336a7a6b ) [ H# 33323130 , H# 37363534
 , ] ( 2d313938 - 2d7a3938 ) [ H# 5F7A3938 , ] ( 2f322e30 ) [ H# 2F6A2E6B
 , ] ( 2b213a3b ) [ H# 24213A3B , H# 3F2C2A40 , ]
: ch h# FFFFFFF0 and unpack [ cf-ii ] + 1@ h# 000000FF and ;
: ii-cf string [ h# 00002A00 , ] ( 0 + ) [ h# 0000002B , H# 2B2D0000
 , H# 2725232E , ] ( zjk 1b262224 ) [ H# 1B1A1918 , H# 1F1E1D1C , H# 28292120
 , H# 2F000000 , H# 3A43355C , H# 3D3E3440 , ] ( 02 484a3744 kj ) [
 H# 54523744 , H# 3336393C , H# 38314742 , H# 3F414632 , ] ( 1 493b45
 z ) [ h# 00563B45 , ] ( - ) [ H# 23000000 , H# 0A13052C , H# 0D0E0410
 , ] ( 02 181a0714 kj ) [ H# 24220714 , h# 0306090C , H# 08011712 ,
 H# 0F111602 , ] ( 1 190b15 z ) [ h# 00260B15 , ]
: chc h# FFFFFFE0 + [ ii-cf ] + 1@ h# 000000FF and ; }block

( 00226C00 )               D# 155 shadow{ 
 ( colorforth to/from ascii w/gds specifics ) { br }

: cf-ii ( otr inae ycms wfgl bpvd quxh ) { indent }
      ( 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? ) { indent }
      ( cba@ gfed 02ih onml srqp wvut ) { indent }
      ( 1yx cba@ gfed 02ih onml srqp wvut 1yx )
: notice [ j and z transposed in cf-ii; - converts to underscore, +
 to dollar. ] }block

( 00227000 )               D# 156 code{ 
 ( big letters ) [ macro ]
: *byte h# 0000C80F 2, ; [ forth ]
: clr [ aper d# 2 + ] ; :# sz 14 :# cur 5579776 [ d# 14 sz ! ]
: ptab ( xy ) d# 1024 * + [ aper @ d# 4 / ] + [ cur ] ! ;
: center ( n ) [ sz ] @ d# -24 * d# 768 + 2/ ptab ;
: table d# 12 * [ d# 12 block ] + ;
: 1line ( a ) [ sz ] @ for [ clr ] @ over ! d# 1 + next drop ;
: pix ( a ) [ sz ] @ for dup 1line d# 1024 + next drop ;
: row ( an-an ) d# 16 for dup and -if over pix then [ sz ] @ u+ 2*
 next d# 1024 [ sz ] @ * [ sz ] @ d# -16 * + u+ ;
: !emit table [ cur ] @ d# 12 for over @ *byte row row drop d# 1 u+
 next drop drop [ sz ] @ d# 18 * [ cur ] +! ;
: !digit d# 24 + !emit ;
: 2. ( nn ) /mod !digit !digit ;
: 4. ( n ) d# 100 /mod d# 10 2. d# 10 2. ; }block

( 00227400 )               D# 157 shadow{ 
 }block

( 00227800 )               D# 158 code{ 
 ( big clock ) [ empty d# 40 load d# 156 load ]
: hm sec d# 60 /
: sex ( n ) d# 60 /mod d# 100 mod d# 10 2. d# 10 2. ; :# t0 32458
: ?beep if ; then beep ;
: till [ t0 ] @ sec negate + green -if negate red then ?beep sex ;
: set ( n ) d# 60 * sec + [ t0 ] !
: ok show black screen blue d# 0 center hm ( till ) ;
: run dup pause drop key? run ; [ ok run ] }block

( 00227C00 )               D# 159 shadow{ 
 }block

( 00228000 )               D# 160 code{ 
 ( compare ) [ empty d# 30 load ]
: n18 ( i-a ) [ abuf d# 18 + block ] + ;
: unpk abs [ d# 1 n18 ] ! [ abuf d# 36 + ] block [ cbuf ] block [ d# 1404 ]
 blks move [ cbuf block ] abuf d# 36 + [ d# 3 n18 ] @ [ d# -36 ] +
 range ;
: check [ abuf ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or drop if
 ; then [ d# 1 n18 ] @ dup and -if unpk ; then drop ;
: blink dup [ abuf ] + [ blk ] ! edit ;
: var push push d# 1 + d# 1 u+ pop pop
: *1 or ;
: *2 var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# 0000000F and jump *1 *1 *2 *1 *1 *2 *1 *1 *1
 *1 *1 *1 var *1 *1 *1
: co ( naa-n ) d# 256 for over @ over @ tag drop if drop drop pop drop
 pop drop dup d# 2 u+ ( i ) pop swap blink ; then d# 1 + d# 1 u+ next
 drop drop ;
: com ( n ) dup block over [ abuf ] + block co ;
: q ( nn ) for com d# 2 + next drop ;
: all d# 18 [ d# 1439 d# -18 + 2/ ] q ;
: old [ blk ] @ [ abuf ] mod dup [ abuf ] + [ blk ] ! copy ; }block

( 00228400 )               D# 161 shadow{ 
: check ( reads backup to { 0001770F } and decompresses if appropriate )
: blink ( displays the given block with its other set as the editor's
 'other' block )
: var ( compares a variable name, advancing pointers to skip its value. )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compare compares the two source cells given, returning true
 if they differ. ignores variable differences. )
: ?nul ( ends the loop in co when nuls are found in both blocks. )
: co ( given the addresses of the two blocks does the work of com. )
: com ( invokes editor to blink the given block if it differs from
 the other, leaving stack set to continue the scan by typing q. otherwise
 returns. )
: all ( scans the whole usable area of the disk. )
: q ( scans for differences given starting block and number of source
 blocks skipping shadows. )
: note! ( return stk probably grows! ) }block

( 00228800 )               D# 162 code{ 
 }block

( 00228C00 )               D# 163 shadow{ 
 }block

( 00229000 )               D# 164 code{ 
 }block

( 00229400 )               D# 165 shadow{ 
 }block

( 00229800 )               D# 166 code{ 
 }block

( 00229C00 )               D# 167 shadow{ 
 }block

( 0022A000 )               D# 168 code{ 
 ( png empty ) [ -nat ] :# w 1024 :# hh 768 :# d 1
: frame { 03A0001F } [ aper @ d# 4 / ] ; [ d# 172 load d# 174 load ]
: -crc ( a ) here over negate + crc .. ;
: here/4 ( -a ) here d# 3 and drop if d# 0 1, here/4 ; then here d# 2
 2/s ;
: bys ( nn-b ) .. here swap , ; { cr }
 ( pallettes ) [ d# 170 load ] { br }

: !png ( awh-an ) [ d ] @ / [ hh ] ! [ d ] @ / [ w ] ! here/4 swap
 H# 474E5089 , H# 0A1A0A0D , ( ihdr ) H# 52444849 d# 13 bys [ w ] @
 .. [ hh ] @ .. h# 00000304 , h# 00000000 1, -crc ( plte ) pallette
 ( idat ) H# 54414449 d# 0 bys swap deflate -crc ( iend ) H# 444E4549
 d# 0 bys -crc here/4 over negate + ; { br }

: 'at ( xy-a ) d# 1024 * + [ frame ] + ;
: full d# 1 [ d ] ! d# 0 dup 'at d# 1024 d# 768 !png ;
: png full wgds ; }block

( 0022A400 )               D# 169 shadow{ 
: d ( is reduction factor ) }block

( 0022A800 )               D# 170 code{ 
 ( - pallettes )
: paper H# 45544C50 d# 48 bys { cr }
 h# 00FFFFFF 3, h# 00C00000 3, h# 0000C000 3, h# 00C0C000 3, { cr }
 h# 000000C0 3, h# 00C000C0 3, h# 0000C0C0 3, h# 00404040 3, { cr }
 h# 00C0C0C0 3, h# 00FF0000 3, h# 0000FF00 3, h# 00FFFF00 3, { cr }
 h# 000000FF 3, h# 00FF00FF 3, h# 0000FFFF 3, h# 00000000 3, -crc ;
 { br }

: crt H# 45544C50 d# 48 bys { cr }
 h# 00000000 3, h# 00C00000 3, h# 0000C000 3, h# 00C0C000 3, { cr }
 h# 000000C0 3, h# 00C000C0 3, h# 0000C0C0 3, h# 00404040 3, { cr }
 h# 00C0C0C0 3, h# 00FF0000 3, h# 0000FF00 3, h# 00FFFF00 3, { cr }
 h# 000000FF 3, h# 00FF00FF 3, h# 0000FFFF 3, h# 00FFFFFF 3, -crc ;
 { br }

: pallette ( paper ) crt ; }block

( 0022AC00 )               D# 171 shadow{ 
 }block

( 0022B000 )               D# 172 code{ 
 ( - crc ) :# ad1 27816 :# ad2 21146 [ macro ] { br }

: 2/s ?lit h# 0000E8C1 2, 1, ; { -cr } : 1@ h# 0000008A 2, ; [ forth ]
: bit ( n-n ) d# 1 ? if d# 1 2/s H# EDB88320 or ; { indent }
      then d# 1 2/s ;
: ,crc ( nn ) for dup d# 8 for bit next , { indent }
      d# 1 + next drop ;
: table ( -a ) align array [ d# 0 d# 256 ,crc ]
: crc ( bn-n ) d# -1 swap for over 1@ over or h# 000000FF and table
 swap d# 8 2/s or d# 1 u+ next - nip ; { br }

: +adl ( n ) h# 000000FF and [ ad1 ] @ + dup [ ad2 ] @ +
: adl! [ ad2 ] ! [ ad1 ] ! ;
: +mod [ ad1 ] @ d# 65521 mod [ ad2 ] @ d# 65521 mod adl! ; }block

( 0022B400 )               D# 173 shadow{ 
: 2/s ( shift right by literal )
: 1@ ( fetch byte, address in eax )
: array ( return word address in dictionary )
: bit ( process 1 bit with standard 32-bit crc )
: fill ( construct crc table for bytes )
: table ( said table )
: crc ( compute crc for a byte string )
: ad1/ad2 ( adler checksums )
: +adl ( add a byte to both checksums )
: adl! ( store checksums )
: +mod ( truncate checksums ) }block

( 0022B800 )               D# 174 code{ 
 ( - lz77 ) [ macro ] { -cr } : *byte h# 0000C486 2, ;
: !bx < a! > h# 00000289 2, < drop > ; [ forth ] { br }

: *bys dup d# 16 2/s *byte swap h# 0000FFFF and *byte h# 00010000 *
 + ; { -cr } : .. *bys , ;
: 0/1 h# 00000080 ? if h# 0000007E and h# 0000007E or drop if d# 7
 ; then h# 0000000F ; then d# 0 and ;
: 4b dup 0/1 h# 00000009 and over d# 8 2/s 0/1 h# 0000000A and +or
 swap d# 16 2/s 0/1 h# 0000000C and +or ;
: pix dup @ [ d ] @ u+ 4b ;
: row 1, dup [ w ] @ 2/ dup d# 1 + dup 2, - 2, d# 0 dup 1, +adl for
 pix d# 16 * push pix pop or dup 1, +adl next drop +mod [ d ] @ d# 1024
 * + ; { br }

: deflate h# 00000178 2, d# 1 d# 0 adl! [ hh ] @ d# -1 + for d# 0 row
 next d# 1 row drop [ ad2 ] @ *byte 2, [ ad1 ] @ *byte 2, here over
 d# 4 + negate + *bys over d# -4 + !bx ; }block

( 0022BC00 )               D# 175 shadow{ 
: 0/1 ( 0, f or 7 for dark, bright or dim ) }block

( 0022C000 )               D# 176 code{ 
 ( cf-html ) [ empty -nat d# 74 load ] { cr }
 :# pad 278806528 [ abuf block d# 4 * pad ! ] { cr }
 :# hld 280317057 [ pad @ hld ! d# 178 d# 6 loads ]
: estyle ,link ,t1cr ( cfhtml.css '? ) ;
: .hdr [ pad ] @ [ hld ] ! ,t1cr ( @html? @head? ) istyle { cr }
 ( estyle ) ,t1cr ( @/head? @body? @table? ) ;
: .blk ( n ) d# 0 [ pos ] ! crlf ,t1 ( @td*class+cf? ) { cr }
 dup even? if dup .dec ,t1cr ( *list ) then { cr }
 .cr block ,t1 ( @code ) d# 0 [ class ] ! d# 0 [ --cr ] ! { cr }
 begin @+ dup and while .token end then { cr }
 [ class ] @ eq? if ,t1 ( ? ) then drop drop { cr }
 begin -eol? while .nb end then .cr { cr }
 ,t1 ( @/code? ) .cr ,t1cr ( @/td? ) ;
: .sep ,t1 ( @td? ) .nb .nb ,t1 ( @/td? ) ;
: .blks ( first last+2 ) over negate + 2/ for { cr }
 ,t1 ( @tr? ) dup d# 1 or .blk .sep dup .blk { cr }
 ,t1cr ( @/tr? ) [ d# 2 ] + next drop ;
: .tlr ,t1cr ( @/table? @/body? @/html? ) sav ;
: run ( first last+2 ) .hdr .blks .tlr ; { br }

 [ named ] ( cf.html ) [ exit d# 18 d# 1440 run ] }block

( 0022C400 )               D# 177 shadow{ 
 ( colorforth to html utility ) { br }

 ( the html is created between ) [ pad ] ( and ) [ hld ] { cr }
 ( by ) .html ( and its factors ) .hdr .blks ( and ) .tlr ( , then
 written to the file last ) [ named ] ( . ) { br }

 ( uncomment ) estyle ( in ) .hdr ( to use an external ) { cr }
 ( stylesheet, maybe for printing. ) { br }

 ( pairs of blocks are formatted 2-up using html tables, with the odd/even
 blocks used to invoke ) [ .html ] ( or ) [ .blks ] ( displayed on
 the right. 'n list' is shown above the even block. ) { br }

 [ d# 176 d# 188 .html ] ( puts shadows on left, while ) { cr }
 [ d# 177 d# 189 .html ] ( puts them on the right. ) { br }

 [ seeb ] ( toggles blue-word visibility. ) { br }

 ( the last line of each block is filled ) { cr }
 ( with ) nbsp ( for column alignment. the ) [ class ] @ { cr }
 ( line closes the ) < code > ( tag of an empty block. ) }block

( 0022C800 )               D# 178 code{ 
 ( - generate html details ) { cr }
: eq? ( nn-n ) over or if drop d# -1 then - ( nz? ; )
: nz? ( n ) dup and drop ;
: even? ( n ) h# 00000001 or h# 00000001 and drop ; { br }

: @+ ( a-an ) dup d# 1 + swap @ ;
: @tag ( a-at ) dup @ h# 0000000F and ; { br }

: sc h# 0000003B ( semicolon )
: ch, ( c ) [ hld ] @ 1! d# 1 [ hld ] +! ;
: lb h# 0000007B ( left-brace ) ch, ;
: rb sc h# 0000007D ( right-brace ) ch,
: crlf d# 13 ch, d# 10 ch, ; { br }

: ,token ( n ) ch if ch, ,token ; then drop drop ;
: ,word ( a-a ) begin @+ ,token @tag drop until ; { cr }
 ( loop ) begin ,word
: ,comments ( a ) @tag d# 9 or drop until drop ; [ macro ] { cr }
: ,t ( words ) 7push pop < ,lit > call ,comments nop ;
: ,trb ( words ) < ,t > call rb nop ;
: ,t1 ( words ) call set1 < ,t > call set0 nop ;
: ,t1cr ( words ) < ,t1 > call crlf nop [ forth ] }block

( 0022CC00 )               D# 179 shadow{ 
: eq? { -cr } : nz? { -cr } : diff? { -cr } : even? ( leave only flags )
 { cr }
: @+ { -cr } : @tag ( are common factors ) { br }

 ( the following words generate ascii text only for html tags and source
 formatting; it will not be visible in the html display. ) { br }

: sc { -cr } : ch, { -cr } : lb { -cr } : rb { -cr } : crlf ( punctuation
 output ) { br }

 ( the macros enable in-line output from the ) { cr }
 ( standard cf-ascii table using ) [ set0 ] ( default or the extended
 table using ) [ set1 ] { br }

: ,token ( output ascii characters for one token )
: ,word ( output a token and any extension tokens )
: ,comments ( output contiguous comment words ) { br }

: ,t ( output from current set, don't change set. )
: ,trb ,t ( output followed by ) rb
: ,t1 ( output from ) set1 ( , return to ) set0 ( at end )
: ,t1cr ,t1 ( output followed by ) crlf }block

( 0022D000 )               D# 180 code{ 
 ( - translate text and numbers ) :# pos 0 :# --bs 1
: -bol? [ pos ] @ nz? ;
: -eol? [ pos ] @ d# 46 or drop ;
: .cr ,t1 ( @br? ) d# 0 [ pos ] ! ; { cr }
 ( loop ) begin .cr { -cr } : emit ( c ) ch, d# 1 [ pos ] +! ;
: .ch ( c ) -eol? until emit ;
: .sp -eol? if -bol? if h# 00000020 emit ; then then ;
: .2sp .sp ( .nb ; )
: .nb h# 00000026 ( ampersand ) .ch ,t ( nbsp ) sc ;
: ?sp [ --bs ] @ nz? if .sp then d# 1 [ --bs ] ! ;
: -sp d# 0 [ --bs ] ! ;
: .sp.tn ( n ) ?sp ( .tn ; )
: .tn ( n ) ch if .ch .tn ; then drop drop ;
: ?ch ( n ) ?seeb if .ch ; then drop .nb ;
: ?sp.tn ( n ) ?sp ( ?tn ; )
: ?tn ( n ) ch if ?ch ?tn ; then drop drop ;
: .hd ( n ) [ d# -10 ] + -if [ h# 0000003A ] + .ch ; then [ h# 00000041 ]
 + .ch ;
: .dec ( n .sp ) ?sp [ d# 0 ] + -if h# 0000002D .ch negate then [ d# -1 ]
 swap begin [ d# 10 ] /mod dup and while end then drop
: spit ( -1 ... ) begin .hd [ d# 0 ] + -until drop ;
: hd ( n-nn ) dup [ h# 0000000F ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n .sp ) ?sp [ d# -1 ] swap begin hd H# 0FFFFFFF and while
 end then drop spit ;
: .3hex ( n ) hd hd hd drop ( .sp ) ?sp .hd .hd .hd ; }block

( 0022D400 )               D# 181 shadow{ 
 :# pos 0 ( character display ) [ pos ] ( ition in line )
: -bol? { -cr } : -eol? ( test position )
: .cr ( visible crlf )
: emit ( visible character )
: .ch { -cr } : .sp { -cr } : .2sp { -cr } : .nb ( quirky characteristics )
 { cr }
 < note > [ .sp ] ( does nothing at left margin ) { cr }
 < note > [ .ch ] ( does ) [ .cr ] ( after 46th character ) { cr }
 < note > [ .2sp ] ( takes only one space at left margin ) { cr }
 < note > [ .nb ] ( takes only one character position. ) { br }

: .tn { -cr } : .sp.tn ( display a token. ) { br }

: .hd { -cr } : hd { -cr } : spit ( are number-output factors )
: .dec { -cr } : .hex { -cr } : .3hex ( display numbers ) }block

( 0022D800 )               D# 182 code{ 
 ( - translate cf token details ) { cr }
 :# class 757071881 :# --cr 0
: ,class ( a ) @ [ class ] @ over or drop ( diff? ) if { cr }
 [ class ] @ nz? if ,t1 ( @/code? @code ) then { cr }
 ,t1 ( *class+ ) dup [ class ] ! ,token ,t1 ( ? ) ; { cr }
 then drop ; [ macro ]
: ,c 7push pop < ,lit > call ,class nop ; [ forth ]
 UNKNOWN: .quirks ( n ) [ --bs ] @ d# -1 + nz? if d# 1 [ --bs ] ! drop ; { ,
 UNKNOWN ... }
 UNKNOWN UNKNOWN then [ --cr ] @ nz? if .2sp drop d# 0 [ --cr ] ! ; { , ... }
 then ( class ) nz? if -bol? if .cr then then ;
: .space -eol? if .nb then ;
: .indent .cr { 0000008F } d# 2 for .nb next ;
 UNKNOWN: .blue ( n ) ?seeb if dup .sp.tn then { , }
 UNKNOWN H# 9080000E ( cr ) eq? if .cr drop ; { , }
 UNKNOWN then H# E721000E ( -cr ) eq? if d# 1 [ --cr ] ! drop ; { , }
 UNKNOWN then H# 8625920E ( space ) eq? if .space drop ; { , }
 UNKNOWN then H# 76C08C4E ( indent ) eq? if .indent drop ; { , }
 then H# C620000E ( br ) eq? if .cr .cr then drop ;
 UNKNOWN UNKNOWN: ?simple ( n-n ) { , ... }
 UNKNOWN UNKNOWN h# FC00000E eq? if ?tn .cr pop drop ; then { , ... }
 UNKNOWN UNKNOWN H# FA00000E eq? if ?tn -sp pop drop ; then { , ... }
 UNKNOWN H# EA00000E eq? if ?sp.tn -sp pop drop ; then { ... }
 UNKNOWN H# EBD4000E eq? if ?sp.tn -sp pop drop ; then { ... }
 H# EBD7A80E eq? if ?sp.tn -sp pop drop ; then ; }block

( 0022DC00 )               D# 183 shadow{ 
 :# class 0 ( current class ) { cr }
 :# --cr 0 ( true suppresses ) [ cr ] ( before next red word ) { cr }
: ,class { -cr } : ,c ( class defining words, cf style ) { br }

: .quirks ( handle the spacing before red words ) { br }

: .space ( blue spaces are ignored at eol! )
: .indent { 0000008F } ( + html leading space ) { br }

: .blue ( generate most of the blue-word effects ) }block

( 0022E000 )               D# 184 code{ 
 ( - translate cf tokens )
: sh? ( n-n ) 2/ 2/ 2/ 2/ dup 2/ swap d# 1 and drop ;
: lh? ( an-an ) push @+ pop h# 00000010 and drop ; { br }

: .t1 ( n ) ,c ( t1 ) .sp.tn ;
: .t2 ( an-a ) lh? if ,c ( h2 ) .hex ; then ,c ( d2 ) .dec ;
: .t3 ( n ) [ class ] @ ,c ( t3 ) .quirks ( .sp.tn ) .tn ;
: .t4 ( n ) ,c ( t4 ) .sp.tn ;
: .t5 ( an-a ) lh? if ,c ( h5 ) .hex ; then ,c ( d5 ) .dec ;
: .t6 ( n ) sh? if ,c ( h6 ) .hex ; then ,c ( d6 ) .dec ;
: .t7 ( n ) ,c ( t7 ) .sp.tn ;
: .t8 ( n ) sh? if ,c ( h8 ) .hex ; then ,c ( d8 ) .dec ;
: .t9 ( n ) ,c ( t9 ) .sp.tn ;
: .ta ( n ) ,c ( ta ) .sp.tn ;
: .tb ( n ) ,c ( tb ) .sp.tn ;
: .tc ( an-a ) ,c ( tc ) .sp.tn ,c ( dc ) @+ .dec ;
: .td ( n ) sh? ,c ( hd ) .3hex ;
: .te ( n ) ,c ( te ) ?simple .blue ;
: .tf ( n ) sh? if ,c ( hf ) .hex ; then ,c ( df ) .dec ; { br }

: .token ( an-a ) dup h# 0000000F and jump { cr }
 .tn .t1 .t2 .t3 .t4 .t5 .t6 .t7 { cr }
 .t8 .t9 .ta .tb .tc .td .te .tf }block

( 0022E400 )               D# 185 shadow{ 
: sh? ( extract short number, true flag if hex )
: lh? ( extract long number, true flag if hex ) { br }

 ( tag ------- cf class ------- html class ) { cr }
 < .t0 > ( extension token ........ ) < same as last >
: .t1 ( execute word ........... ) [ t1 ]
: .t2 ( execute long number .... ) [ h2, d2 ]
: .t3 ( define word ........... ) { -cr } : t3
: .t4 ( compile word ........... ) t4
: .t5 ( compile long number .... ) h5, d5
: .t6 ( compile short number ... ) h6, d6
: .t7 ( compile macro .......... ) < t7 >
: .t8 ( execute short number ... ) [ h8, d8 ]
: .t9 ( lowercase text comment . t9 )
: .ta ( capitalized text comment ta ) < deprecated >
: .tb ( uppercase text comment . tb ) < deprecated >
: .tc ( variable ............... ) :# tc 0 dc
: .td ( target address ......... hd )
: .te ( editor command ......... ) < te >
: .tf ( short number comment ... hf, df ) { br }

: .token ( translate tag-by-tag ) { indent }
      < note > ( address may be incremented ) }block

( 0022E800 )               D# 186 code{ 
 ( - stylesheet details and file output )
: vat ,t ( *vertical-align; top ) sc ;
: bcw crlf ,t ( *background-color; white ) sc ;
: wsn crlf ,t ( *white-space; nowrap ) sc ;
: fo ,t ( *font- ) ;
: ffm crlf fo { indent }
      ,t ( family; lucida*console,monospace ) sc ;
: fwb crlf fo ,t ( weight; bold ) sc ;
: fz fo ,t ( size; ) ;
: fc lb ,t ( *color; ) h# 00000023 ( sharp ) ch, ;
: fsi sc fo ,t ( style; italic ) rb ;
: tt sc ,t ( *text-transform; ) ; { br }

: ,link ,t1 ( @link *rel+stylesheet ) { indent }
      ,t1 ( *type+'text/css' *href+' ) ; { br }

: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 2 d# 0 d# 0 { indent }
      pop pop swap fcreate ;
: sav [ d# 0 fnam ] w/o fopen dup push { indent }
      [ pad ] @ dup negate [ hld ] @ + pop { indent }
      fwr drop fclose ; }block

( 0022EC00 )               D# 187 shadow{ 
: vat { -cr } : bcw { -cr } : wsn { -cr } : fo { -cr } : ffm { -cr } 
: fwb { -cr } : fz { -cr } : fc { -cr } : fsi { -cr } : tt { cr }
 ( space-saving factors of internal stylesheet ) { br }

: ,link ( most of the external stylesheet link ) { br }

: fopen { -cr } : sav ( open, write, close html file ) { cr }
 < note > ( byte addresses throughout ) }block

( 0022F000 )               D# 188 code{ 
 ( - internal stylesheet )
: istyle ,t1cr ( @style*type+'text/css'? ) set1 { cr }
 ,t ( td ) lb vat bcw wsn ffm fwb fz ,trb ( x-large ) ,t ( code ) lb
 fz ,t ( large ) tt ,trb ( lowercase ) { cr }
 ,t ( .t1 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .h2 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d2 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t3 ) fc ,trb ( ff0000 ) { cr }
 ,t ( .t4 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h5 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d5 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h6 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d6 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .t7 ) fc ,trb ( 00cccc ) { cr }
 ,t ( .h8 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d8 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t9 ) fc ,trb ( 444444 ) { cr }
 ,t ( .ta ) fc ,t ( 000000 ) tt ,trb ( capitalize ) { cr }
 ,t ( .tb ) fc ,t ( 000000 ) tt ,trb ( uppercase ) { cr }
 ,t ( .tc ) fc ,trb ( ff00ff ) { cr }
 ,t ( .dc ) fc ,trb ( 00ff00 ) { cr }
 ,t ( .hd ) fc ,t ( bbbbbb ) fsi { cr }
 ,t ( .te ) fc ,trb ( 0000ff ) { cr }
 ,t ( .hf ) fc ,t ( 777777 ) fsi { cr }
 ,t ( .df ) fc ,trb ( 444444 ) ,t1cr ( @/style? ) ; }block

( 0022F400 )               D# 189 shadow{ 
: istyle ( internal styles are aimed toward ) { cr }
 ( providing code examples for stand-alone use in other documents.
 although it's black-on-white, it faithfully displays the colorforth
 screen. ) { br }

 ( some cf-html rendering tests ) { br }

 [ load D# 2147483647 H# 80000000 ]
: t1 ; D# 2147483646 H# 80000001 d# 87 h# 00000057 < ?lit > [ d# 87
 h# 00000057 ] ( rtoeani rtos ascii ) :# var 123 { cr -cr } : quirky
 { 000000BD } { indent { 00000AEF } { 00000AFF } }
      [ d# -87 ] ( end ) [ h# 00000000 ] h# 00000000 { 0000001F } }block

( 0022F800 )               D# 190 code{ 
 ( ga144 chrt .18 design specific )
: gdsnos [ d# 440 ] ;
: nnx { 0000010F } [ d# 18 ] ; { -cr } : nny { 0000008F } [ d# 8 ]
 ; { -cr } : nns [ nnx nny * ] ;
: nnc ( nns ) [ nns d# 2 * d# 144 + ] ;
: nn-n ( n-n { 0000014F } ) [ d# 100 ] /mod [ nnx ] * + ;
: n-nn ( n-n ) [ nnx ] /mod { 0000014F } [ d# 100 ] * + ; { br }

: gapl [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 20 d# 2 * + ] ;
: gapr [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 24 d# 2 * + ] ;
: gapb [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 28 d# 2 * + ] ;
: gapt [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 18 d# 2 * + ] ;
: ray0 ( -xy ) gapl [ d# 199 ] + gapb [ d# 199 ] + ;
: rayn ( -xy ) nnx [ d# 350 ] * nny [ d# 759 ] * d# -1 + ray0 v+ ;
 { br }

: gx [ rayn drop gapr + d# 199 + ] ;
: gy [ rayn nip gapt + d# 199 + ] ; { br }

: origin { 0000148F } { 00000B2F } d# 26 d# 26 ;
: cx [ origin drop d# 2 * gx + d# 2 + ] ;
: cy [ origin nip d# 2 * gy + d# 2 + ] ;
: -cx [ cx negate ] ; { -cr } : cx*y [ cx cy * ] ; { br }

: gfx [ d# 8 ] ; { -cr } : gfy [ d# 16 ] ; }block

( 0022FC00 )               D# 191 shadow{ 
: gdsnos ( block for gds layer numbers )
: nnx ( and nny number of nodes/row and /column )
: nnc ( number of nodes compiled )
: nn-n ( and ) n-nn ( convert yx notation to and from linear node numbers )
: gapl, r, b, t ( distance in tiles between inner edge of padring bus
 and outer edge of core pwr )
: ray0 ( and ) rayn ( are gxy relative phys origin and upper right
 corner of node array. source of constants is ) [ xtab ] ( and ) [ ytab. ]
: gx ( and ) gy ( bounds of pad ring. ) [ always remember to check ]
 global [ reset wiring when size or placement of node array or pad
 ring are changed! ]
: cx ( and ) cy ( bounds of seal ring. )
: -cx ( negative tiles/row )
: origin ( origin of 'die' i.e. pad ring within seal ring. c coords
 rel to seal; g rel to 'die' )
: gfx ( and ) gfy ( fill cell grid ) }block

( 00230000 )               D# 192 code{ 
 ( ga144 pads, ports and resets ) { br }

: port ( i-pa ) align tbl [ h# 000001D5 , h# 00000115 , h# 00000175
 , h# 00000145 , h# 00000195 , h# 00000185 , h# 000001B5 , h# 000001A5
 , ]
: idle ( n-p ) [ nnx ] /mod [ nny d# -1 + ] mod [ d# 1 ] min [ d# 4 ]
 + swap [ nnx d# -1 + ] mod [ d# 1 ] min 2* + port ;
: rstadr align tbl [ h# 000000AA , h# 00000195 , h# 00000185 , h# 000001B5
 , h# 000001A5 , ]
: rstdef strings ( p0aa p13f p12f p11f p10f )
: ?rst ( pa-i ) [ d# 4 ] for dup i rstadr or while drop -next abort
 then drop drop pop ; }block

( 00230400 )               D# 193 shadow{ 
: port ( returns port for 0-3 rdlu then edges )
: idle ( is idle p value for given node. )
: rstadr ( and ) rstdef ( number values and white names of p straps
 rom, corn, side, top/bot, mid. )
: ?rst ( returns index of valid reset or aborts. ) }block

( 00230800 )               D# 194 code{ 
 ( ga144 node types ) { br }

: laid [ nns aray ] { -cr } : resets [ nns aray ]
: kinds [ nns aray ] { br }

: 0's ( n ) for d# 0 , next ;
: +roms ( -ia ) align ray [ nns 0's ]
: iz ( nn i ) swap nn-n +roms ! ; { cr }
 [ d# 701 d# 2 iz d# 705 d# 10 iz d# 708 d# 6 iz ] { indent }
      [ d# 709 d# 14 iz d# 713 d# 14 iz d# 717 d# 14 iz ] { cr }
 [ d# 117 d# 14 iz d# 617 d# 14 iz ] { cr }
 [ d# 1 d# 2 iz d# 200 d# 18 iz d# 300 d# 4 iz ] { cr }
 ( eforth ) [ d# 105 d# 20 iz d# 106 d# 20 iz ] ( sdram... ) { cr }
 [ d# 7 d# 20 iz d# 8 d# 20 iz d# 9 d# 20 iz d# 107 d# 20 iz d# 108
 d# 20 iz ]
: @rom ( nn-n ) nn-n +roms @ [ d# 22 ] less if drop [ d# 1418 ] + ;
 then drop [ d# 100 ] mod [ d# 1301 ] + ; { br }

: bedtab ( -serbed ) [ cuco ] @ nn-n kinds @ ;
: ?serbed [ testb ] @ d# 0 or drop if bedtab ; then d# 0 ; }block

( 00230C00 )               D# 195 shadow{ 
: laid ( nz if node laid out )
: resets ( index of reset address )
: kinds ( kind for testbeds )
: +roms ( and ) @rom ( are here only as temporary kludges. we will
 eventually load a table from the node defns for default kind and prom
 source. )
: +roms ( array indexed by linear node number returning code number
 for rom load block. )
: iz ( sets node ) [ nn ] ( to use rom load block ) [ n ] ( codes-
 0-arith 2-serdes 4-syncboot 6-async 10-spi 14-analog 18-1wire )
: @rom ( returns block number for production rom code applicable to
 the given node. )
: ?serbed ( 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers
 for ) [ cuco ] ( if ) [ testb ] ( nz. ) }block

( 00231000 )               D# 196 code{ 
 }block

( 00231400 )               D# 197 shadow{ 
 }block

( 00231800 )               D# 198 code{ 
 }block

( 00231C00 )               D# 199 shadow{ 
 }block

( 00232000 )               D# 200 code{ 
 ( user f18 code ) [ reclaim ] { br }

 ( softsim example ) [ reclaim d# 0 node d# 1342 load ] { cr }
 ( practical example pwm code ) [ reclaim d# 842 load ] }block

( 00232400 )               D# 201 shadow{ 
 ( use this load block to compile your code ) { cr }
 ( for the f18 computers. ) { br }

 ( as delivered, sample code loaded here is pro- vided to facilitate
 working with examples ) { cr }
 ( presented in the user's guide. it may be ) { cr }
 ( deleted if you no longer have use for it. ) }block

( 00232800 )               D# 202 code{ 
 ( ga application tools )
 UNKNOWN: a-com [ d# 3 ] ; { * }
: a-bps d# 921600 ;
 UNKNOWN: c-com [ d# 10 ] ; { * }
: c-bps d# 921600 ;
 UNKNOWN: host d# 206 ; { * }
 UNKNOWN: target d# 208 ; { , }
 UNKNOWN ( modules ) { * }
 UNKNOWN: sram [ d# 264 ] ; { , }
 UNKNOWN ( utils ) { * }
 UNKNOWN: streamer [ d# 282 ] ; { * }
 UNKNOWN UNKNOWN: loader [ d# 210 ] ; { , , }
: selftest ( port ) [ d# 708 ] load ; :# stp 3
: autotest ( port ) [ d# 712 ] load ; }block

( 00232C00 )               D# 203 shadow{ 
 ( these definitions are used in released code or documented procedures
 and shouldn't be changed or overloaded casually. ) { br }

: a-com ( and ) c-com ( are com port numbers for eval board usb ports
 a and c. )
: a-bps ( and ) c-bps ( are baud rates to which ide ) { cr }
 ( sets these usb ports. )
: host ( and ) target ( load block numbers for serial ide configured
 to work with eval board host or target chips using default usb ports. )
 { br }

 [ definitions for getting started app note ]
: selftest ( runs ats selftest on either chip via the ide com port
 number given. )
: autotest ( given host ide com port number, runs ate tests of target
 chip using sync boot. then tests ) [ serdes ] ( between the chips. )
 }block

( 00233000 )               D# 204 code{ 
 ( - user application tools ) }block

( 00233400 )               D# 205 shadow{ 
 ( this is the place to compile definitions that you wish to be available
 after ) [ empty. ] ( be sure to test compile separately before placing
 them here or you may cause { 0000024F } load to abort. ) }block

( 00233800 )               D# 206 code{ 
 ( evb001 host chip ide ) [ empty compile ] { br }

 [ serial load ] { cr }
 ( customize ) [ -canon d# 0 fh orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { br }

: dac ( n ) h# 00000155 and io r! ; { br }

 ( canon load ) }block

( 00233C00 )               D# 207 shadow{ 
 ( this load block compiles and configures the ) { cr }
 ( ide for the host chip on the eval board. it's also an example of
 configuring and customizing the ide without hacking it and breaking
 other uses of the ide. ) { br }

 ( this block starts by loading the serial ide in its standard form. )
 [ -canon ] ( forgets the mapping of canonical words like ) @ ( and )
 dup ( onto the f18 so that we may interact with x86 code and ram. )
 { cr }
 ( we then set ) [ orgn ] ( so that the ide ) compile ( will reload
 this block, and we set ) [ sport ] ( to the usb port a for normal
 ide operations on host chip. ) [ !nam ] ( updates pathname for that
 com port. ) { br }

: dac ( is defined to illustrate extending the ide ) { cr }
 [ canon load ] ( restores mapping of canonical words onto the f18.
 comment this if you wish to use the 'r-words' for all f18 operations. )
 }block

( 00234000 )               D# 208 code{ 
 ( evb001 target chip ide ) [ empty compile ] { br }

 [ serial load ] { cr }
 ( customize ) [ -canon d# 0 fh orgn ! ] { cr }
 [ c-com sport ! c-bps bps ! !nam ] { br }

: dac ( n ) h# 00000155 and io r! ; { br }

 ( canon load ) }block

( 00234400 )               D# 209 shadow{ 
 ( this load block compiles and configures the ) { cr }
 ( ide for the eval board's target chip. it's ) { cr }
 ( also an example of configuring and customizing the ide without hacking
 it and breaking other uses of the ide. ) { br }

 ( this block starts by loading the serial ide in its standard form. )
 [ -canon ] ( forgets the mapping of canonical words like ) @ ( and )
 dup ( onto the f18 so that we may interact with x86 code and ram. )
 { cr }
 ( we then set ) [ orgn ] ( so that the ide ) compile ( will reload
 this block, and we set ) [ sport ] ( to the usb port c for normal
 ide ops on target chip. ) { cr }
 [ !nam ] ( updates pathname for that com port. ) { br }

: dac ( is defined to illustrate extending the ide ) { cr }
 [ canon load ] ( restores mapping of canonical words onto the f18.
 comment this if you wish to use the 'r-words' for all f18 operations. )
 }block

( 00234800 )               D# 210 code{ 
 UNKNOWN ( ide based loader ) :# pth 2 :# root 708 [ talk ] { , }
 UNKNOWN UNKNOWN ( tables and routing ) [ d# 2 fh d# 2 loads ] { , , }
 UNKNOWN UNKNOWN: body follower [ d# 0 ] + drop -if { , ... }
 UNKNOWN UNKNOWN [ root ] @ active or drop if deliver ; then ; { , ... }
 UNKNOWN UNKNOWN then [ d# 1 ] +route body [ d# -1 ] +route deliver ; { , , }
 UNKNOWN UNKNOWN: ship ( n ) dup [ pth ] ! route active [ root ] ! { , ... }
 [ d# 1 ] +route foc body unfoc [ pth ] @ -hook ; }block

( 00234C00 )               D# 211 shadow{ 
 UNKNOWN UNKNOWN ( ide scripting ) { , , }
 UNKNOWN: body ( recursively visit and initialize ) { , }
 UNKNOWN UNKNOWN ( each node in the path ) { , , }
 UNKNOWN: ship ( use given path and set foc mode ) { , }
 UNKNOWN ( visit each node in the path then cleanup ) { , }
 UNKNOWN ( by convention path { 0000004F } in the ide reaches all ) { , }
 UNKNOWN UNKNOWN ( nodes and is suitable for use by most apps. ) { , , }
 UNKNOWN [ usage ] ( is simple. ) { , }
 UNKNOWN ( 1. ) [ host ] ( or target ) [ load loader load ] { , }
 ( 2. describe the application using +node et al. 3. ) [ ship ] }block

( 00235000 )               D# 212 code{ 
 ( - configuration tables ) :# com 133
: tabl pop 2/ 2/ [ com ] @ + ;
: jsr h# 000000E8 dst ; ( call has been clobbered already )
: table ( nn ) < align > jsr tabl for dup , next drop ;
 UNKNOWN: a-boot [ d# -1 d# 144 table ] { * }
: c-boot [ d# -1 d# 144 table ]
 UNKNOWN: b-boot [ d# -1 d# 144 table ] { * }
: p-reg [ h# 000000A9 d# 144 table ]
 UNKNOWN: a-reg [ d# -1 d# 144 table ] { * }
: b-reg [ io d# 144 table ]
 UNKNOWN: inits [ d# 1 d# 144 table ] { * }
 UNKNOWN UNKNOWN: init d# 11 inits ! ; { , , }
 UNKNOWN: /a ( a ) a-reg ! init ; { * }
: /b ( a ) b-reg ! init ;
: /p ( a ) p-reg ! ;
: +node ( n ) nn-n [ com ] ! ;
: /part ( acb ) b-boot ! c-boot ! a-boot ! ;
: /ram ( b ) b-boot ! d# 64 c-boot ! d# 0 a-boot ! ;
 UNKNOWN UNKNOWN: rammer ( -acb ) a-boot @ c-boot @ b-boot @ ; { , , }
: aaray pop 2/ 2/ [ com ] @ [ d# 11 ] * + ;
: array ( n ) < align > jsr aaray [ d# 11 ] * for d# 0 , next ;
: 'stack [ d# 144 array ] :# sp 10
: @s+ 'stack [ sp ] @ + @ d# 1 [ sp ] +! ;
: !s- ( n ) 'stack [ sp ] @ + ! d# -1 [ sp ] +! ;
 UNKNOWN: /stack ( stuff count ) init { , }
 d# 10 [ sp ] ! dup !s- for !s- next ; }block

( 00235400 )               D# 213 shadow{ 
 ( - configuration tables )
: tabl
 UNKNOWN: jsr ( call from block { 00000B0F } has been clobbered ) { , }
 ( so replace it with jsr instead )
 UNKNOWN: table ( build and initialize a table ) { , }
 ( tables hold configuration information )
: /a a ( specifies ) [ a ] ( value for current node )
: /b a ( specifies ) [ b ] ( value for current node )
: /p a ( specifies entry point for current node )
: +node n ( makes n the current node )
 UNKNOWN: /part acb ( specifies ) [ address count ] ( and ) [ bin ] { , }
 ( for code to be loaded into current node later )
: /ram b ( specifies just the bin, load all { 0000080F } )
 UNKNOWN: rammer -acb ( returns ) [ address count ] ( and ) [ bin ] { , }
 ( from table )
: /stack stuff count ( specifies ) [ count ] ( items to be placed on
 the stack at load time ) }block

( 00235800 )               D# 214 code{ 
 ( - routing ) :# 'rte 67894438
: route ( i ) 'pths + @ [ 'rte ] ! ;
: active ( -n ) [ 'rte ] @ @ ;
: follower ( -n ) [ 'rte ] @ [ d# 1 ] + @ ;
 UNKNOWN UNKNOWN: +route ( n ) [ 'rte ] +! active nn-n [ com ] ! ; { , , }
 UNKNOWN UNKNOWN: ?load c-boot @ [ d# 0 ] + drop -if ; then { , ... }
 UNKNOWN UNKNOWN rammer boot ; { , , }
 UNKNOWN: deliver [ pth ] @ active hook ( pause ) { , }
 UNKNOWN UNKNOWN ?load a-reg @ - [ d# 0 ] + drop -if { , ... }
 UNKNOWN a-reg @ lit' ra! then { , }
 UNKNOWN UNKNOWN b-reg @ - [ d# 0 ] + drop -if { , ... }
 UNKNOWN b-reg @ lit' rb! then { , }
 UNKNOWN UNKNOWN 'stack [ d# 10 ] + @ dup and if dup { , ... }
 UNKNOWN UNKNOWN dup negate [ d# 10 ] + [ sp ] ! for @s+ lit' next { , ... }
 UNKNOWN then drop { , }
 p-reg @ call ; }block

( 00235C00 )               D# 215 shadow{ 
 ( - routing )
: route i ( start on a path )
: active -n ( node being configured )
: follower -n ( next node in path )
 UNKNOWN UNKNOWN: +route n ( change active node ) { , , }
 UNKNOWN UNKNOWN: ?load ( load code into node now if table says to ) { , , }
 UNKNOWN: deliver ( init ram, a, b, stack, and p if ) { , }
 ( tables say to do so ) }block

( 00236000 )               D# 216 code{ 
 }block

( 00236400 )               D# 217 shadow{ 
 }block

( 00236800 )               D# 218 code{ 
 }block

( 00236C00 )               D# 219 shadow{ 
 }block

( 00237000 )               D# 220 code{ 
 }block

( 00237400 )               D# 221 shadow{ 
 }block

( 00237800 )               D# 222 code{ 
 }block

( 00237C00 )               D# 223 shadow{ 
 }block

( 00238000 )               D# 224 code{ 
 }block

( 00238400 )               D# 225 shadow{ 
 }block

( 00238800 )               D# 226 code{ 
 }block

( 00238C00 )               D# 227 shadow{ 
 }block

( 00239000 )               D# 228 code{ 
 }block

( 00239400 )               D# 229 shadow{ 
 }block

( 00239800 )               D# 230 code{ 
 }block

( 00239C00 )               D# 231 shadow{ 
 }block

( 0023A000 )               D# 232 code{ 
 }block

( 0023A400 )               D# 233 shadow{ 
 }block

( 0023A800 )               D# 234 code{ 
 }block

( 0023AC00 )               D# 235 shadow{ 
 }block

( 0023B000 )               D# 236 code{ 
 }block

( 0023B400 )               D# 237 shadow{ 
 }block

( 0023B800 )               D# 238 code{ 
 }block

( 0023BC00 )               D# 239 shadow{ 
 }block

( 0023C000 )               D# 240 code{ 
 ( framer ) [ overlay ]
: exec [ h# 000000B6 ] ; { -cr } : warm [ h# 000000A9 ] ; { -cr } 
: io [ h# 0000015D ] ; { cr }
: right [ h# 000001D5 ] ; { -cr } : down [ h# 00000115 ] ;
: left [ h# 00000175 ] ; { -cr } : up [ h# 00000145 ] ; { cr }
 ( streams ) [ d# 2 fh d# 4 loads ] { br }

: body ( w-w ) follower [ d# 0 ] + drop -if { cr }
 ?load post ; then -load -post pump { cr }
 [ d# 1 ] +route body [ d# -1 ] +route ?load post ; { cr }
: length ( -n ) d# 1 [ 'pth ] @ [ d# 1 ] + begin dup @ - [ d# 0 ] +
 { cr }
 -while - nn-n [ com ] ! c-boot @ [ d# 0 ] + -if [ d# -4 ] + { cr }
 then ( load ) [ d# 5 ] + ( pump ) [ d# 5 ] + ( post ) @post + u+ { cr }
 [ d# 1 ] + end then drop drop ( -1pump ) [ d# -5 ] + ; { br }

: head ( a-w ) active nn-n [ com ] ! [ h# 00010000 ] + !18 { cr }
 [ d# 0 ] side dup !18 length dup !18 { cr }
 swap [ h# 00012000 ] + !18 [ d# 1 ] +route ;
 UNKNOWN: frame [ exec ] head [ d# -1 ] + body drop [ d# -1 ] +route { ,
 UNKNOWN ... }
 UNKNOWN c-boot @ [ d# 0 ] + drop -if d# 0 d# 0 d# 0 /part then { ,
 UNKNOWN ... }
 UNKNOWN UNKNOWN p-reg @ booter /root ; { , , }
 ( default path ) [ d# 22 fh load ] }block

( 0023C400 )               D# 241 shadow{ 
 ( framer load gets the stream vocabulary ) { br }

: body ( recursively make the body of a boot frame )
: length ( add up number of words in boot frame )
: head ( make boot frame header )
: frame ( make the whole boot frame ) { indent { FFFFFFEF } }
      ( for focus , +3 for header ) }block

( 0023C800 )               D# 242 code{ 
 ( - framer ) :# com 131
: tabl pop 2/ 2/ [ com ] @ + ;
: table ( nn ) < align > call tabl for dup , next drop ;
 UNKNOWN: a-boot [ d# -1 d# 144 table ] { * }
: c-boot [ d# -1 d# 144 table ]
 UNKNOWN: b-boot [ d# -1 d# 144 table ] { * }
: p-reg [ h# 000000A9 d# 144 table ]
 UNKNOWN: a-reg [ d# -1 d# 144 table ] { * }
: b-reg [ io d# 144 table ]
 UNKNOWN: inits [ d# 1 d# 144 table ] { * }
: init d# 11 inits ! ;
 UNKNOWN: /a ( a ) a-reg ! init ; { * }
: /b ( a ) b-reg ! init ;
: /p ( a ) p-reg ! ;
: +node ( n ) nn-n [ com ] ! ;
: /part ( acb ) b-boot ! c-boot ! a-boot ! ;
: /ram ( b ) b-boot ! d# 64 c-boot ! d# 0 a-boot ! ;
 UNKNOWN UNKNOWN: booter ( -acb ) a-boot @ c-boot @ b-boot @ ; { , , }
: aaray pop 2/ 2/ [ com ] @ [ d# 11 ] * + ;
: array ( n ) < align > call aaray [ d# 11 ] * for d# 0 , next ;
: 'stack [ d# 144 array ] :# sp 10
: @s+ 'stack [ sp ] @ + @ d# 1 [ sp ] +! ;
: !s- ( n ) 'stack [ sp ] @ + ! d# -1 [ sp ] +! ;
 UNKNOWN: /stack ( stuff count ) init { , }
 d# 10 [ sp ] ! dup !s- for !s- next ; }block

( 0023CC00 )               D# 243 shadow{ 
 ( stream components ) [ com ] ( identfies current node )
: table ( creates an array initialized to { FFFFFFEF } )
: x-boot
: x-reg ( arrays have booter and starter details )
: /p ( specifies entry point )
: /a ( initial value of a )
: /b ( initial value of b )
: +node ( connect to a node in a path ) { cr }
: /part ( from ide, specifies ram address, ) { cr }
 UNKNOWN ( length and source ) { , }
 UNKNOWN [ note scrub must be maintained to match the ] { , }
 [ defaults stored here! ]
: booter ( find a, c, and b for +load ) { br }

: aaray
: array
: 'stack ( an array of { 0000120F } { 0000014F } item stacks )
: @s+ ( get next item to be initialized )
: !s- ( store next item into stacks array )
: /stack ( specify stack initialization ) }block

( 0023D000 )               D# 244 code{ 
 ( - framer ) :# 'pth 67891634
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ; { -cr } : a-b ( a-b ) 2* 2* ;
: create ( -a ) pop b-a ;
 UNKNOWN: route pop b-a { * }
: course ( a ) [ 'pth ] ! ;
: active ( -n ) [ 'pth ] @ @ ;
: follower ( -n ) [ 'pth ] @ [ d# 1 ] + @ ;
: +route ( n ) [ 'pth ] +! active nn-n [ com ] ! ; { br }

 :# wd 75758866
: 'stream ( -a ) [ nnc d# 2 * h# 00008000 + block ] ; { cr }
 [ 'stream d# 1 + wd ! ]
: stream ( -ac ) [ 'stream d# 1 + ] dup [ wd ] @ - + - ;
: strlen ( -n ) stream nip ;
: !18 ( n ) [ h# 00015555 ] or [ wd ] @ ! d# 1 [ wd ] +! ; { br }

: wall ( nn-i ) over over or [ d# 1 ] and drop if { cr }
 or [ d# 2 ] and ; then [ d# 100 ] / swap [ d# 100 ] / or { cr }
 [ d# 2 ] and [ d# 1 ] + ;
: side ( n-a ) [ 'pth ] @ + dup @ swap [ d# 1 ] + @ wall port ; { cr }
: 0/2 ( n-0/2 ) [ d# 0 ] + drop -if [ d# 0 ] ; then [ d# 2 ] ;
: @post ( -n ) a-reg @ 0/2 b-reg @ 0/2 + { cr }
 'stack [ d# 10 ] + @ [ d# 2 ] * + [ d# 1 ] + ; }block

( 0023D400 )               D# 245 shadow{ 
 ( stream components ) { cr }
 [ 'pth ] ( points to current place in path )
: b-a ( byte to word address )
: route ( stores address of new path in ) [ 'pth ]
: course ( is user vocab for setting a path. )
: active ( return current node in path )
: follower ( return next node in path )
: +route ( move to next node in path ) { indent }
      [ pos ] ( moves forward ) [ neg ] ( moves back ) { br }

 [ wd ] ( point to next word in stream buffer )
: !18 ( stores word into stream buffer ) { br }

: wall ( given numbers of two adjacent nodes ) { cr }
 ( return index for shared port )
: side ( given numbers of two adjacent nodes ) { cr }
 ( return address of shared port ) { br }

: 0/2 ( false is 0 and true is { 0000004F } )
: @post ( add up the size of active node's ) { cr }
 ( postamble ) }block

( 0023D800 )               D# 246 code{ 
 ( - framer )
: pump ( w-w ) [ d# -5 ] + ( @pdupa!@p ) [ h# 00004DAF ] !18 { cr }
 [ d# 0 ] side [ h# 00012000 ] + !18 dup [ d# -1 ] + !18 { cr }
 ( push!.. ) [ h# 0002FAB2 ] !18 ( @p!unext. ) [ h# 00005A72 ] !18
 ;
: post a-reg @ - [ d# 0 ] + drop -if { cr }
 ( @pa!.. ) [ h# 00004AB2 ] !18 a-reg @ !18 then { indent }
      b-reg @ - [ d# 0 ] + drop -if { cr }
 ( @pb!.. ) [ h# 00004BB2 ] !18 b-reg @ !18 then { indent }
      'stack [ d# 10 ] + @ dup and if dup { indent }
      dup negate [ d# 10 ] + [ sp ] ! for { cr }
 ( @p .. ) [ h# 000049B2 ] !18 @s+ !18 next then drop { cr }
 ( always ) p-reg @ [ h# 00010000 ] + !18 ; { br }

: +ram ( acb ) nn-n 2* [ h# 00008000 ] + block u+ { cr }
 for dup @ [ h# 00015555 ] or !18 [ d# 1 ] + next drop ;
: +load ( acb ) push ( @pa!@p. ) [ h# 00004A12 ] !18 { cr }
 over !18 dup [ d# -1 ] + !18 ( push... ) [ h# 0002E9B2 ] !18 { cr }
 ( @p!+unext. ) [ h# 00005872 ] !18 pop +ram ; }block

( 0023DC00 )               D# 247 shadow{ 
 ( stream components ) { br }

: pump ( store { 000000AF } word port pump to stream buffer )
: post ( variable length word postamble, ) { cr }
 ( entry point, a, b, stack )
: +ram ( write ram contents to stream buffer )
: +load { 000000AF } ( word load pump to stream buffer ) }block

( 0023E000 )               D# 248 code{ 
 ( - framer )
: ?load ( w-w ) c-boot @ [ d# 0 ] + drop -if ; then { cr }
 booter +load ;
: -load ( w-w ) c-boot @ [ d# 0 ] + -if drop ; then { cr }
 [ d# 5 ] + negate + ;
: -post ( w-w ) @post negate + ; { br }

: adjust begin strlen d# 7 and drop while { cr }
 d# 0 !18 end then strlen 'stream ! ;
: scrub ( n ) +node [ d# -1 ] dup dup /part { cr }
 d# -1 /a io /b warm /p ;
: fresh begin active scrub [ d# 1 ] +route { cr }
 active dup and drop -until ; { br }

: /root ( a' a c b ) push push push { cr }
 h# 00010000 +or !18 pop dup !18 pop dup !18 { cr }
 [ d# 0 ] + if pop +ram ; then drop drop pop drop ; }block

( 0023E400 )               D# 249 shadow{ 
 ( stream components ) { br }

: ?load ( maybe add load pump and ram contents )
: -load ( subtract ram words from payload count ) { cr }
 ( if ram is to be loaded in active node )
: -post ( subtract length of postamble from ) { cr }
 ( payload count ) { br }

: adjust ( align stream to { 0000010F } { 0000024F } bit word boundary )
: scrub ( remove previous initialization clues ) { cr }
 UNKNOWN ( for node n in the current path ) [ must be main- ] { , }
 [ tained whenever defaults for tables change. ]
: fresh ( scrub the entire current path to prepare for another boot
 frame ) }block

( 0023E800 )               D# 250 code{ 
 ( ers flash erase function ) [ overlay ] { cr }
 [ len ! dest ! ] { cr }
 [ serial load -canon ] { cr }
 [ a-com sport ! a-bps bps ! !nam panel ]
: esc key? esc ;
: wait esc d# 0 [ keych ] ! ;
: expand ( n-lh ) dup h# 0000FFFF and [ d# 4 ] * swap { cr }
 h# 000F0000 and d# 64 / ;
: ersall [ h# 00000021 ] call ;
: ers32 [ h# 00000018 ] call ;
: ers [ dest ] @ pause { cr }
 [ d# 0 ] + drop if ersall ; then ers32 ;
: read ( a-a' ) dup expand lit' lit' [ h# 0000000C ] call [ d# -2 ]
 + ;
: r ( d-dw ) [ d# 2 ] + rdrop [ h# 00000025 ] call upd ;
: check [ dest ] @ read [ len ] @ for { cr }
 r h# 0000FFFF or drop if pop [ d# 0 ] ; then -next [ d# -1 ] ; { cr }
 [ nores d# 285 list ] { cr }
 [ .noboot pause wait ] ( ** install noboot jumper ) { cr }
 [ talk ] ( check a-com ) [ d# 0 d# 705 hook h# 00000000 d# 64 d# 1613
 boot ] { cr }
 [ .boot pause wait ] ( *** remove noboot jumper ) { cr }
 ( ers ) [ .erasing pause ersall chill ] ( check ) [ overlay ] }block

( 0023EC00 )               D# 251 shadow{ 
 ( erasing flash ) { br }

: ers ( an ) { cr }
 [ a ] ( byte address in flash on 4k boundary ) { cr }
 [ n ] ( number of ) d# 16 bit words ( to erase ) }block

( 0023F000 )               D# 252 code{ 
 ( flash writer { 0000024F } bit ) [ overlay ] { cr }
 [ d# 7 + d# -8 and len ! dest ! source ! ] { cr }
 [ serial load -canon ] { cr }
 [ a-com sport ! a-bps bps ! !nam talk ] { br }

 [ d# 0 d# 705 hook h# 00000000 d# 64 d# 1609 boot focus ] { cr }
 [ d# 0 d# 706 hook h# 00000000 d# 64 d# 1610 boot ] { br }

 ( flash commands { 000097CF } ) [ d# 2 fh load ] { br }

 [ d# 285 list nosay ] { cr }
 [ .burning pause burn chill ] { cr }
 [ .checking pause check ] { cr }
 [ overlay ] }block

( 0023F400 )               D# 253 shadow{ 
 ( writing a boot stream into flash ) { br }

 ( force length to { 0000000F } mod { 0000010F } so operation ends )
 { cr }
 ( at a { 0000020F } bit boundary ) { br }

: 18burn ( sdn ) { cr }
 [ s ] ( source address of buffer in host memory ) { cr }
 [ d ] ( destination { 0000010F } bit address in flash ) { cr }
 [ n ] ( length of stream in { 0000024F } bit words ) }block

( 0023F800 )               D# 254 code{ 
 ( - code for flash writer )
: read ( a ) left lit' ra! dup h# 000F0000 and d# 64 / { cr }
 swap h# 0000FFFF and d# 4 * lit' lit' [ h# 00000023 ] call ;
: r left lit' ra! [ h# 00000029 ] call upd ;
: commence left lit' ra! [ len ] @ d# 8 / d# -1 + { cr }
 [ dest ] @ dup h# 000F0000 and d# 64 / lit' { cr }
 h# 0000FFFF and d# 4 * lit' lit' [ h# 0000002D ] call ;
: git ( a-an ) dup [ d# 1 ] + swap @ [ h# 00015555 ] or ;
: get ( a-a ) git lit' ;
: burning [ source ] @ [ len ] @ for get !+ next drop ;
: fetch ( -n ) [ h# 00000037 ] call { 000007FF } [ h# 0000003A ] r@
 ;
: check ( -t ) [ dest ] @ read [ source ] @ [ len ] @ { cr }
 for git fetch over ( pause ) over or { cr }
 drop if pop fail ; { cr }
 then drop drop next drop good ;
: burn commence burning ; { br }

: f d# 0 d# 706 hook fetch d# 0 d# 705 hook upd ;
: b d# 0 d# 706 hook burn ; }block

( 0023FC00 )               D# 255 shadow{ 
 }block

( 00240000 )               D# 256 code{ 
 ( exercising flash ) [ h# 00000020 org ]
: focus { 0000041D } @p dup a! .. ( / ) --l- ( / ) ! ;
: reading { 0000047D } ( l h ) focus @p ! .. ( / ) @p @p .. ( / ) { cr }
 ! ! .. @p ! ; ( / ) [ h# 0001200E , ] ( / )
: @word { 0000053D } ( -n ) @p ! .. ( / ) [ h# 000120D9 , ] ( / ) { cr }
 @p ! @ ; ( / ) !p .. ( / )
: writing { 000005BD } ( h l n ) focus { cr }
 left @p ! .. ( / ) @p a! .. ( / ) { cr }
 ! @p ! .. ( / ) @p @p @p .. ( / ) push push ! { cr }
 pop ! pop ! @p ! ; ( / ) [ h# 0001201D , ] ( / )
: stash { 000006FD } focus @word !p ; { 0000075D } [ d# 0 , ] { br }

 [ exit ]
: stash { 000006FD } focus a push @word h# 0000003F a! ! pop a! ; }block

( 00240400 )               D# 257 shadow{ 
 }block

( 00240800 )               D# 258 code{ 
 ( writing flash { 0000010F } bits ) [ overlay ] { cr }
 [ len ! dest ! source ! ] { cr }
 [ serial load -canon ] { cr }
 [ a-com sport ! a-bps bps ! !nam talk ] { br }

 ( flash commands { 0000988F } ) [ d# 2 fh load ] { br }

 [ d# 0 d# 705 hook d# 0 d# 64 d# 1611 boot ] { cr }
 [ d# 285 list nosay ] ( nores ) { cr }
 [ .burning pause burn chill ] { cr }
 [ .checking pause check ] { cr }
 [ overlay ] }block

( 00240C00 )               D# 259 shadow{ 
 ( programming { 0000010F } bit flash ) { br }

: burn ( sdn ) { cr }
 [ s ] ( source address of buffer in host memory ) { cr }
 [ d ] ( destination { 0000010F } bit address in flash ) { cr }
 [ n ] ( length of stream in { 0000020F } bit words ) }block

( 00241000 )               D# 260 code{ 
 ( code for reading and writing flash { 0000010F } bits ) { cr }
: out d# 0 d# 706 hook ; { -cr } : in d# 0 d# 705 hook ;
: read ( a-a' ) in dup dup h# 000F0000 and d# 64 / lit' { cr }
 h# 0000FFFF and [ d# 4 ] * lit' [ h# 0000000E ] call rdup upd [ d# -2 ]
 + ;
: r ( d-dw ) [ d# 2 ] + rdrop [ h# 00000014 ] call upd ;
: r18 ( d-dw ) [ d# 2 ] + rdrop [ h# 000000D9 ] call upd ;
: rr [ h# 00008000 ] read r ;
: ers [ h# 00000024 ] call ; { -cr } : pr [ h# 00000028 ] call ;
: send ( n ) left ( pause ) r! ;
: 2@+ ( b-b'h ) dup d# 2 + swap 2@ h# 0000FFFF and swab ;
: burn in [ dest ] @ dup [ h# 000F0000 ] and [ d# 64 ] / lit' { cr }
 [ h# 0000FFFF ] and [ d# 4 ] * lit' [ len ] @ lit' { cr }
 left lit' ra! pr out [ source ] @ [ len ] @ { cr }
 for 2@+ [ d# 4 ] * send -next drop ;
: check ( -t ) [ dest ] @ read drop { cr }
 [ source ] @ [ len ] @ for 2@+ { 0000073F } [ h# 0000003B ] call [
 h# 0000003F ] r@ or { cr }
 drop if pop drop fail ; then -next drop fair ; }block

( 00241400 )               D# 261 shadow{ 
 ( reading and writing flash ) { br }

: read ( begin at { 0000028F } bit flash byte address )
: r ( read the next { 0000020F } bit word from flash )
: r18 ( read the next { 0000024F } bit word from flash )
: rr ( begin and read first word at { 0010001F } )
: ers ( erase whole flash )
: pr ( program assuming already erased )
: back ( back out to node { 0000584F } for streaming )
: send ( one word into node { 0000582F } , pause to display )
: 2@+ ( fetch { 0000020F } bit word + byte swap )
: burn n ( start programming flash in { 0000582F } , ) { cr }
 ( then back out to { 0000584F } and stream words from ) { cr }
 ( the stream buffer into { 0000582F } . ) }block

( 00241800 )               D# 262 code{ 
 ( default flash path for whole chip )
 UNKNOWN UNKNOWN: line ( ncd ) swap push swap { , ... }
 begin dup , over + -next drop drop ;
 UNKNOWN: count ( nc-ncd ) dup [ d# 100 ] mod [ d# 0 ] + if { , }
 UNKNOWN ( horz ) swap drop [ d# 1 ] ; { , }
 ( vert ) then drop [ d# 100 ] / [ d# 100 ] ;
 UNKNOWN: to ( nn ) over negate + -if { , }
 UNKNOWN ( back ) negate count negate line ; { , }
 UNKNOWN UNKNOWN ( forw ) then count line ; { , , }
 UNKNOWN: entire align create [ d# 705 d# 701 to d# 700 d# 0 to ] { , }
 [ d# 1 d# 17 to d# 117 d# 101 to d# 201 d# 217 to d# 317 d# 301 to ]
 UNKNOWN { , }
 [ d# 401 d# 417 to d# 517 d# 501 to d# 601 d# 617 to d# 717 d# 709
 UNKNOWN to ] { , }
 UNKNOWN UNKNOWN [ d# -1 , ] { , , }
 ( retain asynch boot ) [ d# 708 +node h# 000000AA /p ] }block

( 00241C00 )               D# 263 shadow{ 
: line ncd ( comma nodes into a table starting at node ) n ( for )
 c ( nodes incrementing by ) d { cr }
: /left ( extend line toward the left )
: /right ( extend line toward the right )
: /up ( extend line upward )
: /down ( extend line downward )
: entire ( default path table that ) { cr }
 ( covers the whole virginal chip ) }block

( 00242000 )               D# 264 code{ 
 ( sram cluster mk1 ) { br }

 ( load sram ) [ d# 6 fh d# 3 loads ] { indent }
      ( norm ) [ d# 12 fh ] ( degen { 0000018F } { 0000020F } fh )
 [ load ] }block

( 00242400 )               D# 265 shadow{ 
 UNKNOWN ( load block for sram cluster mk1 ) { , }
 UNKNOWN UNKNOWN ( as documented in an003. ) { , , }
 UNKNOWN UNKNOWN ( packaged as per preliminary module standards ) { , , }
 UNKNOWN [ sram ] ( load block for f18 code ) { , }
 UNKNOWN [ sram d# 2 + ] ( boot descriptors for cluster ) { , }
 UNKNOWN [ sram d# 4 + ] ( optional residual path definition ) { , }
 ( f18 source code follows. ) }block

( 00242800 )               D# 266 code{ 
 UNKNOWN UNKNOWN ( - load descriptor ) { , , }
 UNKNOWN UNKNOWN ( interface ) [ d# 107 +node d# 1614 /ram down /b ] { , ... }
 UNKNOWN ( mask ) [ h# 00008A00 d# 1 /stack ] ( re ) [ h# 00000017 /p ] { ,
 UNKNOWN , }
 UNKNOWN ( data ) [ d# 7 +node d# 1615 /ram h# 00000020 /p ] { , }
 UNKNOWN ( cntl ) [ d# 8 +node d# 1616 /ram h# 00000020 /p ] { , }
 ( addr ) [ d# 9 +node d# 1617 /ram h# 00000020 /p ] }block

( 00242C00 )               D# 267 shadow{ 
 UNKNOWN UNKNOWN ( load descriptor for sram cluster ) { , , }
 UNKNOWN ( this descriptor is suitable for use with ) { , }
 ( ide loader, streamer, and softsim. ) }block

( 00243000 )               D# 268 code{ 
 UNKNOWN UNKNOWN ( - residual paths ) { , , }
 UNKNOWN: s705 align create [ d# 705 d# 701 to d# 700 d# 0 to ] { , }
 [ d# 1 d# 6 to d# 106 d# 101 to d# 201 d# 208 to d# 108 d# 109 to ]
 UNKNOWN { , }
 [ d# 209 d# 210 to d# 110 d# 10 to d# 11 d# 17 to d# 117 d# 111 to ]
 UNKNOWN { , }
 [ d# 211 d# 217 to d# 317 d# 301 to d# 401 d# 417 to d# 517 d# 501
 UNKNOWN to ] { , }
 UNKNOWN UNKNOWN [ d# 601 d# 617 to d# 717 d# 709 to d# -1 , ] { , , }
 UNKNOWN: s708 align create [ d# 708 d# 701 to d# 700 d# 0 to ] { , }
 [ d# 1 d# 6 to d# 106 d# 101 to d# 201 d# 208 to d# 108 d# 109 to ]
 UNKNOWN { , }
 [ d# 209 d# 210 to d# 110 d# 10 to d# 11 d# 17 to d# 117 d# 111 to ]
 UNKNOWN { , }
 [ d# 211 d# 217 to d# 317 d# 301 to d# 401 d# 417 to d# 517 d# 501
 UNKNOWN to ] { , }
 [ d# 601 d# 617 to d# 717 d# 709 to d# -1 , ] }block

( 00243400 )               D# 269 shadow{ 
 UNKNOWN ( memory clusters are often loaded before the ) { , }
 UNKNOWN ( rest of the application so that external ram ) { , }
 UNKNOWN ( may be initialized without burdening appli- ) { , }
 ( cation f18 code. these residual paths provide access from boot nodes
 UNKNOWN UNKNOWN to the rest of the chip in such cases. ) { , , }
: s705 ( residual path for spi flash boot streams. )
: s708 ( residual path for async boot or ide. ) }block

( 00243800 )               D# 270 code{ 
 ( sram.16 address-bus ) [ d# 9 node ] { cr }
 { 0000155D } [ h# 00000020 org ] { br }

: start { 0000041D } right b! .. data a! .. h# 00000003 ( mask )
: cmd ( m ) { 000004DD } @b ( a16 ) 2* 2* over @b -if { indent }
      { 0000051D } - ( p04 ) and or ( a18 ) ! cmd ; { indent }
 UNKNOWN      { 0000055D } then ( p04 ) and or .. ( a18 ) ! cmd ; { , }
 { 0000059D } [ d# 1617 bin ] }block

( 00243C00 )               D# 271 shadow{ 
 ( node { 0000012F } suspends while waiting for a16. it uses the two
 lower page bits to output an ) { cr }
 ( 18-bit address. ) { cr indent }
      a16 ( xx.aaaa.aaaa.aaaa.aaaa ) { indent }
      p04 ( 00.0000.0000.0000.pppp ) { indent }
      a18 ( aa.aaaa.aaaa.aaaa.aapp ) { br }

 ( the code is written to minimize/equalize the time to output the
 address, which must be stable when node8 stores the 'start' command. )
 }block

( 00244000 )               D# 272 code{ 
 ( - control-pins ) [ d# 8 node host ]
: 'r-l- h# 000001F5 lit ; [ target h# 00000000 org ] { br }

 ( 'start' pin control table 0-7 ) { cr }
 { 0000001D } [ h# 0002556E ] ( r00 ) [ , h# 0002557E ] ( r01 ) [ , ]
 { cr }
 { 0000005D } [ h# 0003556E ] ( r10 ) [ , h# 0003557E ] ( r11 ) [ , ]
 { cr }
 { 0000009D } [ h# 0003557A ] ( w11 ) [ , h# 0003556A ] ( w10 ) [ , ]
 { cr }
 { 000000DD } [ h# 0002557A ] ( w01 ) [ , h# 0002556A ] ( w00 ) [ , ]
 { cr }
 { 0000011D } [ h# 00000020 org ] { br }

: start { 0000041D } 'r-l- b! io a!
: cmd { 0000049D } @b ( stop ) ! a push h# 00000007 ( mask ) .. { indent }
      @b ( a16 ) !b @b ( +p/-p ) dup !b { indent }
      2/ 2/ and ( i3 ) a! .. @ ( ctrl ) pop a! { indent }
 UNKNOWN      ( start ) ! cmd ; { , }
 { 0000059D } [ d# 1616 bin ] }block

( 00244400 )               D# 273 shadow{ 
 ( node8 is fed a stop command during start-up, then suspends while
 waiting for a16. after starting the read or write, it again suspends
 while waiting for the stop command. ) { br }

 ( bits 4..2 of the /possibly inverted/ page value are used 'as-is'
 to index into the start table, setting two address bits, write enable,
 and chip enable. ) [ ** note that reads and writes are swapped if
 the page 'overflows' into bit4, with disastrous results ** ] { cr
 cr }
 ( cmd index ) [ .lit. ] ( pin17 pin05 pin03 pin01 ) { cr }
 ( w00 .0111 ) [ h# 0002556A ] ( a19-0 a18-0 /we-0 /ce-0 ) { cr }
 ( r00 .0000 ) [ h# 0002556E ] ( a19-0 a18-0 /we-1 /ce-0 ) { cr }
 ( w01 .0110 ) [ h# 0002557A ] ( a19-0 a18-1 /we-0 /ce-0 ) { cr }
 ( r01 .0001 ) [ h# 0002557E ] ( a19-0 a18-1 /we-1 /ce-0 ) { cr }
 ( w10 .0101 ) [ h# 0003556A ] ( a19-1 a18-0 /we-0 /ce-0 ) { cr }
 ( r10 .0010 ) [ h# 0003556E ] ( a19-1 a18-0 /we-1 /ce-0 ) { cr }
 ( w11 .0100 ) [ h# 0003557A ] ( a19-1 a18-1 /we-0 /ce-0 ) { cr }
 ( r11 .0011 ) [ h# 0003557E ] ( a19-1 a18-1 /we-1 /ce-0 ) }block

( 00244800 )               D# 274 code{ 
 ( - data-bus ) [ d# 7 node host ]
: in h# 00014555 lit ; { -cr } : out h# 00015555 lit ;
: stop h# 0003557F lit ; [ target ] { cr cr }
 { 0000155D } [ h# 00000020 org ]
: start { 0000041D } left b! out io data stop { indent }
      out io data stop in io a! ( in ) ! { indent }
      down a! ( stop ) !b
: cmd ( /soid/ ) { 0000063D } @ ( a16 ) !b @ ( +p/-p ) -if { br }

: w16 ( /soid/p- ) { 0000067D } ( +p/-p ) !b { cr }
 ( /- setup + 45ns ) @ ( w ) a push push ( data ) a! { cr }
 pop ! ( io ) a! ( out ) ! { 0000050F } d# 13 for unext ( stop ) !b
 { cr }
 ( -/ ) in ! pop a! cmd ; { br }

: r16 ( /soid/p- ) { 0000079D } then ( +p/-p ) !b { cr }
 ( /- setup + 55ns ) a push ( data ) a! { cr }
 ( io ) drop ( out ) drop { 0000064F } d# 40 for unext ( stop ) !b
 ( -/ ) { cr }
 UNKNOWN @ ( w ) pop a! ! cmd ; { , }
 { 0000087D } [ d# 1615 bin ] }block

( 00244C00 )               D# 275 shadow{ 
 ( node7 suspends waiting for a16, passes it and page/r/w to nodes { 0000010F }
 and 9, finally controlling the data transfer and timing until sending
 the stop command. ) { br }

 ( the literals needed for writing are loaded ) { cr }
 ( onto the stack and used circularly to save ) { cr }
 ( time. /read's drops are free./ ) { br }

 ( ---- ) .lit. ( pin17 pin05 pin03 pin01 ) { cr }
 ( stop ) h# 0003557F ( a19-1 a18-1 /we-1 /ce-1 ) }block

( 00245000 )               D# 276 code{ 
 ( - interface ) [ d# 107 node h# 00000000 org ]
 UNKNOWN UNKNOWN: cx ( wp- ) { 0000001D } over push @ dup { , ... }
 UNKNOWN ( a ) !b over ( p ) !b @b ( w ) pop - ( w1 ) or if { , }
 UNKNOWN ( ne ) @ ( w2 ) dup or ( ff ) ! ; { , }
 ( eq ) then drop ( a ) !b - ( -p ) !b @ ( w2 ) !b h# 0000FFFF ! ;
 UNKNOWN UNKNOWN { , , }
: cmd { 0000015D } @ -if @ [ ' cx ] -until ( .e! ) - !b !b @ !b ; then
 UNKNOWN { 000001DD } @ -if ( mixpa ) { , }
 UNKNOWN ( .mk! ) { 000001FD } - push drop drop pop if ( mia ) { , }
 UNKNOWN ( ..stim ) { 0000023D } drop and @ over over 2* ahead [ swap ] { , }
 UNKNOWN ( ..mask ) { 0000029D } then drop drop @ 2* over - { , }
 ( ...both ) { 000002DD } then and or
 UNKNOWN: re { 000002FD } ( m ) h# 00015555 dup ahead [ swap ] { ,
 UNKNOWN ... }
 then ( .e@ ) { 0000033D } ( a ) !b ( p ) !b @b ( w ) ! ;
 UNKNOWN: cmds ( mixa ) { 0000037D } a! cmd { * }
 UNKNOWN: poll ( mix ) then io a! { , }
 UNKNOWN { 000003DD } begin drop over over @ or and until { , }
 { 0000043D } over over and if ( mixt ) { 0000047D } and and ( mt )
 UNKNOWN UNKNOWN { , .. }
 UNKNOWN UNKNOWN dup h# 00010000 and if right ahead [ swap ] then { , .. }
 UNKNOWN { 0000051D } drop h# 00001000 over and if left ahead [ swap ] { ,
 UNKNOWN .. }
 UNKNOWN UNKNOWN { 000005BD } then drop { 0000801F } dup up then then { , ... }
 UNKNOWN { 000005FD } ( mtba ) a! and or dup ! ( m ) [ ' re ] end { , }
 UNKNOWN { 0000063D } then drop 2* 2* -if right cmds ; { , }
 UNKNOWN { 000006BD } then 2* 2* 2* 2* -if left cmds ; { , }
 { 0000073D } then up cmds ; { 0000077D } [ d# 1614 bin ] }block

( 00245400 )               D# 277 shadow{ 
 UNKNOWN ( node { 00000D6F } full capability version. ) { , }
 UNKNOWN ( polls for master requests and delivers stimuli ) { , }
 UNKNOWN ( all requests are atomic. passes ) ex@ ( and ) ex! { , }
 ( requests on to node 007, performs ) cx? ( locally using those primitives.
 the command and stimulus mask ) [ m ] ( is maintained on the stack. )
 UNKNOWN UNKNOWN { , , }
 ( requests are variable length messages decoded as shown below where
 UNKNOWN - means 18-bit inverse of { 0000020F } bit argument. ) { ,
 UNKNOWN , }
: ex@ [ +p +a ] ( fetch )
: cx? [ -w1 +p a w2 ] ( comp-and-exch )
: ex! [ -p -a w ] ( store )
: mk! [ +0 -f m ] ( f-1 enables each master whose port write bit is
 set in ) [ m. ] ( kills pending stimulus for any disabled master.
 UNKNOWN abandons old mask. ) { , }
 ( f-0 adds a stimulus for each master whose port write bit is set
 in ) [ m. ] ( caller should not post a stimulus for any disabled master. )
 }block

( 00245800 )               D# 278 code{ 
 ( - user node 106, 108, or 207. )
: x! ( wa ) { 0000073D } dup dup or
: ex! ( wap ) { -cr } : mk! ( mfp' ) { 0000075D } - !b - !b !b ;
: x@ ( a-w ) { 0000079D } dup dup or
: ex@ ( ap-w ) { 000007BD } !b !b @b ;
: cx? ( wapn-f ) { 000007DD } - !b !b !b !b @b ; { 0000081D } }block

( 00245C00 )               D# 279 shadow{ 
 ( example code for memory master nodes. ) { cr }
 ( memory-access words assume that addresses and data are 16-bit parameters
 with the upper two bits zero and pages are 4-bits with the upper { 000001CF }
 bits zero. p.a is thus a 20-bit address. ) { br }

: ex@ [ a p ] ( - ) w ( fetch w from p.a )
: ex! [ w a p ] ( store w at p.a )
: mk! [ w f -0 ] ( set masks from w per f. )
: cx? [ w a p n ] ( - ) f ( comp-and-exch ) { br }

 cx? ( compares value at ) [ p.a ] ( to ) [ n. ] ( if same, writes )
 [ w ] ( to ) [ p.a ] ( and returns true. otherwise, only returns false. )
 x@ ( and ) x! ( are 16-bit versions to access the lowest 64k of available
 memory. ) { br }

 mk! ( sets mask from w when f is 0; ) { cr }
 ( posts stimuli when f is 1. ) }block

( 00246000 )               D# 280 code{ 
 ( - degenerate sram ) [ d# 107 node h# 00000000 org ] { br }

: cx ( wp- ) { 0000001D } over push @ dup { indent }
      ( a ) !b over ( p ) !b @b ( w ) pop - ( w1 ) or if { cr }
 ( ne ) @ ( w2 ) dup or ( ff ) ! ; { cr }
 ( eq ) then drop ( a ) !b - ( -p ) !b @ ( w2 ) !b h# 0000FFFF ! ;
 { br }

: cmd { 0000015D } @ -if @ [ ' cx ] -until ( .e! ) - !b !b @ !b ; then
 { 000001DD } @ ( .e@ ) { 000001FD } ( a ) !b ( p ) !b @b ( w ) ! ;
 { br }

 { 0000023D } [ h# 00000017 org ]
: start { 000002FD } down b! right a!
: run { 0000037D } cmd run ; { 000003BD } }block

( 00246400 )               D# 281 shadow{ 
 ( node { 00000D6F } minimal capability version. ) { cr }
 ( single master, no polling, no stimuli. ) { cr }
 ( maximum speed, minimum power. ) { br }

 ( all requests are atomic. passes ) ex@ ( and ) ex! { cr }
 ( requests on to node 007, performs ) cx? ( locally using those primitives. )
 { br }

 ( requests are variable length messages decoded as shown below where
 - means 18-bit inverse of { 0000020F } bit argument. ) { br }

: ex@ [ +p +a ] ( fetch )
: cx? [ -w1 +p a w2 ] ( comp-and-exch )
: ex! [ -p -a w ] ( store ) }block

( 00246800 )               D# 282 code{ 
 ( streamer ) { cr }
 :# source 75751425 :# dest 0 :# len 3464
: stream ( -an ) [ source ] @ [ len ] @ ;
: 18burn ( sdn ) [ d# -30 fh ] load ;
: burn ( sdn ) [ d# -24 fh ] load ;
: ers ( an ) [ d# -32 fh ] load ;
: framer [ d# -42 fh ] ;
: chill d# 500 for d# 1000000 for nop next next ;
: file [ d# 12 fh ] ; { cr }
 ( feedback ) [ d# 284 load ]
: overlay remember }block

( 00246C00 )               D# 283 shadow{ 
 ( stream building utilities ) { cr }
 ( persistant streamer variables ) { cr }
 source ( word address in host memory buffer ) { cr }
 dest ( byte address in flash ) { cr }
 len ( length of stream in words )
: stream -an ( returns ) [ source ] ( an ) [ len ]
: 18burn sdn ( burn flash in { 0000024F } bit words )
: burn sdn ( burn flash in { 0000020F } bit words )
: ers an ( erase 4k blocks containing range ) [ an ]
: framer ( location of boot frame vocabulary )
: chill ( delay a long enough time to be sure ) { cr }
 ( that the previous operation is complete )
: overlay ( remember point for streamer utility ) { cr }
 ( saying ) [ overlay ] ( restores the dictionary to ) { cr }
 ( its state when overlay was defined ) }block

( 00247000 )               D# 284 code{ 
 ( flash utilties feedback ) { cr }
 :# loaded 464 :# result 0 { cr }
 :# 'say 271551855 :# 'ask 271551511
: nosay [ 'say ] assign nop ; [ nosay ]
: noask [ 'ask ] assign nop ; [ noask ]
: .now blu [ 'say ] xqt ;
: .ask blu [ 'ask ] xqt ;
: .at. blu silver [ loaded ] @ . ;
: chs ( ...n ) for emit next ; [ d# 2 fh load ]
: .res blu [ result ] @ { cr { FFFFFFEF } }
 [ d# 0 ] + -if .fair ; then { cr { 0000000F } }
 [ d# -1 ] + -if drop .good ; then { cr { 0000002F } }
 [ d# -1 ] + -if drop .fail ; then ;
: fair d# -1 [ result ] ! ;
: good d# 0 [ result ] ! ;
: fail d# 1 [ result ] ! ;
: nores d# 2 [ result ] ! ; :# leng 7441 [ d# 36 leng ! ]
 UNKNOWN UNKNOWN: .str blu silver .' ( stream ) space .' ( length ) { , ... }
 UNKNOWN UNKNOWN space [ leng ] @ . .' ( words ) space { , ... }
 [ leng ] @ d# 18 d# 8 */ . .' ( bytes ) space ; }block

( 00247400 )               D# 285 shadow{ 
 UNKNOWN UNKNOWN UNKNOWN ( flash utilities ) { br .str cr .at. cr .ask
 UNKNOWN UNKNOWN cr .now br .res }
 }block

( 00247800 )               D# 286 code{ 
 ( - flash utilities feedback )
: .erasing noask ( nores ) [ 'say ] assign silver { cr }
 ( erasing ) d# 0 h# 0000000D h# 00000006 h# 00000007 h# 00000008 h# 00000005
 h# 00000001 h# 00000004 d# 8 chs ;
: .burning noask ( nores ) [ 'say ] assign silver { cr }
 ( burning ) d# 0 h# 0000000D h# 00000006 h# 00000007 h# 00000006 h# 00000001
 h# 00000016 h# 00000013 d# 8 chs ;
: .checking noask ( nores ) [ 'say ] assign silver { cr }
 ( checking ) d# 0 h# 0000000D h# 00000006 h# 00000007 h# 00000024
 h# 0000000A h# 00000004 h# 00000014 h# 0000000A d# 9 chs ;
: .fair silver ( so far ) d# 0 h# 00000001 h# 00000005 h# 0000000E
 d# 0 h# 00000003 h# 00000008 d# 7 chs { cr }
 ( so good ) d# 0 h# 00000010 h# 00000003 h# 00000003 h# 0000000D d# 0
 h# 00000003 h# 00000008 d# 8 chs ;
: .good green ( good ) d# 0 h# 00000010 h# 00000003 h# 00000003 h# 0000000D
 d# 5 chs ;
: .fail red ( fail ) d# 0 h# 0000000C h# 00000007 h# 00000005 h# 0000000E
 d# 5 chs ;
: .boot nosay ( nores ) [ 'ask ] assign green { cr }
 ( remove ) d# 0 h# 00000004 h# 00000011 h# 00000003 h# 00000009 h# 00000004
 h# 00000001 d# 7 chs
: .j26 { cr }
 ( j26 ) d# 0 h# 0000001E h# 0000001A h# 00000022 d# 4 chs { cr }
 ( then ) d# 0 h# 00000006 h# 00000004 h# 00000014 h# 00000002 d# 5
 chs { cr }
 ( press ) d# 0 h# 00000008 h# 00000008 h# 00000004 h# 00000001 h# 00000012
 d# 6 chs { cr }
 ( key ) d# 0 h# 0000000B h# 00000004 h# 00000024 d# 4 chs ;
: .noboot nosay ( nores ) [ 'ask ] assign green { cr }
 ( install ) d# 0 h# 0000000C h# 0000000C h# 00000005 h# 00000002 h# 00000008
 h# 00000006 h# 00000007 d# 8 chs .j26 ; }block

( 00247C00 )               D# 287 shadow{ 
 }block

( 00248000 )               D# 288 code{ 
 ( pf to flash ) { br }

 ( read/write { 0000024F } bit flash ) { indent }
      [ d# 705 node d# 1364 load d# 1609 bin ] { indent }
      [ d# 706 node d# 256 load d# 1610 bin ] { cr }
 ( read/write { 0000010F } bit flash ) { indent }
      [ d# 705 node d# 1370 load d# 1611 bin ] { cr }
 ( erase flash ) { indent }
      [ d# 705 node d# 1352 load d# 1613 bin ] }block

( 00248400 )               D# 289 shadow{ 
 }block

( 00248800 )               D# 290 code{ 
 ( speedup spi boot ) [ d# 705 node d# 0 org ]
: start d# 5 dup spi-exec ; { cr }
 { 0000007D } [ d# 1608 bin ] }block

( 00248C00 )               D# 291 shadow{ 
 }block

( 00249000 )               D# 292 code{ 
 }block

( 00249400 )               D# 293 shadow{ 
 }block

( 00249800 )               D# 294 code{ 
 ( stream to file ) [ named ] ( stream.bin )
: open ( bf-h ) push push d# 0 d# 32 ( exist ) d# 2 d# 0 d# 0 { cr }
 pop pop swap fcreate ;
: change ( ac ) for dup @ [ h# 00015555 ] or over ! [ d# 1 ] + { cr }
 next drop ;
: keep [ d# 0 fnam ] w/o open dup push stream change { cr }
 stream push d# 4 * pop d# 4 * pop fwr drop fclose { cr }
 stream change ; [ keep ] }block

( 00249C00 )               D# 295 shadow{ 
 ( stream to file )
: open bf-h ( b is byte address of filename )
: change ac ( stream is made as pattern not number )
: keep ( convert stream to number and write it to a file, then change
 it back to pattern ) }block

( 0024A000 )               D# 296 code{ 
 }block

( 0024A400 )               D# 297 shadow{ 
 }block

( 0024A800 )               D# 298 code{ 
 }block

( 0024AC00 )               D# 299 shadow{ 
 }block

( 0024B000 )               D# 300 code{ 
 ( dc characterization code added march 2011. ) { br }

 [ block d# 602 ] ( is code run in a node to measure power. ) { br }

 [ blocks d# 604 ] ( thru ) [ d# 636 ] ( are ide load blocks to set
 up various measurement conditions. ) }block

( 0024B400 )               D# 301 shadow{ 
 }block

( 0024B800 )               D# 302 code{ 
 ( custom test code ) [ d# 609 node h# 00000000 org ]
: t1 { 0000001D } begin begin begin begin { cr }
 unext unext unext unext t1 ;
: t2 { 0000005D } begin begin begin { cr }
 . unext unext unext t2 ;
: t3 { 0000009D } begin begin . . unext unext t3 ;
: t4 { 000000DD } begin . . . unext t4 ;
: t5 { 0000011D } begin begin begin begin { cr }
 next next next next t5 ;
: t6 { 000001BD } begin begin begin begin { cr }
 . . . . next next next next t6 ;
: s++ { 0000027D } h# 00015555 dup { -cr } : s.. dup dup dup dup dup
 dup dup dup ; { -cr } : s+- h# 00015555 h# 0002AAAA s.. ;
: t7 { 0000039D } s++ { -cr } : t78e begin begin begin drop unext unext
 unext t78e ; { -cr } : t8 { 000003FD } s+- t78e ;
: t9 { 0000043D } io b! d# -1 !b begin . drop @b -until ;
: txx { 0000051D } s++ ( s+- )
: txxx begin ( . . . ) - unext txxx ; { 0000055D }
: temp { 0000005F } h# 0003FFFE { 0000007F } h# 0003FFFF d# 999 io
 b! push !b begin unext !b ; { 0000063D }
: temps temp temps ; { 0000067D } }block

( 0024BC00 )               D# 303 shadow{ 
 ( this load block, and the following { 0000032F } source/shadow pairs,
 are yours to do with as you please! ) }block

( 0024C000 )               D# 304 code{ 
 ( set all high z for leakage test ) [ talk ] { br }

 [ d# 0 d# 200 hook d# 0 io ! ] { cr }
 [ d# 0 d# 300 hook d# 0 io ! ] { cr }
 [ d# 0 d# 9 hook d# 0 io ! ] { cr }
 [ d# 0 d# 7 hook d# 0 io ! ] { cr }
 ( serdes already in input just focus it ) { cr }
 [ d# 0 d# 701 hook focus ] { cr }
 [ d# 2 d# 709 hook h# 00000155 io ! ] }block

( 0024C400 )               D# 305 shadow{ 
 }block

( 0024C800 )               D# 306 code{ 
 ( set all weak pd for wpd test ) [ talk ] { br }

 [ d# 0 d# 200 hook h# 00015555 io ! ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! ] { cr { 0000000F } { 0000012F } }
 ( hook { 0000000F } io ! ) { cr { 0000000F } { 000000EF } }
 ( hook { 0000000F } io ! ) { cr }
 ( serdes already in input just focus it ) { cr { 0000000F } { 000057AF } }
 ( hook focus ) { cr { 0000004F } { 000058AF } }
 ( hook { 00002ABF } io ! ) }block

( 0024CC00 )               D# 307 shadow{ 
 }block

( 0024D000 )               D# 308 code{ 
 ( set all high for several tests ) [ talk ] { br }

 [ d# 0 d# 200 hook h# 00030003 io ! ] { cr }
 [ d# 0 d# 300 hook h# 00030003 io ! ] { cr }
 [ d# 0 d# 9 hook h# 0003FFFF data ! ] { cr }
 [ d# 0 d# 7 hook h# 0003FFFF data ! ] { cr }
 ( serdes already in input just focus it ) { cr { 0000000F } { 000057AF } }
 ( hook focus ) { cr }
 [ d# 2 d# 709 hook h# 000000AA io ! ] }block

( 0024D400 )               D# 309 shadow{ 
 }block

( 0024D800 )               D# 310 code{ 
 ( set all low for several tests ) [ talk ] { br }

 [ d# 0 d# 200 hook h# 00020002 io ! ] { cr }
 [ d# 0 d# 300 hook h# 00020002 io ! ] { cr }
 [ d# 0 d# 9 hook h# 00000000 data ! ] { cr }
 [ d# 0 d# 7 hook h# 00000000 data ! ] { cr }
 ( serdes already in input just focus it ) { cr { 0000000F } { 000057AF } }
 ( hook focus ) { cr }
 [ d# 2 d# 709 hook h# 00000155 io ! ] }block

( 0024DC00 )               D# 311 shadow{ 
 }block

( 0024E000 )               D# 312 code{ 
 ( t04 all node access ) [ talk ] { br }

 [ ?rom pause upd pause ] { cr }
 [ d# 2 d# 708 hook pause d# 2 d# 707 hook pause ] { cr }
 [ ?ram pause upd pause ] { cr }
 [ d# 1 lit pause d# 2 lit pause d# 3 lit pause ] { cr }
 [ + pause + ] }block

( 0024E400 )               D# 313 shadow{ 
 }block

( 0024E800 )               D# 314 code{ 
 ( vt+- node { 00001B2F } ) [ compile talk d# 2 d# 217 hook upd ] { cr }
: dak ( n a ) h# 00005BB2 over r! swap h# 00000155 or swap r! ;
: try ( n ) up dak ;
: h h# 00020000 io r! h# 00000000 try d# 100 ms d# 0 io r! { cr }
 d# 0 begin dup h# 00000200 or h# 00000200 and drop while { cr }
 dup try d# 1 + io r@ h# 00020000 and drop until then ;
: l h# 00030000 io r! d# 511 try d# 100 ms d# 0 io r! { cr }
 d# 255 begin dup h# 00000100 or h# 00000100 and drop while { cr }
 dup try d# -1 + io r@ - h# 00020000 and drop until then ; }block

( 0024EC00 )               D# 315 shadow{ 
 }block

( 0024F000 )               D# 316 code{ 
 ( vt+- node { 000040AF } ) [ compile talk d# 0 d# 517 hook upd ] { cr }
: dak ( n a ) h# 00005BB2 over r! swap h# 00000155 or swap r! ;
: try ( n ) up dak ;
: h h# 00020000 io r! h# 00000000 try d# 100 ms d# 0 io r! { cr }
 d# 0 begin dup h# 00000200 or h# 00000200 and drop while { cr }
 dup try d# 1 + io r@ h# 00020000 and drop until then ;
: l h# 00030000 io r! d# 511 try d# 100 ms d# 0 io r! { cr }
 d# 255 begin dup h# 00000100 or h# 00000100 and drop while { cr }
 dup try d# -1 + io r@ - h# 00020000 and drop until then ; }block

( 0024F400 )               D# 317 shadow{ 
 }block

( 0024F800 )               D# 318 code{ 
 ( vt n7/8 ) [ compile talk ] { cr }
 [ d# 2 d# 7 hook h# 00000000 io ! data lit ra! focus ] { cr }
 [ d# 2 d# 8 hook h# 00020000 io ! focus upd ] { cr }
: rd ( a-n @!p ) h# 000039B2 over r! r@ ;
: git ( -n ) left rd ;
: go key? git d# 1 and drop if h# 00030000 io r! go ; { cr }
 then h# 00020000 io r! go ; [ go ] }block

( 0024FC00 )               D# 319 shadow{ 
 }block

( 00250000 )               D# 320 code{ 
 ( vt n9/8 ) [ compile talk ] { cr }
 [ d# 0 d# 9 hook h# 00000000 io ! data lit ra! focus ] { cr }
 [ d# 0 d# 8 hook h# 00020000 io ! focus upd ] { cr }
: rd ( a-n @!p ) h# 000039B2 over r! r@ ;
: git ( -n ) right rd ;
: go key? git h# 00020000 and drop if h# 00030000 io r! go ; { cr }
 then h# 00020000 io r! go ; [ go ] }block

( 00250400 )               D# 321 shadow{ 
 }block

( 00250800 )               D# 322 code{ 
 ( t10 schmitt power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! upd ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! upd ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ d# 0 io ! upd ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! upd ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! upd ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd ] { cr }
 }block

( 00250C00 )               D# 323 shadow{ 
 }block

( 00251000 )               D# 324 code{ 
 ( t11 suspended power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 ( susp boot- ) [ h# 00000000 h# 00000000 ] ( warm ) [ h# 000000A9
 /frame wos !frame ] }block

( 00251400 )               D# 325 shadow{ 
 }block

( 00251800 )               D# 326 code{ 
 ( study single node + boot power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] }block

( 00251C00 )               D# 327 shadow{ 
 }block

( 00252000 )               D# 328 code{ 
 ( t12a boot power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 }block

( 00252400 )               D# 329 shadow{ 
 }block

( 00252800 )               D# 330 code{ 
 ( t12b boot pwr + drop same ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr { 0000026F } }
 [ h# 0000001C call ] }block

( 00252C00 )               D# 331 shadow{ 
 }block

( 00253000 )               D# 332 code{ 
 ( t12c boot pwr + drop alternating ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr { 0000038F } }
 [ h# 0000001F call ] }block

( 00253400 )               D# 333 shadow{ 
 }block

( 00253800 )               D# 334 code{ 
 ( t12d boot pwr + greg test ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 15 boot ?ram ] { cr }
 [ d# 14 call ] }block

( 00253C00 )               D# 335 shadow{ 
 }block

( 00254000 )               D# 336 code{ 
 ( t12e boot pwr + unext ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 [ d# 0 call ] }block

( 00254400 )               D# 337 shadow{ 
 }block

( 00254800 )               D# 338 code{ 
 ( sram test bd quiet i/o ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 8 hook ] ( all hi ) [ h# 0003557F io ! ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 [ d# 0 d# 705 hook h# 0003FFFF io ! ] { cr }
 [ d# 0 -hook ] }block

( 00254C00 )               D# 339 shadow{ 
 }block

( 00255000 )               D# 340 code{ 
 ( study single node w/boot suspended ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 ( run { 0000000F } ) [ h# 00015555 { 007FFFFF } lit dup dup dup h# 00000021
 call ] { cr }
 ( susp boot- ) [ h# 00000000 h# 00000000 ] ( warm ) [ h# 000000A9
 /frame wos !frame ] }block

( 00255400 )               D# 341 shadow{ 
 }block

( 00255800 )               D# 342 code{ 
 { 0000582F } ( unext w/boot suspended ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 0 d# 705 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 ( run ) [ d# 0 call ] { cr }
 ( susp boot- ) [ h# 00000000 h# 00000000 ] ( warm ) [ h# 000000A9
 /frame wos !frame ] }block

( 00255C00 )               D# 343 shadow{ 
 }block

( 00256000 )               D# 344 code{ 
 ( instr timing code ) [ d# 610 node h# 00000000 org ]
: set h# 0003FFFE h# 0003FFFF d# 999 io b! d# 1 a! ;
: t1 { 000000FD } set push !b begin unext !b ;
: t2 { 0000015D } set push !b begin next !b ;
: t3 { 000001DD } set push !b begin . unext !b ;
: t4 { 0000023D } set push !b begin . . . unext !b ;
: t5 { 000002BD } set push !b begin . . @ unext !b ;
: t6 { 0000033D } set push io a! !b begin . . @ unext !b ;
: t7 { 000003FD } set push !b begin . .. next !b ;
: t8 { 0000049D } set push !b begin . .. . .. next !b ;
: t9 { 0000055D } set push !b begin begin dup or push unext . . . .
 next h# 00000002 !b ; { 0000063D } }block

( 00256400 )               D# 345 shadow{ 
 }block

( 00256800 )               D# 346 code{ 
 ( study instr timing ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 00015555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 00015555 io ! h# 00000000 data !
 pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 00015555 io ! h# 00000000 data
 ! pause ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 0003FFFE lit h# 0003FFFE data ! ] { indent }
      [ h# 00020000 io ! pause ] { cr }
 [ d# 0 h# 00000001 hook focus h# 0003FFFE lit h# 0003FFFE data ! ]
 { indent }
      [ h# 00020000 io ! upd pause ] { cr }
 [ d# 0 d# 705 hook upd d# 0 d# 64 d# 610 boot ?ram ] { cr cr }
: t1 [ h# 00000007 ] call ; { -cr } : t2 [ h# 0000000A ] call ;
: t3 [ h# 0000000E ] call ; { -cr } : t4 [ h# 00000011 ] call ;
: t5 [ h# 00000015 ] call ; { -cr } : t6 [ h# 00000019 ] call ;
: t7 [ h# 0000001F ] call ; { -cr } : t8 [ h# 00000024 ] call ;
: t9 [ h# 0000002A ] call ; }block

( 00256C00 )               D# 347 shadow{ 
 }block

( 00257000 )               D# 348 code{ 
 }block

( 00257400 )               D# 349 shadow{ 
 }block

( 00257800 )               D# 350 code{ 
 }block

( 00257C00 )               D# 351 shadow{ 
 }block

( 00258000 )               D# 352 code{ 
 }block

( 00258400 )               D# 353 shadow{ 
 }block

( 00258800 )               D# 354 code{ 
 }block

( 00258C00 )               D# 355 shadow{ 
 }block

( 00259000 )               D# 356 code{ 
 ( mark mem test all nodes ) { cr }
 [ empty compile serial load panel talk d# 2 { 0000000F } path ] { cr }
 :# tgt 417 :# tport 277 :# times 0 { cr }
 :# runs 3 :# greg 98862 :# /max 98862 :# /tot 0 { br }

: init h# 00000000 [ greg ] ! d# 0 [ times ] ! d# 0 [ runs ] ! d# 0
 [ /max ] ! d# 0 [ /tot ] ! d# 0 [ tgt ] ! d# 0 [ tport ] ! ; [ init ]
 { br }

: xx [ d# 0 ] test d# 0 or if d# -1 + dup [ /max ] @ max [ /max ] !
 [ greg ] ! ( drop ) rip d# 9876 d# 54321 abort then drop ; { br }

: -us ( a-a ) dup @ paths @ or drop ;
: -end ( a-a ) dup @ d# -1 or drop ;
: pt@ paths targets @ + ;
: /go pause [ d# 0 ] d# 64 d# 907 boot pfocus paths targets @ + ( ; )
: //go key? [ d# 1 ] + -us if -end if dup @ dup [ tgt ] ! over d# -1
 + @ wall port dup [ tport ] ! ( pause ) tfocus pause xx ( pause )
 creep //go ; then then drop d# 1 [ runs ] +! rip /go ;
: real { -cr } : jj /go drop rip ; [ d# 776 list ] ( /go ) }block

( 00259400 )               D# 357 shadow{ 
 ( old code, not checked recently. )
: go ( entered with path hooked to initial adjacent node. boots it
 with package and makes it active. )
: //go ( entered with path tbl adr for the active node on stack. )
 }block

( 00259800 )               D# 358 code{ 
 ( mark burn on one weak node ) { cr }
 [ empty compile serial load panel talk d# 2 { 0000000F } path ] { cr }
 :# tgt 710 :# tport 373 :# times 0 { cr }
 :# runs 3 :# greg 0 :# /max 0 :# /tot 0 { cr }
: init h# 00000000 [ greg ] ! d# 0 [ times ] ! d# 0 [ runs ] ! d# 0
 [ /max ] ! d# 0 [ /tot ] ! ; [ init ]
: kk d# 0 d# 64 d# 907 boot pfocus left tfocus ( creep right tfocus )
: //run init pause
: /con key? d# 0 test d# 0 or if dup d# 1 [ times ] +! d# -1 + dup
 [ /max ] @ max [ /max ] ! dup [ greg ] ! [ /tot ] +! then [ greg ]
 ! d# 1 [ runs ] +! [ runs ] @ { 00007D0F } { 0000014F } d# 2 mod dup
 and drop if /con ; then pause /con ;
: /real kk d# 12345 ; [ d# 778 list ] ( /go ) }block

( 00259C00 )               D# 359 shadow{ 
 ( old code, not checked recently. )
: go ( entered with path hooked to initial adjacent node. boots it
 with package and makes it active. )
: //go ( entered with path tbl adr for the active node on stack. )
 }block

( 0025A000 )               D# 360 code{ 
 UNKNOWN UNKNOWN ( polyforth virtual machine ) [ reclaim ] { , , }
 UNKNOWN ( sram cluster mk1 ) [ sram load ] { , }
 UNKNOWN UNKNOWN ( serial ) [ d# 38 fh d# 3 loads reclaim ] { , , }
 ( stack ) [ d# 106 node h# 00000039 org d# 278 load d# 14 fh d# 2
 UNKNOWN loads ] { , }
 UNKNOWN ( coprocs ) [ d# 22 fh d# 4 loads ] { , }
 UNKNOWN ( bitsy ) [ d# 105 node d# 18 fh d# 2 loads ] { , }
 UNKNOWN UNKNOWN ( coprocs ) [ d# 30 fh d# 4 loads ] { , , }
 UNKNOWN ( flash to sram ) [ d# 86 fh d# 2 loads reclaim ] { , }
 UNKNOWN ( erase and burn flash ) [ d# 288 load ] { , }
 UNKNOWN UNKNOWN ( spi speedup ) [ d# 290 load ] { , , }
 UNKNOWN ( serial wires ) [ d# 102 node h# 00000020 org ] { , }
 UNKNOWN: start @ !b start ; { 0000043D } [ d# 1709 bin ] { , }
 UNKNOWN ( ganglia ) [ d# 6 fh load ] ( snorkel ) [ d# 10 fh load ] { , }
 ( spi ) [ d# 44 fh load ] }block

( 0025A400 )               D# 361 shadow{ 
 ( this load block compiles the f18 code for all nodes in the polyforth
 vm. ) }block

( 0025A800 )               D# 362 code{ 
 }block

( 0025AC00 )               D# 363 shadow{ 
 }block

( 0025B000 )               D# 364 code{ 
 }block

( 0025B400 )               D# 365 shadow{ 
 }block

( 0025B800 )               D# 366 code{ 
 UNKNOWN UNKNOWN ( generate ganglia ) { , , }
 UNKNOWN [ d# 700 node h# 00000020 org reclaim ] { , }
 UNKNOWN ( rlud ) r--- --l- ---u -d-- [ d# 2 fh load ] { , }
 UNKNOWN UNKNOWN [ d# 1716 bin ] { 0000081D } { , , }
 UNKNOWN [ d# 701 node h# 00000020 org reclaim ] { , }
 UNKNOWN ( rlud ) --l- r--- ---u -d-- [ d# 2 fh load ] { , }
 UNKNOWN UNKNOWN [ d# 1717 bin ] { 0000081D } { , , }
 UNKNOWN [ d# 600 node h# 00000020 org reclaim ] { , }
 UNKNOWN ( rlud ) r--- --l- -d-- ---u [ d# 2 fh load ] { , }
 UNKNOWN UNKNOWN [ d# 1714 bin ] { 0000081D } { , , }
 UNKNOWN [ d# 601 node h# 00000020 org reclaim ] { , }
 UNKNOWN ( rlud ) --l- r--- -d-- ---u [ d# 2 fh load ] { , }
 [ d# 1715 bin ] { 0000081D } }block

( 0025BC00 )               D# 367 shadow{ 
 UNKNOWN ( background nodes are filled by default with ) { , }
 ( ganglia, routing code in { 0000041F } to { 000007FF } thus they )
 UNKNOWN { , }
 UNKNOWN ( may support either ide or neural messaging ) { , }
 UNKNOWN UNKNOWN ( until node is programmed some other way. ) { , , }
 UNKNOWN UNKNOWN ( routing directions are geographic. ) { , ... }
 UNKNOWN UNKNOWN ( coded direction rlud 0123 ) { , , }
 UNKNOWN UNKNOWN ( four bins hold node orientations... ) { , ... { 0000D68F } { 00000C8F }
 UNKNOWN UNKNOWN UNKNOWN .. { 0000D6AF } { 00000CAF } , ... { 0000D64F } }
 UNKNOWN ( 000 ) { .. { 0000D66F } }
 UNKNOWN UNKNOWN ( 001 ) { , , }
 ( routing note- step count is relative to the node first receiving
 UNKNOWN one of these messages. if ) { , }
 UNKNOWN ( all counts zero will deliver to its neighbor ) { , }
 UNKNOWN ( in direction indicated by two lsb of path. a ) { , }
 ( turn to deliver to right neighbor of turner ) [ is not expressible ]
 UNKNOWN ( because whole field zero. ) { , }
 [ third run must never have count d# 8 or more! ] }block

( 0025C000 )               D# 368 code{ 
 UNKNOWN UNKNOWN ( - ganglion template ) { , , }
 UNKNOWN ( a whence b whither ) { , }
 UNKNOWN UNKNOWN ( msg is focus call path cin-1 cout-1 code ) { , , { 0000041F } }
 ( org rlud r--- --l- ---u -d-- )
: aim { 0000049D } ( p-pa ) dup d# 3 and h# 00000020 or b! @b dup b!
 UNKNOWN !b { , }
 @p ; ( / pump ) leap
 UNKNOWN: whither { 0000055D } ( p ) d# -4 . + aim !b ( path ) !b { , }
 ( cnts ) @ dup push !b @ dup push !b
 UNKNOWN UNKNOWN: payload { 0000061D } begin @ !b unext { , ... }
 begin @b ! unext ;
: /8 { 0000065D } ( n-n ) 2/ 2/ 2/ ;
: pump { 0000067D } then pop a! @ dup
 UNKNOWN UNKNOWN: turn ( pp ) h# 0000003C and if drop whither ; then { , ... }
 UNKNOWN drop dup h# 00000FC0 and if drop /8 /8 dup turn ; { , }
 UNKNOWN then drop aim ( cnts ) @ push @ push payload ; { , }
 { 0000081D } }block

( 0025C400 )               D# 369 shadow{ 
 ( ganglia route messages much like chuck's 'sea' delivers exchanges
 UNKNOWN of { 0000002F } or more word out and ) { , { 0000002F } }
 UNKNOWN ( or more word reply to arbitrary nodes with ) { , }
 UNKNOWN UNKNOWN ( source routing. message structure is... ) { , ,
 UNKNOWN .. }
 UNKNOWN UNKNOWN UNKNOWN focus call ( to port ) [ always there ] { , .. .. }
 UNKNOWN UNKNOWN UNKNOWN pump call [ interganglion only ] { , .. .. }
 UNKNOWN UNKNOWN UNKNOWN path ( see below ) [ inter only ] { , .. .. }
 UNKNOWN UNKNOWN UNKNOWN reply count ( words-1 ) [ inter only ] { , .. .. }
 UNKNOWN UNKNOWN payload count ( words-1 ) [ inter only ] { , .. }
 UNKNOWN UNKNOWN payload [ always there ] { , .. }
 UNKNOWN UNKNOWN reply [ always there ] { , , }
 UNKNOWN ( path has { 0000006F } 6-bit runs low order taken first ) { , }
 UNKNOWN UNKNOWN ( run encoded nnnndd path has 3 runs, ) { , ... }
 UNKNOWN UNKNOWN ( 2-bit direction rlud 0123 ) { , ... }
 UNKNOWN UNKNOWN ( 4-bit count 1-relative zero deliver immed ) { , ...
 UNKNOWN ... }
 UNKNOWN ( 3rd run must be lt { 0000010F } ) { , }
 UNKNOWN UNKNOWN ( example from 708 to 617 go down 1 and right 8 ) { , ... }
 UNKNOWN UNKNOWN ( 8 0 1 3 packed as 807 ) [ in octal. ] { , , }
 UNKNOWN ( when an exchange is finished all ) { , }
 UNKNOWN ( ganglia are back where they were ) { , }
 ( on receipt of focusing call. ) }block

( 0025C800 )               D# 370 code{ 
 ( - snorkel ) [ reclaim d# 108 node d# 0 org ]
: mk! ( fp'm )
: /! ( an-a ) { 0000001D } push dup - !b over - !b pop !b ;
: a+ { 0000007D } ( ap-ap+ ) push d# 1 . + h# 00010000 over and if
 UNKNOWN UNKNOWN { , ... }
 or d# 1 then pop . + ;
 UNKNOWN: +@ { 0000017D } ( a-an ) a+ { * }
: /@ { 0000019D } ( a-an ) dup !b over !b @b ;
 UNKNOWN UNKNOWN: @w { 000001DD } ( a-a'u ) /@ d# 7 for 2* 2* unext { , ... }
 push +@ pop or ;
 UNKNOWN: dma { 0000029D } ( x/r ) a+ @w push +@ push +@ pop begin { ,
 UNKNOWN ... }
 UNKNOWN pop pop dup push over push push drop ex { , }
 next pop drop drop drop ( func ) +@ push ;
: x16 { 0000041D } ( x ) dma /@ ! a+ ;
: r16 { 0000047D } ( x ) dma @ /! a+ ;
: x18 { 000004DD } ( x ) dma @w ! a+ ;
 UNKNOWN UNKNOWN: r18 { 0000053D } ( x ) dma @ dup push d# 7 push { , ... }
 begin 2/ 2/ unext d# 3 and /! a+ pop /! a+ ;
: fin { 0000067D } ( x ) dup /! ( +three ) dup - h# 00008000 mk!
 UNKNOWN: idle { 000006FD } ( begin ) @b d# 2 dup dup or /@ ( until ) { ,
 UNKNOWN ... }
 UNKNOWN push dup /! pop over @w a! ( func ) +@ push ; { , }
 { 0000081D } [ d# 1605 bin reclaim exit ] }block

( 0025CC00 )               D# 371 shadow{ 
 to activate snorkel ( wait till ) [ mmptr ] ( zero then write addr
 UNKNOWN of a ) [ sequence/x ] ( to it and stim. ) { , }
 [ mmptr ] ( zeroed after stim and you may queue 2nd ) [ x ] ( by writing
 UNKNOWN UNKNOWN and posting another stim. ) { , , }
 x ( has { 0000004F } wd ) [ port address ] ( followed by one or more )
 UNKNOWN [ function/arg groups. ] ( all x ) { * }
 UNKNOWN: must { * }
 UNKNOWN UNKNOWN: be ( in bottom 64k of memory! ) { , , }
 function/arg group ( is { 0000002F } word ) [ jump adr ] ( in snork
 UNKNOWN followed by ) [ args ] ( if any. ) [ funcs ] ( are... ) { , }
 UNKNOWN x/r 16/18 ( count18, adr20 ) { , }
 UNKNOWN UNKNOWN fin ( done-flg awaken? ) { , , }
 ( if focusing call desired it must be first word in first transmit. )
 UNKNOWN [ nothing about this code ] { , }
 [ depends on using ganglia ... can source ide or any other reasonable
 protocol including direct stream or ad hoc node to node transfer. ]
 }block

( 0025D000 )               D# 372 code{ 
 }block

( 0025D400 )               D# 373 shadow{ 
 }block

( 0025D800 )               D# 374 code{ 
 ( pf.16 stack ) [ h# 00000000 org ]
: '1+ ( w-w ) { 0000001D } d# 1 . + { -cr } : mask ( w-w ) { 0000005D }
 h# 0000FFFF and ;
: '2/ ( w-w ) { 0000009D } 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt ) { 000000DD } dup '1+ over x@ ;
: 'au! ( pst-p43 ) { 0000011D } x!
: popst ( p-pst ) { 0000013D } popt
: pops ( pt-pst ) { 0000015D } push popt pop ;
: pop43 ( pst-p43st ) { 0000019D } push push popst pop pop ;
: '1- ( w-w ) { 000001DD } d# -1 . + mask ; { 0000023D } [ here h# 00000037
 org ]
: psht ( pt-p ) { 000006FD } push '1- pop over ( x! ; ) { 0000073D }
 ( * ) [ org ]
: pshs ( pst-pt ) { 0000023D } push psht pop ;
: pshw ( pstw-ptw ) { 0000027D } push pshs pop ;
: 'sp! ( ptp-pst ) { 000002BD } pshs popst ;
: 'drop ( pst-p3s ) { 000002FD } drop pops ;
: 'over ( pst-pts ) { 0000031D } over pshw ; { br }

: sco ( x3 ) { 0000033D } 2* -if { cr }
 ( code.sx x4 ) { 0000035D } 2* ( up ) [ h# 00000145 ] -until -d--
 ; { cr }
 ( code.sm x4 ) { 000003BD } then drop push ; { 000003DD } { br { 0000006F } }

 ( words to recover! ) [ h# 00000021 org ] }block

( 0025DC00 )               D# 375 shadow{ 
 ( the stack node abuts the memory driver. note that it includes x@
 and friends. ) { br }

: psht ( is placed so it falls into ) x! { br }

: 'name ( denotes ) vm instructions { cr }
: others ( are internal words ) { br }

 ( the external data stack grows downward, using pre-dec writes post-inc
 reads. ) { cr }
 ( the internal stack holds the vm ) [ stack pointer ] ( and cached )
 [ s ] ( and ) [ t ] { br }

 ( 16-bit words are ) [ 00.nnnn.nnnn.nnnn.nnnn ] }block

( 0025E000 )               D# 376 code{ 
 ( - stack cont'd )
: 'dup ( pst-ptt ) { 0000043D } dup pshw ;
: 'swap ( st-ts ) { 0000045D } over push push drop pop pop ;
: '2* ( w-w ) { 0000049D } 2* mask ;
: 'or ( pst-p3w ) { 000004BD } over - and
: 'xor ( pst-p3w ) { 000004DD } or pops ;
: 'and ( pst-p3w ) { 000004FD } and pops ;
: 'neg ( n-n ) { 0000051D } '1-
: 'inv ( w-w ) { 0000053D } begin - mask ;
: 'zeq ( w-f ) { 0000055D } until begin dup or ;
: 'zlt ( n-f ) { 0000059D } 2* 2* -until dup or 'inv ;
: 'um+ ( uu-uc ) { 000005DD } + h# 00010000 over and if or d# 1 ;
: 'nop { 0000067D } then ( begin ) ;
: 'qdup ( pst-pst/ptt ) { 0000069D } ( until )
: '- ( pst-p3n ) { 0000069D } 'neg
: '+ ( pst-p3n ) { 000006BD } + mask pops ; { cr }
 { 000006FD } [ d# 1700 bin ] }block

( 0025E400 )               D# 377 shadow{ 
 ( notes- ) { indent }
      ( the initial sp is reset by ) [ cold ] { indent }
      ( code must fit before block 740's ) psht { indent }
      ( some optimizations are commented out ) { cr }
 ( so as not to lose the code for use later when/if some code is put
 in rom. ) }block

( 0025E800 )               D# 378 code{ 
 ( pf.16 bitsy ) [ h# 00000000 org ]
: 'else { -cr } : bx@ ( a-w ) { 0000001D } @p !b !b . ( / ) @p x@ ( / )
 { cr }
 @p !b @b ; ( / ) !p . . . ( / )
: bx!- ( aw-a' ) { 0000009D } @p !b !b dup ( / ) @p . . . ( / ) { cr }
 @p !b !b . ( / ) @p x! ( / )
: dec ( a-a' ) { 0000011D } d# -1 . + ;
: @2tos ( a- ) { 0000015D } bx@
: bpshw ( w- ) { 0000017D } @p !b !b ; ( / ) @p pshw ( / )
: 'rp@ ( rip-rip ) { 000001BD } push over bpshw pop ;
: 'lit ( rip-rip' ) { 000001FD } dup @2tos
: inc ( a-a' ) { 0000021D } d# 1 . + ;
: 'con ( rip-rip ) { 0000025D } bx@
: 'var ( rip-rip ) { 0000027D } dup bpshw
: 'exit ( rip-r'i'p' ) { 0000029D } drop push
: popi ( r.p-r'ip ) { 000002BD } inc
: geti ( r.p-rip ) { 000002DD } dup bx@ pop ; { br }

: bpopw ( -w ) { 0000031D } @p !b @b ; ( / ) !p pops ( / )
: 'tor ( rip-rip ) { 0000035D } push bx!- bpopw pop ;
: 'r@ ( rip-rip ) { 000003BD } over bpshw ;
: 'rfrom ( rip-rip ) { 000003DD } push bpshw popi ; }block

( 0025EC00 )               D# 379 shadow{ 
 ( the return stack pointer 'r', top of return stack 'i', and vm instruction
 pointer 'p' live on the stack of the bitsy node. in stack pictures
 . shows return stack on right. ) { br }

 }block

( 0025F000 )               D# 380 code{ 
 ( - bitsy cont'd )
: 'exe ( rip-rip ) { 0000041D } bpopw
: xxt ( ripx-rip ) { 0000043D } dup 2* 2* -if { cr }
 ( code ripx2 ) { 0000047D } 2* -if { cr }
 ( code.b ripx3 ) { 0000049D } 2* -if { cr }
 ( code.bx ripx4 ) { 000004BD } 2* ( up ) [ h# 00000145 ] -until -d--
 ; { cr }
 ( code.bm ripx4 ) { 0000051D } then drop push ; { cr }
 ( code.s ripx3 ) { 0000053D } then @p !b push . ( / ) @p @p . . !b
 pop !b .. @p !b ; .. ( / ) sco .. { cr }
 ( hi rix2 ) { 000005DD } then drop push push bx!- pop pop ;
: run ( rip-rip ) { 0000063D } dup bx@ push inc pop xxt run ; { cr }
: 'if ( rip-rip' ) { 000006BD } bpopw if drop inc ; { cr }
 then drop bx@ ;
: 'rx? { 0000073D } @ bpshw ;
: 'tx? { 0000075D } @p !b @b . ( / ) !p . . @p ( / ) ! @ !b ;
: 'rp! ( rip-rip ) { 000007BD } push bx!- bpopw geti ; { cr }
 { 0000081D } [ d# 1703 bin ] }block

( 0025F400 )               D# 381 shadow{ 
 ( the bit-threaded code technique confines execution to the ) bitsy
 ( loop and a small number of code words. pseudo-instruction format
 is ) { br }

 [ xx.0aaa.aaaa.aaaa.aaaa ] ( high level call ) { cr }
 [ xx.100x.xxaa.aaaa.aaaa ] ( xt in stack node ) { cr }
 [ xx.1010.xxaa.aaaa.aaaa ] ( xt in stack up ) { cr }
 [ xx.1011.xxaa.aaaa.aaaa ] ( xt in stack down ) { cr }
 [ xx.110x.xxaa.aaaa.aaaa ] ( xt in bitsy ) { cr }
 [ xx.1110.xxaa.aaaa.aaaa ] ( xt in bitsy up ) { cr }
 [ xx.1111.xxaa.aaaa.aaaa ] ( xt in bitsy down ) { br }

 ( this version uses sco in stack node to decode all its instructions. )
 { br }

 [ d# 7 word decode for stack node ] { cr }
 ( code.s rix3 ) { 0000051D } then 2* -if { cr }
 ( code.sx rix4 ) { 0000053D } @p !b !b . ( / ) @b sco ( / ) drop ;
 ( code.sm ) { 0000059D } then drop h# 0001A000 or !b ; }block

( 0025F800 )               D# 382 code{ 
 ( stack down bxxx ) [ d# 6 node d# 0 org ]
: xqt { 0000001D } @b push ex
: idle { 0000003D } @p !b xqt ; ( / ) drop !p . . ( / ) { 0000007D }
 { br }

: ''s { 0000007D } @p !b @p . ( / ) pshs ( / ) psht ( / ) { cr }
 !b @p !b ; ( / ) dup pops ; { 0000011D } { br }

: 43xp ( op ) { 0000011D } @p !b !b . ( / ) pop43
: pops; { 0000015D } @p !b ; ( / ) pops ;
: 'ex@ ( pst-p3w ) { 0000019D } @p !b pops; ; ( / ) ex@
: 'ex! ( pst-p54 ) { 000001DD } @p 43xp ; ( / ) ex!
: 'cx? ( pst-p5f ) { 0000021D } @p 43xp ; ( / ) cx?
: 'mk! ( pst-p54 ) { 0000025D } @p 43xp ; ( / ) - ex!
 UNKNOWN: 'sus { 0000029D } @p !b ; ( / ) @b drop ; { , }
 { 000002DD } [ d# 1701 bin ] }block

( 0025FC00 )               D# 383 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

: ex@ ( and friends cost { 0000014F } words, two more than the { 0000010F }
 which they took in the stack node. )
: 'mk! ( msk f { 0000000F } inverts { 0000000F } so ex! can do the
 work. )
: 'sus ( suspends vm waiting for stimulus. ) }block

( 00260000 )               D# 384 code{ 
 }block

( 00260400 )               D# 385 shadow{ 
 }block

( 00260800 )               D# 386 code{ 
 ( stack up axxx ) [ d# 206 node d# 0 org ]
: xqt { 0000001D } @b push ex
: idle { 0000003D } @p !b xqt ; ( / ) drop !p . . ( / ) { 0000007D }
 { cr br }

: start { 0000007D } up b! idle ;
: free { 000000BD } @p !b pop ; ( / ) . ; .. { br }

 { 000000FD } [ d# 1702 bin exit ]
: who { 000000FD } @p !b @b @p ( / ) !p @p ; ( / ) [ d# 206 , ] + !b
 ; }block

( 00260C00 )               D# 387 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

 }block

( 00261000 )               D# 388 code{ 
 }block

( 00261400 )               D# 389 shadow{ 
 }block

( 00261800 )               D# 390 code{ 
 ( bitsy down fxxx ) [ d# 5 node d# 0 org ]
: xqt { 0000001D } @b push ex
: idle { 0000003D } @p !b xqt ; ( / ) drop !p . . ( / ) { 0000007D }
 { br }

: 'next { 0000007D } @p !b @b . ( / ) push dup !p . ( / ) { cr }
 push zif @p !b @p . ( / ) drop inc ( / ) dup bx@ { cr }
 !b @p !b ; ( / ) pop inc ; ( / ) then { cr }
 UNKNOWN pop @p !b @p ( / ) dec ( / ) pop bx@ ; ( / ) !b drop ; { , }
 { 000001FD } [ d# 1704 bin ] }block

( 00261C00 )               D# 391 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

: 'next ( length is { 0000018F } vs { 0000008F } or { 000000AF } in
 bitsy, argh. ) }block

( 00262000 )               D# 392 code{ 
 }block

( 00262400 )               D# 393 shadow{ 
 }block

( 00262800 )               D# 394 code{ 
 ( bitsy up exxx ) [ d# 205 node d# 0 org ]
: xqt { 0000001D } @b push ex
: idle { 0000003D } @p !b xqt ; ( / ) drop !p . . ( / ) { 0000007D }
 { br }

: start { 0000007D } up b! idle ;
: free { 000000BD } @p !b pop ; ( / ) . ; .. { br }

 { 000000FD } [ exit ]
: no-op { 0000007D } @p !b ; .. ( / ) ; .. { 000000BD }
: upop { 000000BD } @p !b ; .. ( / ) bpopw { 000000FD }
: upsh { 000000FD } @p !b ; .. ( / ) bpshw { 0000013D }
: uin { 0000013D } ( -n ) @p !b @b ; ( / ) !p .. { 0000017D }
: uout { 0000017D } ( n ) @p !b !b ; ( / ) @p .. { 000001BD }
 UNKNOWN: uid { 000001BD } upop uin d# 205 . + uout upsh no-op ; { , }
 { 0000029D } [ d# 1705 bin ] }block

( 00262C00 )               D# 395 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

 }block

( 00263000 )               D# 396 code{ 
 }block

( 00263400 )               D# 397 shadow{ 
 }block

( 00263800 )               D# 398 code{ 
 ( serial transmit ) [ d# 100 node h# 00000000 org ]
: !bit ( im-i ) { 0000001D } over and { cr }
 if { 0000000F } ( dumb ) h# 00025555 ( maxim { 006AAABF } ) !b drop
 ; { cr }
 then { 0000002F } ( dumb ) h# 00035555 ( maxim { 004AAABF } ) !b drop
 ;
: putc ( dc-d ) { 000000BD } -
: putchar ( di-d ) { 000000DD } h# 000000FF or 2* { cr }
 d# 9 for { 0000015D } ( 1-start, 8-data, 1-stop bit ) { indent }
      d# 1 !bit 2/ over for . unext { cr }
 next { 000001DD } drop ( weak-pulldown { 002AAABF } !b ) ; { br }

 { 000001FD } [ h# 00000020 org ] ( programmed with abandon )
: start io b! right a! d# 2400 ( est. { 0038400F } baud ) { cr }
 ( stopbit state dumb ) h# 00025555 ( maxim { 006AAABF } ) !b
: wait ( d-.d ) { 000004FD } @ -if ( tx! ) putchar wait ; { indent }
      then ( !io ) up a! ! .. @ right a! wait ; { br }

: send ( cd ) { 000005FD } over putc send ;
: send/ ( d ) { 0000063D } h# 00000040 begin dup push putc { indent }
 UNKNOWN      pop d# 1 . + h# 0000005F and end { , }
 { 0000075D } [ d# 1706 bin ] }block

( 00263C00 )               D# 399 shadow{ 
 ( notes- ) { indent }
      [ tx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. ) { br }

: putchar ( takes a clean inverted octet and transmits it low bit first
 via p17. ) { br }

: wait ( suspends while waiting for inverted character or a new delay
 value. ) { cr indent }
      [ the first terminal operation must set ] { cr }
 [ the delay! ] { indent }
      send ( and ) send/ ( test the bit timing using external loop-back. )
 }block

( 00264000 )               D# 400 code{ 
 ( - receive ) [ d# 200 node h# 00000028 org ]
: @bit ( cm-c ) @b - over - and push and pop or ;
: getc ( d-dc ) { 0000057D } dup begin drop @b -until
: getchar ( dx-dc ) { 000005BD } over 2/ for . unext ( 1/2 bit ) d# 8
 for ( 1-start, 8-data, 1-stop bits ) { indent }
      h# 0001FFFF @bit 2/ over for . unext { cr }
 next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ h# 000000FF and ; { br }

: baud ( n-dd ) { 0000075D } if dup ; then - push { cr }
 { 000007BD } begin @b . -until ( at start-bit of space ) { cr }
 { 000007DD } begin @b - -until ( at 1-bit ) { cr }
 { 000007FD } begin @b . zif then . -until ( at 0-bits ) { cr }
 { 0000083D } begin @b - zif then . -until ( stop-bit ) { cr }
 pop - ( n ) dup 2/ . + ( 1.5n ) dup ; { br }

: auto { 000008DD } a push up a! @ baud ! pop a! dup !
: idle ( d ) { 0000099D } @b -if getchar - { indent }
      @b 2* - -if over ! then drop drop idle ; then h# 00000200 and
 .. if auto ; then drop idle ; { br }

 { 00000B1D } [ h# 00000020 org ] ( programmed with some abandon )
 UNKNOWN: start io b! h# 00005555 !b right a! d# 2400 idle ; { , }
 { 000004FD } [ d# 1707 bin ] }block

( 00264400 )               D# 401 shadow{ 
 ( notes- ) { indent }
      [ rx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received
 characters may have one stop bit. ) { br }

: getchar ( called after seeing leading edge of start bit. returns
 clean inverted character. must be called before start bit begins! )
 { br }

: baud ( space is 1...1'0010.0000'0 ) { indent }
      ( stop bits ---' .hex..20. '--- start ) { br }

: idle }block

( 00264800 )               D# 402 code{ 
 ( - interface ) [ d# 104 node h# 00000020 org ] { cr }
 ( programmed with abandon )
: start io b! right a! ahead
: rx? { 0000049D } h# 00000400 and .. if ( avail ) up a! @ then
: rtn ( w- ) { 0000053D } h# 0000FFFF and right a! ! { cr }
: idle { 000005BD } then @b 2* .. [ ' rx? ] -until { indent }
      ( not read ) 2* [ ' idle ] -until { indent }
      ( write ) @ 2* 2* 2/ 2/ .. -if
: tx! ( c- ) { 0000067D } @b h# 00001000 and if ( full ) drop rtn ;
 { indent }
      ( room ) then left a! over ! rtn ;
: iox ( c- ) { 0000075D } then left a! ! { indent }
 UNKNOWN      up a! begin @ - -until - rtn ; { , }
 { 0000081D } [ d# 1708 bin ] }block

( 00264C00 )               D# 403 shadow{ 
 ( notes- ) { indent }
      idle ( is a polling loop waiting for ) { cr }
 [ right ] ( reading - ) [ rx? ] ( returns ) 16-bit inv { indent }
      character ( from recv queue or ) d# 0 ( if ) { indent }
      ( queue is empty. ) { cr }
 [ right ] ( writing - do ) [ tx! ] ( for ) 16-bit inv { indent }
      character ( or ) [ iox ] ( for ) 16-bit pos { indent }
      bit delay ( input. ) { cr indent }
      [ tx! ] ( returns the ) 16-bit inv character ( when the xmit
 queue is full and ) d# 0 ( otherwise. ) { cr indent }
      [ iox ] ( suspends until it puts the ) 16-bit pos bit delay ( in
 the xmit queue and again while it discards any ) inv characters ( in
 the recv queue before the new ) pos bit delay ( arrives. ) }block

( 00265000 )               D# 404 code{ 
 ( spi flash sst25wf080 ) [ reclaim d# 705 node d# 0 org ]
: entry { 0000001D } pop a! ( delay ) @
 UNKNOWN UNKNOWN: nxt { 0000003D } ( d-d ) @ push ex . nxt ; { , , }
: null { 0000007D } ( d ) dup !
: done { 0000009D } ( d ) -++ !b await ;
: cmd { 000000FD } ( d ) dup select
 UNKNOWN UNKNOWN: out { 0000011D } ( d ) @ for @ 2* 2* 8obits zif { , ... }
 drop ( pop drop ) ; then 8obits drop next ;
: byte { 0000021D } ( d-dw ) dup dup or
 UNKNOWN UNKNOWN: +byte { 0000023D } ( dw-dw ) d# 7 push begin begin { , ... }
 UNKNOWN UNKNOWN UNKNOWN --- !b --+ !b . @b -while { , ... ... }
 drop - 2* - next ; then drop 2* next ;
 UNKNOWN UNKNOWN: bytin { 000003DD } ( d ) @ for byte zif ! done ; { , ... }
 then +byte ! next done ;
 UNKNOWN UNKNOWN: wout { 000004BD } ( d ) @ push .. zif begin { , .. }
 UNKNOWN UNKNOWN select h# 0002B400 8obits drop [ swap ] then { , ..
 UNKNOWN .. }
 UNKNOWN UNKNOWN UNKNOWN @ 2* 2* 8obits 8obits drop select dup { , ... ... }
 UNKNOWN begin drop @b -until drop next null ; { , }
 { 0000067D } [ d# 1606 bin reclaim ] }block

( 00265400 )               D# 405 shadow{ 
 UNKNOWN ( timing roughly { 000006AF } ns 19.2 mhz read clock ) { , }
 UNKNOWN ( clk low 16.5 ns 30. mhz so this is good for ) { , }
 UNKNOWN ( all sst25wfxxx parts as well. with mk1 sram ) { , }
 UNKNOWN UNKNOWN ( we get { 0000456F } us block read time. ) { , , }
 UNKNOWN ( registers b-io a-boss t-delay r-cmd. command ) { , }
 UNKNOWN UNKNOWN ( stream starts with dly and then funcs... ) { , , }
: done ( deselect ) [ and end operation. ]
: null ( does so after sending a dummy byte in. )
: cmd ( selects and pumps a command )
: out ( given nbyt-1 sends nbyt bytes to device. )
 UNKNOWN UNKNOWN: bytin ( given nbyt-1 receives nbyt bytes from ) { , ... }
 ( the device ) [ and ends operation. ]
 UNKNOWN UNKNOWN: wout ( given nwds writes nwds 16-bit words to ) { , ... }
 UNKNOWN UNKNOWN ( the device in aai mode. used immed after ) { , ... }
 ( address, should be followed by wrdi rdsr. ) }block

( 00265800 )               D# 406 code{ 
 UNKNOWN ( minimal spi ) [ reclaim d# 705 node d# 0 org ] { , }
 ( working before speed up )
: entry { 0000001D } pop a! ( delay ) @
 UNKNOWN UNKNOWN: nxt { 0000003D } ( d-d ) @ push ex . nxt ; { , , }
: null { 0000007D } ( d ) dup !
: done { 0000009D } ( d ) -++ !b await ;
: cmd { 000000FD } ( d ) dup select
 UNKNOWN UNKNOWN: out { 0000011D } ( d ) @ for @ 2* 2* 8obits zif { , ... }
 drop ; then 8obits drop next ;
: byte { 0000021D } ( d-dw ) dup dup or
: +byte { 0000023D } ( dw-dw ) d# 7 push ibits ;
 UNKNOWN UNKNOWN: bytin { 0000029D } ( d ) @ for byte zif ! done ; { , ... }
 UNKNOWN then +byte ! next done ; { , }
 { 0000037D } [ d# 1606 bin reclaim ] }block

( 00265C00 )               D# 407 shadow{ 
 ( minimal code but slow; timing roughly { 0000080F } ns or 15.4 mhz
 read clock, low { 000003EF } ns; write { 0000098F } ns or 13.2 mhz.
 when delay is zero. addl delay about { 0000008F } ns per count. )
 UNKNOWN { , }
 UNKNOWN UNKNOWN ( command stream starts with dly and then funcs ) { , , }
: done ( deselect ) [ and end operation. ]
: null ( does so after sending a dummy byte in. )
: cmd ( selects and pumps a command )
: out ( given nbyt-1 sends nbyt bytes to device. )
 UNKNOWN UNKNOWN: bytin ( given nbyt-1 receives nbyt bytes from ) { , ... }
 ( the device ) [ and ends operation. ] }block

( 00266000 )               D# 408 code{ 
 }block

( 00266400 )               D# 409 shadow{ 
 }block

( 00266800 )               D# 410 code{ 
 }block

( 00266C00 )               D# 411 shadow{ 
 }block

( 00267000 )               D# 412 code{ 
 }block

( 00267400 )               D# 413 shadow{ 
 }block

( 00267800 )               D# 414 code{ 
 }block

( 00267C00 )               D# 415 shadow{ 
 }block

( 00268000 )               D# 416 code{ 
 }block

( 00268400 )               D# 417 shadow{ 
 }block

( 00268800 )               D# 418 code{ 
 }block

( 00268C00 )               D# 419 shadow{ 
 }block

( 00269000 )               D# 420 code{ 
 }block

( 00269400 )               D# 421 shadow{ 
 }block

( 00269800 )               D# 422 code{ 
 }block

( 00269C00 )               D# 423 shadow{ 
 }block

( 0026A000 )               D# 424 code{ 
 }block

( 0026A400 )               D# 425 shadow{ 
 }block

( 0026A800 )               D# 426 code{ 
 }block

( 0026AC00 )               D# 427 shadow{ 
 }block

( 0026B000 )               D# 428 code{ 
 }block

( 0026B400 )               D# 429 shadow{ 
 }block

( 0026B800 )               D# 430 code{ 
 }block

( 0026BC00 )               D# 431 shadow{ 
 }block

( 0026C000 )               D# 432 code{ 
 }block

( 0026C400 )               D# 433 shadow{ 
 }block

( 0026C800 )               D# 434 code{ 
 }block

( 0026CC00 )               D# 435 shadow{ 
 }block

( 0026D000 )               D# 436 code{ 
 }block

( 0026D400 )               D# 437 shadow{ 
 }block

( 0026D800 )               D# 438 code{ 
 }block

( 0026DC00 )               D# 439 shadow{ 
 }block

( 0026E000 )               D# 440 code{ 
 }block

( 0026E400 )               D# 441 shadow{ 
 }block

( 0026E800 )               D# 442 code{ 
 }block

( 0026EC00 )               D# 443 shadow{ 
 }block

( 0026F000 )               D# 444 code{ 
 }block

( 0026F400 )               D# 445 shadow{ 
 }block

( 0026F800 )               D# 446 code{ 
 UNKNOWN UNKNOWN ( - sram loader nodes ) { , , }
 ( wires ) [ d# 605 node d# 0 org ]
 UNKNOWN: wire ( b! a! ) @ dup !b for @ !b unext warm ; { , }
 UNKNOWN UNKNOWN { 0000009D } [ d# 1711 bin ] { , , }
 UNKNOWN ( sram loader node { 00000D8F } ) { , }
 UNKNOWN [ d# 108 node h# 00000039 org d# 278 load ] { , }
 UNKNOWN [ d# 0 org ] { * }
 UNKNOWN: start { 0000001D } up a! left b! { , }
 UNKNOWN d# 0 @ dup push over x! { , }
 UNKNOWN begin d# 1 . + @ over x! next warm ; { , }
 { 000001BD } [ d# 1713 bin ] }block

( 0026FC00 )               D# 447 shadow{ 
 ( minimal version of plumbing for sram boot from flash. wires are
 UNKNOWN compiled only once and are ) { , }
 UNKNOWN ( initialized with source port in a and dest ) { , }
 UNKNOWN UNKNOWN ( port in b. ) { , , }
 ( message consists of word count n-1 followed by n words to be passed
 UNKNOWN UNKNOWN along. ) { , , }
 UNKNOWN ( node { 00000D8F } now loads the image received from ) { , }
 UNKNOWN ( flash into sram. { 00001A0F } is just another wire ) { ,
 UNKNOWN , }
 UNKNOWN ( however, the generic sram interface code is ) { , }
 UNKNOWN ( compiled at the usual place anyway, so this ) { , }
 UNKNOWN ( bin can be used by both the streamer and the ) { , }
 ( ide ) }block

( 00270000 )               D# 448 code{ 
 ( - spi flash { 0000010F } bits ) [ d# 705 node d# 0 org host ]
: resume nnc d# 2 * h# 00008000 + block @ h# 000FFFFF and { indent }
      d# 18 d# 8 */ d# 4 * lit ; [ target ]
: wait ( dw-dw ) { 0000001D } select dup begin drop @b -until drop
 select ;
: 2cmd ( dw-d ) { 0000009D } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 0000013D } io b! ( fast ) d# 5 ;
: fet ( ah al-d ) { 0000019D } push push set ( read ) h# 00000C00 cmd
 pop !8 pop 8obits !8 ;
: 16ibits ( d-db ) { 0000025D } dup d# 15 for { cr }
 rbit ibit - next h# 0000FFFF and ;
: start { 0000033D } down a! d# 0 h# 00020000 fet { cr }
 16ibits dup ! for 16ibits ! next { indent }
      resume fet 18ibits h# 0001E000 . + - -if
: done io b! d# 20 d# 20 -++ half warm ; then { cr }
 d# 5 resume push spicmd spi-boot ; { cr }
 { 0000069D } [ d# 1710 bin ] }block

( 00270400 )               D# 449 shadow{ 
: start ( 1st word read is count in words ) }block

( 00270800 )               D# 450 code{ 
 UNKNOWN ( polyforth ide boot ) [ host load loader load ] { , }
 ( kill boots ) [ d# 0 d# 708 hook d# 0 -hook ]
 UNKNOWN UNKNOWN: s1+ ( nm-mn' ) swap [ d# 1 ] + ; { , , }
 UNKNOWN ( custom routes ) [ d# 2 fh load sram d# 4 + load ] { , }
 UNKNOWN UNKNOWN ( select ) [ pfp0 'pths ! pfp1 'pths d# 1 + ! ] { , ... }
 UNKNOWN [ s708 'pths d# 2 + ! ] { , }
 UNKNOWN UNKNOWN ( vm build tools ) [ d# 4 fh load d# 12 fh load ] { , , }
 UNKNOWN ( sram ) [ d# 6 fh load d# 1 ship ] { , }
 UNKNOWN: !img ( n ) push [ fbuf ] d# 0 begin over 2@ swab { , }
 over sm swap [ d# 2 ] + s1+ next drop drop ;
 UNKNOWN UNKNOWN: !nuc [ chr ] @ 2/ [ d# 1 ] + !img ; { , ... }
 UNKNOWN [ d# 1 d# 108 hook !nuc ] { . }
 UNKNOWN UNKNOWN [ unfoc d# 1 -hook ] { , , }
 UNKNOWN ( rest ) [ d# 470 load ] { . }
 UNKNOWN [ d# 2 ship ] { . }
 UNKNOWN [ panel upd ?ram ] { , }
 }block

( 00270C00 )               D# 451 shadow{ 
 ( customize ide for polyforth development. ) { br }

: pf ( loads polyforth f18 code, nucleus in sram, and starts it up. )
 { br }

 < ***no canonical opcodes*** > { cr }
 [ use the ] 'remote' [ ones ] }block

( 00271000 )               D# 452 code{ 
 UNKNOWN UNKNOWN ( - custom ide paths ) { , , }
 UNKNOWN: pfp0 align create [ d# 708 d# 707 to d# 607 d# 207 to ] { , }
 UNKNOWN UNKNOWN [ d# 206 d# 205 to d# -1 , ] { , , }
 UNKNOWN: pfp1 align create ( sram ) [ d# 708 d# 108 to d# 107 d# 7 to ] { , }
 [ d# 8 d# 9 to d# -1 , ] }block

( 00271400 )               D# 453 shadow{ 
 ( paths { 0000000F } and { 0000002F } are customized for interactive
 UNKNOWN UNKNOWN devel and testing of polyforth. ) { , , }
: pfp0 ( is not used by the loading procedures and is available for
 detailed application testing. if more paths are needed in testing,
 UNKNOWN UNKNOWN stuff new path vectors after ) pf ( is loaded. ) { , , }
: pfp1 ( is used after reset to load and start the sram cluster, then
 boot sram as needed. ) }block

( 00271800 )               D# 454 code{ 
 ( - sram user code from nodes 106, 108, { 000019EF } )
: 2lit' ( nn- ) swap lit' lit' ;
: sm ( wa- ) 2lit' [ h# 00000039 ] ( x! ) call ;
: sem ( wap- ) push 2lit' pop lit' [ h# 0000003A ] ( ex! ) call ;
: fm ( a-w ) lit' [ h# 0000003C ] ( x@ ) call
: get ( -w ) upd [ stak ] @ rdrop ;
: fem ( ap-w ) 2lit' [ h# 0000003D ] ( ex@ ) call get ;
: 4lit' ( nnnn- ) push push 2lit' pop pop 2lit' ;
: cxm ( wapw-f ) 4lit' [ h# 0000003E ] ( cx? ) call get ; { cr cr }
 ( sram test code )
: fmem ( ap-... ) d# 8 for push dup i fem { indent }
      s1+ pop next drop drop ;
: smem ( wapn- ) for push over over i sem { indent }
      s1+ s1+ pop next drop drop drop ;
: n2x ( wapn- ) 4lit' [ h# 00000042 ] ( n2x ) call ;
: nqx ( wapn- ) 4lit' [ h# 0000004A ] ( nqx ) call ; { br }

 }block

( 00271C00 )               D# 455 shadow{ 
 ( this tester code assumes the ide is hooked to one of the sram user
 nodes. ) }block

( 00272000 )               D# 456 code{ 
 ( - ph0 sram setup ) { br }

 ( kill boot nodes { 0000004F } { 0000004F } hook { 0000004F } -hook { 0000002F }
 path ) { br }

 ( sram setup ) [ sram d# 2 + load ] { br }

 ( temporary ) [ d# 108 +node d# 1713 /ram left /b ] }block

( 00272400 )               D# 457 shadow{ 
 ( load sram cluster for booting pf nucleus ) { br }

 ( this is done with ide path { 0000002F } from { 0000588F } down to { 00000D8F }
 before any of the rest of the chip is set up. ) { br }

 ( after it's completed, the whole rest of the chip can be booted using
 the serpentine path 2. this relatively byzantine method is used instead
 of simply reloading the sram with a more regular path so that the
 methods will still work with external dram. ) { br }

 ( this block leaves path { 0000002F } connected to sram for use by
 !pf ) }block

( 00272800 )               D# 458 code{ 
 }block

( 00272C00 )               D# 459 shadow{ 
 }block

( 00273000 )               D# 460 code{ 
 UNKNOWN UNKNOWN ( install pf in flash ) [ empty ] { , , }
 UNKNOWN [ compile streamer load ] { , }
 UNKNOWN UNKNOWN [ d# 0 fh loaded ! nores ] { , , }
 UNKNOWN UNKNOWN ( read pfdisk.blk ) [ d# 2 fh load ] { , ... }
 UNKNOWN [ fbuf source ! d# 4607 len ! ] { , }
 UNKNOWN UNKNOWN ( display nuc length ) { , ... }
 UNKNOWN UNKNOWN [ len @ d# 1 + d# 2 * d# 8 d# 18 */ leng ! ] { , , }
 UNKNOWN UNKNOWN [ h# 00008000 stream nip ers ] { , ... }
 UNKNOWN UNKNOWN ( burn nucleus ) [ stream h# 00008000 swap burn ] { , , }
 ( generate boot stream ) [ d# 4 fh load ] }block

( 00273400 )               D# 461 shadow{ 
 ( load this block to install polyforth for flash booting. just follow
 UNKNOWN UNKNOWN instructions. ) { , , }
 UNKNOWN ( burns nucleus to flash starting at 32k then ) { , }
 ( generates and burns full chip boot stream. ) }block

( 00273800 )               D# 462 code{ 
 ( - read pf nucleus ) :# ft 0 :# chr 9216
 UNKNOWN: a-b ( a-b ) 2* 2* ; { * }
 UNKNOWN: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ; { , }
 UNKNOWN: fbuf ( -a ) [ nnc d# 2 * h# 00008000 + block a-b ] ; { ,
 UNKNOWN , }
 UNKNOWN: +pf [ d# 0 fnam b-a ] r/o fopen if [ ft ] ! ; { , }
 then drop abort ;
 UNKNOWN: -pf [ ft ] @ [ d# 0 ] + if fclose d# 0 then [ ft ] ! ; { ,
 UNKNOWN , }
 UNKNOWN: @nuc +pf [ fbuf ] d# 9216 [ ft ] @ frd [ chr ] ! -pf ; { ,
 UNKNOWN , }
 UNKNOWN UNKNOWN [ named ] ( pf/pfdisk.blk ) { , , }
 [ @nuc ] }block

( 00273C00 )               D# 463 shadow{ 
 }block

( 00274000 )               D# 464 code{ 
 ( - burn pf boot stream ) { cr }
 [ empty ] ( 1st pass ) [ compile streamer load ] { cr }
 [ framer load ] ( the stream ) [ d# 2 fh load ] { br }

 [ empty ] ( 2nd pass ) [ compile streamer load ] { cr }
 [ framer load ] ( the stream ) [ d# 2 fh load ] { br }

 [ d# 0 fh loaded ! ] { cr }
 ( write stream into flash ) { cr { 0000000F } }
 ( stream nip ers ) { cr }
 UNKNOWN ( display stream length ) [ strlen leng ! ] { , }
 [ stream d# 0 swap 18burn ] }block

( 00274400 )               D# 465 shadow{ 
 ( pf stream ) { br }

 ( two passes required to calculate address ) { cr }
 ( to resume booting from after loading sram ) { cr }
 ( and compile it into node { 0000582F } ) }block

( 00274800 )               D# 466 code{ 
 ( -- generate pf stream ) { br }

 ( speedup ) { indent }
      [ d# 0 d# 0 d# 3 d# 1608 /root ] { br }

 ( default ) [ entire course ] { cr }
 UNKNOWN ( sram driver ) [ sram d# 2 + load ] { , }
 UNKNOWN ( flash to sram ) [ d# 2 fh load ] { , }
 UNKNOWN UNKNOWN [ frame adjust ] ( resume point ) { , , }
 UNKNOWN [ fresh ] ( residual ) [ sram d# 4 + load s705 course ] { ,
 UNKNOWN ... }
 UNKNOWN UNKNOWN ( rest of chip ) [ d# 470 load ] { , ... }
 UNKNOWN ( retain asynch boot ) [ d# 708 +node h# 000000AA /p ] { ,
 UNKNOWN , }
 [ frame ] }block

( 00274C00 )               D# 467 shadow{ 
 }block

( 00275000 )               D# 468 code{ 
 UNKNOWN ( --- load polyforth nucleus ) { , }
 UNKNOWN: /nwire ( in out ) /b /a d# 0 d# 4 [ d# 1711 ] /part d# 0 /p ; { ,
 UNKNOWN , }
 UNKNOWN [ d# 705 +node d# 1710 /ram h# 00000019 /p ] { , }
 UNKNOWN [ d# 605 +node down left /nwire ] { , }
 UNKNOWN [ d# 606 +node left right /nwire ] { , }
 UNKNOWN [ d# 607 +node right left /nwire ] { , }
 UNKNOWN [ d# 608 +node left up /nwire ] { , }
 UNKNOWN [ d# 508 +node up down /nwire ] { , }
 UNKNOWN [ d# 408 +node down up /nwire ] { , }
 UNKNOWN [ d# 308 +node up down /nwire ] { , }
 UNKNOWN [ d# 208 +node down up /nwire ] { , }
 [ d# 108 +node d# 1713 /ram left /b d# 0 /p ] }block

( 00275400 )               D# 469 shadow{ 
 }block

( 00275800 )               D# 470 code{ 
 UNKNOWN ( pf load descriptors ) { , }
: l, ( nn ) dup +node d# 100 /mod d# 1 and 2* swap d# 1 and + d# 1714
 + push d# 32 d# 32 pop /part ( warm ) h# 000000A9 /p ;
 UNKNOWN UNKNOWN: ganglia nns for i d# -1 + n-nn l, next ; { , , }
 UNKNOWN ( sea of ) [ ganglia ] { , }
 UNKNOWN ( snorkel ) [ d# 108 +node d# 1605 /ram left /b h# 00000037 /p ] { ,
 UNKNOWN , }
 UNKNOWN ( sram cluster mk1 ) [ sram d# 2 + load ] { , }
 UNKNOWN ( virtual machine ) [ d# 2 fh load ] { , }
 UNKNOWN ( serial terminal ) [ d# 4 fh load ] { , }
 ( additional i/o ) [ d# 6 fh load ] }block

( 00275C00 )               D# 471 shadow{ 
 ( this block describes entire chip's loading for polyforth boot environment. )
 UNKNOWN UNKNOWN { , , }
 UNKNOWN ( suitable for use with ide loader, streamer, ) { , }
 UNKNOWN UNKNOWN ( and softsim. ) { , , }
 ( all nodes not otherwise programmed are loaded with ganglia for ad
 UNKNOWN UNKNOWN hoc routing. ) { , , }
 ( the sram cluster is invoked here for complete documentation although
 UNKNOWN it has been loaded ) { , }
 ( earlier and is excluded from the path used by the main stream. )
 }block

( 00276000 )               D# 472 code{ 
 ( - virtual machine ) { br }

 ( buds ) [ d# 205 +node d# 1705 /ram up /b d# 1 /p ] { indent }
      [ d# 5 +node d# 1704 /ram down /b d# 1 /p ] { indent }
      [ d# 206 +node d# 1702 /ram up /b right { 0000002F } /p ] { indent }
      [ d# 6 +node d# 1701 /ram down /b d# 1 /p ] { br }

 ( bitsy ) [ d# 105 +node d# 1703 /ram ] { indent }
      [ h# 0000FFE0 h# 00015555 ] ( 'cold ) [ d# 1 d# 3 /stack ] { indent }
      [ left /b right /a h# 00000031 /p ] { br }

 ( stack ) [ d# 106 +node d# 1700 /ram ] { indent }
      [ h# 0000FFFF d# 0 d# 0 d# 3 /stack ] { indent }
      [ right /b left /p ] }block

( 00276400 )               D# 473 shadow{ 
 }block

( 00276800 )               D# 474 code{ 
 ( - serial terminal ) { br }

: /wire ( io ) h# 00000020 d# 1 [ d# 1709 ] /part /b /a [ h# 00000020 ]
 /p ; { br }

 [ d# 104 +node d# 1708 /ram h# 00000020 /p ] { cr }
 [ d# 103 +node left right /wire ] { cr }
 [ d# 102 +node right left /wire ] { cr }
 [ d# 101 +node left right /wire ] { cr }
 [ d# 100 +node d# 1706 /ram h# 00000020 /p ] { br }

 [ d# 204 +node left up /wire ] { cr }
 [ d# 203 +node right left /wire ] { cr }
 [ d# 202 +node left right /wire ] { cr }
 [ d# 201 +node right left /wire ] { cr }
 [ d# 200 +node d# 1707 /ram h# 00000020 /p ] }block

( 00276C00 )               D# 475 shadow{ 
 }block

( 00277000 )               D# 476 code{ 
 UNKNOWN ( - additional i/o ) { , }
 ( spi ) [ d# 705 +node d# 1606 /ram io /b h# 000000A9 /p ] }block

( 00277400 )               D# 477 shadow{ 
 }block

( 00277800 )               D# 478 code{ 
 }block

( 00277C00 )               D# 479 shadow{ 
 }block

( 00278000 )               D# 480 code{ 
 ( g144a12 ats test components ) { br }

 ( pkg { 0000FA0F } to { 0000FC2F } ) [ d# 482 d# 18 loads ] { cr }
 ( pkg { 0001068F } to { 000108AF } ) [ d# 518 d# 18 loads ] { cr }
 ( pkg { 0001130F } to { 0001140F } ) [ d# 554 d# 9 loads ] { br }

 ( ats/ide parts { 0000960F } to { 000096CF } ) [ d# 630 d# 7 loads ]
 { br }

 ( steven mem-random xxxx { 0000480F } { 0000002F } loads ) { cr { 0000AF0F } }
 ( to { 0000AF0F } { 0000510F } { 0000002F } loads ) }block

( 00278400 )               D# 481 shadow{ 
 }block

( 00278800 )               D# 482 code{ 
 { 0000FA0F } ( port tests ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000001B org ]
: release { 0000037D } @p ! ; ( / ) ; ( / )
: bit { 000003BD } ( n-nn ) @p ! dup dup ( / ) @p !p .. ( / ) { cr }
 ! @ or ;
: walk { 0000041D } ( n ) d# 17 for bit if pop !b pop { cr }
 release ; then drop 2* next drop ; { cr }
 { 0000051D } [ d# 4 org ] { -cr } : ftst a h# 000001FF and h# 00013400
 or
: tst { 0000011D } ( cport ) dup a! ! { cr }
 h# 00015554 dup walk dup - walk release dup or !b ;
: trd { 000001FD } leap ( tr ) { -cr } : td { 0000021D } @p tst ; -d--
: tdr { 0000025D } td { -cr } : tr { 0000027D } then @p tst ; r---
: tdl { 000002BD } td { -cr } : tl { 000002DD } @p tst ; --l-
: tru { 0000031D } tr { -cr } : tu { 0000033D } @p tst ; ---u { cr }
 { 0000037D } [ d# 2000 bin ] }block

( 00278C00 )               D# 483 shadow{ 
 ( port tests )
: bit ( send and receive 1 bit pattern via port )
: walk ( test with pattern shifted left { 0000024F } times )
: tst ( focus neighbor with a call then ) { cr }
 ( walk with { 0000002F } bit set and { 0000002F } bit clear ) { cr }
 ( shifting left on the test node )
: release ( causes node under test to return . ) { cr }
 ( error code { 0000000F } for success , ) { cr }
 ( loop index for failure ) { cr }
 parameter ( is ignored ) { br }

 tests ( on single neighbor and on pairs ) { cr }
 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 [ h# 00000013 ] ( tests the ) [ right ] ( neighbor ) { cr }
 [ h# 00000010 ] ( tests the ) [ down ] ( neighbor ) { cr }
 [ h# 00000016 ] ( tests the ) [ left ] ( neighbor ) { cr }
 [ h# 00000019 ] ( tests the ) [ up ] ( neighbor ) { cr }
 [ h# 00000015 ] ( tests the ) [ down ] ( and ) [ left ] ( neighbors )
 { cr }
 [ h# 00000012 ] ( tests the ) [ down ] ( and ) [ right ] ( neighbors )
 { cr }
 [ h# 00000018 ] ( tests the ) [ right ] ( and ) [ up ] ( neighbors )
 { cr }
 [ h# 0000000F ] ( tests the ) [ right ] ( and ) [ down ] ( neighbors )
 }block

( 00279000 )               D# 484 code{ 
 { 0000FA2F } ( port tests with 2* ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000001B org ]
: release { 0000037D } @p ! ; ( / ) ; ( / )
: bit { 000003BD } ( n-nn ) @p ! dup dup ( / ) @p 2* !p .. ( / ) { cr }
 ! 2* @ or ;
: walk { 0000043D } ( n ) d# 17 for bit if pop !b pop { cr }
 release ; then drop 2* next drop ; { cr }
 { 0000055D } [ d# 4 org ] { -cr } : ftst a h# 000001FF and h# 00013400
 or
: tst { 0000011D } ( cport ) dup a! ! { cr }
 h# 00015554 dup walk dup - walk release dup or !b ;
: trd { 000001FD } { -cr }  leap ( tr ): td { 0000021D } @p tst ; -d--
: tdr { 0000025D } td { -cr } : tr { 0000027D } then @p tst ; r---
: tdl { 000002BD } td { -cr } : tl { 000002DD } @p tst ; --l-
: tru { 0000031D } tr { -cr } : tu { 0000033D } @p tst ; ---u { cr }
 { 0000037D } [ d# 2001 bin ] }block

( 00279400 )               D# 485 shadow{ 
 ( port tests )
: bit ( send and receive 1 bit pattern via port )
: walk ( test with pattern shifted left { 0000024F } times )
: tst ( focus neighbor with a call then ) { cr }
 ( walk with { 0000002F } bit set and { 0000002F } bit clear )
: release ( causes node under test to return . ) { cr }
 ( error code { 0000000F } for success , ) { cr }
 ( loop index for failure ) { cr }
 parameter ( is ignored ) { br }

 tests ( on single neighbor and on pairs ) { cr }
 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 [ h# 00000013 ] ( tests the ) [ right ] ( neighbor ) { cr }
 [ h# 00000010 ] ( tests the ) [ down ] ( neighbor ) { cr }
 [ h# 00000016 ] ( tests the ) [ left ] ( neighbor ) { cr }
 [ h# 00000019 ] ( tests the ) [ up ] ( neighbor ) { cr }
 [ h# 00000015 ] ( tests the ) [ down ] ( and ) [ left ] ( neighbors )
 { cr }
 [ h# 00000012 ] ( tests the ) [ down ] ( and ) [ right ] ( neighbors )
 { cr }
 [ h# 00000018 ] ( tests the ) [ right ] ( and ) [ up ] ( neighbors )
 { cr }
 [ h# 0000000F ] ( tests the ) [ right ] ( and ) [ down ] ( neighbors )
 }block

( 00279800 )               D# 486 code{ 
 { 0000FA4F } ( extensive ram test jeff ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000028 org ]
: err [ d# 4 org ]
: test ( n1 ) @p ! @p dup ( ' ) h# 0000003F push dup dup { cr }
 ! @p ! ( ' ) or dup a! . { cr }
 @p ! ( ' ) begin dup !+ unext .. { 0000017D } ( erased ) { cr }
 for { br }

 h# 00019999 @p ! dup ( ' ) @p ! @ . { cr }
 ! @p ! . ( ' ) !b @p ! { cr }
 @ or if { 0000025D } pop err ; then { 0000027D } ( test1 ) { cr }
 h# 0000CCCC dup ! @p ( ' ) @ !b dup dup { cr }
 ! @ or if { 0000031D } pop err ; then { 0000033D } ( 0 test2 ) { cr }
 @p ! . ( ' ) or ! . ( erased ) { br }

 drop @p ! @p ( ' ) dup ( 0 0 ) - { 007FFFFF } ! h# 0000003E { cr }
 ! @p ! ( ' ) @+ !b push { 0000001F } { cr }
 @ - if { 0000043D } pop err ; then { 0000045D } ( test3 ) { cr }
 drop @p ! ( ' ) begin @+ !b unext . { 0000001F } { cr }
 h# 0000003E for @ if pop pop
: err { 0000051D } d# 1 + !b ; then { 0000055D } ( test4 ) { cr }
 drop next { cr }
 @p ! . . ( ' ) dup !+ . next ( erased ) { cr }
 dup dup or !b ; { 0000061D } [ d# 2002 bin ] }block

( 00279C00 )               D# 487 shadow{ 
 ( test tests neighbor's memory ) { br }

 ( tests the tfocused node node's ram. ) { cr }
 [ apocryphal documentation follows ] { br }

 ( 19999 cccc test shorts to bits two bits away ) { cr }
 ( 3ffff { 0000001F } test shorts to bits one bit away ) { cr }
 ( tests for shorts between two addresses ) { cr }
 ( by reading { 0000080F } words after each { 007FFFFF } ! ) { cr }
 }block

( 0027A000 )               D# 488 code{ 
 { 0000FA6F } ( testing t and s ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000020 org ]
: echo { 0000041D } ( n-n ) @p ! dup .. ( / ) @p - dup .. ( / ) { cr }
 ! @p ! .. ( / ) drop !p .. ( / ) - @ or ; [ d# 4 org ]
: test { 0000009D } ( n ) d# 17 for dup echo { cr }
 if pop d# 1 . + !b ; then drop 2* next { cr }
 dup or !b ; { 000001DD } [ d# 2003 bin ] }block

( 0027A400 )               D# 489 shadow{ 
 ( testing t and s ) { br }

 ( intended to isolate testing to t and s ) { cr }
 ( non-zero return value identifies bad bit ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) { cr }
 ( loop index for failure ) }block

( 0027A800 )               D# 490 code{ 
 { 0000FA8F } ( testing t and r ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000020 org ]
: echo { 0000041D } ( n-n ) @p ! dup .. ( / ) @p - push .. ( / ) { cr }
 ! @p ! .. ( / ) pop !p .. ( / ) - @ or ; [ d# 4 org ]
: test { 0000009D } ( n ) d# 17 for dup echo { cr }
 if pop d# 1 . + !b ; then drop 2* next { cr }
 dup or !b ; { 000001DD } [ d# 2004 bin ] }block

( 0027AC00 )               D# 491 shadow{ 
 ( testing t and s ) { br }

 ( intended to isolate testing to t and r ) { cr }
 ( non-zero return value identifies bad bit ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) { cr }
 ( loop index for failure ) }block

( 0027B000 )               D# 492 code{ 
 { 0000FAAF } ( testing stack registers ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load d# 6 org ]
: put ( n ) @p ! ! ; ( / ) @p .. ( / )
: get ( -n ) @p ! @ ; ( / ) !p .. ( / )
: stack { 0000015D } d# 1 d# 9 for dup put 2* next { cr }
 d# 9 for 2/ get over or if pop d# 1 . + !b { cr }
 pop ; then drop next ; { 0000031D } [ d# 4 org ]
: start ( n ) stack dup or !b ; { 000000DD } [ d# 2005 bin ] }block

( 0027B400 )               D# 493 shadow{ 
 ( testing stack registers ) { br }

 ( fill the stack registers with unique ) { cr }
 ( numbers and read them back. error code ) { cr }
 ( identifies the register that failed the test. ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) { cr }
 ( loop index for failure ) }block

( 0027B800 )               D# 494 code{ 
 { 0000FACF } ( testing return stack registers ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] { 0000009D } ahead
: !error ( n ) d# 1 !b ;
: put { 000000FD } ( n ) @p ! ! ; ( / ) @p push .. ( / )
: get { 0000013D } ( -n ) @p ! @ ; ( / ) pop !p .. ( / )
: fill { 0000017D } ( n-n ) d# 8 for - dup put next ;
: check { 0000023D } ( n-f ) leap - then fill - { cr }
 d# 9 for - get over or .. if !error pop ; { cr }
 then drop next ;
: test ( n ) then d# 0 check h# 00015555 check { cr }
 ( .. ) h# 00019999 check h# 00033333 check { cr }
 ( .. ) dup or !b ; { cr }
 { 000004DD } [ d# 2006 bin ] }block

( 0027BC00 )               D# 495 shadow{ 
 ( testing return stack registers ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then read back and verify each pattern ; relies
 on ) s ( and ) t ( of uut ) { cr }
 ( and instructions ) @p !p push pop ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , { 0000002F } for failure )
 { br }

 ( comment ) - ( after ) fill ( to force failure ) }block

( 0027C000 )               D# 496 code{ 
 { 0000FAEF } ( mark ram test { 0000190F } node ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: store @p ! ; .. ( / ) !+ .. ( / )
: fetch ( -n ) @p ! @ ; ( / ) @+ !b drop .. ( / )
: /neighbor d# 4 for @p ! unext ;
: /stack { 0000019D } h# 00015555 { 0055555F } dup - over over over
 { cr }
 over over over over over over { 0000023D } .. ; { br }

: go ( entry ) { 0000025D } then /neighbor /stack
: testmem { 0000029D } d# 3 { 001FFFEF } for { cr }
 @p ! drop .. ( / ) dup or a! .. ( / ) { cr }
 h# 0000003F for store next h# 0000003F for fetch or if { indent }
      pop pop d# 3 { 001FFFEF } or d# 1 . + !b ; { cr }
 then drop next next { cr }
 ( good ) h# 00000000 { 002468BF } !b ; { 0000053D } [ d# 2007 bin ]
 }block

( 0027C400 )               D# 497 shadow{ 
 ( worst case ram test looking for store failures when driving weak
 inverter high. ) [ this test preserves b, a, and p. ] { br }

: store ( makes target store next value in next wd )
: fetch ( makes target return next word in ram )
: /stack ( executed in either node sets stack to alternating { 002AAABF }
 and { 0055555F } with { 002AAABF } on top. )
: /neighbor ( feeds ) /stack ( to target node. doesn't pass the last
 word - return. ) { br }

: go ( sets both nodes' stacks that way then begins the ) testmem
: testmem ( runs test cycles, must do at least 2. each cycle switches
 polarity { 002AAABF } or { 0055555F } for first word stored, then
 stores alternating values into all ram in target. reads back and compares.
 if all cycles run ok, returns zero status. otherwise returns the { 0000002F }
 relative cycle number in which the failure occurred. ) }block

( 0027C800 )               D# 498 code{ 
 { 0000FB0F } ( mark r d stack test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: store dup ! dup ! dup ! ! ;
: fetch ( -n ) @p ! @ ; ( / ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack dup - over .. ( / ) over over ( - ) { cr }
 over .. ( / ) over over over .. ( / ) over .. ( / ) ;
: t-stk { 0000029D } { cr }
 dup /neighbor /stack { 000002DD } { cr { 001FFFDF } }
 d# 8 for { cr }
 @p .. push push push .. store { cr }
 fetch drop @p .. pop pop pop .. store { cr cr }
 d# 9 for fetch or .. if pop pop h# 0000FFFF and pop drop !b ; then
 drop { cr }
 next next ; { cr }
 then { 0000057D } [ h# 0000002B org ]
: full { 0000057D } h# 0002AAAA t-stk dup or t-stk h# 00033333 t-stk
 h# 00019999 t-stk dup or t-stk { 0000001F } dup or !b ; { cr }
 { 000006DD } [ d# 2008 bin ] }block

( 0027CC00 )               D# 499 shadow{ 
 ( testing return and data stacks registers ) { cr }
 ( also mulitple overs pops and pushes in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then push to return stack then pop to data stack
 then read back and verify each pattern ; relies on ) b s t r r-stack
 ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) @p !b over push pop ( in the port ) { br }

 [ address h# 0000002B ]
: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , next count for failure ) { br }

 ( comment ) - ( in ) [ /stack ] ( after ) over ( to force failure )
 }block

( 0027D000 )               D# 500 code{ 
 { 0000FB2F } ( +* a shift test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: !error ( n ) d# 1 !b ;
: init ( s ) @p ! ! ; ( / ) @p .. ( / )
: check ( an-a ) over or if !error pop pop ; { cr }
 then drop ;
: step ( tan-t'a' ) push .. { cr }
 @p ! ! .. ( / ) @p a! @p .. ( / ) { cr }
 ! @p ! . ( / ) +* !p a !p ( / ) @ @ pop check ;
: start then { cr }
 d# 1 init d# 0 h# 00015555 h# 0002AAAA step h# 00015555 step { cr }
 ( ...... ) d# 0 h# 00019999 h# 0002CCCC step h# 00016666 step { cr }
 d# 2 init d# 0 h# 00015555 h# 0000AAAA step h# 00025555 step { cr }
 ( ...... ) d# 0 h# 00019999 h# 0000CCCC step h# 00026666 step { cr }
 dup or !b ; { cr }
 { 000006BD } [ d# 2009 bin ] }block

( 0027D400 )               D# 501 shadow{ 
 ( testing a shifts by ) +* { br }

 ( tests the { 0000008F } combinations of shifting 1/0 ) { cr }
 ( from t for add/notadd behavior of +* . the ) { cr { 0033333F } }
 ( group checks the double shift error seen previously ; relies on )
 s ( and ) t ( of uut ) { cr }
 ( and instructions ) @p !p +* a a! ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , { 0000002F } for failure )
 { br }

 ( replace pattern before ) step ( with ) d# 0 { cr }
 ( to force failure ) }block

( 0027D800 )               D# 502 code{ 
 { 0000FB4F } ( t s a and r data path tests ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: check or if pop !b pop ; then drop ;
: -t- ( n ) dup @p ! .. ( / ) @p !p .. ( / ) ! @ ( 2* ) check ;
: -s- ( n ) dup @p ! dup ( / ) @p @p !p !p ( / ) { cr }
 ! ! @ drop @ ( 2* ) check ;
: t-a ( n ) dup @p ! .. ( / ) @p a! a !p ( / ) { cr }
 ! @ ( 2* ) check ;
: t-r ( n ) dup @p ! .. ( / ) @p push pop !p ( / ) { cr }
 ! @ ( 2* ) check ;
: start then { 0000033D } h# 0003FFFF dup - h# 0002AAAA { cr }
 dup - h# 00033333 dup - h# 00006666 dup - dup dup drop { cr }
 d# 256 for drop -t- { 0000049D } -s- { 000004BD } { cr }
 ( ............ ) t-a { 000004DD } t-r { 000004FD } next dup or !b
 ; { 0000053D } [ d# 2010 bin ] }block

( 0027DC00 )               D# 503 shadow{ 
 ( testing t s a and r data paths ) { br }

 ( does { 0000040F } reps of { 0000010F } patterns between t and )
 { cr }
 ( the other registers; relies on instructions ) { cr }
 @p !p a! a push pop ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, address after ) { cr }
 ( test for failure ) { br }

 ( uncomment ) 2* ( in each test to force failure ) }block

( 0027E000 )               D# 504 code{ 
 { 0000FB6F } ( gpio pin test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: !it ( n ) { 000000BD } @p drop !p ;
: its ( n-n ) { 000000DD } d# 0 and ;
: ++ { 0000011D } d# -1 { -cr } : !io its ! ; { -cr } : -- h# 0002AAAA
 !io ;
: 500ns ( n ) { 000001DD } d# 199 for unext ;
: .hi ( -n ) { 0000023D } d# 15 for @ its if { cr }
 drop pop ; then drop next dup dup or ;
: .lo { 0000031D } for @ h# 0002AAAA and its while drop next { cr }
 dup dup or ; then drop pop ;
: start ( n ) { 0000041D } then !it io a! { cr }
 ++ 500ns ( wpd ) h# 00015555 !io d# 8191 .lo { cr }
 d# -16 -- and 500ns ++ .hi or 500ns { cr }
 2* -- 2* 2* 2* d# 15 .lo or !b ; { cr }
 { 0000069D } [ d# 2011 bin ] }block

( 0027E400 )               D# 505 shadow{ 
 ( drive test of a single gpio pin whose control bits are nonzero in
 the argument. ) { br }

 ( while testing a pin any other pins are set at high impedance so
 we can prove all three drive transistors work for this pin and detect
 any opens. other tests look for shorts between pins ) }block

( 0027E800 )               D# 506 code{ 
 { 0000FB8F } ( mark d stack test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: fetch ( -n ) @p ! @ ; ( // ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack { 0000019D } dup - over .. ( / ) over over { cr }
 over .. ( / ) over over over .. ( / ) over ( - ) . .. ( / ) ;
: d-stack { 0000023D } h# 00000008 for dup - /neighbor /stack { 000002DD }
 next { cr }
 d# 12 { 0000001F } for drop fetch or if pop pop h# 0000FFFF and ( !b )
 pop ( and ) drop !b ; then { cr }
 next ; { cr }
 { 0000043D } [ h# 0000002A org ] then
: full { 0000055D } h# 0002AAAA d-stack dup or d-stack h# 00033333
 d-stack h# 00019999 d-stack dup or d-stack { cr }
 !b ; { 000006BD } [ d# 2012 bin ] }block

( 0027EC00 )               D# 507 shadow{ 
 ( testing data stack registers ) { cr }
 ( also overs in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then read back and verify each pattern ; relies
 on ) b s t ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) @p !b over ( in the port ) { br }

 [ address h# 0000002A ]
: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , next count for failure ) { br }

 ( comment ) - ( in ) [ /stack ] ( after ) over ( to force failure )
 }block

( 0027F000 )               D# 508 code{ 
 { 0000FBAF } ( io data path tests ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: check ( nn ) or if pop !b pop ; then drop ;
: t-io ( mn-m ) h# 00015555 or dup @p ( / ) @p ! @ !p ( / ) { cr }
 ! ! @ or over and over check ;
: start ( m ) then { 000001DD } if d# 0 for { cr }
 io @p ! .. ( / ) @p a! .. ( / ) ! { cr }
 dup t-io { 000002DD } d# 0 t-io { 0000031D } next then dup or !b ;
 { 0000035D } [ d# 2013 bin ] }block

( 0027F400 )               D# 509 shadow{ 
 ( testing io data path ) { br }

 ( checks that the masked bits return their ) { cr }
 ( inverse ; relies on ) a ( of uut ) { cr }
 ( and instructions ) @p !p ! @ ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is a mask for the io bits ) { cr }
 ( to be tested . error code { 0000000F } for success, ) { cr }
 ( test's return address for failure ) { br }

 ( include unwritable bits in the mask ) { cr }
 ( to force failure ) }block

( 0027F800 )               D# 510 code{ 
 { 0000FBCF } ( set/clear carry test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] { br }

 [ h# 0000002A org ] ( test tools )
: +c { 0000055D } ( n-c ) a h# 00000200 or !
: +@ { 000005BD } ( n-c ) @p ! dup ( / ) . . . @p ( / ) { cr }
 ( .. ) { 000005FD } ! @p ! . ( / ) @p . + !p ( / ) ! @ a ! ;
: ?t { 0000067D } ( c ) or if pop !b pop then drop ; { 000006DD } { br }

 [ h# 00000004 org ] ( test start ) { cr }
 { 0000009D } ( post args ) push h# 00020000 h# 00000000 begin { cr }
 { 000000FD } ( clr nxt ) dup +c ( ign was ) drop { cr }
 { 0000013D } ( set nxt ) over +c ( tst clr ) over ?t { cr }
 { 0000017D } ( set nxt ) over +c ( tst set ) h# 00000001 ?t { cr }
 { 000001DD } ( clr nxt ) dup +c ( tst set ) h# 00000001 ?t { cr }
 { 0000023D } ( clr nxt ) dup +c ( tst clr ) over ?t { cr }
 { 0000027D } ( nop nxt ) over +@ ( see nop ) over ?t { cr }
 { 000002BD } ( set nxt ) over +c ( tst clr ) over ?t { cr }
 { 000002FD } ( nop nxt ) dup +@ ( see nop ) over ?t { cr }
 { 0000033D } ( clr nxt ) dup +c ( tst set ) h# 00000001 ?t { cr }
 { 0000039D } next ( pass ) !b drop ; { cr }
 { 000003DD } [ d# 2014 bin ] }block

( 0027FC00 )               D# 511 shadow{ 
 ( test ) p9 ( control of carry ) { br }

 ( verify that neighbor carry can be set or ) { cr }
 ( cleared under control of p9 and that carry is preserved when p9
 is zero. ) { br }

 ( depends upon uut ) p9 cry s ( and ) t ( as well as ) { cr }
 ( uut ) jump @p !p . + ( in port. ) { cr }
 ( test starts at ) { 0000009D } ( with loop count input. ) { cr { 0000018F } }
 ( words of ram are unused. ) { cr }
 ( error code is ) ?t ( return address. ) { cr }
 ( verify by defeating any ) ?t ( parameter. ) { br }

: +@ ( calculate n+n in test node, returning c ) { cr }
 ( then clear tested's p9. )
: +c ( set p9 in test node prior to add. )
: ?t ( match result to expected and abort with ) { cr }
 ( call address as return code in case of error. ) [ note ] ( that
 loop count will clear high ) r ( bits. ) }block

( 00280000 )               D# 512 code{ 
 { 0000FBEF } ( mark @p test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] { 0000009D } ahead
 { cr }
: seq ( -n ) { 000000BD } d# 63 .. a push d# 6 a! { cr }
 if dup d# -1 . + ! pop a! ; { cr }
 then drop d# 63 ! pop a! ( @p!bunext; ) h# 00005B75 ;
: init { 0000023D } @p ! @p .. ( / ) @p a! .. ( / ) [ d# 1 , ] ! { cr }
 d# 63 for seq @p ! ! .. ( / ) @p !+ .. ( / ) next { cr }
 @p ! a .. ( / ) @p push .. ( / ) { cr }
 ! @p ! @p ( / ) @p push .. ( / ) [ d# 63 , ] { cr }
 ! @p ! ; ( / ) dup or push ; ( / )
: /@p ( n ) { 0000043D } then init { cr }
 d# 63 for @ seq ( - ) or .. if pop !b ; { cr }
 then drop next dup or !b ; { cr }
 { 0000055D } [ d# 2015 bin ] }block

( 00280400 )               D# 513 shadow{ 
 ( testing @p ) { br }

 ( does { 0000080F } reps of @p on target covering all ram addresses;
 relies on target port instructions; ) @p a! !+ dup or push ; { cr }
 ( relies on target ram instructions; ) { cr }
 @p !b unext ; { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, target address ) { cr }
 ( for failure ) { br }

 ( uncomment ) - ( to force failure ) }block

( 00280800 )               D# 514 code{ 
 { 0000FC0F } ( test i-ad and r-ad data paths ) { cr }
 ( creeper ) [ reclaim d# 2 node d# 1344 load ] { br }

 ( test start ) { cr }
 { 0000009D } ( @p; ) h# 00005500 d# 63 for .. { cr }
 { 000000FD } pop dup push dup @p ! ! .. ( / ) @p dup a! @p { 0000015D }
 over or @p .. ( / ) ! b! @b !p ( / ) { cr }
 { 0000019D } over ! ! @ ( - ) or .. if pop h# 00000040 or !b ; { cr }
 { 0000025D } then drop next { cr }
 { 0000027D } a @p ! .. ( / ) @p b! .. ( / ) ! ( dup or !b ; ) { cr }
 { 000002DD } ( call ) h# 00012000 d# 63 for .. { cr }
 { 0000033D } dup ! d# 1 @p ( / ) !p .. ( / ) ! . + dup { cr }
 { 000003BD } @ ( - ) or h# 0000003F and if pop h# 00000080 or !b ;
 { cr }
 { 0000047D } then drop next ( dup or !b ; ) { cr }
 { 0000049D } ( ex { 0024081F } ) dup d# 63 for .. { cr }
 { 000004DD } @p ! ! @p ( / ) @p push ex ( / ) [ d# 1 , ] { cr }
 { 0000053D } @p ! . + ( / ) !p .. ( / ) @ over ( - ) or h# 0000003F
 { cr }
 { 000005BD } and if pop drop h# 000000C0 or !b ; { cr }
 { 0000063D } then drop dup .. next dup or !b ; { br }

 { 0000069D } [ d# 2016 bin ] }block

( 00280C00 )               D# 515 shadow{ 
 ( test 8,5-0 of ) i ( and ) r ( to adrs bus ) { br }

 ( verify adrs drivers for above bits in uut. ) { cr }
 ( 1. using ) a ( set ) [ @p ; n ] ( in ram, where ) [ n ] ( is ) { cr }
 ( -- loc of same word. chk ram via ) b ( and ) { cr }
 ( -- return error code ) < 40+n > ( if fail. ) { cr }
 ( 2. for ) [ n ] ( of ) < 0-3f > ( store ) [ call-n ] ( / ) [ !p .. ]
 ( into ) { cr }
 ( -- port and read back and confirm that data ) { cr }
 ( -- have the same low order { 000000CF } bits as the next -- call
 we are to send. return error code ) { cr }
 ( -- ) < 80+n > ( if fail. ) { cr }
 ( 3. same as test { 0000004F } using ) [ ex ] ( instead of ) [ call ]
 { cr }
 ( -- return error code ) < c0+n > ( if fail. ) { br }

 ( test starts at ) { 0000009D } ( with ignored input. ) { cr }
 ( depends upon uut ) a b r s t ( and ) ram ( as well as uut ) call
 ex ; @p !p . push dup a! b! ! @b ( in ram or port. ) { br }

 ( failure is forced by uncommenting ) [ - ] ( in ) { cr }
 ( each test ) }block

( 00281000 )               D# 516 code{ 
 { 0000FC2F } ( rom checksum ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ]
: start ( n ) { 0000009D } d# 0 d# 63 for pop dup push h# 00000080
 . + { cr }
 @p .. ( / ) @p a! @ !p ( / ) ! ! @ or next { cr }
 or if d# 1 then !b ; { cr }
 { 0000023D } [ d# 2017 bin ] }block

( 00281400 )               D# 517 shadow{ 
 ( rom check sums ) { br }

 ( does an xor checksum of the { 0000080F } target node rom locations
 ; relies on instructions ) { cr }
 @p !p a! a ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is expected checksum ) { cr }
 ( error code { 0000000F } for success, { 0000002F } for failure )
 { br }

 [ d# 0 test ] ( to force failure ) }block

( 00281800 )               D# 518 code{ 
 { 0001068F } ( parallel port pin test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: return ( n ) pop dup b! push !b ;
: chk ( nn ) { 000000FD } or { cr }
 if pop pop drop pop drop return ; { cr }
 then drop ;
: write ( n ) { 0000019D } ( out ) h# 00015555 !b ! ;
: 50ns ( -n ) { 000001DD } d# 18 { 0000042F } for unext ( ; )
: sample ( -n ) { 0000023D } ( in ) h# 00014555 !b .. @ ( out ) h# 00015555
 !b ;
: 300ns ( -n ) { 000002BD { 00000ECF } } d# 87 for unext sample ;
: once ( n-n' ) { 0000031D } { cr }
 dup write 50ns d# 0 chk { 0000039D } 300ns over chk { 000003DD } { cr }
 d# 0 write 50ns over chk { 0000045D } 300ns d# 0 chk { 000004BD }
 2* ;
: start ( n ) { 000004DD } then { cr }
 d# 0 data a! io b! write 300ns d# 0 chk { 000005DD } { cr }
 d# 1 d# 17 for once next drop !b dup or return ; { cr }
 { 000006BD } [ d# 2100 bin ] }block

( 00281C00 )               D# 519 shadow{ 
 ( parallel port pin test ) { br }

 ( walking ones test of parallel port pins in ) { cr }
 ( nodes { 000000EF } and { 0000012F } , detects opens shorts and weak
 drive transistors . ) { br }

 [ address h# 00000004 ] ( tests active node given arg which is ending
 io value. ) [ note purpose is to control wr bit setting and if the
 bit does not work in either node the test will fail in one of em. ]
 { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr }
 ( test's return address for failure ) { br }

 ( force an 'open pad' failure by running ) { cr }
 ( the test on node { 0000012F } of a chip with sram ) { cr }
 ( connected ) { br }

 ( force a 'short' failure by temporarily ) { cr }
 ( connecting a pin to power ground or a ) { cr }
 ( neighbor pin ) }block

( 00282000 )               D# 520 code{ 
 { 000106AF } ( mark @b !b test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: /t { 000000BD } ( n ) dup - .. ( / ) @p ! ! ; ( / ) @p .. ( / )
: /b! { 0000011D } ( n ) @p ! ! ; ( / ) @p b! .. ( / )
: /!b { 0000015D } ( n ) @p ! ! ; ( / ) @p !b .. ( / )
: /@b { 0000019D } ( -n ) @p ! @ ; ( / ) @b !p .. ( / )
: end @p ! a . ( / ) @p b! .. ( / ) ! !b ;
: init { 0000023D } then @p ! @p .. ( / ) dup or a! . [ d# 63 , ] { cr }
 { 0000029D } @p ! ! .. ( / ) { 000002BD } @p push .. { 000002DD }
 ( / ) { cr }
 @p ! .. ( / ) { 000002FD } begin a - !+ unext .. { 0000031D } ( /
 ; ) { cr }
 d# 1 dup { 000007DF } h# 0000003F for over . + /t dup /b! dup /!b
 next ( ; )
: chk-a { 0000043D } d# 1 dup h# 0000003F for over . + /t dup /b! dup
 /@b or .. if pop d# -1064 . + - !b pop drop ; then drop next
: b-adr d# 0 end ; { cr }
 { 0000065D } [ d# 2101 bin ] }block

( 00282400 )               D# 521 shadow{ 
 ( b-adr-data test; b-reg adr paths to ram and data path from t to
 ram and ram to t using b-reg ) { br }

 ( uses !+ to fill ram with -1 to -40 ) { cr }
 ( next uses b to change ram to { 0000000F } to 3f ) { cr }
 ( next checks to see if ram successfully changed ; relies on instructions )
 { cr }
 @p ( / ) @p b! ( / ) @b !p ( / ) @p push ( / ) dup or a! ( / ) { cr }
 a - !+ unext ( / in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr }
 ( address + { 00007D0F } of failure for failure ) { br }

 ( uncomment { 000007DF } and comment ) h# 0000003F ( in )
: init ( to force failure ) }block

( 00282800 )               D# 522 code{ 
 { 000106CF } ( mark t to b reg test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ( ahead { 0000025F } )
 [ h# 00000014 org ]
: end { 0000029D } @p ! a . ( / ) @p b! .. ( / ) ! !b ;
: /t { 000002FD } ( n ) dup - .. ( / ) @p ! ! .. ( / ) @p .. ( / )
 ;
: /b! { 0000037D } ( n ) @p ! ! .. ( / ) @p b! .. ( / ) ;
: /!b { 000003DD } ( n ) @p ! ! .. ( / ) @p !b .. ( / ) ;
: /@b { 0000043D } ( -n ) @p ! @ .. ( / ) @b !p .. ( / ) ;
: chk-a { 0000049D } h# 0000003F and dup dup /t /b! /@b or ( - ) ..
 if drop d# 1000 . + end pop pop pop ; then ;
: 2chk dup dup chk-a drop drop - chk-a drop drop chk-a ; { 000006DD }
 [ h# 00000004 org ]
: init ( then ) @p ! .. ( / ) dup or a! .. ( / ) { cr }
 h# 0000003F ( / ) { 0000011D } @p ! ! .. ( / ) { 0000013D } @p push
 .. { 0000015D } ( / ) { cr }
 @p ! .. ( / ) { 0000017D } begin a !+ unext .. { 0000019D } ( / )
: b-reg { 0000019D } dup or 2chk h# 000000AA 2chk h# 00000033 2chk
 h# 00000019 2chk { cr }
 { 0000029D } ( end ; ) { cr }
 [ d# 2102 bin ] }block

( 00282C00 )               D# 523 shadow{ 
 ( b-reg testing t to b-reg ) { br }

 ( uses !+ to fill ram with { 0000001F } to { 000007FF } ) { cr }
 ( next puts { 0000001F } on t and -1 on s ) { cr }
 ( next puts the { 0000001F } into b and does a @b with -1 on t ) { cr }
 ( next checks if t contains { 0000001F } ) { cr }
 ( then does this for { 000007FF } , { 0000001F } and other numbers
 ; relies on instructions ) { cr }
 @p ( / ) @p b! ( / ) @b !p ( / ) @p push ( / ) dup or a! ( / ) { cr }
 ( / ) a !+ unext ( / in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr }
 ( address + { 00007D0F } of failure for failure ) { br }

 ( uncomment - in )
: chk-a ( to force failure ) }block

( 00283000 )               D# 524 code{ 
 { 000106EF } ( mark port to i-reg test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000001A org ]
: chk { 0000035D } or if pop d# 1000 !b ; then ;
: rets @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! @p ( / ) dup dup or . ( / ) push push . . ( / ) !
: init { 0000049D } h# 00015555 dup - over over ( - ) over over { cr }
 ( . 2/ . ) over { 0000051D } .. @p ! ! . ( / ) @p a! @p @p ( / ) { cr }
 .. ! ! @p . ( / ) @p @p . . ( / ) ! ( . ) ! ! ;
: code { 000005BD } @p - dup . ( / ) begin a! !p drop unext ( / ) -
 over ! ! @ push ( / ) ! pop ; ( ; - @p dup ) { cr }
: -code { 0000065D } @p dup - dup ( / ) a! - @p dup ( / ) push ! !
 ! pop ! ; ( / ; !p drop unext ) { br }

 { 000006DD } [ h# 00000004 org ]
: i-reg { 0000009D } rets ( ; ) code over chk drop { cr }
 { 0000011D } .. ( / ) @p ! @ . ( / ) a !p !p .. ( / ) { cr }
 { 0000015D } - chk drop @ - chk ( / end first check ) { cr }
 { 000001BD } rets .. ( / ) @p ! @p . ( / ) pop pop drop . ( / ) push
 .. ( / ) ! dup dup -code { cr }
 { 0000027D } ( / ) @p ! @ ( . ) .. ( / ) !p !p !p .. ( / ) { cr }
 chk drop @ chk drop @ chk ( end second check ) { cr }
 !b ; { 0000035D } [ d# 2103 bin ] }block

( 00283400 )               D# 525 shadow{ 
 ( port testing port to i-reg ) { br }

 ( uses the instruction / ) a! !p drop unext ( / ) { cr }
 ( first the inverse instruction is sent then the instruction then
 the inverse instruction again ) [ note ] ( the inverse of ) a! ( is )
 ; { cr }
 ( next the inverse of instruction / ) a! - @p dup ( is used, except
 for the ) a! ( / ) { cr }
 [ note ] ( the pre and post instructions begin with ) ; ( and don,t
 effect the stack ) { cr }
 ( after each triplet the stack is checked; ) { cr }
 ( relies on instructions ) { cr }
 @p dup push . ( / ) dup dup or . ( / ) push push .. ( / ) @p a! @p
 @p ( / ) @p @p . . ( / ) a !p !p . ( / ) { cr }
 pop pop drop . ( / ) push .. ( / ) { cr }
 ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00283800 )               D# 526 code{ 
 { 0001070F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 0000027F } h# 00000017
 org ]
: chk { 000002FD } or if pop pop d# 1000 { 0002001F } !b ; then drop
 ;
: init { 0000039D } h# 00003807 dup 2* dup 2* dup dup { cr }
 2* dup dup 2* dup dup { cr }
 { 0000043D } .. @p ! @p . ( / ) @p @p @p . ( / ) [ h# 00012345 , ]
 ( . 2/ . ) ! ! ! ;
: read { 000004BD } ( / ) @p ! @ . ( / ) !p !p !p . ( / ) @ @ ; { br }

: code { 0000051D } ( / ) @p ; ( / ) and @b and @p ( / )
: -code { 0000055D } ( / ) @p ; ( / ) @b and @b + ( / ) { br }

: run { 0000059D } -code ! ( . ) ! ! ( . ) code ! ( . ) ! ! ( . ) { cr }
 -code ! ( . ) ! ! ( . ) ; { cr br }

 { 0000065D } [ h# 00000004 org ]
: i-reg { 0000009D } init run read h# 00012345 chk h# 00010020 chk
 h# 0001502A chk { cr }
 dup or !b ; { 000001DD } [ d# 2104 bin { 0013027F } ] }block

( 00283C00 )               D# 527 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions / ) and @b and + ( / ) { cr }
 ( and ) @b and @b + ( checked; ) { cr }
 ( relies on instructions ) { cr }
 @p dup push . ( / ) dup dup or . ( / ) push push .. ( / ) @p a! @p
 @p ( / ) @p @p . . ( / ) a !p !p . ( / ) { cr }
 pop pop drop . ( / ) push .. ( / ) { cr }
 ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00284000 )               D# 528 code{ 
 { 0001072F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000001A org ]
: chk { 0000035D } or if pop pop d# 1000 { 0002001F } !b ; then drop
 ;
: init { 000003FD } { cr }
 dup or - dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p push @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! ! ; { cr }
: 3code { 0000053D } ( / ) @p dup dup . ( / ) - - - . ( / !p !p !p
 ; )
: run { 0000057D } push ! - ! @ @ @ pop ! { cr }
 .. ( / ) @p ! @ . ( / ) !p !p !p . ( / ) @ @ ; { br }

 { 0000063D } [ h# 00000004 org ]
: i-reg { 0000009D } init 3code h# 0003FFC0 chk h# 0003FFE0 chk h# 0000000F
 chk h# 0003FFF8 chk h# 0003FFFC chk h# 00000001 ( - ) chk { cr cr }
 dup or !b ; { 0000027D } [ d# 2105 bin ] }block

( 00284400 )               D# 529 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions / ) - - - . ( / ) !p !p !p ; ( / relies on
 instructions ) { cr }
 ( / ) !p !p !p . ( / ) @p @p @p @p ( / ) @p push @p @p ( / . in the
 port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00284800 )               D# 530 code{ 
 { 0001074F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000018 org ]
: chk { 0000031D } or if pop pop d# 1000 !b ; then drop ;
: init { 000003BD } dup or - dup 2* dup 2* dup 2* { cr }
 dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 .. ( / ) ! @p ! . ( / ) push @p a! @p ( / ) { cr }
 { 000004FD } ! ! @p . ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! !
 ; { cr }
: 2code { 0000057D } ( / ) @p - dup . ( / ) !p - a! . ( / - !p ; ; )
: run { 000005BD } - over push push ! @ pop ! @ pop ! @ { cr }
 .. ( / ) @p ! @ . .. ( / ) a !p !p . ( / ) @ .. ; { br }

 { 000006BD } [ h# 00000004 org ]
: i-reg { 0000009D } init 2code h# 0003FF00 chk h# 0000003F chk h# 0000007F
 chk h# 0003FFE0 chk h# 0000000F chk { cr }
 dup or !b ; { 0000023D } [ d# 2106 bin ] }block

( 00284C00 )               D# 531 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) !p - a! . ( / ) - !p ; ; ( / ) { cr }
 ( relies on instructions ) { cr }
 ( / / ) @p dup push . ( / ) push @p a! @p ( / ) { cr }
 ( / ) @p @p @p @p ( / ) a !p !p . ( / ) { cr }
 ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00285000 )               D# 532 code{ 
 { 0001076F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 0000031F } h# 00000017
 org ]
: chk { 000002FD } or if pop pop d# 1000 { 0002001F } !b ; then drop
 ;
: init { 0000039D } { cr }
 dup or - dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! . ( / ) push @p a! . ( / ) { cr }
 { 0000047D } ! @p ! . ( / ) @p @p @p @p ( / . 2/ . ) ! ! ! ! ; { cr }
: 1code { 000004FD } ( / ) @p - dup . ( / ) - a! - . ( / !p ; !p ; )
: run { 0000053D } ! @ ( ; ) push dup - ! ! pop @ { cr }
 .. ( / ) @p ! @ . ( / ) !p a !p . ( / ) @ ;
: 0code { 000005FD } ( / ) @p - dup . ( / ) a! - . . ( / ; !p c c )
: 0run { 0000063D } - over ! ! ! { cr }
 .. ( / ) @p ! @ . ( / ) a !p !p !p ( / ) @ @ ; { br }

 { 000006DD } [ h# 00000004 org ]
: i-reg { 0000009D } init 1code h# 00000001 chk h# 0003FFF8 chk d# 3
 chk h# 0003FFFF chk { cr }
 { 000001DD } init 0code h# 0003FFFC chk h# 00000001 chk h# 0003FFFF
 chk { cr }
 dup or !b ; { 000002FD } [ d# 2107 bin ] }block

( 00285400 )               D# 533 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) a! - . . ( / ) ; !p c c ( / ) { cr }
 ( / ) - a! - . ( / ) !p ; !p ; ( / ) { cr }
 @p dup push . ( / ) dup dup or . { cr }
 ( relies on instructions ) { cr }
 ( / ) a !p !p !p ( / ) !p a !p . ( / ) @p @p @p @p { cr }
 ( / ) push @p a! . ( / ) @p dup push . ( / ) { cr }
 ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00285800 )               D# 534 code{ 
 { 0001078F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000015 org ]
: chk { 000002BD } or if pop pop d# 1000 { 0002001F } !b ; then drop
 ;
: init { 0000035D } { cr }
 dup or - dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! . ( / ) push @p a! . ( / ) { cr }
 { 0000043D } ! @p ! . ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! ;
 { cr }
: +code { 000004BD } ( / ) @p - dup . ( / ) a! a! a! . ( / ; ; ; ; )
: +run { 000004FD } - over ! ! ! { cr }
 .. ( / ) @p ! @ . ( / ) a !p !p . ( / ) @ ; { br }

 { 0000059D } [ h# 00000004 org ]
: i-reg { 0000009D } init +code h# 0003FFF8 chk h# 0003FFFC chk { cr }
 { 0000015D } dup or !b ; { 0000017D } [ d# 2108 bin ] }block

( 00285C00 )               D# 535 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) a! a! a! . ( / ; ; ; ; / ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p dup push . ( / ) push @p a! . ( / ) { cr }
 ( / ) @p @p @p @p ( / ) a !p !p . ( / ) { cr }
 ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00286000 )               D# 536 code{ 
 { 000107AF } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000015 org ]
: chk { 000002BD } or if pop pop d# 1000 !b ; then drop ;
: init { 0000035D } dup or - dup 2* dup 2* dup 2* { cr }
 dup 2* dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! . ( / ) push @p a! @p ( / ) { cr }
 { 0000047D } ! ! @p . ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! !
 ; { cr }
: -code { 000004FD } ( / ) @p ; ( / ) @p @p @p ; ( / )
: +code { 0000053D } ( / ) @p ; ( / ) a! a! a! . ( / ; ; ; ; )
: -run { 0000057D } +code ! -code ! ( . ) ! ! ! ( . ) +code ! { cr }
 .. ( / ) @p ! @ . ( / ) a !p !p !p . ( / ) @ @ ; { br }

 { 0000067D } [ h# 00000004 org ]
: i-reg { 0000009D } init -run h# 0003FF80 chk h# 0003FFC0 chk h# 0003FFFC
 chk { cr }
 dup or !b ; { 000001BD } [ d# 2109 bin ] }block

( 00286400 )               D# 537 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) @p @p @p ; ( / ) a! a! a! . ( / ) ; ; ; ; ( / ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p dup push . ( / ) push @p a! @p ( / ) { cr }
 ( / ) @p @p @p @p ( / ) a !p !p !p . ( / ) { cr }
 ( / ) { cr }
 ( in the port ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00286800 )               D# 538 code{ 
 { 000107CF } ( mark prp-call test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 000001BF } { 0000019F }
 h# 00000009 org ]
: p-r-p dup h# 00000001 . + h# 0000007E for
: init { 0000005F } { 0000007F } dup ( 3 ) push over a { cr { 0000007F } }
 ( . { 0000005F } a ) pop ( 3 ) a push dup push h# 00000001 . + { cr { 0000007F } }
 ( . { 0000005F } a { 0000009F } ) dup a! - { 000007FF } h# 0000007F
 and { cr { 0000007F } }
 ( . { 0000005F } a { 0000077F } ) dup push h# 00013000 or pop { cr { 0000007F } }
 ( . { 0000005F } a { 0026077F } { 0000077F } ) pop { 0000007F } ( . { 0000005F }
 a { 0000077F } { 0000007F } ) { cr }
 a { 0000009F } pop a! { 0000009F } push { cr }
 ( / ) .. @p ! ! . ( // ) @p @p @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( // ) @p .. ( / ) ! ! { cr }
 d# 8 for @p ! unext { cr }
 ( / { 0000005F } ) a! @p !+ . ( / ) !b pop !b . ( / ) { cr }
 ( a ) push !+ @p .. ( / ) ; ( / ) { cr }
: forcefail !+ dup .. ( / { 0000077F } ) a! { 0000077F } ( . 2/ . )
 @p @p .. !b pop !b . ( / ) pop dup push ; { cr }
 !+ !+ push .. ( / ) { cr cr }
: calls { 0000055D { 0000007F } } pop { 0000009F } over { 0000007F }
 h# 00011000 or ! ( ? @ ; ? ) { cr }
 ( / ) .. @p ! @ .. ( // ) !p .. a { cr }
 ( chk ) or if pop pop d# 1000 !b ; then drop { cr cr }
 next ; { 000006BD } [ h# 00000004 org ]
: p-r h# 00000000 p-r-p h# 00000200 p-r-p dup or !b ; { cr }
 { 0000013D } [ d# 2110 bin ] }block

( 00286C00 )               D# 539 shadow{ 
 ( prp-call testing p to r to p using ) call ( and ) ; ( also test )
 jump ( from port to ram. ) ; ( returns to port and to ram ) { br }

 ( uses the instructions in ram ) { cr }
 ( / ) pop dup push ; ( / ) call ( / ) ; ( / ) { br }

 ( to insure failure on fail, fills ram with ) { cr }
 ( / ) !b pop !b . ( / ) { br }

 ( relies on instructions in the port ) { cr }
 ( / ) a! @p !+ . ( / ) push !+ @p .. ( / ) { cr }
 ( / ) !+ dup .. ( / ) a! @p @p .. ( / ) { cr }
 ( / ) !+ !+ push .. ( / ) { cr br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: forcefail ( to force failure ) { cr }
 ( uncomment ) [ @ ; ] ( in )
: calls ( and removing ) [ for next ] ( structure ) { cr }
 ( might help debuging chip. ) }block

( 00287000 )               D# 540 code{ 
 { 000107EF } ( mark prp-ex test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000000D org ]
: p-r-p dup h# 00000001 . + h# 0000007E for
: init { 0000005F } { 0000007F } dup ( 3 ) push over a { cr { 0000007F } }
 ( . { 0000005F } a ) pop ( 3 ) a push dup push h# 00000001 . + { cr { 0000007F } }
 ( . { 0000005F } a { 0000009F } ) dup a! - h# 0000007F and { cr { 0000007F } }
 ( . { 0000005F } a { 0000077F } ) pop { 0000007F } ( . { 0000005F }
 a { 0000077F } { 0000007F } ) { cr }
 a { 0000009F } pop a! { 0000009F } push { cr }
 ( / ) .. @p ! ! . ( // ) @p @p @p @p ( / ) ! ! ! { cr cr }
 d# 10 for @p ! unext { cr }
 ( / { 0000005F } ) a! @p !+ . ( / ) !b pop !b . ( / ) { cr }
 ( a ) push @p @p .. ( / ) ; ( / ) ex .. ( / ) { cr }
 !+ !+ dup dup .. ( / { 0000077F } ) a! { 0000077F } push @p @p ( / )
 { cr }
 ( / ) !b pop !b . ( / ) pop dup ( . . ) push ( . ) ; ( / ) { cr }
: forcefail !+ !+ .. ( / . 2/ . ) push drop .. ( / ) { cr cr }
: calls { 0000057D { 0000007F } } pop { 0000009F } over { 0000007F }
 h# 00011000 or ! ( ? ; ? ) { cr }
 ( / ) a .. @p ! @ .. ( // ) !p .. { cr }
 ( chk ) or if pop pop d# 1000 !b ; then drop { cr }
 next ; { 000006DD } [ h# 00000004 org ]
: p-r d# 0 p-r-p h# 00000200 p-r-p dup or !b ; { cr }
 { 0000013D } [ d# 2111 bin ] }block

( 00287400 )               D# 541 shadow{ 
 ( prp-ex testing p to r to p using ) ex ( and ) ; { cr }
 ( also test ) jump ( from port to ram. ) ; ( returns to port and to
 ram ) { br }

 ( uses the instructions in ram ) { cr }
 ( / ) pop dup push ; ( / ) ex .. ( / ) ; ( / ) { cr }
 ( to insure failure on fail, fills ram with ) { cr }
 ( / ) !b pop !b . ( / ) { cr }
 ( relies on instructions in the port ) { cr }
 ( / ) a! @p !+ . ( / ) push @p @p .. ( / ) { cr }
 ( / ) !+ !+ dup dup .. ( / ) a! push @p @p ( / ) { cr }
 ( / ) !+ !+ .. ( / ) push drop .. ( / ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: forcefail ( to force failure ) { cr }
 ( uncomment ) [ @ ; ] ( in )
: calls ( and removing ) [ for next ] ( structure ) { cr }
 ( might help debuging chip. ) }block

( 00287800 )               D# 542 code{ 
 { 0001080F } ( serdes 001 slave test ) { cr }
 ( creeper ) [ reclaim d# 1 node d# 1344 load ] ahead
: s-lis { 000000BD } ( rip ) d# -1 !b .. cold ;
: lis { 0000011D } io a! h# 00015555 ! data a! h# 0003FFFE dup ! ;
: m-lis ( arg ) { 000001FD } then a push lis pop a! .. d# 0 !b ; { 0000029D }
 { br }

: ran ( n-n ) { 0000029D } -if 2* h# 0002CD81 or ; then 2* ;
: rcv ( -n ) { 0000031D } h# 0003FFFE @ ( nip ) over or or ;
: dly { 0000037D } d# 50 for unext ;
: one { 000003DD } up a! d# 0 rcv dup for { cr }
 ran dup push rcv or over - and or pop next { cr }
 drop dly { cr }
 data a! h# 00031416 or dup ! io a! h# 00020000 ! { cr }
 up a! ! dly lis warm ; { br }

 { 000006DD } [ d# 2112 bin ] }block

( 00287C00 )               D# 543 shadow{ 
 ( basic serdes test. this package is loaded into node 001 and location { 000000AF }
 executed, returning negative status to rip the creeper out and placing
 the node in its cold configuration to execute anything node { 000057AF }
 sends it. the location { 0000008F } entry point is used in node { 000057AF }
 on the way to 001 to place { 000057AF } in listen mode first. ) { br }

: s-lis ( is used from node { 00000CAF } to start 001 listening for
 instructions from node 701. )
: one ( is called by master thru serdes to run the test. receives count,
 nominally 250,000, and then receives one more than that words of data.
 compares each word with prn sequence generated off the initial count.
 ors all error bits together, then xors that result with { 000F570F }
 and returns two copies after turning line around. finally goes back
 to receive and warm so it's rdy for the next test. ) }block

( 00288000 )               D# 544 code{ 
 { 0001082F } ( serdes { 000057AF } master test ) { cr }
 ( creeper ) [ reclaim d# 1 node d# 1344 load ] ahead { br }

: ran ( n-n ) { 000000BD } -if 2* h# 0002CD81 or ; then 2* ;
: dly { 0000013D { 0000014F } } d# 12 for unext ;
: lis { 0000019D } io a! h# 00015555 ! data a! h# 0003FFFE dup ! ;
: go ( arg ) { 0000027D } then data a! io h# 0001201E { cr }
 ! a! up h# 00020000 ( . ) ! a! dup ! dup for { indent }
      dly ran dup ! next drop { cr }
 ( result ) . .. . .. lis dly dly lis up a! @ @ { cr }
 h# 00031416 or over h# 00031416 or over - and or { cr }
 dup 2/ over - and or h# 0001FFFF and .. !b ; { br }

 { 0000063D } [ d# 2113 bin exit ] }block

( 00288400 )               D# 545 shadow{ 
 ( basic serdes test. single package used in two modes on path { 0000002F }
 for the two nodes. ) { br }

: s-lis ( is used from node { 00000CAF } to start 001 listening for
 instructions from node 701. ) }block

( 00288800 )               D# 546 code{ 
 { 0001084F } ( basic analog checks ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] { br }

: !dac { 0000009D } ( n ) io a! ! dup dup or !b ;
: ladc { 000000FD } ( n ) io a! ! ldata
: .adc { 0000015D } a! ! @ dup d# 1000 for unext { cr }
 ( ---- ) { 000001DD } ! @ - d# 1 . + . + h# 0001FFFF and !b ;
: uadc { 0000027D } ( n ) io a! ! data .adc ; { br }

 { 000002FD } [ d# 2114 bin exit ] { br }

: !dac { 0000033D } ( n ) dup @p ! dup ( / ) @p a! @p . ( / ) { cr }
 ( ---- ) { 0000037D } io ! ! @p ( / ) ! . . . ( / ) ! or !b ; }block

( 00288C00 )               D# 547 shadow{ 
 ( basic analog control ) { br }

 ( this code is intended to run in the active ) { cr }
 ( node, not the target node. ) { br }

: !dac ( sets dac value into io and returns zero. )
: ladc ( sets up dac and io then reads back raw ) { cr }
 ( adc value when used in a left analog node. )
: uadc ( does the same for an up analog node. ) }block

( 00289000 )               D# 548 code{ 
 { 0001086F } ( mark 2* test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000013 org ]
: t! ( n ) @p ! ! ; ( // ) @p .. ( / )
: t2* @p ! ; ( // ) 2* .. ( / )
: t@ ( -n ) @p ! @ ; ( // ) !p .. ( / )
: t2*3 @p ! .. ( // ) 2* 2* 2* .. ( / ) { cr }
 @p ! @ ; ( // ) dup !p .. ( / )
: chk over or .. if pop pop pop d# 1000 !b ; then drop ;
: h2* dup t! d# 18 for { cr }
 dup . + t2* t@ dup t! chk { cr }
 next ;
: h2*3 dup t! d# 6 for { cr }
 dup . + dup . + dup . + t2*3 chk next ;
: forcefail { 000006DD } [ h# 00000004 org ]
: tst-2* { 0000009D } h# 00015555 h2* h# 00000001 h2* - { 007FFFFF }
 h2*3 { 0000001F } h2*3 h# 00015555 h2*3 h# 00033333 h2*3 h# 000071C7
 h2*3 h# 00000001 h2*3 !b ; { cr }
 { 0000027D } [ d# 2115 bin ] }block

( 00289400 )               D# 549 shadow{ 
 ( tst-2* testing 2* ) { cr br }

 ( relies on instructions in the port ) { cr }
 @p . . . ( / ) 2* . . . ( / ) !p . . . ( / ) 2* 2* 2* . ( / ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( first comment ) dup ( in )
: h2*3 ( to force failure ) { cr }
 ( then comment ) dup ( in )
: h2* ( to force failure ) }block

( 00289800 )               D# 550 code{ 
 { 0001088F } ( mark 2/ test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 0000027F } h# 00000019
 org ]
: t2/ ( n-n ) dup . + @p ( // ) @p 2/ !p .. ( / ) ! dup ! over @ ;
: t2/3 ( n-n ) dup . + dup . + { cr }
 .. ( / ) dup . + @p ( // ) @p .. ( / ) { cr }
 ( / ) ! dup ! @p ( // ) 2/ 2/ 2/ !p ( / ) { cr }
 ( / ) ! over @ ;
: chk or .. if pop pop pop d# 1000 !b ; then drop ;
: h2/ d# 12 for dup t2/ chk next ;
: h2/3 d# 3 for dup t2/3 chk next ; { 000006DD } [ h# 00000004 org ]
: tst-2/ { 0000009D } h# 0000000F h2/ h# 00000005 h2/ h# 00000003 h2/
 h# 0000000C h2/ h# 0000000F h2/3 h# 00000005 h2/3 h# 00000003 h2/3
 h# 0000000C h2/3 h# 00000007 h2/3 h# 00000009 h2/3 dup or !b ; { cr }
 { 0000033D } [ d# 2116 bin ] }block

( 00289C00 )               D# 551 shadow{ 
 ( tst-2/ testing 2/ ) { cr br }

 ( relies on instructions in the port ) { cr }
 @p 2/ !p . ( / ) @p . . . ( / ) 2/ 2/ 2/ !p ( / ) { cr br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( first comment ) dup ( in )
: h2/ ( to force failure ) { cr }
 ( then comment ) dup ( in )
: h2/3 ( to force failure ) }block

( 0028A000 )               D# 552 code{ 
 { 000108AF } ( mark 2/ test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000022 org ]
: t2/ ( n-n ) dup . + @p ( // ) @p 2/ !p .. ( / ) ! ! @ ;
: t2/3 ( n-n ) dup . + dup . + { cr }
 .. ( / ) dup . + @p ( // ) @p .. ( / ) { cr }
 ( / ) ! ! @p .. ( // ) 2/ 2/ 2/ !p ( / ) { cr }
 ( / ) ! @ ;
: chk or .. if pop pop pop d# 1000 !b ; then drop ;
: h2/ dup t2/ chk ;
: h2/3 dup t2/3 chk ; { 000006DD } [ h# 00000004 org ]
: tst-2/b { 0000009D } h# 00030000 h2/ h# 0003AAAA h2/ h# 00035555
 h2/ h# 0003FFFE h2/ h# 00033333 h2/ h# 0003CCCC h2/ { cr }
 h# 0003C000 h2/3 h# 0003EAAA h2/3 h# 0003D555 h2/3 h# 0003FFF8 h2/3
 h# 0003F333 h2/3 h# 0003CCCC h2/3 h# 0003C0F0 h2/3 h# 0003C1C3 h2/3
 dup or !b ; { cr }
 { 0000043D } [ d# 2117 bin ] }block

( 0028A400 )               D# 553 shadow{ 
 ( tst-2/b testing 2/ ) { cr br }

 ( relies on instructions in the port ) { cr }
 @p 2/ !p . ( / ) @p . . . ( / ) 2/ 2/ 2/ !p ( / ) { cr br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( first comment ) dup ( in )
: h2/ ( to force failure ) { cr }
 ( then comment ) dup ( in )
: h2/3 ( to force failure ) }block

( 0028A800 )               D# 554 code{ 
 { 0001130F } ( tst+ mark testing + ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000002A org ] { cr }
: chk or if pop pop d# 1000 !b ; then drop ;
: t+ ( nnn-n ) push .. { cr }
 ( / ) @p ! ! @p ( // ) @p ( . - . ) .. ( // ) @p . + !p ( / ) { cr }
 ( / ) ! ! @ pop chk ; { cr }
 { 000006BD } [ h# 00000004 org ] { cr }
: tst+ h# 00015555 dup dup h# 0002AAAA t+ { cr }
 dup dup - h# 0003FFFF t+ - dup - dup h# 0002AAAA h# 0003FFFF t+ dup
 - h# 0003FFFF t+ { cr }
 dup or - dup dup h# 0003FFFE t+ h# 0002AAAA h# 0000CCCC h# 00037776
 t+ h# 00019999 h# 00015555 h# 0002EEEE t+ h# 00033333 h# 00008888
 h# 0003BBBB t+ { cr }
 dup or !b ; { cr }
 { 000004FD } [ d# 2200 bin ] }block

( 0028AC00 )               D# 555 shadow{ 
 ( tst+ mark testing + ) { cr br }

 ( relies on ) s ( and ) t ( of uut ) { cr }
 ( relies on instructions in the port ) { cr }
 ( / ) @p .. ( / ) @p . + !p ( / ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( fail mode; ) { cr }
 ( uncomment ) - ( in )
: t+ ( to force failure ) { cr cr }
 }block

( 0028B000 )               D# 556 code{ 
 { 0001132F } ( mark r d stack test v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000000E org ]
: store dup ! dup ! dup ! ! ;
: fetch ( -n ) @p ! @ ; ( / ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack dup - over .. ( / ) over over ( . - . ) { cr }
 over .. ( / ) over over over .. ( / ) over .. ( / ) ;
: t-stk { 000003BD } { cr }
 dup /neighbor /stack { 000003FD } { cr { 001FFFDF } }
 d# 8 for { cr }
 @p .. push push push .. store { cr }
 fetch drop @p .. pop pop pop .. store { cr cr }
 d# 11 for fetch or .. if pop pop - d# 10 . + !b pop ; then drop { cr }
 next drop fetch drop next ; { cr }
 { 000006BD } [ h# 00000004 org ]
: full { 0000009D } h# 0002AAAA t-stk dup or { 0000001F } t-stk h# 00033333
 t-stk h# 00019999 t-stk dup or !b ; { cr }
 { 000001BD } [ d# 2201 bin ] }block

( 0028B400 )               D# 557 shadow{ 
 ( rdstk mark testing return and data stacks registers ) { cr }
 ( also mulitple overs pops and pushes in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then push to return stack then pop to data stack
 then read back and verify each pattern ; relies on ) b s t r r-stack
 ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) { cr }
 ( / ) !b .. ( / ) @p .. dup - over .. ( / ) { cr }
 ( / ) over over over .. ( / ) over .. ( / ) { cr }
 ( / ) push push push .. ( / ) pop pop pop .. ( / ) { cr }
 ( / ) @p .. ( / ) !b .. ( / ) over push pop .. ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , next count for failure ) { br }

 ( uncomment ) - ( in )
: /stack ( after ) over ( to force failure ) }block

( 0028B800 )               D# 558 code{ 
 { 0001134F } ( mark d stack test v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000018 org ]
: fetch ( -n ) @p ! @ ; ( // ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack { 000003FD } dup - over .. ( / ) over over { cr }
 over .. ( / ) over over over .. ( / ) over .. ( / ) ;
: d-stack { 0000049D } h# 00000008 for dup ( . - . ) /neighbor /stack
 ( . ) d# 11 for fetch or if pop pop - d# 10 . + !b pop ; then drop
 { cr }
 next next ; { cr }
 { 0000067D } [ h# 00000004 org ]
: full { 0000009D } h# 0002AAAA d-stack dup or { 0000001F } d-stack
 h# 00015555 d-stack dup or - { 007FFFFF } d-stack h# 00033333 d-stack
 h# 00019999 d-stack h# 0000CCCC d-stack h# 00026666 d-stack dup dup
 or { cr }
 !b ; { 000002DD } [ d# 2202 bin ] { cr }
 }block

( 0028BC00 )               D# 559 shadow{ 
 ( stk mark testing data stack registers ) { cr }
 ( also overs in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then read back and verify each pattern ; relies
 on ) b s t ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) { cr }
 ( / ) dup - over .. ( / ) over over over .. ( / ) { cr }
 ( / ) over .. ( / ) @p .. ( / ) !b .. ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , next count for failure ) { br }

 ( uncomment ) - ( in )
: d-stack ( after ) dup ( to force failure ) }block

( 0028C000 )               D# 560 code{ 
 { 0001136F } ( mark test + v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000018 org ] { cr }
: h+ over over ( . - . ) . + push
: t+ ( nn-n ) @p ! ! @p ( // ) @p .. ( // ) @p . + !p ( / ) ! ! @ { cr }
 pop over ( chk ) or if pop pop d# 1000 !b ; then drop ; { cr }
: first ( x ) leap h# 00023225 . + dup
: xstr @p drop !p ; { -cr } : x then h# 00000000 ; { 0000055D }
: sec ( y ) leap h# 0001F9A9 . + dup
: ystr @p drop !p ; { -cr } : y then h# 00000000 ;
: thr ( z ) leap h# 0001BE29 . + dup
: zstr @p drop !p ; { -cr } : z then h# 00000000 ; { cr cr }
 { 000006DD } [ h# 00000004 org ] { cr }
: tst+ dup or { 007FFFFF } h# 000003FF for first h+ sec over h+ thr
 h+ x - h+ over h+ z - h+ - y h+ dup h+ h+ next dup or !b ; { cr }
 { 0000031D } [ d# 2203 bin ] }block

( 0028C400 )               D# 561 shadow{ 
 ( tst+b mark testing + ) { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions in the port / ) { cr }
 @p .. ( / ) @p . + !p ( / ) { br }

 [ address h# 00000004 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success, ) { cr { 00007D0F } }
 ( for failure ) { br }

 ( uncomment ) - ( in )
: h+ ( to force failure ) { cr }
 }block

( 0028C800 )               D# 562 code{ 
 { 0001138F } ( mark testing and ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000001E org ]
: chk ( nn ) or if pop pop pop h# 00001000 !b ; then ( drop ) ;
: tand ( nn-n ) @p ! ! .. ( // ) @p @p and !p ( / ) ! @ ;
: ttand over over ( . - . ) and push tand pop chk ;
: first ( x ) leap h# 00023225 . + dup
: xstr @p drop !p ; { -cr } : x then h# 00000000 ;
: sec ( y ) leap h# 0001F9A9 . + dup
: ystr @p drop !p ; { -cr } : y then h# 00000000 ; { cr }
 { 000006BD } [ h# 00000004 org ]
: tstand { 007FFFFF } h# 00000100 for first sec ttand x - y ttand x
 y - ttand x - y - ttand y - x ttand y x - ttand y - x - ttand next
 dup or !b ; { cr }
 { 000003BD } [ d# 2204 bin ] { cr cr }
 }block

( 0028CC00 )               D# 563 shadow{ 
 ( tst-and mark testing and ) { br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) [ d# 1000 ] ( for failure )
 { br }

 ( uncomment ) - ( in )
: ttand ( after ) over ( to force failure ) }block

( 0028D000 )               D# 564 code{ 
 { 000113AF } ( mark test and ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000025 org ]
: chk ( nn ) or if pop pop h# 00001000 !b ; then ;
: tand ( nn-n ) @p ! ! .. ( // ) @p @p and !p .. ( / ) ! @ ; { cr }
: tand3 ( nnnn-n ) @p ! ! .. ( // ) @p @p @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( // ) and and and !p .. ( / ) ! @ ;
: tsa tand chk ;
: tsa3 tand3 chk ; { cr }
 { 000006DD } [ h# 00000004 org ]
: tstand { 0000000F } h# 00002222 h# 00017777 h# 0002AAAA h# 0003FAFF
 h# 00033333 tsa3 h# 00030A5C h# 0003FFFF over tsa h# 00030A5C - h# 0003FFFF
 over tsa h# 00000A00 h# 0003FF00 h# 00000FFF h# 0003FFFF h# 0003FA55
 tsa3 - tsa h# 00015555 tsa dup h# 0002AAAA tsa h# 00015555 h# 0002AAAA
 tsa !b ; { cr }
 { 000004BD } [ d# 2205 bin ] { cr cr }
 }block

( 0028D400 )               D# 565 shadow{ 
 ( tst-andb mark testing and ) { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p .. ( / ) @p @p @p @p ( / ) { cr }
 ( / ) and and and !p ( / ) { cr }
 ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) [ d# 1000 ] ( for failure )
 { br }

 ( first fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand ( to force failure ) { cr cr }
 ( second fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand3 ( to force failure ) { cr }
 }block

( 0028D800 )               D# 566 code{ 
 { 000113CF } ( mark testing or ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 0000001E org ]
: chk ( nn ) or if pop pop pop h# 00001000 !b ; then ;
: tor ( nn-n ) @p ! ! .. ( // ) @p @p or !p ( / ) ! @ ;
: ttor over over ( . - . ) or push tor pop chk ;
: first ( x ) leap h# 00023225 . + dup
: xstr @p drop !p ; { -cr } : x then h# 00000000 ;
: sec ( y ) leap h# 0001F9A9 . + dup
: ystr @p drop !p ; { -cr } : y then h# 00000000 ; { cr }
 { 000006BD } [ h# 00000004 org ]
: tst-or { 007FFFFF } h# 00000100 for first sec ttor x - y ttor x y
 - ttor x - y - ttor y - x ttor y x - ttor y - x - ttor next dup or
 !b ; { cr }
 { 000003BD } [ d# 2206 bin ] { cr cr }
 }block

( 0028DC00 )               D# 567 shadow{ 
 ( tst-or mark testing and ) { br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) [ d# 1000 ] ( for failure )
 { br }

 ( uncomment ) - ( in )
: ttand ( after ) over ( to force failure ) }block

( 0028E000 )               D# 568 code{ 
 { 000113EF } ( mark test or v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000025 org ]
: chk ( nn ) or if pop pop pop h# 00001000 !b ; then ;
: tor ( nn-n ) @p ! ! .. ( // ) @p @p or ( . - . ) !p .. ( / ) ! @
 ; { cr }
: tor3 ( nnnn-n ) @p ! ! .. ( // ) @p @p @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( // ) or or or ( . - . ) !p .. ( / ) ! @ ;
: tso tor chk ;
: tso3 tor3 chk ; { cr }
 { 000006DD } [ h# 00000004 org ]
: tstor h# 0003E372 h# 00035FA9 h# 0003F57F h# 00025733 h# 00011E97
 tso3 h# 0003F555 h# 0003FF00 h# 00000FFF h# 0003FFFF h# 0003FA55 tso3
 h# 00015555 h# 0003FFFF over - tso h# 0002AAAA h# 0003FFFF over -
 tso dup or dup - dup tso dup or - dup dup - tso h# 00015555 over -
 over - tso !b ; { cr }
 { 000004BD } [ d# 2207 bin ] { cr cr }
 }block

( 0028E400 )               D# 569 shadow{ 
 ( tst-orb mark testing and ) { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p .. ( / ) @p @p @p @p ( / ) { cr }
 ( / ) and and and !p ( / ) { cr }
 ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { 0000000F } for success , ) [ d# 1000 ] ( for failure )
 { br }

 ( first fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand ( to force failure ) { cr cr }
 ( second fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand3 ( to force failure ) { cr }
 }block

( 0028E800 )               D# 570 code{ 
 { 0001140F } ( mark test - ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 00000026 org ]
: chk ( nn ) ! @ or if pop pop h# 00001000 !b ; then ;
: t- ( n-n ) @p ! .. ( // ) @p - !p .. ( / ) chk ;
: t-2 ( n-n ) dup @p ! .. ( // ) @p - - !p .. ( / ) chk ; { cr }
: t-3 ( n-n ) @p ! ! @p ( // ) @p .. ( / ) { cr }
 ( // ) - - - !p .. ( / ) chk ; { cr }
 { 000006DD } [ h# 00000004 org ]
: tstor h# 00001C8D h# 0003E372 t- h# 0002AAAA h# 00015555 t- h# 00015555
 h# 0002AAAA t- h# 0003FFFF dup dup or t- dup dup or h# 0003FFFF t-
 { cr }
 dup dup or t-2 h# 0003FFFF t-2 h# 0002AAAA t-2 h# 00015555 t-2 h# 0003FFFF
 dup dup or t-3 h# 0002AAAA h# 00015555 t-3 !b ; { cr }
 { 000004DD } [ d# 2208 bin ] { cr cr }
 }block

( 0028EC00 )               D# 571 shadow{ 
 ( tst- mark testing ) - { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p - !p .. ( / ) @p - - !p .. ( / ) { cr }
 ( / ) @p .. ( / ) - - - !p .. ( / ) { br }

 ( in the port ) { br }

 ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code ) [ d# 0 ] ( for success , ) [ d# 1000 ] ( for failure )
 { br }

 ( first fail mode; ) { cr }
 ( uncomment ) - ( in )
: t- ( to force failure ) { br }

 ( second fail mode; ) { cr }
 ( uncomment ) - ( in )
: t-2 ( to force failure ) { br }

 ( second fail mode; ) { cr }
 ( uncomment ) - ( in )
: t-3 ( to force failure ) }block

( 0028F000 )               D# 572 code{ 
 }block

( 0028F400 )               D# 573 shadow{ 
 }block

( 0028F800 )               D# 574 code{ 
 }block

( 0028FC00 )               D# 575 shadow{ 
 }block

( 00290000 )               D# 576 code{ 
 }block

( 00290400 )               D# 577 shadow{ 
 }block

( 00290800 )               D# 578 code{ 
 }block

( 00290C00 )               D# 579 shadow{ 
 }block

( 00291000 )               D# 580 code{ 
 }block

( 00291400 )               D# 581 shadow{ 
 }block

( 00291800 )               D# 582 code{ 
 }block

( 00291C00 )               D# 583 shadow{ 
 }block

( 00292000 )               D# 584 code{ 
 }block

( 00292400 )               D# 585 shadow{ 
 }block

( 00292800 )               D# 586 code{ 
 }block

( 00292C00 )               D# 587 shadow{ 
 }block

( 00293000 )               D# 588 code{ 
 }block

( 00293400 )               D# 589 shadow{ 
 }block

( 00293800 )               D# 590 code{ 
 }block

( 00293C00 )               D# 591 shadow{ 
 }block

( 00294000 )               D# 592 code{ 
 }block

( 00294400 )               D# 593 shadow{ 
 }block

( 00294800 )               D# 594 code{ 
 }block

( 00294C00 )               D# 595 shadow{ 
 }block

( 00295000 )               D# 596 code{ 
 }block

( 00295400 )               D# 597 shadow{ 
 }block

( 00295800 )               D# 598 code{ 
 }block

( 00295C00 )               D# 599 shadow{ 
 }block

( 00296000 )               D# 600 code{ 
 ( res for more ats test pkgs --- ) }block

( 00296400 )               D# 601 shadow{ 
 }block

( 00296800 )               D# 602 code{ 
 }block

( 00296C00 )               D# 603 shadow{ 
 }block

( 00297000 )               D# 604 code{ 
 }block

( 00297400 )               D# 605 shadow{ 
 }block

( 00297800 )               D# 606 code{ 
 }block

( 00297C00 )               D# 607 shadow{ 
 }block

( 00298000 )               D# 608 code{ 
 }block

( 00298400 )               D# 609 shadow{ 
 }block

( 00298800 )               D# 610 code{ 
 }block

( 00298C00 )               D# 611 shadow{ 
 }block

( 00299000 )               D# 612 code{ 
 }block

( 00299400 )               D# 613 shadow{ 
 }block

( 00299800 )               D# 614 code{ 
 }block

( 00299C00 )               D# 615 shadow{ 
 }block

( 0029A000 )               D# 616 code{ 
 }block

( 0029A400 )               D# 617 shadow{ 
 }block

( 0029A800 )               D# 618 code{ 
 }block

( 0029AC00 )               D# 619 shadow{ 
 }block

( 0029B000 )               D# 620 code{ 
 }block

( 0029B400 )               D# 621 shadow{ 
 }block

( 0029B800 )               D# 622 code{ 
 }block

( 0029BC00 )               D# 623 shadow{ 
 }block

( 0029C000 )               D# 624 code{ 
 }block

( 0029C400 )               D# 625 shadow{ 
 }block

( 0029C800 )               D# 626 code{ 
 }block

( 0029CC00 )               D# 627 shadow{ 
 }block

( 0029D000 )               D# 628 code{ 
 }block

( 0029D400 )               D# 629 shadow{ 
 }block

( 0029D800 )               D# 630 code{ 
 { 0000ED8F } ( ats analog ) { cr }
 [ reclaim d# 717 node d# 0 org ]
: sam ( n-k ) { 0000001D } io b! data a! @b - h# 000001FF and or { cr }
 !b dup ! @ d# 1000 for unext dup ! @ - . + ;
: vdd { 0000019D } h# 00002000 sam ; { -cr } : vss { 000001DD } h# 00006000
 sam ;
: vpin { 0000021D } h# 00000000 sam ;
: u* ( nn-hl ) { 0000025D } dup a! dup or d# 17 for +* unext { cr }
 push drop pop a ;
: m/ ( dn-q ) --u/mod push drop pop ;
: mv ( -n ) { 0000033D } vss vdd over - . + push { cr }
 vpin - . + -if dup or then d# 1800 u* pop m/ ;
: !mv ( n ) { 0000047D } io b! d# 511 u* d# -1800 m/ h# 00000155 or
 !b ; { cr }
 { 0000057D } [ d# 1900 bin ] }block

( 0029DC00 )               D# 631 shadow{ 
 ( ide mode code. )
: mv ( returns approx pad voltage in mv using contemporaneous cal values
 from our own rails assuming said rails at { 0000000F } and 1800. no
 linearization. dac output remains unchanged. )
: !mv ( sets dac output to a voltage in mv. this is most bogus since
 no linearization is done; the actual voltage will be much higher than
 what we are setting. ) }block

( 0029E000 )               D# 632 code{ 
 { 0000EDAF } ( ats sync boot master ) { cr }
 [ reclaim d# 300 node d# 0 org ]
: dly { 0000001D } ( b ) !b d# 40 { 000003EF } for unext ;
: 1bt { 0000007D } ( wb-w' ) dup dly h# 00010000 or dly ;
: 18o { 000000DD } ( w ) h# 00030000 dly d# 8 for begin { cr }
 { 0000015D } -if ( 1- ) h# 00030003 1bt [ swap ] { -cr } : rise { cr }
 { 000001BD } 2* -if ( 1+ ) h# 00020003 1bt 2* *next drop ; { cr }
 { 0000025D } ( . ) then ( 0+ ) h# 00020002 1bt 2* *next drop ; { cr }
 { 000002DD } ( . ) then ( 0- ) h# 00030002 1bt rise ; { cr }
: off { 0000033D } io b! h# 00020002 dly h# 00010001 !b ; { cr }
 { 000003FD } [ d# 1901 bin ] }block

( 0029E400 )               D# 633 shadow{ 
 ( this code is loaded into tb001 test chip node { 0000258F } to boot
 node { 0000258F } of the uut. the ide uses ) 18o ( to form a boot
 stream to load the link ) { cr }
 ( routine into the remote node. once remote ) { cr }
 ( is started ide sets the local pins to low ) { cr }
 ( tri-state and weak-low before loading the ) { cr }
 ( link code into the local node and starting it. at this time both
 of these nodes remain off of the grid until both the test and uut
 chip have been reset. ) }block

( 0029E800 )               D# 634 code{ 
 { 0000EDCF } ( boot frame for master testing ) { cr }
 [ reclaim d# 300 node d# 0 org ] { cr }
 [ host ] { -cr } : 3- h# FFFFFFFD + ; [ target ] { br }

: frame ser-exec -d-- [ d# 0 , ]
: portex @p !b . . ( / ) [ h# 00030000 , ] ( / ) { cr }
 { 000000BD } [ here here 3- d# 2 org , ] { cr }
 [ org ] { 000000BD } [ d# 1902 bin ] }block

( 0029EC00 )               D# 635 shadow{ 
 ( boot frame which commands uut node { 0000401F } to set its pin 200.17
 high. ) }block

( 0029F000 )               D# 636 code{ 
 { 0000EDEF } ( boot frame for master testing ) { cr }
 [ reclaim d# 300 node d# 0 org ] { cr }
 [ host ] { -cr } : 3- h# FFFFFFFD + ; [ target ] { br }

: frame ser-exec -d-- [ d# 0 , ]
: portex @p !b . . ( / ) [ h# 00020000 , ] ( / ) { cr }
 { 000000BD } [ here here 3- d# 2 org , ] { cr }
 [ org ] { 000000BD } { cr }
 [ h# 00000020 org ]
: misc ---u @p - !p ; [ d# 1903 bin ] }block

( 0029F400 )               D# 637 shadow{ 
 ( boot frame which commands uut node { 0000401F } to set its pin 200.17
 low. ) }block

( 0029F800 )               D# 638 code{ 
 { 0000EE0F } ( ats sync bridge ) { cr }
 [ reclaim d# 300 node { 0000006F } d# 8 org ] { cr }
 [ host ] { -cr } : hd- { FFFFFFAF } d# -8 + ; [ target ] { br }

: dly { 0000011D } ( b ) !b d# 40 for unext ; ( 88ns )
: 1bt { 0000017D } ( wb-w' ) dup dly h# 00010000 or dly ;
: zro { 000001DD } h# 00010001 dly ; { -cr } : wpd { 0000021D } h# 00010001
 !b ;
: 18o { 0000025D } ( w ) zro d# 17 for begin { cr }
 { 000002BD } -if h# 00030003 1bt 2* *next drop wpd ; { cr }
 { 0000035D } then h# 00030002 1bt 2* next drop wpd ; { br }

: 18i { 000003DD } ( x ) drop dup or !b d# 17 for { cr }
 { 0000043D } ( .. ) begin @b -until { cr }
 { 0000045D } ( .. ) begin @b - -until { cr }
 { 0000047D } ( .. ) - d# 2 and 2/ a 2* or a! next { cr }
 { 000004FD } a up a! ! { br }

: idl { 0000055D } h# 00000165 ( --lu ) a! . @ @b -if drop 18i ; { cr }
 { 000005DD } then zro drop 18o idl ; { cr }
: ent { 0000063D } io b! wpd begin @b - -until idl ; { cr }
 { 000006DD } [ here here hd- { 0000000F } d# 5 org ]
: frame ent dly [ , ] { cr }
 [ org ] { 000006DD } [ d# 1904 bin ] }block

( 0029FC00 )               D# 639 shadow{ 
 shadow out of date. { cr }
 ( this code is loaded into nodes { 0000258F } of both ) { cr }
 ( the test and uut chips of the tb001 board. ) { cr }
 ( the transmitter controls the clock and data is sampled on the falling
 edge. the clock is set to low tri-state and data to weak-low one half
 bit time from the end of word. the code idles reading from a neighbor
 and the clock pin. ) { cr }
 ( data from the neighbor are transmitted and ) { cr }
 ( receive data are writen to the neighbor. no ) { cr }
 ( attempt is made to be able to terminate either of these serial linked
 nodes except reset. ) { cr }
 ( terminating the remote node would require ) { cr }
 ( an enhanced protocol. also we see no need ) { cr }
 ( to impliment flow control at this time. on ) { cr }
 ( entry the code waits for the clock to drop ) { cr }
 ( to facilitate transition from the old boot ) { cr }
 ( protocol. ) { cr }
 [ origin moved to d# 5 so boot frame header can be laid down without
 affecting slot d# 2 jumps. ] }block

( 002A0000 )               D# 640 code{ 
 { 0000EE2F } ( uut bridge debug ) { cr }
 [ reclaim d# 300 node { 0000006F } d# 8 org ] { cr }
 [ host ] { -cr } : hd- { FFFFFFAF } d# -8 + ; [ target ] { br }

: dly { 0000011D } ( b ) !b { 0000050F } d# 400 for unext ; ( 88ns )
: 1bt { 0000017D } ( wb-w' ) dup dly h# 00010000 or dly ;
: zro { 000001DD } h# 00010001 dly ;
: wpd { 0000021D } h# 00010001 !b ;
: 18o { 0000025D } ( w ) zro d# 17 for begin { cr }
 { 000002BD } -if h# 00030003 1bt 2* *next drop wpd ; { cr }
 { 0000035D } then h# 00030002 1bt 2* next drop wpd ;
: 18i { 000003DD } ( x ) drop dup or !b d# 17 for { cr }
 { 0000043D } ( .. ) begin @b -until { cr }
 { 0000045D } ( .. ) begin @b - -until { cr }
 { 0000047D } ( .. ) - d# 2 and 2/ a 2* or a! next { cr }
 { 000004FD } a ( up a! ! { 0000002F } and { 0000004F } or !b ) zro
 d# 12345 . + 18o { br }

: idl { 0000057D } h# 00000165 ( --lu ) a! { cr }
 { 000005BD } @ @b -if drop 18i ; then { cr }
 { 000005FD } zro drop 18o ( idl ; ) { cr }
: ent { 0000063D } io b! wpd { cr }
 begin @b - -until idl ; { cr }
 { 000006DD } [ here here hd- { 0000000F } d# 5 org ]
: frame ent dly [ , ] { cr }
 [ org ] { 000006DD } [ d# 1905 bin ] }block

( 002A0400 )               D# 641 shadow{ 
 shadow out of date. { cr }
 ( this code is loaded into nodes { 0000258F } of both ) { cr }
 ( the test and uut chips of the tb001 board. ) { cr }
 ( the transmitter controls the clock and data is sampled on the falling
 edge. the clock is set to low tri-state and data to weak-low one half
 bit time from the end of word. the code idles reading from a neighbor
 and the clock pin. ) { cr }
 ( data from the neighbor are transmitted and ) { cr }
 ( receive data are writen to the neighbor. no ) { cr }
 ( attempt is made to be able to terminate either of these serial linked
 nodes except reset. ) { cr }
 ( terminating the remote node would require ) { cr }
 ( an enhanced protocol. also we see no need ) { cr }
 ( to impliment flow control at this time. on ) { cr }
 ( entry the code waits for the clock to drop ) { cr }
 ( to facilitate transition from the old boot ) { cr }
 ( protocol. ) { cr }
 [ origin moved to d# 5 so boot frame header can be laid down without
 affecting slot d# 2 jumps. ] }block

( 002A0800 )               D# 642 code{ 
 { 0000EE4F } ( tester bridge debug ) { cr }
 [ reclaim d# 300 node { 0000006F } d# 8 org ] { cr }
 [ host ] { -cr } : hd- { FFFFFFAF } d# -8 + ; [ target ]
: dly { 0000011D } ( b ) !b { 0000050F } d# 400 for unext ; ( 88ns )
: 1bt { 0000017D } ( wb-w' ) dup dly h# 00010000 or dly ;
: zro { 000001DD } h# 00010001 dly ;
: wpd { 0000021D } h# 00010001 !b ;
: 18o { 0000025D } ( w ) io b! zro d# 17 for begin { cr }
 { 000002FD } -if h# 00030003 1bt 2* *next drop wpd ; { cr }
 { 0000039D } then h# 00030002 1bt 2* next drop wpd ;
: 18i { 0000041D } ( x ) drop dup or !b d# 17 for { cr }
 { 0000047D } ( .. ) begin @b -until { cr }
 { 0000049D } ( .. ) begin @b - -until { cr }
 { 000004BD } ( .. ) - d# 2 and 2/ a 2* or a! next { cr }
 { 0000055D } a ( up a! ! ) ;
: joe { 0000057D } ( w ) 18o 18i ;
: idl { 000005BD } h# 00000165 ( --lu ) a! { cr }
 { 000005FD } @ @b -if drop 18i ; then { cr }
 { 0000063D } zro drop 18o ( idl ; ) { cr }
: ent { 0000067D } io b! h# 00010001 !b { cr }
 begin @b - -until ( idl ) ; { cr }
 { 0000075D } [ here here hd- { 0000000F } d# 5 org ]
: frame ent dly [ , ] { cr }
 [ org ] { 0000075D } [ d# 1906 bin ] }block

( 002A0C00 )               D# 643 shadow{ 
 shadow out of date. { cr }
 ( this code is loaded into nodes { 0000258F } of both ) { cr }
 ( the test and uut chips of the tb001 board. ) { cr }
 ( the transmitter controls the clock and data is sampled on the falling
 edge. the clock is set to low tri-state and data to weak-low one half
 bit time from the end of word. the code idles reading from a neighbor
 and the clock pin. ) { cr }
 ( data from the neighbor are transmitted and ) { cr }
 ( receive data are writen to the neighbor. no ) { cr }
 ( attempt is made to be able to terminate either of these serial linked
 nodes except reset. ) { cr }
 ( terminating the remote node would require ) { cr }
 ( an enhanced protocol. also we see no need ) { cr }
 ( to impliment flow control at this time. on ) { cr }
 ( entry the code waits for the clock to drop ) { cr }
 ( to facilitate transition from the old boot ) { cr }
 ( protocol. ) { cr }
 [ origin moved to d# 5 so boot frame header can be laid down without
 affecting slot d# 2 jumps. ] }block

( 002A1000 )               D# 644 code{ 
 }block

( 002A1400 )               D# 645 shadow{ 
 }block

( 002A1800 )               D# 646 code{ 
 }block

( 002A1C00 )               D# 647 shadow{ 
 }block

( 002A2000 )               D# 648 code{ 
 { 0000AF0F } ( ats cs master0 n108 ) { cr }
 [ reclaim d# 108 node { 00005CCF } ] ( load ) { 0000155D } [ d# 0
 org ]
: sam ( n-k ) { 0000001D } { cr }
 { 0000003D } [ d# 1400 bin ] }block

( 002A2400 )               D# 649 shadow{ 
 ( code for node { 00000D8F } in ats. ) { cr }
 }block

( 002A2800 )               D# 650 code{ 
 { 0000AF2F } ( ats cs wire ) { cr }
 [ reclaim d# 109 node d# 0 org ]
: sam ( n-k ) { 0000001D } { cr }
 { 0000057D } [ d# 1401 bin ] }block

( 002A2C00 )               D# 651 shadow{ 
 }block

( 002A3000 )               D# 652 code{ 
 { 0000AF4F } ( ats cs digital ) { cr }
 [ reclaim d# 717 node d# 0 org ]
: sam ( n-k ) { 0000001D } { cr }
 { 0000057D } [ d# 1402 bin ] }block

( 002A3400 )               D# 653 shadow{ 
 ( pf mode code for digital nodes. ) }block

( 002A3800 )               D# 654 code{ 
 { 0000AF6F } ( ats cs analog ) { cr }
 [ reclaim d# 717 node d# 0 org ]
: sam ( n-k ) { 0000001D } io b! data a! @b - h# 000001FF and or { cr }
 !b dup ! @ d# 1000 for unext dup ! @ - . + ;
: vdd { 0000019D } h# 00002000 sam ; { -cr } : vss { 000001DD } h# 00006000
 sam ;
: vpin { 0000021D } h# 00000000 sam ;
: u* ( nn-hl ) { 0000025D } dup a! dup or d# 17 for +* unext { cr }
 push drop pop a ;
: m/ ( dn-q ) --u/mod push drop pop ;
: mv ( -n ) { 0000033D } vss vdd over - . + push { cr }
 vpin - . + -if dup or then d# 1800 u* pop m/ ;
: !mv ( n ) { 0000047D } io b! d# 511 u* d# -1800 m/ h# 00000155 or
 !b ; { cr }
 { 0000057D } [ d# 1403 bin ] }block

( 002A3C00 )               D# 655 shadow{ 
 ( pf mode code. )
: mv ( returns approx pad voltage in mv using contemporaneous cal values
 from our own rails assuming said rails at { 0000000F } and 1800. no
 linearization. dac output remains unchanged. )
: !mv ( sets dac output to a voltage in mv. this is most bogus since
 no linearization is done; the actual voltage will be much higher than
 what we are setting. ) }block

( 002A4000 )               D# 656 code{ 
 }block

( 002A4400 )               D# 657 shadow{ 
 }block

( 002A4800 )               D# 658 code{ 
 ( xxxx smtm mem-random converted ) { cr }
 [ reclaim d# 0 node d# 0 ] d# 3 [ org ]
: rnd ( n-n' ) { 0000001D } -if 2* h# 0002CD81 or ; then 2* ;
: run { 0000009D } @p @p a! dup ( / ) [ h# 00012155 , h# 000000A9 , ]
 ( / ) { cr }
 @ h# 0000000B a! .. or h# 00000003 h# 0003FFF8 .. rnd dup ! and ..
 { cr }
 push h# 00000008 begin 2* . . unext and if or ahead { cr }
 [ swap ] then run ; { 0000029D } . .. . ..
: go { 000002DD } then @ over a! @p ( / ) @p dup push dup { cr }
 a ! ! h# 0000000E push dup ! begin @p ! . unext ( /- ) { cr }
 { 0000039D } push dup push dup push dup push dup { cr }
 { 000003DD } push dup push dup push push pop dup { cr }
 { 0000041D } pop pop pop pop pop pop pop pop h# 0000003F dup { cr }
 { 0000049D } push push or dup a! or or or or or or or . { 0000051D }
 begin dup !+ . unext begin @+ or . unext { cr }
 { 0000055D } @p a! ! . ( -/ ) a ! @ or if warm ; then
: migrate h# 0001557F !b h# 0001556A . h# 0000001F for . . . unext
 { cr }
 { 0000069D } !b h# 00000004 @p . ( / ) @p dup 2/ . ( / ) { cr }
 { 000006FD } a ! ! h# 00000043 push begin @p !+ . unext ( /- ) { cr }
 { 0000077D } [ h# 0000003F , ] 2* a! push begin @p !+ . unext { cr }
 { 000007DD } @p push ; ( -/ ) ! warm ; { cr }
 { 0000081D } ( xxxx bin ) }block

( 002A4C00 )               D# 659 shadow{ 
 ( this is steven's ) { cr }
 ( g144-smtm-self-tet-mem-random ) }block

( 002A5000 )               D# 660 code{ 
 ( tb001 ide pretest ) [ empty serial load ] { br }

 ( customize ) [ -canon d# 660 orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { br }

: mv ( -n ) [ h# 00000019 ] call h# 0000003F lit' ra! !a h# 0000003F
 r@ ;
: !mv ( n ) lit' [ h# 00000023 ] call ;
: +a ( nn ) d# 2 swap hook d# 0 d# 64 d# 1900 boot ; { br }

: !vdc ( mv ) [ d# 709 ] +a !mv ; { -cr } : vdc ( -mv ) [ d# 709 ]
 +a mv ;
: !vdi ( mv ) [ d# 713 ] +a !mv ; { -cr } : vdi ( -mv ) [ d# 713 ]
 +a mv ;
: !vda ( mv ) [ d# 717 ] +a !mv ; { -cr } : vda ( -mv ) [ d# 717 ]
 +a mv ;
: !bus ( mv ) [ d# 117 ] +a !mv ; { -cr } : bus ( -mv ) [ d# 117 ]
 +a mv ;
: drain d# 2 [ d# 617 ] hook h# 000000AA io r! h# 00000155 io r! ;
: set ( n nn ) d# 2 swap hook [ d# 2 ] + [ h# 00010000 ] * io r! ;
: rst ( n ) [ d# 417 ] set ;
: 1.8 ( n ) [ d# 715 ] set ; { -cr } : 1.475 ( n ) [ d# 517 ] set ;
: hivd [ d# 1 ] 1.8 [ d# 0 ] 1.475 ; { -cr } : lovd [ d# 1 ] 1.475
 [ d# 0 ] 1.8 ;
: novd [ d# 0 ] 1.8 [ d# 0 ] 1.475 drain ; { br }

 ( functions ) [ d# 662 d# 4 loads ] { cr }
 ( automate ) [ talk pre ] }block

( 002A5400 )               D# 661 shadow{ 
 ( these defns are used in ide on ats master to simulate actions later
 run by polyforth. ) { br }

: !vdx ( and ) vdx ( drive and read uut power bus ) [ x ] ( in nonlinear
 millivolts. )
: !bus ( and ) bus ( do the same with analog bus. )
: rst ( sets uut reset line low if ) [ n d# 0 ] ( or high ) [ d# 1 ]
: drain ( used only when no power enabled to short out the supply rails
 briefly. )
: rst ( controls uut reset line ) [ d# 0 ] ( is low. )
: 1.8 ( and ) 1.475 ( control power supplies ) [ d# 1 ] ( enables )
 [ d# 0 ] ( disables. )
: hivd lovd ( and ) novd ( select high, low, and zero voltage power
 supply to uut. ) }block

( 002A5800 )               D# 662 code{ 
 ( - pre powerup tests ) [ d# 662 list ] { br }

 UNKNOWN ( preliminary tests ) { .pok }
 :# vval 1 { cr }
 :# vcop 1 :# vcsh 1 :# viop 1 :# vish 1 :# vaop 1 :# vash 1 { br }

: init d# 0 [ vcop ] ! d# 0 [ vcsh ] ! d# 0 [ viop ] ! d# 0 [ vish ]
 ! { cr }
 d# 0 [ vaop ] ! d# 0 [ vash ] ! d# 0 [ vval ] ! pause
: -pwr d# 0 rst d# 0 !vdc d# 0 !vdi d# 0 !vda novd ; { br }

 [ exit ] ( test procedure... )
: - no chip in socket
: - 'compile'
: - '280 load talk'
: - insert chip
: - 'pre'
: - will stop here if pretests fail
: - else runs creeper tests in d# 250
: - [ always say ] -pwr [ before removing chip!!! ] }block

( 002A5C00 )               D# 663 shadow{ 
: -pwr ( removes all power from uut socket and leaves it ) safe ( for
 inserting or removing chip. puts chip in reset, disables both power
 supplies, removes drive from power rail test dacs, and drains the
 rails. )
: ?open ( checks each supply rail for enough loading to believe there's
 a chip in the socket. ) }block

( 002A6000 )               D# 664 code{ 
 ( - power opens and shorts )
: sam ( -n ) mv mv + mv + mv + 2/ 2/ ;
: -sam ( x-mv ) drop sam ;
: lt ( nn-t ) less if drop drop d# 1 ; { cr }
 then drop drop d# 0 ;
: -sht ( n.mv.mv-t ) max 2* swap lt ; { br }

: ?cop [ d# 75 ] !vdc sam ( dup ) [ d# 500 ] lt [ vcop ] ! d# 0 !mv
 ;
: ?iop [ d# 75 ] !vdi sam ( dup ) [ d# 500 ] lt [ viop ] ! d# 0 !mv
 ;
: ?aop [ d# 75 ] !vda sam ( dup ) [ d# 850 ] lt [ vaop ] ! d# 0 !mv
 ;
: ?open ?cop pause ?iop pause ?aop pause ; { br }

: ?csht [ d# 75 ] !vdc sam vdi -sam vda -sam { cr }
 -sht [ vcsh ] ! d# 0 !vdc ;
: ?isht [ d# 75 ] !vdi sam vdc -sam vda -sam { cr }
 -sht [ vish ] ! d# 0 !vdi ;
: ?asht [ d# 75 ] !vda sam vdi -sam vdc -sam { cr }
 -sht [ vash ] ! d# 0 !vda ;
: ?short ?csht pause ?isht pause ?asht pause ; }block

( 002A6400 )               D# 665 shadow{ 
 }block

( 002A6800 )               D# 666 code{ 
 ( - results )
: chs ( ...n ) for emit next ;
: ?good ( -t ) [ vcop ] @ [ vcsh ] @ and [ viop ] @ and [ vish ] @
 and [ vaop ] @ and [ vash ] @ and ;
: .pf ?good drop if { cr }
 green d# 42 d# 36 d# 3 d# 3 chs space ; { cr }
 then red d# 42 d# 12 d# 7 d# 5 d# 14 d# 5 chs space ;
: .pok blu [ vval ] @ d# 0 + drop if .pf ; { cr }
 then silver d# 11 d# 8 d# 22 d# 19 d# 4 chs space ; }block

( 002A6C00 )               D# 667 shadow{ 
: .pok ( shows how to make a blue word display variable text strings. )
 }block

( 002A7000 )               D# 668 code{ 
 ( - port bridge ) { br }

: !sync d# 0 [ d# 300 ] hook d# 0 d# 64 [ d# 1901 ] boot [ h# 00000019 ]
 call ; { br }

: pt@ ( a-n ) @ h# 00015555 or ;
: frame ( a nd ) nn-n 2* d# 32768 + block + dup d# 2 + pt@ d# 3 + for
 dup pt@ lit' d# 6 call [ d# 1 ] + next drop ;
: !hitst d# 0 [ d# 1902 ] frame ;
: !lotst d# 0 [ d# 1903 ] frame ;
: !his d# 5 [ d# 1904 { 0000EE2F } ] frame ; { br }

: !ours ( off ) [ h# 00000019 ] call d# 0 d# 64 [ d# 1904 ] boot { cr }
 ( ent ) [ h# 00000030 ] call ( testing ) h# 00000000 [ d# 400 ] hook
 focus ; { br }

: setup ?good drop if -pwr !sync hivd d# 1 rst { cr }
 [ d# 300 ] node ( !hitst ) !his !ours then ; { br }

: pre [ d# 662 ] list pause init { cr }
 ?open ?short d# 1 [ vval ] ! d# 123 pause { cr }
 ?good drop if setup { cr }
 d# 2 -hook d# 1 -hook d# 0 -hook drop pause { cr }
 [ d# 670 ] load ; then ; }block

( 002A7400 )               D# 669 shadow{ 
 ( set up port bridge. ) { br }

: first ( we load sync boot master in our { 0000258F } done by ) !sync
: second ( we load bridge in uut node { 0000258F } using ) frame ( which
 sends a boot frame starting at location ) [ a ] ( compiled for bin )
 [ nd's ] ( ram )
: third ( we load bridge into our node { 0000258F } ) { br }

: setup ( does all this and loads new ide for the bridged 2-chip system. )
: pre ( runs full set of pre-tests ) }block

( 002A7800 )               D# 670 code{ 
 ( tb001 ide creepers ) [ empty serial load ] { br }

 ( customize ) [ -canon d# 670 orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { cr }
 ( functions ) [ d# 674 d# 5 loads ] { br }

 UNKNOWN ( test status is ) { .pok br }

 ( details ) :# ph 3 :# id 2002 :# tgt 1000 :# pos 154 { cr }
 ( ------- ) :# ans 0 :# rval 39050 { cr }
 ( ------- ) :# nrun 13125 :# vval 1 { br }

: init d# 0 [ tgt ] ! d# 0 [ pos ] ! d# 0 [ nrun ] ! d# 0 [ id ] !
 d# 0 [ rval ] ! d# 0 [ ans ] ! d# 0 [ vval ] ! d# -1 [ ph ] ! ; { cr }
 ( runner ) [ d# 684 d# 9 loads d# 672 load { 000053CF } ] ( list )
 { br }

: run d# 670 list !p0 !p1 init pause { indent }
      -buses d# 0 d# 1000 hook d# 0 -hook ana0 ( ; ) { cr }
 d# 0 [ ph ] ! d# 0 path z t911 t917 ta00 t913 { cr }
 d# 1 [ ph ] ! d# 1 path z !p1a { cr }
 d# 2 [ ph ] ! d# 1 path z !p1 ser70 !p1b ser07 !p1 { cr }
 d# 3 [ ph ] ! lovd d# 0 path d# 2007 runall d# 2002 runall { cr }
 d# 1 [ vval ] ! -pwr ; [ run ] }block

( 002A7C00 )               D# 671 shadow{ 
 ( ide environment to run ide and creepers in the uut. path { 0000004F }
 reaches right side controls. paths { 0000000F } and { 0000002F } are
 mutually exclusive reaching into the uut. ) { br }

: !vdx ( and ) vdx ( drive and read uut power bus ) [ x ] ( in nonlinear
 millivolts. )
: !bus ( and ) bus ( do the same with analog bus. )
: rst ( sets uut reset line low if ) [ n d# 0 ] ( or high ) [ d# 1 ]
: drain ( used only when no power enabled to short out the supply rails
 briefly. )
: rst ( controls uut reset line ) [ d# 0 ] ( is low. )
: 1.8 ( and ) 1.475 ( control power supplies ) [ d# 1 ] ( enables )
 [ d# 0 ] ( disables. )
: hivd lovd ( and ) novd ( select high, low, and zero voltage power
 supply to uut. ) { br }

 [ needing special runners - d# 913 d# 911 ] }block

( 002A8000 )               D# 672 code{ 
 ( - all tests ) { br }

: z ( lov-ram ) [ d# 2007 ] runall { cr }
 ( port ) [ d# 2000 ] runall ( port2* ) [ d# 2001 ] runall { cr }
 ( ram ) [ d# 2002 ] runall ( t,s ) [ d# 2003 ] runall { cr }
 ( t,r ) [ d# 2004 ] runall ( stack ) [ d# 2005 ] runall { cr }
 ( return ) [ d# 2006 ] runall ( ms-rdst ) [ d# 2008 ] runall { cr }
 ( shifta ) [ d# 2009 ] runall ( tsar-data ) [ d# 2010 ] runall { cr }
 ( ms-stk ) [ d# 2012 ] runall ( carry ) [ d# 2014 ] runall { cr }
 ( ms-@p ) [ d# 2015 ] runall ( i,r-ad ) [ d# 2016 ] runall { cr }
 ( @b!b ) [ d# 2101 ] runall ( b-reg ) [ d# 2102 ] runall { cr }
 ( i-reg ) [ d# 2103 ] runall ( i-reg ) [ d# 2104 ] runall { cr }
 ( i-reg ) [ d# 2105 ] runall ( i-reg ) [ d# 2106 ] runall { cr }
 ( i-reg ) [ d# 2107 ] runall ( i-reg ) [ d# 2108 ] runall { cr }
 ( i-reg ) [ d# 2109 ] runall ( prp-call ) [ d# 2110 ] runall { cr }
 ( prp-ex ) [ d# 2111 ] runall ( tst-2* ) [ d# 2115 ] runall { cr }
 ( tst-2/ ) [ d# 2116 ] runall ( tst-2/b ) [ d# 2117 ] runall { cr }
 ( tst+ ) [ d# 2200 ] runall ( rdstkv2 ) [ d# 2201 ] runall { cr }
 ( dstkv2 ) [ d# 2202 ] runall ( +v2 ) [ d# 2203 ] runall { cr }
 ( and ) [ d# 2204 ] runall ( andv2 ) [ d# 2205 ] runall { cr }
 ( or ) [ d# 2206 ] runall ( orv2 ) [ d# 2207 ] runall { cr }
 ( - ) [ d# 2208 ] runall { cr }
 ; }block

( 002A8400 )               D# 673 shadow{ 
 }block

( 002A8800 )               D# 674 code{ 
 ( - multichip ide )
: mwall ( nn-i ) [ d# 1000 ] mod swap [ d# 1000 ] mod { cr }
 over over or drop if swall ; { cr }
 then drop drop ( up ) d# 3 ; [ ' mwall 'wall ! ] { br }

: uup0 align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1500 , d# 1600 , ] { cr }
 [ d# 1700 , d# 1701 , d# 1702 , d# 1703 , d# 1704 , d# 1705 , ] { cr }
 [ d# 1706 , d# 1707 , d# 1708 , d# 1709 , d# 1710 , d# 1711 , ] { cr }
 [ d# 1712 , d# 1713 , d# 1714 , d# 1715 , d# 1716 , d# 1717 , ] { cr }
 [ d# 1617 , d# 1616 , d# 1615 , d# 1614 , d# 1613 , d# 1612 , ] { cr }
 [ d# 1611 , d# 1610 , d# 1609 , d# 1608 , d# 1607 , d# 1606 , ] { cr }
 [ d# 1605 , d# 1604 , d# 1603 , d# 1602 , d# 1601 , ] { cr }
 [ d# 1501 , d# 1502 , d# 1503 , d# 1504 , d# 1505 , d# 1506 , ] { cr }
 [ d# 1507 , d# 1508 , d# 1509 , d# 1510 , d# 1511 , d# 1512 , ] { cr }
 [ d# 1513 , d# 1514 , d# 1515 , d# 1516 , d# 1517 , ] { cr }
 [ d# 1417 , d# 1416 , d# 1415 , d# 1414 , d# 1413 , d# 1412 , ] { cr }
 [ d# 1411 , d# 1410 , d# 1409 , d# 1408 , d# 1407 , d# 1406 , ] { cr }
 [ d# 1405 , d# 1404 , d# 1403 , d# 1402 , d# 1401 , ] { cr }
 [ d# 1301 , d# 1302 , d# 1303 , d# 1304 , d# 1305 , d# 1306 , ] { cr }
 [ d# 1307 , d# 1308 , d# 1309 , d# 1310 , d# 1311 , d# 1312 , ] { cr }
 [ d# 1313 , d# 1314 , d# 1315 , d# 1316 , d# 1317 , ] { cr }
 }block

( 002A8C00 )               D# 675 shadow{ 
: mwall ( discards chip id portion of node number and in the special
 case of two consecutive nodes of same number forces up port to be
 the wall between them. thus a path going from { 0000320F } to { 0000AF0F }
 uses up to make the connection via the { 0000258F } to { 0000258F }
 sync bridge. ) { br }

: uup0 ( is the primary path for pass/fail testing in the uut. it reaches
 all nodes but the bridge in { 0000258F } )
: uup1 ( is secondary path which passes thru most of the ports skipped
 by uup1. it does not include nodes 000 { 00000C8F } { 0000190F } and
 leaves { 0000008F } ports that have not been exercised. )
: up1a ( is a quick path that is substituted for path { 0000002F }
 to catch the four remaining ports. ) { br }

 when all three have been done, only node d# 300 and its right and
 down ports have not been exercised. }block

( 002A9000 )               D# 676 code{ 
 ( -- paths 0,1 ) { cr }
 [ d# 1217 , d# 1216 , d# 1215 , d# 1214 , d# 1213 , d# 1212 , ] { cr }
 [ d# 1211 , d# 1210 , d# 1209 , d# 1208 , d# 1207 , d# 1206 , ] { cr }
 [ d# 1205 , d# 1204 , d# 1203 , d# 1202 , d# 1201 , d# 1200 , ] { cr }
 [ d# 1100 , d# 1101 , d# 1102 , d# 1103 , d# 1104 , d# 1105 , ] { cr }
 [ d# 1106 , d# 1107 , d# 1108 , d# 1109 , d# 1110 , d# 1111 , ] { cr }
 [ d# 1112 , d# 1113 , d# 1114 , d# 1115 , d# 1116 , d# 1117 , ] { cr }
 [ d# 1017 , d# 1016 , d# 1015 , d# 1014 , d# 1013 , d# 1012 , ] { cr }
 [ d# 1011 , d# 1010 , d# 1009 , d# 1008 , d# 1007 , d# 1006 , ] { cr }
 [ d# 1005 , d# 1004 , d# 1003 , d# 1002 , d# 1001 , d# 1000 , d# -1
 , ] { br }

: uup1 align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1500 , d# 1600 , d# 1700 , ] { cr }
 [ d# 1701 , d# 1601 , d# 1501 , d# 1401 , d# 1301 , d# 1201 , ] { cr }
 [ d# 1101 , d# 1001 , d# 1002 , d# 1102 , d# 1202 , d# 1302 , ] { cr }
 [ d# 1402 , d# 1502 , d# 1602 , d# 1702 , ] { cr }
 [ d# 1703 , d# 1603 , d# 1503 , d# 1403 , d# 1303 , d# 1203 , ] { cr }
 [ d# 1103 , d# 1003 , d# 1004 , d# 1104 , d# 1204 , d# 1304 , ] { cr }
 [ d# 1404 , d# 1504 , d# 1604 , d# 1704 , ] { cr }
 }block

( 002A9400 )               D# 677 shadow{ 
 }block

( 002A9800 )               D# 678 code{ 
 ( -- paths 1 ) { cr }
 [ d# 1705 , d# 1605 , d# 1505 , d# 1405 , d# 1305 , d# 1205 , ] { cr }
 [ d# 1105 , d# 1005 , d# 1006 , d# 1106 , d# 1206 , d# 1306 , ] { cr }
 [ d# 1406 , d# 1506 , d# 1606 , d# 1706 , ] { cr }
 [ d# 1707 , d# 1607 , d# 1507 , d# 1407 , d# 1307 , d# 1207 , ] { cr }
 [ d# 1107 , d# 1007 , d# 1008 , d# 1108 , d# 1208 , d# 1308 , ] { cr }
 [ d# 1408 , d# 1508 , d# 1608 , d# 1708 , ] { cr }
 [ d# 1709 , d# 1609 , d# 1509 , d# 1409 , d# 1309 , d# 1209 , ] { cr }
 [ d# 1109 , d# 1009 , d# 1010 , d# 1110 , d# 1210 , d# 1310 , ] { cr }
 [ d# 1410 , d# 1510 , d# 1610 , d# 1710 , ] { cr }
 [ d# 1711 , d# 1611 , d# 1511 , d# 1411 , d# 1311 , d# 1211 , ] { cr }
 [ d# 1111 , d# 1011 , d# 1012 , d# 1112 , d# 1212 , d# 1312 , ] { cr }
 [ d# 1412 , d# 1512 , d# 1612 , d# 1712 , ] { cr }
 [ d# 1713 , d# 1613 , d# 1513 , d# 1413 , d# 1313 , d# 1213 , ] { cr }
 [ d# 1113 , d# 1013 , d# 1014 , d# 1114 , d# 1214 , d# 1314 , ] { cr }
 [ d# 1414 , d# 1514 , d# 1614 , d# 1714 , ] { cr }
 [ d# 1715 , d# 1615 , d# 1515 , d# 1415 , d# 1315 , d# 1215 , ] { cr }
 [ d# 1115 , d# 1015 , d# 1016 , d# 1116 , d# 1216 , d# 1316 , ] { cr }
 [ d# 1416 , d# 1516 , d# 1616 , d# 1716 , ] { cr }
 [ d# 1717 , d# 1617 , d# 1517 , d# 1417 , d# 1317 , d# 1217 , ] { cr }
 [ d# 1117 , d# 1017 , d# -1 , ] }block

( 002A9C00 )               D# 679 shadow{ 
 }block

( 002AA000 )               D# 680 code{ 
 ( -- paths 1a ) { cr }
: up1a align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1401 , d# 1501 , d# 1500 , d# 1600 , d# 1601 , ] { cr }
 [ d# 1602 , d# 1502 , d# 1402 , d# 1302 , d# 1202 , ] { cr }
 [ d# 1201 , d# 1200 , d# 1100 , d# 1000 , d# -1 , ] { br }

: up1b align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1401 , d# 1301 , d# 1201 , d# 1101 , d# 1001 , ] { cr }
 [ d# 1002 , d# 1102 , d# 1202 , d# 1302 , d# 1402 , d# 1502 , ] { cr }
 [ d# 1602 , d# 1702 , d# 1701 , d# 1700 , d# -1 , ] { br }

: !p0 uup0 [ 'pths ] ! ;
: !p1 uup1 [ 'pths ] d# 1 + ! ;
: !p1a up1a [ 'pths ] d# 1 + ! ;
: !p1b up1b [ 'pths ] d# 1 + ! ; }block

( 002AA400 )               D# 681 shadow{ 
: path1a ( catches the port walls that are left ) { cr }
 ( after using paths { 0000000F } and 1. )
: path1b ( reverses path { 0000002F } swapping serdes roles. ) }block

( 002AA800 )               D# 682 code{ 
 ( - control lines ) { br }

: mv ( -n ) [ h# 00000019 ] call h# 0000003F lit' ra! !a h# 0000003F
 r@ ;
: !mv ( n ) lit' [ h# 00000023 ] call ;
: +a ( nn ) d# 2 swap hook d# 0 d# 64 d# 1900 boot ; { br }

: !vdc ( mv ) [ d# 709 ] +a !mv ; { -cr } : vdc ( -mv ) [ d# 709 ]
 +a mv ;
: !vdi ( mv ) [ d# 713 ] +a !mv ; { -cr } : vdi ( -mv ) [ d# 713 ]
 +a mv ;
: !vda ( mv ) [ d# 717 ] +a !mv ; { -cr } : vda ( -mv ) [ d# 717 ]
 +a mv ;
: !bus ( mv ) [ d# 117 ] +a !mv ; { -cr } : bus ( -mv ) [ d# 117 ]
 +a mv ;
: drain d# 2 [ d# 617 ] hook h# 000000AA io r! h# 00000155 io r! ;
: set ( n nn ) d# 2 swap hook [ d# 2 ] + [ h# 00010000 ] * io r! ;
: rst ( n ) [ d# 417 ] set ;
: 1.8 ( n ) [ d# 715 ] set ; { -cr } : 1.475 ( n ) [ d# 517 ] set ;
: hivd [ d# 1 ] 1.8 [ d# 0 ] 1.475 ; { -cr } : lovd [ d# 1 ] 1.475
 [ d# 0 ] 1.8 ;
: novd [ d# 0 ] 1.8 [ d# 0 ] 1.475 drain ; { br }

: -pwr d# 0 rst d# 0 !vdc d# 0 !vdi d# 0 !vda novd drain ; }block

( 002AAC00 )               D# 683 shadow{ 
 ( these defns control and interrogate the uut. )
: !vdx ( and ) vdx ( drive and read uut power bus ) [ x ] ( in nonlinear
 millivolts. )
: !bus ( and ) bus ( do the same with analog bus. )
: rst ( sets uut reset line low if ) [ n d# 0 ] ( or high ) [ d# 1 ]
: drain ( used only when no power enabled to short out the supply rails
 briefly. )
: rst ( controls uut reset line ) [ d# 0 ] ( is low. )
: 1.8 ( and ) 1.475 ( control power supplies ) [ d# 1 ] ( enables )
 [ d# 0 ] ( disables. )
: hivd lovd ( and ) novd ( select high, low, and zero voltage power
 supply to uut. ) }block

( 002AB000 )               D# 684 code{ 
 ( - all-nodes runner ) { br }

: pt@ ( -a ) paths [ pos ] @ + ;
: active ( -nn ) pt@ @ ;
: nxt ( -nn ) pt@ d# 1 + @ ;
: -us ( nn-nn ) dup paths @ or drop ;
: -end ( nn-nn ) dup d# -1 or drop ; { br }

 :# 'arg 270112297
: -try ( n-t ) d# 1 [ nrun ] +! test dup [ ans ] ! d# 0 or drop ;
: ecch ( fail ) h# 00000BAD h# 00000BAD rip d# 1 [ vval ] ! abort ;
: pass [ 'arg ] xqt -try if ecch then ; { br }

: /all ( n ) [ id ] ! targets @ [ pos ] ! pause { cr }
 d# 0 d# 64 [ id ] @ boot ( ?ram ) pfocus ( punchout ; )
: hike key? active nxt -us if -end if { cr }
 dup [ tgt ] ! ( pause ) wall port tfocus pass { cr }
 creep d# 1 [ pos ] +! hike ; { cr }
 then then drop drop rip ;
: /zero [ 'arg ] assign d# 0 ;
: runall ( n ) /zero /all rip ; }block

( 002AB400 )               D# 685 shadow{ 
: tgt ( current target node )
: pos ( posn of current active node in path )
: nrun ( number of tests run on current chip )
: id ( puka number for test being run )
: ans ( most recent answer from a test ) { br }

: pt@ ( addresses path table for active node. )
: active ( returns active node no. yxx format )
: nxt ( returns next target node in path. )
: -us ( true if node given is not current boot )
: -end ( true if node given is not end path marker )
: -pass ( runs current test, true if failed ) { br }

: runall ( runs the test whose puka number is given on all nodes using
 the selected path. this path must be empty, selecting a node adjacent
 to the boot in use. )
: hike ( starts with active node selected. runs test against next node
 then creeps into it and repeats. aborts on test fail. returns with
 path ripped and ready to load new test after all remaining nodes in
 path have been tested ok. ) }block

( 002AB800 )               D# 686 code{ 
 ( - incremental runner ) { br }

: some ( n ) [ id ] ! targets @ [ pos ] ! pause { cr }
 d# 0 d# 64 [ id ] @ boot ( ?ram ) pfocus ;
: adv active nxt -us if -end if dup [ tgt ] ! { cr }
 ( pause ) wall port tfocus creep d# 1 [ pos ] +! ; { cr }
 then then ecch ;
: kreep ( nn ) begin key? active dup [ tgt ] ! { cr }
 over or drop while adv end then drop ;
: uno ( nn ) kreep d# 0 pass ; }block

( 002ABC00 )               D# 687 shadow{ 
 ( runner components for tests that do not apply to all nodes and for
 tests that work on the active rather than the target node. ) { br }

: some ( starts work on current path given test in given bin. )
: adv ( steps to the next node in path. )
: kreep ( advances to make the given node active. )
: uno ( kreeps if necessary to the given node and runs the test there. )
 { br }

 ( usage... ) [ d# 906 some ] { cr }
 [ d# 1500 kreep d# 1 pass d# 1600 uno rip ] }block

( 002AC000 )               D# 688 code{ 
 ( - build table of valid io w/r bits )
: iom [ nns aray h# 000201FF d# 0 iom nns fill ]
: iom! ( nm ) push nn-n iom dup @ pop or swap ! ;
: c0, ( n ) h# 00001E00 iom! ; { -cr } : l0, ( n ) h# 00001800 iom!
 ;
: u0, ( n ) h# 00000600 iom! ; { -cr } : !l ( nn ) over l0, iom! ;
: !u ( nn ) over u0, iom! ; { -cr } : l1, ( n ) h# 00020000 !l ;
: u1, { -cr } : us, { -cr } : u18, ( n ) h# 00020000 !u ;
: l2, ( n ) h# 00020003 !l ; { -cr } : u2, ( n ) h# 00020003 !u ;
: u4, ( n ) h# 0002003F !u ; { -cr } : la, ( nn ) l1, l1, ;
: ua, ( nn ) u1, u1, ; { br }

 ( single ) [ d# 100 l1, d# 317 l1, d# 417 l1, d# 500 l1, d# 600 l1, ]
 ( serdes ) [ d# 1 us, d# 701 us, ] ( spi ) [ d# 705 u4, ] { cr }
 ( async ) [ d# 708 u2, ] ( 1wire ) [ d# 200 l1, ] ( sync ) [ d# 300
 l2, ] { cr }
 ( parallel ) [ d# 7 u18, d# 8 u4, d# 9 u18, ] { cr }
 ( analog ) [ d# 709 d# 715 ua, d# 713 d# 715 ua, d# 717 d# 715 ua, ]
 { cr }
 [ d# 117 d# 217 la, d# 617 d# 517 la, ] { cr }
 ( no pins ) [ d# 0 c0, d# 2 u0, d# 3 u0, d# 4 u0, d# 5 u0, d# 6 u0, ]
 { cr }
 [ d# 10 u0, d# 11 u0, d# 12 u0, d# 13 u0, d# 14 u0, d# 15 u0, ] { cr }
 [ d# 16 u0, d# 17 c0, d# 400 l0, d# 700 c0, d# 702 u0, d# 703 u0,
 d# 704 u0, d# 706 u0, d# 707 u0, d# 710 u0, ] { cr }
 [ d# 711 u0, d# 712 u0, d# 714 u0, d# 716 u0, ] }block

( 002AC400 )               D# 689 shadow{ 
 ( notes- ) { br }

 ( this took the bulk of the code from softsim ) }block

( 002AC800 )               D# 690 code{ 
 ( - build table of rom checksums )
: sums [ nns aray d# 0 d# 0 sums nns fill ]
: !sum ( n ) dup push 2* h# 00008000 + block h# 00000080 + h# 00000000
 { indent }
      d# 63 for over i + @ or -next { indent }
      pop sums ! drop ;
: !sums [ nns d# -1 + ] for i !sum -next ; [ !sums ] { cr }
 }block

( 002ACC00 )               D# 691 shadow{ 
 }block

( 002AD000 )               D# 692 code{ 
 ( - results )
: chs ( ...n ) for emit next ;
: .pf [ ans ] @ d# 0 + drop if { cr }
 red d# 42 d# 12 d# 7 d# 5 d# 14 d# 5 chs space ; { cr }
 then green d# 42 d# 36 d# 3 d# 3 chs space ;
: .pok blu [ vval ] @ d# 0 + drop if .pf ; { cr }
 then silver d# 11 d# 8 d# 22 d# 19 d# 4 chs space ; { br }

: -buses d# 0 d# 1009 hook ( ou ) h# 00015555 io r! h# 00000000 data
 r! { cr }
 d# 0 d# 1007 hook ( in ) h# 00014555 io r! h# 00000000 data r! ; }block

( 002AD400 )               D# 693 shadow{ 
: .pok ( shows how to make a blue word display variable text strings. )
 { br }

: -buses ( quiets test chip parallel buses by setting { 000000EF }
 to read and { 0000012F } to write. this facilitates later creeper
 test using path 0. easily burns hundreds of ma if not done due to
 cross coupling of output mode buses on powerup. ) }block

( 002AD800 )               D# 694 code{ 
 ( - runner for { 000071EF } pin test ) { br }

: atest ( arg-ans ) d# 1 [ nrun ] +! test dup [ rval ] ! ;
: within ( nlh-t ) push less drop pop if drop d# 0 and ; then less
 if drop d# -1 +or ; then drop d# 0 and ;
: pinok ( ans ) d# 16 /mod d# 16 /mod d# 24 d# 180 within { cr }
 push d# 4 d# 12 within push d# 4 d# 12 within pop and { cr }
 pop and ( ; ) drop if ; then d# 2011 [ ans ] ! ecch ; { br }

: p17 h# 00030000 ;
: p5 h# 00000030 ; { -cr } : p3 h# 0000000C ; { -cr } : p1 h# 00000003
 ;
: a911 ( p ) atest pinok ;
: n911 ( np ) swap kreep a911 ;
: t911 d# 0 path d# 2011 some { cr }
 [ d# 1500 ] p17 n911 [ d# 1600 ] p17 n911 { cr }
 [ d# 1705 ] p1 n911 [ p3 ] a911 [ p5 ] a911 { cr }
 ( 1k pullup ) [ p17 ] atest [ h# 00007000 ] +or pinok { cr }
 ( no-caps { 0000D58F } p17 n911 p1 a911 ) { cr }
 [ d# 1715 ] p17 n911 [ d# 1517 ] p17 n911 [ d# 1417 ] p17 n911 { cr }
 [ d# 1317 ] p17 n911 [ d# 1217 ] p17 n911 rip ; }block

( 002ADC00 )               D# 695 shadow{ 
 }block

( 002AE000 )               D# 696 code{ 
 ( - runner for { 000072AF } rom checksum ) { br }

: /917 [ 'arg ] assign [ tgt ] @ d# 1000 mod nn-n sums @ ;
: t917 /917 d# 2017 /all rip ;
: /913 [ 'arg ] assign [ tgt ] @ d# 1000 mod nn-n iom @ ;
: t913 /913 d# 2013 /all rip ; { br }

: na00 ( np ) swap kreep -try if ecch then ;
: ta00 d# 0 path d# 2100 some { cr }
 [ d# 1009 ] h# 00014555 na00 [ d# 1007 ] h# 00014555 na00 rip { cr }
 d# 1 path d# 2100 some { cr }
 [ d# 1007 ] h# 00014555 na00 [ d# 1009 ] h# 00015555 na00 rip d# 0
 path ; }block

( 002AE400 )               D# 697 shadow{ 
: t917 ( needs arg of expected xor checksum value. )
: t913 ( needs arg of io latch bit mask. )
: ta00 ( needs arg of state to leave in io at end. ) }block

( 002AE800 )               D# 698 code{ 
 ( - runner for { 0001082F } serdes test ) { br }

: /many [ 'arg ] assign d# 250000 ;
: stest ( arg-ans ) /many pass ; { br }

: ser70 d# 1 path [ d# 2112 ] some /zero { cr }
 [ d# 1701 ] kreep pass { cr }
 [ d# 1001 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 1 path [ d# 2113 ] some [ d# 1701 ] kreep stest rip ; { br }

: ser07 d# 1 path [ d# 2112 ] some /zero { cr }
 [ d# 1001 ] kreep pass { cr }
 [ d# 1701 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 1 path [ d# 2113 ] some [ d# 1001 ] kreep stest rip ; }block

( 002AEC00 )               D# 699 shadow{ 
 }block

( 002AF000 )               D# 700 code{ 
 ( - runner for { 0001084F } analog test ) { br }

 :# 'side 270113283
: tops [ 'side ] assign [ h# 00000013 ] ;
: rights [ 'side ] assign [ h# 00000007 ] ;
: stest ( arg-ans ) /many pass ;
: atest ( arg.ent-ans ) d# 1 [ nrun ] +! vtest dup [ rval ] ! ;
: !da ( n ) [ h# 00000004 ] atest drop ;
: @ad ( n-n ) h# 00000155 or [ 'side ] xqt atest ;
: @vdd ( -n ) [ h# 00002000 ] @ad ; { -cr } : @vss ( -n ) [ h# 00006000 ]
 @ad ;
: @off ( -n ) [ h# 00004000 ] @ad ; { -cr } : @pad ( -n ) [ h# 00000000 ]
 @ad ; { br }

: a? ( nlhk ) push within if drop pop drop ; then { cr }
 pop [ ans ] ! ecch ;
: /vlo d# 13000 d# 14700 ; { -cr } : /vhi d# 8250 d# 9350 ;
: aok ( nn ) kreep pause @off d# 0 d# 1 [ d# 1 ] a? { cr }
 @vdd /vhi [ d# 2 ] a? { cr }
 @vss /vlo [ d# 3 ] a? [ h# 000000AA ] @ad /vhi [ d# 4 ] a? { cr }
 @pad /vlo [ d# 5 ] a? d# 1800 !bus d# 0 path { cr }
 @pad /vhi [ d# 6 ] a? d# 0 !bus d# 0 path ;
: ana0 d# 0 path [ d# 2114 ] some { cr }
 tops [ d# 1709 ] aok [ d# 1713 ] aok [ d# 1717 ] aok { cr }
 rights [ d# 1617 ] aok [ d# 1117 ] aok rip ; }block

( 002AF400 )               D# 701 shadow{ 
 }block

( 002AF800 )               D# 702 code{ 
 }block

( 002AFC00 )               D# 703 shadow{ 
 }block

( 002B0000 )               D# 704 code{ 
 }block

( 002B0400 )               D# 705 shadow{ 
 }block

( 002B0800 )               D# 706 code{ 
 }block

( 002B0C00 )               D# 707 shadow{ 
 }block

( 002B1000 )               D# 708 code{ 
 ( selftest a chip, port on stack ) [ empty stp ! ] { br }

 [ compile serial load -canon ] :# usb 3 { cr }
 [ stp @ dup sport ! usb ! a-bps bps ! !nam ] { cr }
 ( functions ) [ d# 674 d# 4 loads ] ( exit ) { br }

 UNKNOWN ( test status is ) { .pok br }

 ( details ) :# ph 3 :# id 913 :# tgt 701 :# pos 7 { cr }
 ( ------- ) :# ans 0 :# rval 0 { cr }
 ( ------- ) :# nrun 11520 :# vval 1 { br }

: init d# 0 [ tgt ] ! d# 0 [ pos ] ! d# 0 [ nrun ] ! d# 0 [ id ] !
 d# 0 [ rval ] ! d# 0 [ ans ] ! d# 0 [ vval ] ! d# -1 [ ph ] ! ; [ init ]
 { cr }
 ( runner ) [ d# 684 d# 7 loads d# 672 load d# 710 load ] { br }

: run [ d# 708 ] list init pause talk { indent }
      2pa [ 'pths ] d# 2 + ! { indent }
      d# 2 d# 708 hook d# 2 -hook !p0 !p1 !p2 ( ; ) { cr }
 d# 0 [ ph ] ! d# 0 path z t917 t913 { cr }
 d# 1 [ ph ] ! d# 1 path z t917 t913 { cr }
 d# 2 [ ph ] ! d# 2 path z t917 t913 !p1a { cr }
 d# 3 [ ph ] ! d# 1 path z t917 t913 { cr }
 d# 1 [ vval ] ! ; [ run ] }block

( 002B1400 )               D# 709 shadow{ 
 ( this code runs selected creeper tests directly on a chip using the
 ide. use with a-com/c-com or a literal port number. ) { br }

: tgt ( current target node )
: pos ( posn of current active node in path )
: nrun ( number of tests run on current chip )
: id ( puka number for test being run )
: ans ( most recent answer from a test ) }block

( 002B1800 )               D# 710 code{ 
 ( - paths )
: line ( ncd ) swap push swap { indent }
      begin dup , over + -next drop drop ;
: count ( nc-ncd ) dup [ d# 100 ] mod [ d# 0 ] + if { cr }
 ( horz ) swap drop [ d# 1 ] ; ( vert ) then drop [ d# 100 ] / [ d# 100 ]
 ;
: to ( nn ) over negate + -if { cr }
 ( back ) negate count negate line ; { cr }
 ( forw ) then count line ; { br }

: stp2 align create [ d# 708 d# 717 to d# 617 d# 600 to ] { cr }
 [ d# 500 d# 517 to d# 417 d# 400 to d# 300 d# 317 to d# 217 d# 200
 to ] { cr }
 [ d# 100 d# 117 to d# 17 d# 0 to d# -1 , ]
: stp1 align create [ d# 708 d# 8 to d# 7 d# 707 to ] { cr }
 [ d# 706 d# 6 to d# 5 d# 705 to d# 704 d# 4 to d# 3 d# 703 to ] { cr }
 [ d# 702 d# 2 to d# 1 d# 701 to d# 700 d# 0 to d# -1 , ]
: stp1a align create [ d# 708 d# 701 to d# -1 , ]
: stp0 align create [ d# 708 d# 8 to d# 9 d# 709 to d# 710 d# 10 to
 d# 11 d# 711 to d# 712 d# 12 to d# 13 d# 713 to d# 714 d# 14 to ]
 { cr }
 [ d# 15 d# 715 to d# 716 d# 16 to d# 17 d# 717 to d# -1 , ] { br }

: !p0 stp0 [ 'pths ] ! ; { -cr } : !p1 stp1 [ 'pths ] d# 1 + ! ;
: !p1a stp1a [ 'pths ] d# 1 + ! ;
: !p2 stp2 [ 'pths ] d# 2 + ! ; }block

( 002B1C00 )               D# 711 shadow{ 
: line ncd ( comma nodes into a table starting at node ) n ( for )
 c ( nodes incrementing by ) d { cr }
: /left ( extend line toward the left )
: /right ( extend line toward the right )
: /up ( extend line upward )
: /down ( extend line downward )
: path ( make a default path table that ) { cr }
 ( covers the whole chip ) }block

( 002B2000 )               D# 712 code{ 
 ( ats target test given host port ) [ empty stp ! ] { br }

 [ compile serial load -canon ] :# usb 3 { cr }
 [ stp @ dup sport ! usb ! a-bps bps ! !nam ] { cr }
 ( functions ) [ d# 674 d# 4 loads ] ( exit ) { br }

 UNKNOWN ( test status is ) { .pok br }

 ( details ) :# ph -1 :# id 0 :# tgt 0 :# pos 0 { cr }
 ( ------- ) :# ans 0 :# rval 0 { cr }
 ( ------- ) :# nrun 0 :# vval 0 { br }

: init d# 0 [ tgt ] ! d# 0 [ pos ] ! d# 0 [ nrun ] ! d# 0 [ id ] !
 d# 0 [ rval ] ! d# 0 [ ans ] ! d# 0 [ vval ] ! d# -1 [ ph ] ! ; [ init ]
 { cr }
 ( runner ) [ d# 684 d# 7 loads d# 672 load d# 710 load ] { cr }
 [ d# 714 d# 3 loads ] { br }

: run [ d# 712 ] list init pause talk { cr }
 ( .. ) 2pa [ 'pths ] d# 2 + ! d# 2 d# 708 hook d# 2 -hook { cr }
 ( .. ) !p0 !p1 !p2 setup ( ; ) { cr }
 d# 0 [ ph ] ! d# 0 path z t917 t913 { cr }
 d# 1 [ ph ] ! d# 1 path z t917 t913 !p1a { cr }
 d# 2 [ ph ] ! d# 1 path z t917 t913 !p1 { cr }
 d# 3 [ ph ] ! serht serth talk d# 1 [ vval ] ! ; [ run ] }block

( 002B2400 )               D# 713 shadow{ 
 ( this code runs selected creeper tests directly on a chip using the
 ide. use with a-com/c-com or a literal port number. ) { br }

: tgt ( current target node )
: pos ( posn of current active node in path )
: nrun ( number of tests run on current chip )
: id ( puka number for test being run )
: ans ( most recent answer from a test ) }block

( 002B2800 )               D# 714 code{ 
 ( - paths )
: atp2 align create { cr }
 [ d# 708 d# 700 to d# 600 d# 300 to d# -1 , ] { cr }
: atp0 align create [ d# 708 d# 408 to d# 407 d# 400 to ] { cr }
 [ d# 1400 d# 1700 to d# 1701 d# 1717 to d# 1617 d# 1601 to ] { cr }
 [ d# 1501 d# 1517 to d# 1417 d# 1401 to d# 1301 d# 1317 to ] { cr }
 [ d# 1217 d# 1200 to d# 1100 d# 1117 to d# 1017 d# 1000 to d# -1 , ]
: atp1 align create [ d# 708 d# 408 to d# 407 d# 400 to ] { cr }
 [ d# 1400 d# 1700 to d# 1701 d# 1001 to d# 1002 d# 1702 to ] { cr }
 [ d# 1703 d# 1003 to d# 1004 d# 1704 to d# 1705 d# 1005 to ] { cr }
 [ d# 1006 d# 1706 to d# 1707 d# 1007 to d# 1008 d# 1708 to ] { cr }
 [ d# 1709 d# 1009 to d# 1010 d# 1710 to d# 1711 d# 1011 to ] { cr }
 [ d# 1012 d# 1712 to d# 1713 d# 1013 to d# 1014 d# 1714 to ] { cr }
 [ d# 1715 d# 1015 to d# 1016 d# 1716 to d# 1717 d# 1017 to d# -1 , ]
: atp1a align create [ d# 708 d# 408 to d# 407 d# 400 to ] { cr }
 [ d# 1400 d# 1401 to d# 1501 d# 1500 to d# 1600 d# 1602 to ] { cr }
 [ d# 1502 d# 1202 to d# 1201 d# 1200 to d# 1100 d# 1000 to d# -1 , ]
 { br }

: !p0 atp0 [ 'pths ] ! ; { -cr } : !p1 atp1 [ 'pths ] d# 1 + ! ;
: !p1a atp1a [ 'pths ] d# 1 + ! ;
: !p2 atp2 [ 'pths ] d# 2 + ! ; }block

( 002B2C00 )               D# 715 shadow{ 
 ( these paths are used by host chip to test the target chip via sync
 node 300. ) { br }

: atp2 ( runs from { 0000588F } to the { 0000578F } corner and down
 to { 00003E8F } which controls target reset, accessing { 000057AF }
 for ) [ serdes ] ( testing along the way. includes { 0000258F } so
 it may be used to boot both chips' 300. )
: atp0 atp1 ( and ) atp1a ( steer clear of path two on their way to
 node 300's up port where they duplicate the paths used on tb001 for
 ats testing ) }block

( 002B3000 )               D# 716 code{ 
 ( - build port bridge )
: set ( n nn ) d# 2 swap hook [ d# 2 ] + [ h# 00010000 ] * io r! ;
: rst ( n ) [ d# 500 ] set ; { br }

: !sync d# 2 [ d# 300 ] hook d# 0 d# 64 [ d# 1901 ] boot [ h# 00000019 ]
 call ; { br }

: pt@ ( a-n ) @ h# 00015555 or ;
: frame ( a nd ) nn-n 2* d# 32768 + block + dup d# 2 + pt@ d# 3 + for
 dup pt@ lit' d# 6 call [ d# 1 ] + next drop ;
: !hitst d# 0 [ d# 1902 ] frame ;
: !lotst d# 0 [ d# 1903 ] frame ;
: !his d# 5 [ d# 1904 { 0000EE2F } ] frame ; { br }

: !ours ( off ) [ h# 00000019 ] call d# 0 d# 64 [ d# 1904 ] boot ( ent )
 [ h# 00000030 ] call ; { cr }
: setup d# 0 rst !sync d# 1 rst { cr }
 d# 2 [ d# 300 ] hook ( !hitst ) !his !ours d# 2 -hook { cr }
 ( testing ) h# 00000000 [ d# 400 ] hook focus ( ; ) { cr }
 d# 2 -hook d# 1 -hook d# 0 -hook ; }block

( 002B3400 )               D# 717 shadow{ 
: setup ( resets target chip and sets up the port bridge for ide and
 creeper use. ) { br }

: first ( we load sync boot master in our { 0000258F } done by ) !sync
: second !his ( loads bridge in uut node { 0000258F } using ) frame
 ( which sends a boot frame starting at location ) [ a ] ( compiled
 for bin ) [ nd's ] ( ram )
: third !ours ( loads bridge into our node { 0000258F } ) { br }

: setup ( does all this and leaves ide set to node { 0000320F } which
 may talk to { 0000AF0F } through its up port for testing of the bridged
 2-chip system. ) }block

( 002B3800 )               D# 718 code{ 
 ( - runner for { 0001082F } serdes test ) { br }

: /many [ 'arg ] assign d# 250000 ;
: stest ( arg-ans ) /many pass ; { br }

: serht d# 2 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 701 ] kreep pass rip { cr }
 d# 1 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 1001 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 2 path [ d# 2113 ] some [ d# 701 ] kreep stest rip ; { br }

: serth d# 1 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 1001 ] kreep pass rip { cr }
 d# 2 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 701 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 1 path [ d# 2113 ] some [ d# 1001 ] kreep stest rip ; }block

( 002B3C00 )               D# 719 shadow{ 
: serht ( transmits 250k words from host { 000057AF } into tgt 001
 with success feedback. ) }block

( 002B4000 )               D# 720 code{ 
 ( g144a12 automated testing system ) { cr }
 [ copyright c 2010-2011 ] greenarrays, inc. { cr }
 [ see db007 for ats documentation ] { br }

 d# 480 ( load block for f18 test code ) { indent }
      ( compiled for bins { 0000708F } and up ) { cr }
 d# 482 ( f18 test code and documentation ) { cr }
 d# 560 ( f18 ats master code ide mode ) { cr }
 d# 576 ( test compilation of steven's mem-random ) { cr }
 d# 580 ( pf ats f18 code ) { cr }
 d# 660 ( load block for tb001 ats ide pretest ) { cr }
 d# 670 ( load block for tb001 ats ide creepers ) { cr }
 d# 706 ( load block for creeper control scripts ) }block

( 002B4400 )               D# 721 shadow{ 
 }block

( 002B4800 )               D# 722 code{ 
 }block

( 002B4C00 )               D# 723 shadow{ 
 }block

( 002B5000 )               D# 724 code{ 
 }block

( 002B5400 )               D# 725 shadow{ 
 }block

( 002B5800 )               D# 726 code{ 
 }block

( 002B5C00 )               D# 727 shadow{ 
 }block

( 002B6000 )               D# 728 code{ 
 }block

( 002B6400 )               D# 729 shadow{ 
 }block

( 002B6800 )               D# 730 code{ 
 }block

( 002B6C00 )               D# 731 shadow{ 
 }block

( 002B7000 )               D# 732 code{ 
 }block

( 002B7400 )               D# 733 shadow{ 
 }block

( 002B7800 )               D# 734 code{ 
 }block

( 002B7C00 )               D# 735 shadow{ 
 }block

( 002B8000 )               D# 736 code{ 
 }block

( 002B8400 )               D# 737 shadow{ 
 }block

( 002B8800 )               D# 738 code{ 
 }block

( 002B8C00 )               D# 739 shadow{ 
 }block

( 002B9000 )               D# 740 code{ 
 }block

( 002B9400 )               D# 741 shadow{ 
 }block

( 002B9800 )               D# 742 code{ 
 }block

( 002B9C00 )               D# 743 shadow{ 
 }block

( 002BA000 )               D# 744 code{ 
 }block

( 002BA400 )               D# 745 shadow{ 
 }block

( 002BA800 )               D# 746 code{ 
 }block

( 002BAC00 )               D# 747 shadow{ 
 }block

( 002BB000 )               D# 748 code{ 
 }block

( 002BB400 )               D# 749 shadow{ 
 }block

( 002BB800 )               D# 750 code{ 
 }block

( 002BBC00 )               D# 751 shadow{ 
 }block

( 002BC000 )               D# 752 code{ 
 }block

( 002BC400 )               D# 753 shadow{ 
 }block

( 002BC800 )               D# 754 code{ 
 }block

( 002BCC00 )               D# 755 shadow{ 
 }block

( 002BD000 )               D# 756 code{ 
 }block

( 002BD400 )               D# 757 shadow{ 
 }block

( 002BD800 )               D# 758 code{ 
 }block

( 002BDC00 )               D# 759 shadow{ 
 }block

( 002BE000 )               D# 760 code{ 
 }block

( 002BE400 )               D# 761 shadow{ 
 }block

( 002BE800 )               D# 762 code{ 
 }block

( 002BEC00 )               D# 763 shadow{ 
 }block

( 002BF000 )               D# 764 code{ 
 }block

( 002BF400 )               D# 765 shadow{ 
 }block

( 002BF800 )               D# 766 code{ 
 }block

( 002BFC00 )               D# 767 shadow{ 
 }block

( 002C0000 )               D# 768 code{ 
 }block

( 002C0400 )               D# 769 shadow{ 
 }block

( 002C0800 )               D# 770 code{ 
 }block

( 002C0C00 )               D# 771 shadow{ 
 }block

( 002C1000 )               D# 772 code{ 
 }block

( 002C1400 )               D# 773 shadow{ 
 }block

( 002C1800 )               D# 774 code{ 
 }block

( 002C1C00 )               D# 775 shadow{ 
 }block

( 002C2000 )               D# 776 code{ 
 }block

( 002C2400 )               D# 777 shadow{ 
 }block

( 002C2800 )               D# 778 code{ 
 }block

( 002C2C00 )               D# 779 shadow{ 
 }block

( 002C3000 )               D# 780 code{ 
 }block

( 002C3400 )               D# 781 shadow{ 
 }block

( 002C3800 )               D# 782 code{ 
 }block

( 002C3C00 )               D# 783 shadow{ 
 }block

( 002C4000 )               D# 784 code{ 
 }block

( 002C4400 )               D# 785 shadow{ 
 }block

( 002C4800 )               D# 786 code{ 
 }block

( 002C4C00 )               D# 787 shadow{ 
 }block

( 002C5000 )               D# 788 code{ 
 }block

( 002C5400 )               D# 789 shadow{ 
 }block

( 002C5800 )               D# 790 code{ 
 }block

( 002C5C00 )               D# 791 shadow{ 
 }block

( 002C6000 )               D# 792 code{ 
 }block

( 002C6400 )               D# 793 shadow{ 
 }block

( 002C6800 )               D# 794 code{ 
 }block

( 002C6C00 )               D# 795 shadow{ 
 }block

( 002C7000 )               D# 796 code{ 
 }block

( 002C7400 )               D# 797 shadow{ 
 }block

( 002C7800 )               D# 798 code{ 
 }block

( 002C7C00 )               D# 799 shadow{ 
 }block

( 002C8000 )               D# 800 code{ 
 }block

( 002C8400 )               D# 801 shadow{ 
 }block

( 002C8800 )               D# 802 code{ 
 }block

( 002C8C00 )               D# 803 shadow{ 
 }block

( 002C9000 )               D# 804 code{ 
 }block

( 002C9400 )               D# 805 shadow{ 
 }block

( 002C9800 )               D# 806 code{ 
 }block

( 002C9C00 )               D# 807 shadow{ 
 }block

( 002CA000 )               D# 808 code{ 
 }block

( 002CA400 )               D# 809 shadow{ 
 }block

( 002CA800 )               D# 810 code{ 
 }block

( 002CAC00 )               D# 811 shadow{ 
 }block

( 002CB000 )               D# 812 code{ 
 }block

( 002CB400 )               D# 813 shadow{ 
 }block

( 002CB800 )               D# 814 code{ 
 }block

( 002CBC00 )               D# 815 shadow{ 
 }block

( 002CC000 )               D# 816 code{ 
 }block

( 002CC400 )               D# 817 shadow{ 
 }block

( 002CC800 )               D# 818 code{ 
 }block

( 002CCC00 )               D# 819 shadow{ 
 }block

( 002CD000 )               D# 820 code{ 
 }block

( 002CD400 )               D# 821 shadow{ 
 }block

( 002CD800 )               D# 822 code{ 
 }block

( 002CDC00 )               D# 823 shadow{ 
 }block

( 002CE000 )               D# 824 code{ 
 }block

( 002CE400 )               D# 825 shadow{ 
 }block

( 002CE800 )               D# 826 code{ 
 }block

( 002CEC00 )               D# 827 shadow{ 
 }block

( 002CF000 )               D# 828 code{ 
 }block

( 002CF400 )               D# 829 shadow{ 
 }block

( 002CF800 )               D# 830 code{ 
 }block

( 002CFC00 )               D# 831 shadow{ 
 }block

( 002D0000 )               D# 832 code{ 
 }block

( 002D0400 )               D# 833 shadow{ 
 }block

( 002D0800 )               D# 834 code{ 
 }block

( 002D0C00 )               D# 835 shadow{ 
 }block

( 002D1000 )               D# 836 code{ 
 }block

( 002D1400 )               D# 837 shadow{ 
 }block

( 002D1800 )               D# 838 code{ 
 }block

( 002D1C00 )               D# 839 shadow{ 
 }block

( 002D2000 )               D# 840 code{ 
 ( uncommitted/user code ) }block

( 002D2400 )               D# 841 shadow{ 
 ( this index page of { 00000F0F } blocks is available for user code. )
 { br }

 ( any code delivered in this area is provided to facilitate working
 with examples presented in the user's guide. it may be deleted if
 you no longer have use for it. ) { br }

 ( when deleting examples here, be sure to remove references in load
 blocks such as 200. ) }block

( 002D2800 )               D# 842 code{ 
 ( pwm demo ) [ d# 600 node d# 0 org ] { br }

: pol { 0000001D } @b h# 00002000 ( dw ) and if { cr }
 ( ... ) { 0000007D } ( ... ) down b! @b push ex { cr }
: rtn { 000000DD } ( ... ) io b! then { 0000011D } drop { br }

 ( cyc ie- ) h# 0001FFFF and over . + -if { cr }
 ( ... ) { 0000019D } ( ... ) h# 00020000 !b pol ; { cr }
 ( ... ) { 000001FD } then h# 00010000 { 0000001F } !b pol ; { br }

: upd { 0000025D } ( xex- ) drop push drop h# 00000100 { cr }
 ( ... ) { 0000029D } pop pop ( iex- ) rtn ; { 000002DD } }block

( 002D2C00 )               D# 843 shadow{ 
 ( pwm demo for host node { 00004B0F } ) { br }

: pol ( checks for ide inputs and calls ) down { cr }
 ( when noticed. )
: rtn ( is the return point from a ) down ( call ) { cr }
 ( and is used by ) [ upd ] ( as an re-entry point. )
: cyc ( begins the actual pwm code. )
: upd ( is the ide entry point for initial ) { cr }
 ( start or output update. ) }block

( 002D3000 )               D# 844 code{ 
 ( demo ide boot ) [ empty compile serial load ] { br }

 ( customize ) [ -canon d# 0 fh orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { br }

: seed ( n ) h# 00000013 r! h# 00000012 call upd ; { br }

: run talk d# 0 d# 600 hook d# 0 d# 64 d# 600 boot { indent }
      upd ?ram panel d# 0 lit h# 00018000 seed ; }block

( 002D3400 )               D# 845 shadow{ 
 ( configure ide for demo testing. ) { br }

 < ***no canonical opcodes*** > { cr }
 [ use the ] 'remote' [ ones ] { br }

: seed ( loads pwm 'rate' and re-/runs cycle. )
: run ( selects node { 00004B0F } target, loads the pwm ) { cr }
 ( into it and starts it with a default value. ) }block

( 002D3800 )               D# 846 code{ 
 UNKNOWN ( loader template ) [ host load loader load ] { , }
 UNKNOWN ( using default ide paths ) { , }
 UNKNOWN UNKNOWN ( kill boots ) [ d# 0 d# 708 hook d# 0 -hook ] { , , }
 UNKNOWN UNKNOWN ( setup application ) { , ... }
 UNKNOWN [ d# 600 +node d# 600 /ram d# 0 d# 1 /stack h# 00000012 /p ] { ,
 UNKNOWN , }
 ( visit whole chip ) [ d# 2 ship panel upd ?ram ] }block

( 002D3C00 )               D# 847 shadow{ 
 }block

( 002D4000 )               D# 848 code{ 
 UNKNOWN UNKNOWN ( framer template ) [ empty ] { , , }
 UNKNOWN [ compile streamer load framer load ] { , }
 UNKNOWN UNKNOWN ( default ) [ entire course ] { , , }
 UNKNOWN UNKNOWN ( setup application ) { , ... }
 UNKNOWN [ d# 600 +node d# 600 /ram d# 0 d# 1 /stack h# 00000012 /p ] { ,
 UNKNOWN , }
 UNKNOWN UNKNOWN ( make boot ) [ frame ] { , , }
 UNKNOWN ( feedback ) [ d# 0 fh loaded ! nores strlen leng ! ] { , }
 UNKNOWN ( erase flash ) [ stream ers ] { , }
 ( flash ) [ stream d# 0 swap 18burn ] }block

( 002D4400 )               D# 849 shadow{ 
 }block

( 002D4800 )               D# 850 code{ 
 }block

( 002D4C00 )               D# 851 shadow{ 
 }block

( 002D5000 )               D# 852 code{ 
 }block

( 002D5400 )               D# 853 shadow{ 
 }block

( 002D5800 )               D# 854 code{ 
 }block

( 002D5C00 )               D# 855 shadow{ 
 }block

( 002D6000 )               D# 856 code{ 
 }block

( 002D6400 )               D# 857 shadow{ 
 }block

( 002D6800 )               D# 858 code{ 
 }block

( 002D6C00 )               D# 859 shadow{ 
 }block

( 002D7000 )               D# 860 code{ 
 }block

( 002D7400 )               D# 861 shadow{ 
 }block

( 002D7800 )               D# 862 code{ 
 }block

( 002D7C00 )               D# 863 shadow{ 
 }block

( 002D8000 )               D# 864 code{ 
 }block

( 002D8400 )               D# 865 shadow{ 
 }block

( 002D8800 )               D# 866 code{ 
 }block

( 002D8C00 )               D# 867 shadow{ 
 }block

( 002D9000 )               D# 868 code{ 
 }block

( 002D9400 )               D# 869 shadow{ 
 }block

( 002D9800 )               D# 870 code{ 
 }block

( 002D9C00 )               D# 871 shadow{ 
 }block

( 002DA000 )               D# 872 code{ 
 }block

( 002DA400 )               D# 873 shadow{ 
 }block

( 002DA800 )               D# 874 code{ 
 }block

( 002DAC00 )               D# 875 shadow{ 
 }block

( 002DB000 )               D# 876 code{ 
 }block

( 002DB400 )               D# 877 shadow{ 
 }block

( 002DB800 )               D# 878 code{ 
 }block

( 002DBC00 )               D# 879 shadow{ 
 }block

( 002DC000 )               D# 880 code{ 
 }block

( 002DC400 )               D# 881 shadow{ 
 }block

( 002DC800 )               D# 882 code{ 
 }block

( 002DCC00 )               D# 883 shadow{ 
 }block

( 002DD000 )               D# 884 code{ 
 }block

( 002DD400 )               D# 885 shadow{ 
 }block

( 002DD800 )               D# 886 code{ 
 }block

( 002DDC00 )               D# 887 shadow{ 
 }block

( 002DE000 )               D# 888 code{ 
 }block

( 002DE400 )               D# 889 shadow{ 
 }block

( 002DE800 )               D# 890 code{ 
 }block

( 002DEC00 )               D# 891 shadow{ 
 }block

( 002DF000 )               D# 892 code{ 
 }block

( 002DF400 )               D# 893 shadow{ 
 }block

( 002DF800 )               D# 894 code{ 
 }block

( 002DFC00 )               D# 895 shadow{ 
 }block

( 002E0000 )               D# 896 code{ 
 }block

( 002E0400 )               D# 897 shadow{ 
 }block

( 002E0800 )               D# 898 code{ 
 }block

( 002E0C00 )               D# 899 shadow{ 
 }block

( 002E1000 )               D# 900 code{ 
 }block

( 002E1400 )               D# 901 shadow{ 
 }block

( 002E1800 )               D# 902 code{ 
 }block

( 002E1C00 )               D# 903 shadow{ 
 }block

( 002E2000 )               D# 904 code{ 
 }block

( 002E2400 )               D# 905 shadow{ 
 }block

( 002E2800 )               D# 906 code{ 
 }block

( 002E2C00 )               D# 907 shadow{ 
 }block

( 002E3000 )               D# 908 code{ 
 }block

( 002E3400 )               D# 909 shadow{ 
 }block

( 002E3800 )               D# 910 code{ 
 }block

( 002E3C00 )               D# 911 shadow{ 
 }block

( 002E4000 )               D# 912 code{ 
 }block

( 002E4400 )               D# 913 shadow{ 
 }block

( 002E4800 )               D# 914 code{ 
 }block

( 002E4C00 )               D# 915 shadow{ 
 }block

( 002E5000 )               D# 916 code{ 
 }block

( 002E5400 )               D# 917 shadow{ 
 }block

( 002E5800 )               D# 918 code{ 
 }block

( 002E5C00 )               D# 919 shadow{ 
 }block

( 002E6000 )               D# 920 code{ 
 }block

( 002E6400 )               D# 921 shadow{ 
 }block

( 002E6800 )               D# 922 code{ 
 }block

( 002E6C00 )               D# 923 shadow{ 
 }block

( 002E7000 )               D# 924 code{ 
 }block

( 002E7400 )               D# 925 shadow{ 
 }block

( 002E7800 )               D# 926 code{ 
 }block

( 002E7C00 )               D# 927 shadow{ 
 }block

( 002E8000 )               D# 928 code{ 
 }block

( 002E8400 )               D# 929 shadow{ 
 }block

( 002E8800 )               D# 930 code{ 
 }block

( 002E8C00 )               D# 931 shadow{ 
 }block

( 002E9000 )               D# 932 code{ 
 }block

( 002E9400 )               D# 933 shadow{ 
 }block

( 002E9800 )               D# 934 code{ 
 }block

( 002E9C00 )               D# 935 shadow{ 
 }block

( 002EA000 )               D# 936 code{ 
 }block

( 002EA400 )               D# 937 shadow{ 
 }block

( 002EA800 )               D# 938 code{ 
 }block

( 002EAC00 )               D# 939 shadow{ 
 }block

( 002EB000 )               D# 940 code{ 
 }block

( 002EB400 )               D# 941 shadow{ 
 }block

( 002EB800 )               D# 942 code{ 
 }block

( 002EBC00 )               D# 943 shadow{ 
 }block

( 002EC000 )               D# 944 code{ 
 }block

( 002EC400 )               D# 945 shadow{ 
 }block

( 002EC800 )               D# 946 code{ 
 }block

( 002ECC00 )               D# 947 shadow{ 
 }block

( 002ED000 )               D# 948 code{ 
 }block

( 002ED400 )               D# 949 shadow{ 
 }block

( 002ED800 )               D# 950 code{ 
 }block

( 002EDC00 )               D# 951 shadow{ 
 }block

( 002EE000 )               D# 952 code{ 
 }block

( 002EE400 )               D# 953 shadow{ 
 }block

( 002EE800 )               D# 954 code{ 
 }block

( 002EEC00 )               D# 955 shadow{ 
 }block

( 002EF000 )               D# 956 code{ 
 }block

( 002EF400 )               D# 957 shadow{ 
 }block

( 002EF800 )               D# 958 code{ 
 }block

( 002EFC00 )               D# 959 shadow{ 
 }block

( 002F0000 )               D# 960 code{ 
 ( uncommitted/user code ) }block

( 002F0400 )               D# 961 shadow{ 
 ( this index page of { 00000F0F } blocks is available for user code. )
 { br }

 ( any code delivered in this area is provided to facilitate working
 with examples presented in the user's guide. it may be deleted if
 you no longer have use for it. ) { br }

 ( when deleting examples here, be sure to remove references in load
 blocks such as 200. ) }block

( 002F0800 )               D# 962 code{ 
 }block

( 002F0C00 )               D# 963 shadow{ 
 }block

( 002F1000 )               D# 964 code{ 
 }block

( 002F1400 )               D# 965 shadow{ 
 }block

( 002F1800 )               D# 966 code{ 
 }block

( 002F1C00 )               D# 967 shadow{ 
 }block

( 002F2000 )               D# 968 code{ 
 }block

( 002F2400 )               D# 969 shadow{ 
 }block

( 002F2800 )               D# 970 code{ 
 }block

( 002F2C00 )               D# 971 shadow{ 
 }block

( 002F3000 )               D# 972 code{ 
 }block

( 002F3400 )               D# 973 shadow{ 
 }block

( 002F3800 )               D# 974 code{ 
 }block

( 002F3C00 )               D# 975 shadow{ 
 }block

( 002F4000 )               D# 976 code{ 
 }block

( 002F4400 )               D# 977 shadow{ 
 }block

( 002F4800 )               D# 978 code{ 
 }block

( 002F4C00 )               D# 979 shadow{ 
 }block

( 002F5000 )               D# 980 code{ 
 }block

( 002F5400 )               D# 981 shadow{ 
 }block

( 002F5800 )               D# 982 code{ 
 }block

( 002F5C00 )               D# 983 shadow{ 
 }block

( 002F6000 )               D# 984 code{ 
 }block

( 002F6400 )               D# 985 shadow{ 
 }block

( 002F6800 )               D# 986 code{ 
 }block

( 002F6C00 )               D# 987 shadow{ 
 }block

( 002F7000 )               D# 988 code{ 
 }block

( 002F7400 )               D# 989 shadow{ 
 }block

( 002F7800 )               D# 990 code{ 
 }block

( 002F7C00 )               D# 991 shadow{ 
 }block

( 002F8000 )               D# 992 code{ 
 }block

( 002F8400 )               D# 993 shadow{ 
 }block

( 002F8800 )               D# 994 code{ 
 }block

( 002F8C00 )               D# 995 shadow{ 
 }block

( 002F9000 )               D# 996 code{ 
 }block

( 002F9400 )               D# 997 shadow{ 
 }block

( 002F9800 )               D# 998 code{ 
 }block

( 002F9C00 )               D# 999 shadow{ 
 }block

( 002FA000 )               D# 1000 code{ 
 }block

( 002FA400 )               D# 1001 shadow{ 
 }block

( 002FA800 )               D# 1002 code{ 
 }block

( 002FAC00 )               D# 1003 shadow{ 
 }block

( 002FB000 )               D# 1004 code{ 
 }block

( 002FB400 )               D# 1005 shadow{ 
 }block

( 002FB800 )               D# 1006 code{ 
 }block

( 002FBC00 )               D# 1007 shadow{ 
 }block

( 002FC000 )               D# 1008 code{ 
 }block

( 002FC400 )               D# 1009 shadow{ 
 }block

( 002FC800 )               D# 1010 code{ 
 }block

( 002FCC00 )               D# 1011 shadow{ 
 }block

( 002FD000 )               D# 1012 code{ 
 }block

( 002FD400 )               D# 1013 shadow{ 
 }block

( 002FD800 )               D# 1014 code{ 
 }block

( 002FDC00 )               D# 1015 shadow{ 
 }block

( 002FE000 )               D# 1016 code{ 
 }block

( 002FE400 )               D# 1017 shadow{ 
 }block

( 002FE800 )               D# 1018 code{ 
 }block

( 002FEC00 )               D# 1019 shadow{ 
 }block

( 002FF000 )               D# 1020 code{ 
 }block

( 002FF400 )               D# 1021 shadow{ 
 }block

( 002FF800 )               D# 1022 code{ 
 }block

( 002FFC00 )               D# 1023 shadow{ 
 }block

( 00300000 )               D# 1024 code{ 
 }block

( 00300400 )               D# 1025 shadow{ 
 }block

( 00300800 )               D# 1026 code{ 
 }block

( 00300C00 )               D# 1027 shadow{ 
 }block

( 00301000 )               D# 1028 code{ 
 }block

( 00301400 )               D# 1029 shadow{ 
 }block

( 00301800 )               D# 1030 code{ 
 }block

( 00301C00 )               D# 1031 shadow{ 
 }block

( 00302000 )               D# 1032 code{ 
 }block

( 00302400 )               D# 1033 shadow{ 
 }block

( 00302800 )               D# 1034 code{ 
 }block

( 00302C00 )               D# 1035 shadow{ 
 }block

( 00303000 )               D# 1036 code{ 
 }block

( 00303400 )               D# 1037 shadow{ 
 }block

( 00303800 )               D# 1038 code{ 
 }block

( 00303C00 )               D# 1039 shadow{ 
 }block

( 00304000 )               D# 1040 code{ 
 }block

( 00304400 )               D# 1041 shadow{ 
 }block

( 00304800 )               D# 1042 code{ 
 }block

( 00304C00 )               D# 1043 shadow{ 
 }block

( 00305000 )               D# 1044 code{ 
 }block

( 00305400 )               D# 1045 shadow{ 
 }block

( 00305800 )               D# 1046 code{ 
 }block

( 00305C00 )               D# 1047 shadow{ 
 }block

( 00306000 )               D# 1048 code{ 
 }block

( 00306400 )               D# 1049 shadow{ 
 }block

( 00306800 )               D# 1050 code{ 
 }block

( 00306C00 )               D# 1051 shadow{ 
 }block

( 00307000 )               D# 1052 code{ 
 }block

( 00307400 )               D# 1053 shadow{ 
 }block

( 00307800 )               D# 1054 code{ 
 }block

( 00307C00 )               D# 1055 shadow{ 
 }block

( 00308000 )               D# 1056 code{ 
 }block

( 00308400 )               D# 1057 shadow{ 
 }block

( 00308800 )               D# 1058 code{ 
 }block

( 00308C00 )               D# 1059 shadow{ 
 }block

( 00309000 )               D# 1060 code{ 
 }block

( 00309400 )               D# 1061 shadow{ 
 }block

( 00309800 )               D# 1062 code{ 
 }block

( 00309C00 )               D# 1063 shadow{ 
 }block

( 0030A000 )               D# 1064 code{ 
 }block

( 0030A400 )               D# 1065 shadow{ 
 }block

( 0030A800 )               D# 1066 code{ 
 }block

( 0030AC00 )               D# 1067 shadow{ 
 }block

( 0030B000 )               D# 1068 code{ 
 }block

( 0030B400 )               D# 1069 shadow{ 
 }block

( 0030B800 )               D# 1070 code{ 
 }block

( 0030BC00 )               D# 1071 shadow{ 
 }block

( 0030C000 )               D# 1072 code{ 
 }block

( 0030C400 )               D# 1073 shadow{ 
 }block

( 0030C800 )               D# 1074 code{ 
 }block

( 0030CC00 )               D# 1075 shadow{ 
 }block

( 0030D000 )               D# 1076 code{ 
 }block

( 0030D400 )               D# 1077 shadow{ 
 }block

( 0030D800 )               D# 1078 code{ 
 }block

( 0030DC00 )               D# 1079 shadow{ 
 }block

( 0030E000 )               D# 1080 code{ 
 ( compile 16-bit eforth virtual machine ) { cr }
 UNKNOWN UNKNOWN [ reclaim ] { , , }
 UNKNOWN UNKNOWN ( sram cluster mk1 ) [ sram load ] { , ... }
 ( user ) [ d# 108 node h# 00000039 org d# 278 load d# 1817 bin ] { cr }
 UNKNOWN UNKNOWN ( boot flash-sram pipe ) [ d# 1170 d# 2 loads ] { , , }
 ( e4vm16 siobus wires ) [ d# 1120 load ] { indent }
      ( tx plug ) [ d# 100 node d# 1124 load ] { indent }
      ( rx plug ) [ d# 200 node d# 1126 d# 2 loads ] { indent }
      ( 1-pin plug ) [ d# 500 node d# 1130 load ] { indent }
      ( 1-pin plug ) [ d# 600 node d# 1130 load ] { indent }
      ( flash plug ) [ d# 704 node d# 1132 load ] { cr }
 ( e4vm16 stack ) [ d# 106 node ] { indent }
      ( sram+ ) [ h# 00000039 org d# 278 load ] { indent }
      [ d# 1082 d# 2 loads ] ( +buds ) [ d# 1086 d# 4 loads ] { cr }
 ( e4vm16 bitsy +buds ) [ d# 1094 d# 8 loads ] { cr }
 ( e4vm16 starter ) [ d# 207 node ] ( sram+ ) [ h# 00000039 org d# 278
 load ' -d-- ' ---u h# 00008A00 d# 1114 load ] { cr }
 ( e4vm16 flash-sram pipe { 00008ACF } load ) { cr }
 ( erase and burn flash ) [ d# 288 load ] { cr }
 ( spi speedup ) [ d# 290 load ] }block

( 0030E400 )               D# 1081 shadow{ 
 }block

( 0030E800 )               D# 1082 code{ 
 ( - e4vm16 stack 8xxx-9xxx ) { cr -cr }  ( 'x@ ) [ h# 0000003C org ]
: 'au@ ( a-w ) { 0000079D } [ h# 00000000 org ]
: '1+ ( w-w ) { 0000001D } d# 1 . + { -cr } : mask ( w-w ) { 0000005D }
 h# 0000FFFF and ;
: '2/ ( w-w ) { 0000009D } 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt ) { 000000DD } dup '1+ over x@ ;
: 'au! ( pst-p43 ) { 0000011D } x!
: popst ( p-pst ) { 0000013D } popt
: pops ( pt-pst ) { 0000015D } push popt pop ;
: pop43 ( pst-p43st ) { 0000019D } push push popst pop pop ;
: '1- ( w-w ) { 000001DD } d# -1 . + mask ; [ here ] ( 'x!-2 ) [ h# 00000037
 org ]
: psht ( pt-p ) { 000006FD } push '1- pop over ( x! ; ) { 0000073D }
 ( * ) [ org ]
: pshs ( pst-pt ) { 0000023D } push psht pop ;
: pshw ( pstw-ptw ) { 0000027D } push pshs pop ;
: 'sp@ ( pst-ptp ) { 000002BD } pshs psht dup pops ;
: 'sp! ( ptp-pst ) { 0000031D } pshs popst ; { br }

: 'drop ( pst-p3s ) { 0000035D } drop pops ;
: 'dup ( pst-ptt ) { 0000037D } dup pshw ;
: 'over ( pst-pts ) { 0000039D } over pshw ;
: 'swap ( st-ts ) { 000003BD } over push push drop pop pop ;
: 'or ( pst-p3w ) { 000003FD } over - and
: 'xor ( pst-p3w ) { 0000041D } or pops ;
: 'and ( pst-p3w ) { 0000043D } and pops ; }block

( 0030EC00 )               D# 1083 shadow{ 
 ( notes- ) { indent }
      ( the e4th stack node must abut the memory driver to have fast
 bidirectional access to ) { cr }
 ( external memory. ) { indent }
      ( the code must not overwrite the sram user code compiled at )
 [ h# 00000039 ] { indent }
      psht ( is placed so it falls into ) x! { indent }
      ( names beginning with ' are e4vm code words. others are internal
 words ) { indent }
      ( e4th's external data stack grows down ) { cr }
 ( with pre-dec writes and post-inc reads. ) { indent }
      ( the stack-node's stack keeps the e4th ) { cr }
 [ stack pointer ] ( and cached ) [ s ] ( and ) [ t ] { indent }
      ( 16-bit words are ) [ 00.nnnn.nnnn.nnnn.nnnn ] }block

( 0030F000 )               D# 1084 code{ 
 ( --- more stack )
: 'um+ ( uu-uc ) { 0000045D } + h# 00010000 over and if or d# 1 ;
: 'nop { 000004FD } then ;
: 'zlt ( n-f ) { 0000051D } 2* 2* -if dup or ..
: 'inv ( w-w ) { 0000055D } - mask ; { 0000057D } then dup or ; { br }

 { 0000059D } ( must be at or before ) [ h# 00000032 org ] { cr }
 ( bitsy left slot2 call reaches { 0000061F } - { 000006FF } )
: c.s* ( code0* prix3 ) { 0000065D } 2* -if { cr }
 ( code01* prix4 ) { 0000067D } 2* -if -d-- ; then ---u ; { cr }
 ( code00* prix4 ) { 000006DD } then drop push ; { br }

 { 000006FD } [ exit ] ( started by ide )
: start h# 0000FFE0 h# 00000000 dup ( sp.s.t ) { indent }
      ( memory ) right b! ( bitsy ) --l- ; { 000007BD } }block

( 0030F400 )               D# 1085 shadow{ 
 ( notes- ) { indent }
      ( the initial sp is reset by ) [ cold ] { indent }
      ( code must fit before ) psht }block

( 0030F800 )               D# 1086 code{ 
 ( -- stack up bud axxx ) [ d# 206 node h# 00000020 org ]
: start @p b! ahead [ ' ---u , ]
: xqt { 0000045D } @b push ex
: cmd { 0000047D } then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / )
 { br }

 { 000004BD } }block

( 0030FC00 )               D# 1087 shadow{ 
 }block

( 00310000 )               D# 1088 code{ 
 }block

( 00310400 )               D# 1089 shadow{ 
 }block

( 00310800 )               D# 1090 code{ 
 ( -- stack down bud bxxx ) [ d# 6 node h# 00000020 org ]
: start @p b! ahead [ ' -d-- , ]
: xqt { 0000045D } @b push ex
: cmd { 0000047D } then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / )
 { br }

: .ex! ( pst-p54 ) { 000004BD } @p @p @p ( reversed! ) { indent }
      ( / ) pops ; ( ' ) ex! ( ' ) pop43 ( / ) !b !b !b ;
: .ex@ ( pst-p3w ) { 0000055D } @p @p .. ( reversed! ) { indent }
      ( / ) pops ; ( ' ) ex@ ( / ) !b !b ;
: .cx? ( pst-p5f ) { 000005DD } @p @p @p ( reversed! ) { indent }
      ( / ) pops ; ( ' ) cx? ( ' ) pop43 ( / ) !b !b !b ; { br }

: '+ ( pst-p3n ) { 0000067D } @p @p .. ( reversed! ) { indent }
      ( / ) pops ; ( ' ) + mask ( / ) !b !b ;
: '2* ( w-w ) { 000006FD } @p !b ; ( / ) 2* mask ; ( / ) { 0000073D }
 }block

( 00310C00 )               D# 1091 shadow{ 
 }block

( 00311000 )               D# 1092 code{ 
 }block

( 00311400 )               D# 1093 shadow{ 
 }block

( 00311800 )               D# 1094 code{ 
 ( - e4vm16 bitsy cxxx ) [ d# 105 node h# 00000000 org ]
: inc ( a-a ) { 0000001D } d# 1 . + ;
: bpshw ( w- ) { 0000005D } @p !b !b ; ( / ) @p pshw ( / )
: 'rp@ ( pri-pri ) { 0000009D } push over bpshw pop ;
: 'else { -cr } : bx@ ( a-w ) { 000000DD } @p !b !b . ( / ) @p x@ ( / )
: gett ( -w ) @p !b @b ; ( / ) !p .. ( / )
: 'rfrom ( pri-pri ) { 0000015D } push bpshw
: popr ( p.i-pri ) { 0000017D } inc
: getr ( p.i-pri ) { 0000019D } dup bx@ pop ;
: 'exit ( pri-pri ) { 000001DD } drop push popr ;
: bpops ( -w ) { 000001FD } @p !b @b ; ( / ) !p pops ( / )
: bx! ( wa- ) { 0000023D } @p !b !b . ( / ) @p push @p . ( / ) { indent }
      !b @p !b ; ( / ) pop x! ( / )
: pshr ( aw-a ) { 000002BD } over bx!
: dec ( a-a ) { 000002DD } d# -1 . + ;
: 'tor ( pri-pri ) { 0000031D } push pshr bpops pop ;
: 'rp! ( pri-pri ) { 0000037D } push pshr bpops getr ;
: 'if ( pri-pri ) { 000003DD } bpops if drop inc ; { indent }
      then drop bx@ ;
: 'con ( pri-pri ) { 0000045D } bx@
: 'var ( pri-pri ) { 0000047D } dup bpshw 'exit ; { 000004BD } }block

( 00311C00 )               D# 1095 shadow{ 
 ( notes- ) { indent }
      ( the bitsy node keeps the return-stack ) { cr }
 ( pointer, top-of-return-stack ) r ( and the interpreter pointer on
 its stack. ) { indent }
      ( memory access gets done only through the stack node. ) }block

( 00312000 )               D# 1096 code{ 
 ( --- more bitsy ) { cr }
 { 000004BD } ( must be at or before ) [ h# 00000028 org ] { indent }
      begin drop ;
: 'exe ( pri-pri ) { 0000053D } bpops
: ?exe ( pri?-pri ) { 0000055D } until
: xxt ( prix-pri ) { 0000057D } dup 2* 2* -if { cr }
 ( code prix2 ) { 000005BD } 2* -if { cr }
 ( code1* prix3 ) { 000005DD } 2* -if { cr }
 ( code11* prix4 ) { 000005FD } 2* -if -d-- ; then ---u ; { cr }
 ( code101 prix4 ) { 0000065D } then 2* -if r--- ; { cr }
 ( code100 prix5 ) { 0000069D } then drop push ; { cr }
 ( code0* prix3 ) { 000006BD } then ( slot2 port call! ) { indent }
      @p !b push . ( / ) @p @p c.s* ( / ) !b pop !b ; { cr }
 ( list prix2 ) { 0000071D } then drop push push pshr { indent }
      pop pop 2* ;
: step ( pri-pri ) { 0000077D } dup bx@ push inc pop xxt ;
: bitsy ( pri ) { 000007DD } step bitsy ; { 000007DF } ( in block { 0000898F } )
 { br }

 { 0000081D } [ exit ] ( started by ide )
: start h# 0000FFF0 h# 00000005 dup ( rp.r.ip ) left ( stack ) b! { indent }
      right ( terminal ) a! bitsy ; { 000008FD } }block

( 00312400 )               D# 1097 shadow{ 
 ( notes- ) { indent }
      ( the bit-threaded code technique confines execution to the )
 bitsy ( loop and a small number of code subroutines. it uses one or
 more bits of the execution token to select the class- ) { indent }
      [ 00.10**.xxaa.aaaa.aaaa ] ( code.s-xt's ) { indent }
      [ 00.11**.xxaa.aaaa.aaaa ] ( code.b-xt's ) { indent }
      [ 00.0aaa.aaaa.aaaa.aaaa ] ( list-xt ) { cr }
 ( -and process the token. code tokens are called while list tokens
 are interpreted by pushing the current ) [ ip ] ( address onto the
 return stack and continuing at 2*xt. ) { indent }
      ( the ) [ ide ] ( can single-step the bitsy node by calling )
 step ( instead of executing ) bitsy. }block

( 00312800 )               D# 1098 code{ 
 ( -- bitsy right bud dxxx ) [ d# 104 node host ]
: 'lu h# 00000165 lit ; [ target h# 00000020 org ]
: start @p b! .. [ ' r--- , ] 'lu a! ahead
: xqt { 0000049D } @b push ex
: cmd { 000004BD } then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / )
 { br }

: message ( nw-w ) { 000004FD } @p ! - . ( / ) @p over @p ; ( / ) { cr }
 over ! ! @ ( ... ) drop @ or drop @ ;
: n@ ( n-w ) { 0000059D } h# 0003FFFF message h# 0000FFFF and ;
: n! ( nw- ) { 0000061D } message drop ; { br }

: br!p ( i- ) { 0000065D } @p !b !b ; ( / ) bpops .. ( / )
: brpops { 0000069D } @p br!p ; ( / ) !p .. ( / )
: pn!; ( n- ) @p br!p ( / ) !p ; ( / ) @b n! ;
: n@p; ( n- ) { 0000073D } n@ @p !b !b ; ( / ) @p bpshw ; ( / )
: .n@ { 0000079D } brpops @b n@p; ;
: .n! { 000007DD } brpops @b pn!; ; { br }

: .rx { 0000081D } d# 200 n@p; ; { -cr } : .io@ { 0000085D } d# 100
 n@p; ;
: .tx { 0000089D } d# 100 pn!; ; { -cr } : .io! { 000008DD } d# 200
 pn!; ; { cr }
 { 0000091D } ( must be at or before { 00000C1F } ) }block

( 00312C00 )               D# 1099 shadow{ 
 }block

( 00313000 )               D# 1100 code{ 
 }block

( 00313400 )               D# 1101 shadow{ 
 }block

( 00313800 )               D# 1102 code{ 
 ( -- bitsy up bud exxx ) [ d# 205 node h# 00000020 org ]
: start @p b! ahead [ ' ---u , ]
: xqt { 0000045D } @b push ex
: cmd { 0000047D } then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / )
 { br }

 { 000004BD } }block

( 00313C00 )               D# 1103 shadow{ 
 }block

( 00314000 )               D# 1104 code{ 
 }block

( 00314400 )               D# 1105 shadow{ 
 }block

( 00314800 )               D# 1106 code{ 
 ( -- bitsy down bud fxxx ) [ d# 5 node h# 00000020 org ]
: start @p b! ahead [ ' -d-- , ]
: xqt { 0000045D } @b push ex
: cmd { 0000047D } then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / )
 { br }

: 'next ( pri-pri ) { 000004BD } @p !b @b ( / ) push !p .. ( / ) { cr }
 if @p !b !b @p ( / ) @p dec ( ' ) pop bx@ ; ( / ) !b ; { cr }
 then drop @p @p @p ( reversed! ) { indent }
      ( / ) pop inc ; ( ' ) dup bx@ ( ' ) inc ( / ) !b !b !b ;
: '@exe ( pri-pri ) { 0000063D } @p @p @p . ( reversed! ) { indent }
      ( / ) ?exe ; ( ' ) bx@ ( ' ) bpops ( / ) !b !b !b ;
: 'r@ ( pri-pri ) { 000006DD } @p !b ; ( / ) over bpshw ; ( / )
: 'lit ( pri-pri ) { 0000071D } @p @p @p ( reversed! ) { indent }
      ( / ) inc ; ( ' ) bpshw ( ' ) dup bx@ ( / ) !b !b !b ; { 000007BD }
 }block

( 00314C00 )               D# 1107 shadow{ 
 }block

( 00315000 )               D# 1108 code{ 
 }block

( 00315400 )               D# 1109 shadow{ 
 }block

( 00315800 )               D# 1110 code{ 
 ( - flash to sram pipe ) [ host ]
: head { -cr } : pipe [ d# 1112 ] load ; [ target ] { cr }
 ( -------- --in-- --out- ---- ) { cr }
 [ d# 307 node ' ---u ' -d-- pipe ] { cr }
 [ d# 407 node ' -d-- ' ---u pipe ] { cr }
 [ d# 507 node ' ---u ' -d-- pipe ] { cr }
 [ d# 607 node ' r--- ' ---u pipe ] { cr }
 [ d# 606 node ' --l- ' r--- pipe ] { cr }
 [ d# 605 node ' -d-- ' --l- head ] { br }

 [ d# 705 node ] ( interface ) [ d# 1116 load ] }block

( 00315C00 )               D# 1111 shadow{ 
 }block

( 00316000 )               D# 1112 code{ 
 ( -- head/pipe nodes take two parameters! ) { cr }
 [ h# 00000020 org ] ( programmed with abandon )
: start ( init ) leap warm ;
: init { 0000045D } then @p b! .. ( out ) [ , ] @p a! ; ( in ) [ , ]
: prime ( i-i ) { 000004DD } dup !p ; ( install /* */ )
: pump { 000004FD } ( /* ) begin @ !b unext ; ( */ )
: run ( in ) { 0000051D } init { indent }
      @p !b over . ( / ) @p prime ( / ) { indent }
      !b @p !b dup ( / ) @p run ( / ) { indent }
      !b push pump ; { br }

 ( used in the 'head' node )
: hf2s ( n ) { 000005FD } @p prime ( / ) begin @ !b unext ; ( / ) { cr }
 over run ;
: hs2f ( n ) { 0000065D } @p prime ( / ) begin @b ! unext ; ( / ) { cr }
 over run ; { 000006BD } }block

( 00316400 )               D# 1113 shadow{ 
 ( notes- ) { cr }
 ( this is a bi-directional port pump! it assumes control comes from
 the 'head' and passes the it to the b-reg 'tail' of the pipe. a-reg
 the registers are set each time it is used, so the pipe may be crossed
 by other 'courteous' users. at this point only the count is passed--the
 tail has a fixed address to read to or write from. ) }block

( 00316800 )               D# 1114 code{ 
 ( -- tail / starter node takes three parameters! ) [ h# 00000000 org ]
 ( programmed with abandon )
: tf2s { 0000001D } ( e4base ) d# 0 { indent }
      begin @ over x! d# 1 . + next warm ;
: ts2f { 0000011D } ( e4base ) d# 0 { indent }
      begin dup x@ ! d# 1 . + next warm ;
: xm! ( m- ) { 000001FD } dup dup or dup - mk! ; { 0000023D } { br }

 [ h# 00000020 org ]
: start { 0000041D } @p @p b! @p ( mask ) [ , ] ( out ) [ , ] ( in )
 [ , ] { indent }
      a! xm! warm ;
: prime ( i-i ) { 000004DD } ; ( dummy ) ;
: run ( in ) { 0000051D } push @p or ( /* ) begin @b ! unext ; ( */ )
 if tf2s ; then ts2f ; { 000005BD } }block

( 00316C00 )               D# 1115 shadow{ 
 ( notes- ) { indent }
      xm! [ mask ] ( sets which neighbor nodes get access to memory. { 0010001F }
 is 106, { 0001001F } is 108, { 0000401F } is 207, { 0011401F } is
 all three. ) [ use carefully! ] }block

( 00317000 )               D# 1116 code{ 
 ( -- eforth flash interface ) [ h# 00000000 org ]
: 2cmd ( dw-d ) select ( +2r ) { -cr } : +cmd ( dw-d ) 8obits ( +4r )
: cmd ( db-d ) select { -cr } : !8 ( db-d ) 8obits drop ;
: reading ( dh-d ) { 000000BD } io b! over . ( read ) h# 00000C00 cmd
 ( +5r )
: !24h ( dhd-d ) { 0000013D } drop 8obits
: !16 ( dw-d ) { 0000015D } 8obits !8 ;
: @16 ( d-dw ) { 0000019D } d# 15 dup push dup or ( 'ibits ) [ h# 000000DB ]
 end
: set ( ndo-n ) { 000001FD } down a! ! drop dup ! ;
: f2s ( dndh-d ) { 0000025D } reading ( +6r ) @p set ( / ) @p hf2s
 ( / )
: readn ( dn-d ) { 000002BD } for @16 ( +4r ) ! next ;
: start ( dx-dx ) { 0000033D } drop ( n-1 ) over d# 512 f2s ( +7r )
: restart ( d-dx ) { 000003BD } ( resume ) reading dup spi-exec ;
: deselect ( dx-dx ) { 0000041D } io b! -++ half warm ; { cr }
 { 000004BD } [ exit ]
: +wr ( d-d wren+wrsr ) h# 00001804 2cmd ( 0+ebsy ) h# 000001C0 +cmd
 ;
: er32k ( dh-dd ) { 0000053D } over +wr ( +6r ) { indent }
      ( wren+ers32 ) h# 00001948 2cmd !24h dup select ;
: writing ( dh-d ) { 000005DD } over +wr ( +6r ) { indent }
      ( wren+aaip ) h# 00001AB4 2cmd !24h ;
: s2f ( dndh-d ) { 0000065D } writing ( +7r ) @p set ( / ) @p hs2f
 ( / )
: writn ( dn-d ) { 000006BD } push ahead begin [ swap ] { indent }
      ( aaip ) h# 0002B400 cmd then @ !16 ( +5r ) { indent }
      ( wait ) dup select { 0000075D } begin drop @b -until { cr }
 { 0000077D } drop next ( wrdi+dbsy ) h# 00001200 2cmd ; { 000007DD }
 }block

( 00317400 )               D# 1117 shadow{ 
 ( notes- ) { indent }
      ( assumes that during booting the delay value is on the top of
 the data stack and is preserved during all flash accesses. ) { indent }
      ( also assumes b contains io. ) }block

( 00317800 )               D# 1118 code{ 
 }block

( 00317C00 )               D# 1119 shadow{ 
 }block

( 00318000 )               D# 1120 code{ 
 ( - siobus16 wire nodes ) [ host ]
: wire [ d# 1122 ] load ; [ target ] { cr }
 ( ------- plug -dest- --in-- --out- ---- ) { cr }
 [ d# 204 node d# 999 ' r--- ' -d-- ' ---u wire ] { cr }
 [ d# 304 node d# 999 ' r--- ' ---u ' -d-- wire ] { cr }
 [ d# 404 node d# 999 ' r--- ' -d-- ' ---u wire ] { cr }
 [ d# 504 node d# 999 ' r--- ' ---u ' -d-- wire ] { cr }
 [ d# 604 node d# 704 ' -d-- ' --l- ' ---u wire ] ( * ) { cr }
 [ d# 603 node d# 999 ' -d-- ' r--- ' --l- wire ] { cr }
 [ d# 602 node d# 999 ' -d-- ' --l- ' r--- wire ] { cr }
 [ d# 601 node d# 600 ' r--- ' ---u ' --l- wire ] ( * ) { cr }
 [ d# 501 node d# 500 ' r--- ' -d-- ' ---u wire ] ( * ) { cr }
 [ d# 401 node d# 999 ' r--- ' ---u ' -d-- wire ] { cr }
 [ d# 301 node d# 999 ' r--- ' -d-- ' ---u wire ] { cr }
 [ d# 201 node d# 200 ' r--- ' ---u ' -d-- wire ] ( * ) { cr }
 [ d# 101 node d# 100 ' r--- ' --l- ' ---u wire ] ( * ) { cr }
 [ d# 102 node d# 999 ' r--- ' r--- ' --l- wire ] { cr }
 [ d# 103 node d# 999 ' r--- ' --l- ' r--- wire ] }block

( 00318400 )               D# 1121 shadow{ 
 ( notes- ) { cr }
 [ iobus ] ( nodes have { 0000008F } values defined when booted- )
 in-port ( and ) destination ( are kept on the stack, ) dest-port ( is
 put in a, and ) out-port ( into b. an ) [ iobus ] ( node with a )
 destination ( of ) [ d# 999 ] ( only ) { cr }
 ( passes messages from its ) in-port ( to ) out-port. ( its ) dest-port
 ( is unused. otherwise they are ) { cr }
 ( the node-number and port of a node with pins. ) { cr }
 [ iobus ] ( messages consist of three words; ) { indent }
      ( / ) @p over @p ; ( / ) < destination > ( / ) < data > ( / )
 { br }

 < destination > ( is the node-number of a node with code to handle )
 < data > { br }

 < data > ( is ) [ d# 0 ] ( for reads and the 18-bit inverse of a )
 [ 16-bit value ] ( for writes. ) { br }

 ( eforth originates all messages. they travel around the loop until
 their ) < destination > ( matches an ) [ iobus ] ( node's or they
 return to eforth. at a matching node ) < data > ( is written and the )
 { cr }
 ( reply read and returned to eforth. ) }block

( 00318800 )               D# 1122 code{ 
 ( -- generic siobus wire ) [ h# 00000030 org ] { br }

: start ( takes four parameters! ) { indent }
      @p b! @p .. ( out-port ) [ , ] ( in-port ) [ , ] { indent }
      @p a! @p .. ( dest-port ) [ , ] ( dest-node ) [ , ]
: wait ( id ) { 000006DD } over push ex ( ... @p over @p ; )
: test ( idndw ) { 000006FD } push over or if
: pass ( idnx.w ) { 0000073D } { indent }
      @p !b drop .. ( / ) @p over @p ; ( / ) { indent }
      !b pop !b wait ;
: mine ( idn0.w ) { 000007BD } then pop ! @ push pass ; { 000007FD }
 }block

( 00318C00 )               D# 1123 shadow{ 
 }block

( 00319000 )               D# 1124 code{ 
 ( -- tx plug node ) [ host ]
: tx0 ( dumb ) h# 00025555 ( maxim { 006AAABF } ) lit ;
: tx1 ( dumb ) h# 00035555 ( maxim { 004AAABF } ) lit ;
: 'ru [ h# 000001C5 ] lit ; { -cr } : 115k [ d# 2350 ] lit ; { cr }
 [ target h# 00000030 org ]
: !bit ( im-i ) { 0000061D } over and { indent }
      if tx0 !b drop ; then tx1 !b drop ;
: putchar ( di-dx ) { 000006BD } h# 000000FF or 2* .. { cr }
 ( 1-start, 8-data, 1-stop bit ) d# 9 for { 0000073D } { indent }
      d# 1 !bit 2/ over for . unext next ; { 000007DD } { br }

 { 000007DD } [ h# 00000020 org ] ( programmed with abandon )
: start io b! ( space ) tx0 !b 'ru a! ( bit delay ) 115k
: wait ( *d ) { 000004DD } @ ( ... ) if { cr }
 ( dly *d ) [ ' wait ] -until { cr }
 ( n! ) { 0000051D } ( *di ) - putchar ! wait ; { cr }
 ( n@ ) { 0000055D } ( *d0 ) then drop dup ! wait ; { 0000059D } }block

( 00319400 )               D# 1125 shadow{ 
 ( notes- ) { indent }
      [ tx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. ) { br }

: putchar ( takes a clean inverted octet and ) { cr }
 ( transmits it low bit first via p17. ) { br }

: wait ( suspends while waiting for an inverted ) { cr }
 ( character or a new delay value. the message ) { cr }
 ( protocol guarentees that there won't be a port conflict. ) }block

( 00319800 )               D# 1126 code{ 
 ( -- rx plug node ) [ h# 00000000 org ]
: @bit ( cm-c ) @b - over - and push and pop or ;
: getchar ( dx-di ) { 0000007D } over 2/ for . unext ( 1/2 bit ) d# 8
 for ( 1-start, 8-data, 1-stop bits ) { indent }
      h# 0001FFFF @bit 2/ over for . unext { cr }
 next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ h# 000000FF and - ; { br }

: baud ( n-ddd ) { 0000023D } if dup dup ; then - push { cr }
 { 0000029D } begin @b . -until ( at start-bit of space ) { cr }
 { 000002BD } begin @b - -until ( at 1-bit ) { cr }
 { 000002DD } begin @b . zif then . -until ( at 0-bits ) { cr }
 { 0000031D } begin @b - zif then . -until ( stop-bit ) { cr }
 { 0000035D } pop - ( n ) dup 2/ . + ( 1.5n ) dup dup ; { 000003BD }
 }block

( 00319C00 )               D# 1127 shadow{ 
 ( notes- ) { indent }
      [ rx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received
 characters may have one stop bit. ) { br }

: getchar ( called after seeing leading edge of start bit. returns
 clean inverted character. must be called before start bit begins! )
 { br }

: baud ( space is 1...1'0010.0000'0 ) { indent }
      ( stop bits ------' .hex..20. '--- start ) { br }

: idle }block

( 0031A000 )               D# 1128 code{ 
 ( --- more rx ) { br }

 { 000003BD } [ h# 00000020 org ] ( programmed with 2-stack abandon )
: start ( est 115k delay ) d# 2350 { indent }
      ( tri-state pin17 ) io b! h# 00005555 !b { indent }
      ( 2-char empty buffer ) d# 0 dup push
: pwait ( *dl.p* ) { 000004FD } push
: wait ( *d.lp* ) { 0000051D } ( io-mask ) h# 00028000 dup { indent }
      begin drop @b over and until -if { cr }
 ( pin *dm-.lp* ) drop getchar pwait ; { cr }
 ( msg *dm+.lp* ) then drop drop right a! @ -if { cr }
 ( n! *d-.lp* ) { 0000065D } - baud ! up a! ! wait ; { cr }
 ( n@ *d0.lp* ) { 000006DD } then pop if { cr }
 ( *d0l.p* ) pop if { 0000004F } ( chars in buffer ) { indent }
      ( *d0lp.* ) ! over push push drop wait ; { indent }
      ( *d0l0.* ) then push ( 0/1 char in buffer ) { cr }
 ( *d0l.p* ) then ! pwait ; { 000007BD } }block

( 0031A400 )               D# 1129 shadow{ 
 }block

( 0031A800 )               D# 1130 code{ 
 ( -- 1-pin plug node ) [ h# 00000020 org ]
: start right a! io b! ( p17 hi-imp ) h# 00005555 dup !b
: cmd ( m ) { 000004DD } @ ( ... ) -if { cr }
 ( n! ) { 000004FD } ( mw ) d# 1 or d# 7 for 2* 2* unext { indent }
      over over or !b ! cmd ; { cr }
 ( n@ ) { 000005FD } ( m0 ) then @b -if drop - ! cmd ; { indent }
      then drop ! cmd ; { 0000069D } }block

( 0031AC00 )               D# 1131 shadow{ 
 ( notes- ) { cr }
 ( currently plugged into nodes { 00003E8F } and { 00004B0F } . ) { cr }
 [ d# 0 ] n! ( drives the pin lo. ) { cr }
 [ d# 1 ] n! ( drives the pin hi. ) { cr }
 [ d# 2 ] n! ( tri-states the pin. ) { cr }
 [ d# 3 ] n! ( attaches a weak pull-down to the pin. ) { cr }
 n@ ( samples the pin, returning ) { indent }
      [ d# -1 ] ( when hi, ) [ d# 0 ] ( when lo. ) { br }

 ( high level eforth code toggles at { 00001F4F } khz! ) }block

( 0031B000 )               D# 1132 code{ 
 ( -- dummy flash controller plug ) [ h# 00000000 org ]
: !x @p drop !p ; { -cr } : x d# 0 ;
: xfers dup !x ; [ h# 00000020 org ]
: start down a!
: cmd { 0000045D } @ ( ... ) -if { cr }
 ( n! ) { 0000047D } ( w ) - xfers ! cmd ; { cr }
 ( n@ ) { 000004BD { 0000000F } } then drop x ! cmd ; }block

( 0031B400 )               D# 1133 shadow{ 
 }block

( 0031B800 )               D# 1134 code{ 
 }block

( 0031BC00 )               D# 1135 shadow{ 
 }block

( 0031C000 )               D# 1136 code{ 
 }block

( 0031C400 )               D# 1137 shadow{ 
 }block

( 0031C800 )               D# 1138 code{ 
 }block

( 0031CC00 )               D# 1139 shadow{ 
 }block

( 0031D000 )               D# 1140 code{ 
 UNKNOWN UNKNOWN ( eforth ide ) [ host load ] { , , }
: hoot ( pn ) dup push hook d# 0 d# 64 pop boot pause ;
 UNKNOWN: 'lu [ h# 00000165 ] ; { * }
: 'cold [ h# 00000005 ] ; ( eforth cold-start )
: e4base ( -a ) [ h# 00000000 { 0010001F } ] ; ( eforth location in
 sram )
 UNKNOWN: 'bitsy [ h# 0000003E ] ; { * }
 UNKNOWN: 'rp [ h# 0000FFF0 ] ; { * }
 UNKNOWN UNKNOWN: 'sp [ h# 0000FFE0 ] ; { , , }
 UNKNOWN UNKNOWN ( tools ) [ d# 1142 d# 4 loads ] { , , }
 ( build chip ) [ d# 1160 load talk e4 ] }block

( 0031D400 )               D# 1141 shadow{ 
 ( customize ide for eforth development. ) { br }

: hoot ( combines ) [ hook ] ( and ) [ boot ]
: e4 ( loads f18 virtual machine code, puts ) { cr }
 ( threaded-code image in sram, and starts it. ) { cr }
 [ note--initial 'space' character needed from ] { cr }
 [ the terminal to determine the baud rate. ] { br }

 < ***no canonical opcodes*** > { cr }
 [ use the ] 'remote' [ ones for both ] { cr }
 [ compiled and interpreted scripts. ] }block

( 0031D800 )               D# 1142 code{ 
 ( - ide build paths ) { br }

: route ( p ) pop b-a swap
: !path ( ap ) dup -hook 'pths + ! panel pause ; { br }

: srampath [ d# 1 ] align route [ d# 708 , d# 608 , ] { indent }
      [ d# 508 , d# 408 , d# 308 , d# 208 , d# 108 , d# 107 , ] { indent }
      [ d# 7 , d# 8 , d# 9 , d# -1 , ] ( srampath ) { br }

: e4path [ d# 0 ] align route [ d# 708 , d# 707 , { 0000584F } ] ( , )
 { indent { 0000582F } }
      ( , { 00004BAF } , { 00004BCF } , ) [ d# 607 , d# 507 , d# 407
 , ] { indent }
      [ d# 307 , d# 207 , d# 206 , d# 205 , d# 105 , d# 106 , ] { indent }
      [ d# 6 , d# 5 , d# 4 , d# 104 , d# 103 , d# 102 , d# 101 , ]
 { indent }
      [ d# 100 , d# 200 , d# 201 , d# 301 , d# 401 , d# 501 , ] { indent }
      [ d# 500 , d# 600 , d# 601 , d# 602 , d# 603 , d# 703 , ] { indent }
      [ d# 704 , d# 604 , d# 504 , d# 404 , d# 304 , d# 204 , ] { indent }
      [ d# -1 , ] ( e4path ) { br }

: flpath [ d# 0 ] align route [ d# 708 , d# 707 , d# 706 , ] { indent }
      [ d# 705 , d# -1 , ] }block

( 0031DC00 )               D# 1143 shadow{ 
 }block

( 0031E000 )               D# 1144 code{ 
 ( - read 16-bit eforth.bin file ) { cr }
 :# ft 0 { -cr } : e4max ( -h ) [ d# 16384 ] ; :# e4siz 4926
: a-b ( a-b ) 2* 2* ; { -cr } : b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ;
: string pop ; { -cr } : h-b 2* ; { -cr } : b-h [ d# 1 ] + 2/ ;
: fbuf ( -b ) [ nnc d# 2 * h# 00008000 + block a-b ] ; { br }

: +e4 [ d# 0 fnam b-a ] r/w fopen if [ ft ] ! ; { cr }
 then drop abort ;
: -e4 [ ft ] @ [ d# 0 ] + if fclose d# 0 then [ ft ] ! ;
: !e4 +e4 if fbuf [ e4max ] h-b [ ft ] @ frd { indent }
      b-h [ e4siz ] ! -e4 then ; { br }

 [ named ] ( ef/eforth.bin ) [ !e4 ]
: n-1 [ e4siz @ d# -1 + ] ; { br }

 }block

( 0031E400 )               D# 1145 shadow{ 
 }block

( 0031E800 )               D# 1146 code{ 
 ( - ide access sram16 from nodes { 00000D8F } and { 000019EF } )
: n108 srampath d# 1 d# 108 hook panel ?ram ;
: n207 e4path d# 0 d# 207 hook panel ?ram ;
: get ( -w ) upd [ stak ] @ rdrop ;
: put2 ( nn- ) swap lit' lit' ;
: put4 ( nnnn- ) push push put2 pop pop put2 ; { br }

: xm! ( m- ) lit' ( xm! ) [ h# 00000037 ] call ;
: x! ( wa- ) put2 ( x! ) [ h# 00000039 ] call ;
: x@ ( a-w ) lit' ( x@ ) [ h# 0000003C ] call get ;
: ex! ( wap- ) push put2 pop lit' ( ex! ) [ h# 0000003A ] call ;
: ex@ ( ap-w ) put2 ( ex@ ) [ h# 0000003D ] call get ;
: cx? ( wapw-f ) put4 ( cx? ) [ h# 0000003E ] call get ; { br }

: dmp ( ap-... ) d# 7 for push dup i ex@ { indent }
      swap [ d# 1 ] + pop -next drop drop ;
: fil ( wapn- ) for push over over i ex! { indent }
      [ d# 1 ] u+ [ d# 1 ] + pop -next drop drop drop ; { br }

: !e4th [ fbuf ] e4base [ n-1 ] for { indent }
      over 2@ swab over x! [ d# 2 ] u+ [ d# 1 ] + { cr }
 -next drop drop ; }block

( 0031EC00 )               D# 1147 shadow{ 
 ( notes ) { indent }
      ( assumes the ide is hooked to one of the sram user nodes. )
 { indent }
      }block

( 0031F000 )               D# 1148 code{ 
 ( - ide access term16 from { 00000D0F } , flash from { 0000584F } )
: n104 e4path d# 0 d# 104 hook panel ?ram ;
: io! ( w ) d# 200
: n! ( wn ) lit' lit' ( n! ) h# 00000030 call upd ;
: tx ( w ) d# 100 n! ;
: io@ ( -w ) d# 100
: n@ ( n-w ) lit' ( n@ ) h# 0000002C call get ;
: rx ( -w ) d# 200 n@ ;
: key ( -w ) begin rx if h# 0000FFFF or ; then drop end
: emit ( w- ) h# 0000FFFF or tx ; [ exit ] { br }

: n706 flpath d# 0 d# 706 hoot panel ?ram ;
: ffo ( foc ) [ h# 00000020 ] call ; { -cr } : blk ( n- ) [ h# 00000200 ]
 * lit ;
: len ( len ) [ h# 00000023 ] call ; { -cr } : f2s ( dnl ) [ h# 00000032 ]
 call ;
: des ( des ) [ h# 00000034 ] call ; { -cr } : don ( don ) [ h# 0000003C ]
 call ;
: e32 ( e32 ) [ h# 00000036 ] call ; { -cr } : s2f ( upl ) [ h# 00000038 ]
 call ;
: burn ( k ) foc blk n108 x@ d# -1 + { indent }
      h# 00000000 path lit s2f don ;
: try ( k ) foc blk len f2s don ; }block

( 0031F400 )               D# 1149 shadow{ 
 }block

( 0031F800 )               D# 1150 code{ 
 }block

( 0031FC00 )               D# 1151 shadow{ 
 }block

( 00320000 )               D# 1152 code{ 
 }block

( 00320400 )               D# 1153 shadow{ 
 }block

( 00320800 )               D# 1154 code{ 
 }block

( 00320C00 )               D# 1155 shadow{ 
 }block

( 00321000 )               D# 1156 code{ 
 }block

( 00321400 )               D# 1157 shadow{ 
 }block

( 00321800 )               D# 1158 code{ 
 }block

( 00321C00 )               D# 1159 shadow{ 
 }block

( 00322000 )               D# 1160 code{ 
 ( eforth chip builder ) { br }

: hooked panel pause d# 2 d# 708 hook pause d# 2 -hook ;
: clean unfoc d# 2 -hook d# 1 -hook d# 0 -hook ;
: e4sram [ d# 1162 ] load ;
: e4sio [ d# 1164 ] load ;
: e4vm [ d# 1166 ] load ;
: e4boot e4sram e4sio e4vm clean ;
: e4bin e4sram !e4th ;
: e4 e4bin e4sio e4vm clean ; }block

( 00322400 )               D# 1161 shadow{ 
 }block

( 00322800 )               D# 1162 code{ 
 ( - build sram16 using ) [ srampath ] { br }

 ( address-bus ) [ d# 1 d# 9 hook d# 0 d# 64 d# 1617 boot h# 00000020
 UNKNOWN call ] { , }
 ( control-pins ) [ d# 1 d# 8 hook d# 0 d# 64 d# 1616 boot h# 00000020
 UNKNOWN call ] { , }
 ( data-bus ) [ d# 1 d# 7 hook d# 0 d# 64 d# 1615 boot h# 00000020
 UNKNOWN call ] { , }
 UNKNOWN ( interface ) [ d# 1 d# 107 hook d# 0 d# 64 d# 1614 boot ] { ,
 UNKNOWN ... }
 UNKNOWN UNKNOWN [ down lit rb! ] { , ... }
 ( 108+207 mask ) [ h# 00008A00 lit ] ( re ) [ h# 00000017 call ] { cr }
 ( user ) [ d# 1 d# 108 hook d# 0 d# 64 d# 1817 boot ] }block

( 00322C00 )               D# 1163 shadow{ 
 }block

( 00323000 )               D# 1164 code{ 
 ( - build siobus wires and plugs using ) [ e4path ]
: wire ( n ) d# 0 over hook push h# 00000030 d# 16 pop boot { indent }
      pause h# 00000030 call ;
: plug ( n ) d# 0 swap hoot h# 00000020 call ; { br }

 [ d# 204 wire d# 304 wire d# 404 wire d# 504 wire ] { cr }
 [ d# 604 wire ] ( flash ) [ d# 704 plug d# 603 wire d# 602 wire ]
 { cr }
 [ d# 601 wire ] ( 1-pin ) [ d# 600 plug ] ( 1-pin ) [ d# 500 plug ]
 { cr }
 [ d# 501 wire d# 401 wire d# 301 wire d# 201 wire ] { cr }
 ( rx ) [ d# 200 plug ] ( tx ) [ d# 100 plug d# 101 wire d# 102 wire ]
 { cr }
 [ d# 103 wire exit ] ( for eforth ) { br }

 ( testing serial bus from bitsy right bud ) { indent }
      [ d# 104 plug 'lu lit ra! ] }block

( 00323400 )               D# 1165 shadow{ 
 }block

( 00323800 )               D# 1166 code{ 
 ( - build e4vm16 nodes using ) [ e4path ]
: pipe ( n ) dup node push h# 00000020 d# 32 pop boot { indent }
      h# 00000020 call ; { br }

 ( bitsy right bud ) [ foc d# 104 plug ] { cr }
 ( bitsy down bud ) [ d# 5 plug ] { cr }
 ( stack down bud ) [ d# 6 plug ] { br }

 ( stack ) [ d# 0 d# 106 hoot right lit rb! ] { indent }
      [ 'sp lit ] ( s ) [ d# 0 lit ] ( t ) [ d# 0 lit ] { indent }
      [ left call ] { br }

 ( bitsy ) [ d# 0 d# 105 hoot left lit rb! ] { indent }
      [ 'rp lit ] ( r ) [ d# 0 lit ] ( ip ) [ 'cold lit ] { indent }
      [ 'bitsy call unfoc ] { br }

 ( bitsy up bud ) [ d# 205 plug ] { cr }
 ( stack up bud ) [ d# 206 plug ] { br }

 ( starter/tail node ) [ d# 207 plug exit ] { br }

 ( pipeline ) [ d# 307 pipe d# 407 pipe d# 507 pipe ] { indent }
      [ d# 607 pipe d# 606 pipe ] ( head ) [ d# 605 pipe ] }block

( 00323C00 )               D# 1167 shadow{ 
 }block

( 00324000 )               D# 1168 code{ 
 }block

( 00324400 )               D# 1169 shadow{ 
 }block

( 00324800 )               D# 1170 code{ 
 UNKNOWN UNKNOWN ( - sram loader nodes ) { , , }
 ( wires ) [ d# 605 node d# 0 org ]
 UNKNOWN: wire ( b! a! ) @ dup !b for @ !b unext warm ; { , }
 UNKNOWN UNKNOWN { 0000009D } [ d# 1815 bin ] { , , }
 UNKNOWN ( sram loader node { 00001A0F } ) { , }
 [ d# 208 node d# 0 org ] ahead
 UNKNOWN: !sram { 0000003D } ( an ) @p !b !b .. ( / ) @p @p .. ( / ) { , }
 !b @p !b ; ( / ) x! ( / )
 UNKNOWN: start { 000000BD } then down a! up b! { , }
 UNKNOWN d# 0 dup @ dup push !sram begin { , }
 UNKNOWN d# 1 . + dup @ !sram next warm ; { , }
 { 0000023D } [ d# 1816 bin ] }block

( 00324C00 )               D# 1171 shadow{ 
 ( minimal version of plumbing for sram boot from flash. wires are
 UNKNOWN compiled only once and are ) { , }
 UNKNOWN ( initialized with source port in a and dest ) { , }
 UNKNOWN UNKNOWN ( port in b. ) { , , }
 ( message consists of word count n-1 followed by n words to be passed
 along. ) }block

( 00325000 )               D# 1172 code{ 
 ( - spi flash { 0000010F } bits ) [ d# 705 node d# 0 org host ]
: resume nnc d# 2 * h# 00008000 + block @ h# 000FFFFF and { indent }
      d# 18 d# 8 */ d# 4 * lit ; [ target ]
: wait ( dw-dw ) { 0000001D } select dup begin drop @b -until drop
 select ;
: 2cmd ( dw-d ) { 0000009D } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 0000013D } io b! ( fast ) d# 5 ;
: fet ( ah al-d ) { 0000019D } push push set ( read ) h# 00000C00 cmd
 pop !8 pop 8obits !8 ;
: 16ibits ( d-db ) { 0000025D } dup d# 15 for { cr }
 rbit ibit - next h# 0000FFFF and ;
: start { 0000033D } down a! d# 0 h# 00020000 fet { cr }
 16ibits dup ! for 16ibits ! next { indent }
      resume fet 18ibits h# 0001E000 . + - -if
: done io b! d# 20 d# 20 -++ half warm ; then { cr }
 d# 5 resume push spicmd spi-boot ; { cr }
 { 0000069D } [ d# 1814 bin ] }block

( 00325400 )               D# 1173 shadow{ 
: start ( 1st word read is count in words ) }block

( 00325800 )               D# 1174 code{ 
 UNKNOWN ( load eforth kernel ) { , }
 UNKNOWN: /nwire ( in out ) /b /a d# 0 d# 4 [ d# 1815 ] /part d# 0 /p ; { ,
 UNKNOWN , }
 UNKNOWN [ d# 705 +node d# 1814 /ram h# 00000019 /p ] { , }
 UNKNOWN [ d# 605 +node down left /nwire ] { , }
 UNKNOWN [ d# 606 +node left right /nwire ] { , }
 UNKNOWN [ d# 607 +node right left /nwire ] { , }
 UNKNOWN [ d# 608 +node left up /nwire ] { , }
 UNKNOWN [ d# 508 +node up down /nwire ] { , }
 UNKNOWN [ d# 408 +node down up /nwire ] { , }
 UNKNOWN [ d# 308 +node up down /nwire ] { , }
 UNKNOWN [ d# 208 +node d# 1816 /ram d# 0 /p ] { , }
 [ d# 108 +node d# 1817 /ram left /b ] }block

( 00325C00 )               D# 1175 shadow{ 
 }block

( 00326000 )               D# 1176 code{ 
 }block

( 00326400 )               D# 1177 shadow{ 
 }block

( 00326800 )               D# 1178 code{ 
 }block

( 00326C00 )               D# 1179 shadow{ 
 }block

( 00327000 )               D# 1180 code{ 
 UNKNOWN UNKNOWN ( build eforth bootstream ) { , , }
 UNKNOWN UNKNOWN ( speedup ) { , ... }
 UNKNOWN UNKNOWN [ h# 00000000 d# 0 d# 3 d# 1608 /root ] { , , }
 ( default ) [ entire course ] { cr }
 UNKNOWN ( sram driver ) [ sram d# 2 + load ] { , }
 UNKNOWN ( flash to sram ) [ d# 1174 load ] { , }
 UNKNOWN UNKNOWN [ frame adjust ] ( resume point ) { , , }
 UNKNOWN [ fresh ] ( residual ) [ sram d# 4 + load s705 course ] { ,
 UNKNOWN ... }
 UNKNOWN UNKNOWN ( siobus and virtual machine ) [ d# 1182 load ] { , ... }
 UNKNOWN UNKNOWN ( flash-sram pipe { 0000940F } load ) { , ... }
 UNKNOWN ( retain asynch boot ) [ d# 708 +node h# 000000AA /p ] { , }
 [ frame ] }block

( 00327400 )               D# 1181 shadow{ 
 }block

( 00327800 )               D# 1182 code{ 
 ( - build siobus and virtual machine bootstream )
: wire ( n ) dup +node push h# 00000030 d# 16 pop /part h# 00000030
 /p ;
: plug ( n ) dup +node /ram h# 00000020 /p ; { br }

 [ d# 103 wire d# 102 wire d# 101 wire ] { indent }
      ( tx ) [ d# 100 plug ] ( rx ) [ d# 200 plug ] { cr }
 [ d# 201 wire d# 301 wire d# 401 wire d# 501 wire ] { indent }
      ( 1-pin ) [ d# 500 plug ] ( 1-pin ) [ d# 600 plug ] { cr }
 [ d# 601 wire d# 602 wire d# 603 wire ] { indent }
      ( flash ) [ d# 704 plug ] { cr }
 [ d# 604 wire d# 504 wire d# 404 wire d# 304 wire ] { cr }
 [ d# 204 wire ] { br }

 ( bitsy ) [ d# 105 +node d# 105 /ram ] { indent }
      ( rp ) [ h# 0000FFF0 ] ( r ) [ d# 0 ] ( ip 'cold ) [ h# 00000005
 d# 3 /stack ] { indent }
      [ left /b right /a ] ( 'bitsy ) [ h# 0000003E /p ] { indent }
      ( buds ) [ d# 205 plug d# 104 plug d# 5 plug ] { br }

 ( stack ) [ d# 106 +node d# 106 /ram ] { indent }
      ( sp ) [ h# 0000FFE0 ] ( s ) [ d# 0 ] ( t ) [ d# 0 d# 3 /stack ]
 { indent }
      [ right /b left /p ] { indent }
      ( buds ) [ d# 206 plug d# 6 plug ] { br }

 ( starter/tail ) [ d# 207 plug ] }block

( 00327C00 )               D# 1183 shadow{ 
 }block

( 00328000 )               D# 1184 code{ 
 ( - build flash-sram pipe bootstream )
: pipe ( n ) dup node push h# 00000020 d# 32 pop boot h# 00000020 /p
 ; { br }

 ( head ) [ d# 605 pipe ] { cr }
 ( pipeline ) [ d# 606 pipe d# 607 pipe ] { indent }
      [ d# 507 pipe d# 407 pipe d# 307 pipe ] { cr }
 }block

( 00328400 )               D# 1185 shadow{ 
 }block

( 00328800 )               D# 1186 code{ 
 }block

( 00328C00 )               D# 1187 shadow{ 
 }block

( 00329000 )               D# 1188 code{ 
 }block

( 00329400 )               D# 1189 shadow{ 
 }block

( 00329800 )               D# 1190 code{ 
 ( burn 16-bit eforth.bin file into flash ) { cr }
 [ empty compile streamer load ] { cr }
 [ d# 1190 loaded ! nores ] { cr }
 ( read eforth.bin ) [ d# 1144 load ] { cr }
 UNKNOWN [ fbuf source ! n-1 len ! ] { , }
 ( display image length ) [ len @ d# 8 d# 18 */ leng ! ] { br }

 [ h# 00008000 stream nip ers ] { cr }
 [ stream h# 00008000 swap burn d# 1194 load ] { br }

 [ exit ] ( source cf-byte-addr ) [ fbuf ] { cr }
 ( dest flash-byte-addr ) [ h# 00008000 ] { cr }
 ( count 16-bit-words ) [ n-1 burn ] }block

( 00329C00 )               D# 1191 shadow{ 
 }block

( 0032A000 )               D# 1192 code{ 
 }block

( 0032A400 )               D# 1193 shadow{ 
 }block

( 0032A800 )               D# 1194 code{ 
 ( burn 18-bit eforth bootstream into flash ) { cr }
 ( 1st pass ) [ empty compile streamer load ] { cr }
 ( framer ) [ framer load ] ( the stream ) [ d# 1180 load ] { br }

 ( 2nd pass ) [ empty compile streamer load ] { cr }
 ( framer ) [ framer load ] ( the stream ) [ d# 1180 load ] { br }

 UNKNOWN [ d# 1194 loaded ! ] { , }
 UNKNOWN ( display stream length ) [ strlen leng ! ] { , }
 ( write stream into flash ) { indent }
      ( source cf-word-addr ) [ stream ] { indent }
      ( dest flash-byte-addr ) [ d# 0 ] { indent }
      ( count 18-bit-words ) [ swap ] ( flasher ) [ 18burn ] }block

( 0032AC00 )               D# 1195 shadow{ 
 }block

( 0032B000 )               D# 1196 code{ 
 }block

( 0032B400 )               D# 1197 shadow{ 
 }block

( 0032B800 )               D# 1198 code{ 
 ( eforth index and listing ) { br }

 [ index load named ] ( eforth.txt ) [ d# 1080 d# 1200 run ] { br }

 [ html load named ] ( eforth.html ) [ d# 1080 d# 1200 run ] { br }

 [ exit ] }block

( 0032BC00 )               D# 1199 shadow{ 
 }block

( 0032C000 )               D# 1200 code{ 
 }block

( 0032C400 )               D# 1201 shadow{ 
 }block

( 0032C800 )               D# 1202 code{ 
 }block

( 0032CC00 )               D# 1203 shadow{ 
 }block

( 0032D000 )               D# 1204 code{ 
 }block

( 0032D400 )               D# 1205 shadow{ 
 }block

( 0032D800 )               D# 1206 code{ 
 }block

( 0032DC00 )               D# 1207 shadow{ 
 }block

( 0032E000 )               D# 1208 code{ 
 }block

( 0032E400 )               D# 1209 shadow{ 
 }block

( 0032E800 )               D# 1210 code{ 
 }block

( 0032EC00 )               D# 1211 shadow{ 
 }block

( 0032F000 )               D# 1212 code{ 
 }block

( 0032F400 )               D# 1213 shadow{ 
 }block

( 0032F800 )               D# 1214 code{ 
 }block

( 0032FC00 )               D# 1215 shadow{ 
 }block

( 00330000 )               D# 1216 code{ 
 }block

( 00330400 )               D# 1217 shadow{ 
 }block

( 00330800 )               D# 1218 code{ 
 }block

( 00330C00 )               D# 1219 shadow{ 
 }block

( 00331000 )               D# 1220 code{ 
 }block

( 00331400 )               D# 1221 shadow{ 
 }block

( 00331800 )               D# 1222 code{ 
 }block

( 00331C00 )               D# 1223 shadow{ 
 }block

( 00332000 )               D# 1224 code{ 
 }block

( 00332400 )               D# 1225 shadow{ 
 }block

( 00332800 )               D# 1226 code{ 
 }block

( 00332C00 )               D# 1227 shadow{ 
 }block

( 00333000 )               D# 1228 code{ 
 }block

( 00333400 )               D# 1229 shadow{ 
 }block

( 00333800 )               D# 1230 code{ 
 }block

( 00333C00 )               D# 1231 shadow{ 
 }block

( 00334000 )               D# 1232 code{ 
 }block

( 00334400 )               D# 1233 shadow{ 
 }block

( 00334800 )               D# 1234 code{ 
 }block

( 00334C00 )               D# 1235 shadow{ 
 }block

( 00335000 )               D# 1236 code{ 
 }block

( 00335400 )               D# 1237 shadow{ 
 }block

( 00335800 )               D# 1238 code{ 
 ( interactive )
: node ( n ) nn-n [ nod ] ! ; { -cr } : other ( n ) nn-n [ nod2 ] !
 ;
: focus [ nod ] @ !inode ; { -cr } : lit ( n ) focus +t ;
: rdup focus t @ +t ; { -cr } : rdrop focus -t drop ;
: rover focus s @ +t ; { -cr } : rpop focus -r +t ;
: rpush focus -t +r ;
: ror focus bin or t ! ;
: rand focus bin and t ! ;
: r+ focus bin + 18bit t ! ;
: r- focus t @ - 18bit t ! ;
: r2* focus t @ 2* 18bit t ! ;
: r2/ focus t @19 2/ t ! ;
: ra! focus -t ar ! ;
: ra@ focus ar @ +t ;
: rb! focus -t 10bit b ! ;
: r+* focus t @19 ?s+ 2/ 18bit t ! ; }block

( 00335C00 )               D# 1239 shadow{ 
 ( interactive ) }block

( 00336000 )               D# 1240 code{ 
 ( - )
: exec ( n ) focus pc @ +r ir ! d# 1 slot ! d# 0 cnt ! ;
: fin step step step ;
: x!b ( .!b;; ) [ h# 0002DB55 ] exec !b ; { -cr } : !b x!b fin ;
: x!a ( .!a;; ) [ h# 0002DA55 ] exec !a ; { -cr } : !a x!a fin ;
: x!+ ( .!+;; ) [ h# 0002D855 ] exec !+ ; { -cr } : !+ x!+ fin ;
: x@b ( .@b;; ) [ h# 0002DF55 ] exec @b ; { -cr } : @b x@b fin ;
: x@a ( .@a;; ) [ h# 0002DE55 ] exec @a ; { -cr } : @a x@a fin ;
: x@+ ( .@+;; ) [ h# 0002DC55 ] exec @+ ; { -cr } : @+ x@+ fin ;
: r@ ( a-n ) lit ra! @a -t ;
: r! ( na ) lit ra! lit !a ;
: io [ h# 0000015D ] ; { -cr } : data [ h# 00000141 ] ; { -cr } : ldata
 [ h# 00000171 ] ;
: right [ h# 000001D5 ] ; { -cr } : down [ h# 00000115 ] ;
: left [ h# 00000175 ] ; { -cr } : up [ h# 00000145 ] ;
: call pc @ lit rpush lit rpush ret fin h ;
: boot ( acn ) swap push puka over + swap [ nod ] @ { cr }
 n-nn puka + pop move ; { br }

: default [ d# 100 ] !node [ d# 0 ] mem ! [ d# 0 ] !node [ d# 0 ] mem
 ! { cr }
 [ d# 0 ] node [ d# 100 ] other d# 0 [ xo ] ! d# 0 [ yo ] ! !vis ;
 }block

( 00336400 )               D# 1241 shadow{ 
 ( memory operators and constants ) }block

( 00336800 )               D# 1242 code{ 
 ( build boot stream for softsim flash testbed ) { cr }
 [ streamer load framer load ] { cr }
 ( smtm ) [ d# 2 d# 0 d# 64 d# 0 /root ] }block

( 00336C00 )               D# 1243 shadow{ 
 ( makes a boot stream from the smtm example ) { cr }
 ( starting at address { 0000004F } in order to avoid ) { cr }
 ( running into the edge ) }block

( 00337000 )               D# 1244 code{ 
 ( spi testbed ) :# clk 0 :# btcnt 33 { cr }
 :# cmd -1 [ d# 0 cmd ! ] :# spbit 1363525650
: 'stream ( -a ) [ nnc d# 2 * h# 00008000 + block d# 1 + ] ;
: setmem ( b ) h# 00FFFFFF and d# 8 * ( byte offset in bits ) { cr }
 [ 'stream ] d# 18 * + [ spbit ] ! ; [ d# 0 setmem ]
: 'cmd ( -a ) [ cmd ] dup @ p5v @ low? -if { indent }
      2* over ! ; then - 2* - over ! ;
: ?bit [ btcnt ] @ d# -1 + d# 0 max dup [ btcnt ] ! { indent }
      dup and drop if 'cmd @ setmem { indent }
      pop drop ; then ;
: bitn ( n-nn ) dup @ swap over d# 1 + swap ! { indent }
      d# 18 /mod @ p-n swap d# 1 + ;
: bit17 d# 0 [ spbit ] bitn for 2* next { indent }
      h# 00040000 and drop if drop [ vdd @ ] then { indent }
      p17v ! ; }block

( 00337400 )               D# 1245 shadow{ 
 ( spi testbed ) { cr }
 [ boot stream is assembled starting at nnc ]
: setmem ( adds an offset and converts to bits )
: ?bit ( reads command or allows data write ) { br }

: spi ( assigns initial behavior to softbed ) { cr }
 [ first waits for select high , ] { cr }
 [ then waits for select low , then watches ] { cr }
 [ spi clock and accumulates data until select ] { cr }
 [ goes high , at which point it starts over ] }block

( 00337800 )               D# 1246 code{ 
 ( spi testbed )
: threshold ( -v ) [ vdd @ d# 2 / negate ] ;
: clk? ( -n ) p1v @ threshold + - d# 0 max d# 1 min ;
: hi? ( a ) @ threshold + d# 0 max dup and drop ;
: lo? ( a ) @ threshold + - d# 0 max dup and drop ;
: spi [ d# 705 ] !node
: desel d# -1 [ cmd ] ! d# 33 [ btcnt ] ! { cr }
 softbed assign p3v lo? if ; then { cr }
 softbed assign clk? [ clk ] ! p3v lo? if { cr }
 softbed assign p3v hi? if desel ; then { indent }
      [ clk ] @ clk? dup [ clk ] ! or { indent }
      drop if [ clk ] @ dup and drop { indent }
      if ; then ?bit bit17 then then ; }block

( 00337C00 )               D# 1247 shadow{ 
 ( spi testbed ) { cr }
 [ boot stream is assembled starting at nnc ]
: setmem ( adds an offset and converts to bits )
: ?bit ( reads command or allows data write ) { br }

: spi ( assigns initial behavior to softbed ) { cr }
 [ first waits for select high , ] { cr }
 [ then waits for select low , then watches spi ] { cr }
 [ clock and accumulates data until select ] { cr }
 [ goes high , at which point it starts over ] }block

( 00338000 )               D# 1248 code{ 
 ( show directions ) :# arrow 92 [ d# 92 arrow ! ]
: magenta h# 00FF00FF color ;
: .dir ( o ) [ xy ] @ dup push + [ xy ] ! { indent }
      [ arrow ] @ emit pop [ xy ] ! ;
: ?dir ( n-n ) dup d# 1 and drop if pop drop then ;
: .ndir 2/ ?dir h# 00160000 .dir ;
: .sdir 2/ ?dir h# 001600A5 .dir ;
: .wdir 2/ ?dir h# FFF5004B .dir ;
: .edir 2/ ?dir h# 0037004B .dir ;
: .eswn ( a ) magenta .ndir .wdir { indent }
      red .sdir .edir drop ;
: .wsen ( a ) magenta .ndir .edir { indent }
      red .sdir .wdir drop ;
: .enws ( a ) magenta .sdir .wdir { indent }
      red .ndir .edir drop ;
: .wnes ( a ) magenta .sdir .edir { indent }
      red .ndir .wdir drop ;
: which d# 92 dbus @ [ wrq ] and drop { indent }
      if d# -2 + then [ arrow ] ! ;
: .drs abus @ dup - h# 00000100 and drop { indent }
      if drop ; then which h# 000000A0 or d# 8 / { indent }
      [ comb ] @ [ h# 00008000 block negate ] + [ h# 00000200 ] / { indent }
      dup d# 9 / d# 2 and swap d# 1 and or { indent }
      jump .enws .wnes .eswn .wsen }block

( 00338400 )               D# 1249 shadow{ 
: which dbus @ dup wrq and drop { indent }
      if drop d# 90 [ arrow ] ! ; then { indent }
      rrq and drop if d# 92 [ arrow ] ! then ; }block

( 00338800 )               D# 1250 code{ 
 ( prelude ) :# comb 75530240
: xqt? ( a ) @ ( b ) dup and if push ; then drop ;
: nodes ( i-n ) 2* blks ;
: inode ( i-a ) nodes [ h# 00008000 block ] + ;
: !node ( n ) nn-n { -cr } : !inode ( i ) inode [ comb ] ! ;
: my ( o-a ) [ comb ] @ + ; ( node variables )
: memory ( o-a ) h# 000000BF and my ; { -cr } : rombit ( -m ) h# 00000080
 ; { cr }
 ( 40-7c defined later )
: bp [ h# 0000007D ] my ; { -cr } : entry [ h# 0000007E ] my ; { -cr } 
: pins [ h# 0000007F ] my ;
: nnxmod ( -n ) [ d# 100 ] ; { br }

: enter ( a nn ) !node entry ! ; }block

( 00338C00 )               D# 1251 shadow{ 
 ( prelude )
: comb ( base address of node vars for this node )
: xqt? ( execute code starting at adr in preceding variable ) }block

( 00339000 )               D# 1252 code{ 
 ( softsim node variables ) { cr }
 ( cpu -pattern- buses and registers )
: dbus h# 00000040 my ;
: uport h# 00000041 my ; { -cr } : udest h# 0000004E my ;
: lport h# 00000042 my ; { -cr } : ldest h# 0000004D my ;
: dport h# 00000044 my ; { -cr } : ddest h# 0000004B my ;
: rport h# 00000048 my ; { -cr } : rdest h# 00000047 my ; { cr }
 ( pins and testbed )
: p17v h# 00000050 my ; { -cr } : p5v h# 00000051 my ;
: p3v h# 00000052 my ; { -cr } : p1v h# 00000053 my ;
: bus h# 00000054 my ; { -cr } : ios h# 00000055 my ;
: softbed h# 00000056 my ; { cr }
 ( cpu -number- buses and registers )
: abus h# 00000057 my ; { -cr } : ioc h# 00000058 my ;
: ar h# 00000059 my ; { -cr } : b h# 0000005A my ;
: t h# 0000005B my ; { -cr } : pc h# 0000005C my ; { -cr } : ir h# 0000005D
 my ;
: s h# 0000005E my ; { -cr } : ss ( i ) d# 7 and h# 00000060 my + ;
: r h# 0000005F my ; { -cr } : rs ( i ) d# 7 and h# 00000068 my + ;
 }block

( 00339400 )               D# 1253 shadow{ 
 ( softsim node variables ) { br }

 ( some node variables make more sense as hardware patterns, others
 as numbers ) }block

( 00339800 )               D# 1254 code{ 
 ( softsim node variables and shared code ) { cr }
 ( variables )
: 'tik h# 00000043 my ; { -cr } : 'tok h# 00000045 my ;
: sp h# 00000046 my ; { -cr } : slot h# 00000049 my ;
: cnt h# 0000004A my ; { -cr } : pre h# 0000004C my ;
: cy h# 0000004F my ; { -cr } : 'op h# 00000070 my ;
: rp h# 00000071 my ; { -cr } : mem h# 00000072 my ;
: pwv h# 00000073 my ; { -cr } : vis h# 00000074 my ;
: ip h# 00000075 my ; { -cr } : bp' h# 00000076 my ;
: rqs h# 00000077 my ; ( 78-7c available )
: rrq h# 00080000 ; { -cr } : wrq h# 00040000 ; { -cr } : brq h# 000C0000
 ; { br }

 :# vdd 1800 [ d# 1800 vdd ! macro ]
: 2/s ?lit h# 0000F8C1 2, 1, ;
: 2*s ?lit h# 0000E0C1 2, 1, ; [ forth ]
: @10 @ { -cr } : 10bit h# 000003FF and ;
: p-n { -cr } : n-p h# 00015555 or ;
: 18bit h# 0003FFFF and ; { -cr } : 8bit h# 000000FF and ;
: !18 ( na ) push 18bit i @ h# FFFC0000 and or pop ! ;
: !10 ( na ) push 10bit i @ h# 0003FC00 and or pop ! ; }block

( 00339C00 )               D# 1255 shadow{ 
 ( softsim node variables and shared code ) { cr }
 ( variables )
: 'tik 'tok ( defered execution )
: sp slot ( stack and slot pointers )
: cnt pre ( timers )
: cy 'op ( carry )
: rp mem ( return stack pointer , mem dump pointer )
: pwv vis
: ip bp' ( instruction pointer , ) { indent }
      ( alternate breakpoint )
: rqs ( requests from all ports accumulated here )
: rrq wrq brq ( read , write , both requests ) { br }

 vdd ( is 1.8v )
: 2/s ( right shift macro )
: 2*s ( left shift macro )
: @10 10bit ( mask and store 10 bit address )
: p-n n-p ( convert pattern to/from numbers )
: 18bit 8bit ( mask address bits )
: !18 ( store masked off 18 bit address )
: !10 ( store masked off 10 bit address ) }block

( 0033A000 )               D# 1256 code{ 
 ( softsim all tiks )
: out ( apm ) and if drop [ vdd @ ] then swap ! ;
: low? ( v- ) [ vdd @ d# 2 / negate ] + drop ; { indent }
      begin drop drop ;
: ?1p bus [ brq ] over @ over and drop until { indent }
      ioc @ p17v @ low? -if - then h# 00000800 { indent }
      and drop if - over @ and swap ! ; { indent }
      then over @ or swap ! ;
: ?18p p17v [ d# 8 !node ioc ] @ pwv @ out ?1p ;
: ?sp ;
: ?ap p17v pwv @ @ h# 00020000 out ?1p ;
: ?pins pins @ jump { indent }
      nul ?1p ?1p ?1p ?18p ?sp ?ap { br }

: @dest ( a-p ) h# 0000000F or @ @ ;
: +ours ( pa-p ) dup @ swap @dest +or { indent }
      [ brq ] and or 2/ 2/ ;
: @ours [ d# 0 ] uport +ours lport +ours { indent }
      dport +ours rport +ours 2/ rqs ! ; { br }

: status ?pins @ours ; }block

( 0033A400 )               D# 1257 shadow{ 
 ( softsim all tiks )
: out ( output is zero or 1.8v )
: low? ( output negative if voltage is low ) { br }

: @ours ( accumulate r/w requests into ) rqs }block

( 0033A800 )               D# 1258 code{ 
 ( softsim all toks )
: v-b ( mn-mb ) low? -if d# 0 ; then dup ;
: @pin ( mpmv-mp ) @ v-b v+ ;
: @4p ( mp-mp ) h# 00000020 p5v @pin h# 00000008 p3v @pin
: @2p ( mp-mp ) h# 00000002 p1v @pin
: @1p ( mp-mp ) h# 00020000 p17v @pin ;
: @sp ( mp-mp ) ;
: @pins ( mp-mp ) pins @ jump { indent }
      nul @1p @2p @4p @1p @sp @1p { br }

: !pin ( vm ) ioc @ over over and drop if 2* out { cr }
 ; then ( in ) 2* - and drop if ( tri ) drop ; then { cr }
 ( weak0 ) dup @ dup 2/ 2/ negate + swap ! ;
: !4p p5v h# 00000020 !pin p3v h# 00000008 !pin
: !2p p1v h# 00000002 !pin { -cr } : !1p p17v h# 00020000 !pin ;
: !18p abus @ h# 00000100 or h# 00000110 and drop if ; { indent }
      ( up ) then dbus @ cnt @ - 2* drop { indent }
      -if 18bit then p-n bus ! ;
: !sp ;
: !ap ;
: !pins pins @ jump { indent }
      nul !1p !2p !4p !18p !sp !ap }block

( 0033AC00 )               D# 1259 shadow{ 
 ( softsim all toks ) }block

( 0033B000 )               D# 1260 code{ 
 ( softsim suspended tiks and toks )
: cnt? cnt @ dup and drop ; { br }

: -hand ( mp-mp ) 2* 2* over over over and or drop ;
: -shake [ brq ] rqs @ 2* -hand if -hand if { indent }
      -hand if -hand then then then drop drop ;
: wait? cnt? if -shake ; then ; { br }

: +mine ( pa-p ) @ [ brq ] and or 2/ 2/ ;
: @mine [ d# 0 ] uport +mine lport +mine { indent }
      dport +mine rport +mine 2/ rqs ! ;
: !port ( mo-mo ) over over and { indent }
      if drop dbus @ then over dbus + ! 2/ ;
: !ports abus @ h# 00000155 or dup d# 4 2/s h# 00000008 { indent }
      d# 4 for !port next drop drop { indent }
      h# 00000014 or drop if d# -1 cnt ! then @mine ; }block

( 0033B400 )               D# 1261 shadow{ 
 ( softsim suspended tiks and toks ) { br }

: @mine ( accumulate r/w requests into ) rqs }block

( 0033B800 )               D# 1262 code{ 
 ( softsim tik/tok and power ) :# op 270081749 { cr }
 :# bail 0 [ d# 0 bail ! ] ( breakpoint )
: update !pins softbed xqt ios h# 0001FE00 d# 0 @pins { cr }
 push - over @ and pop or rqs @ or swap ! ;
: 0ports [ d# 0 ] cnt ! [ d# 0 ] dbus ! pc @ abus ! [ d# 0 ] rqs !
 { cr }
 [ d# 0 ] uport ! [ d# 0 ] lport ! [ d# 0 ] dport ! [ d# 0 ] rport
 ! ;
: ipower ( i ) !inode 'tok assign { cr }
 [ d# 0 ] p17v [ p17v negate softbed + ] fill { cr }
 [ d# 0 p-n ] abus [ softbed negate d# 7 rs + ] fill { cr }
 d# 0 mem ! entry @ pc ! [ h# 0000015D ] b ! d# 4 slot ! [ h# 000000A9 ]
 ip !
: newop 0ports update [ op ] @ 'tik ! d# 2 pre ! ;
: ?bp ip @ slot @ or bp @ or drop if ; { indent }
      then [ comb ] @ [ bail ] ! ;
: itik ( i ) !inode { -cr } : tik ?bp 'tik xqt ;
: itok ( i ) !inode { -cr } : tok 'tok xqt ;
: tiks [ nns d# -1 + ] for i itik -next ;
: toks [ nns d# -1 + ] for i itok -next ;
: power [ nns d# -1 + ] for i ipower -next toks tiks ;
: /enter [ nns d# -1 + ] for i dup !inode resets @ { cr }
 rstadr entry ! -next ; [ /enter ] }block

( 0033BC00 )               D# 1263 shadow{ 
 ( opcode ---tick--- ---tock--- ) { cr }
 ( -alu-- ..update.. .!results. ) { cr }
 ( ...... .......... ) { cr }
 ( -addr- .upd,bus,? / ) { br }

 ( alu ops don't have to change tick; ) { cr }
 ( addr ops set abus,dbus in tick, then check for completion; if not
 done, tock writes dbus to ports and tick checks again, repeated til
 done. when done, tock clears ports and resumes opcode. ) }block

( 0033C000 )               D# 1264 code{ 
 ( softsim read/write access )
: @port ( mop-mop ) push over over and { indent }
      if dbus + @dest then pop +or over u+ ;
: pr/o dbus @ [ wrq ] ? drop if ; then { cr }
 abus @ d# 4 2/s h# 00000015 or h# 00000001 d# 0 { cr }
 d# 4 for @port next nip nip 18bit dbus ! ; { br }

: ir/w abus @ h# 0000015D or drop if ; then { indent }
      dbus @ [ wrq ] ? if 18bit p-n ioc ! ; { indent }
      then drop ios @ dbus ! ; { br }

: ram! ( w ) abus @ [ rombit ] ? if drop drop ; { indent }
      then memory ! ;
: mr/w dbus @ [ wrq ] ? if 18bit ram! ; { indent }
      then drop abus @ memory @ dbus ! ; }block

( 0033C400 )               D# 1265 shadow{ 
 ( softsim read/write access ) }block

( 0033C800 )               D# 1266 code{ 
 ( softsim port, register, and memory access ) { cr }
 ( tik0 ) { -cr } : por@! status 'tok assign { cr }
 ( tok0 ) !ports update d# -1 cnt +! 'tik assign { cr }
 ( tiki ) status wait? if 'tok assign { cr }
 ( toki ) update d# -1 cnt +! ; { cr }
 ( tike ) then pr/o 'tok assign
: toke 'op xqt pre xqt newop ; { br }

 ( tike ) { -cr } : reg@! status 'tok assign { cr }
 ( toke ) update ir/w toke ; { br }

 begin 'tik assign { -cr cr }
 ( tiki )
: mem@! status cnt? while 'tok assign { cr }
 ( toki ) update d# -1 cnt +! end { cr }
 ( tike ) then 'tok assign { cr }
 ( toke ) mr/w toke ; { br }

: access ( apc ) pop ( group ) pre ! pop ( op ) 'op ! { indent }
      cnt ! dbus ! h# 000003FF and dup abus ! { indent }
      h# 00000100 ? if h# 00000155 or h# 000000F0 ? if { cr }
 ( ports m ) drop d# 1 cnt ! por@! ; { cr }
 ( regs ) then ( 0 ) cnt ! reg@! ; { cr }
 ( mem ) then ( x ) drop mem@! ; { br }

 }block

( 0033CC00 )               D# 1267 shadow{ 
 ( opcode ---tick--- ---tock--- ) { cr }
 ( -alu-- ..update.. .!results. ) { cr }
 ( ...... .......... ) { cr }
 ( -addr- .upd,bus,? / ) { br }

 ( alu ops don't have to change tick; ) { cr }
 ( addr ops set abus,dbus in tick, then check for completion; if not
 done, tock writes dbus to ports and tick checks again, repeated til
 done. when done, tock clears ports and resumes opcode. ) }block

( 0033D000 )               D# 1268 code{ 
 ( softsim ops common code )
: ++@ ( a-n ) dup push @ d# 1 + dup pop ! ;
: @-- ( a-n ) dup push @ dup d# -1 + pop ! ;
: +t ( n ) t @ s @ sp ++@ ss ! s ! t ! ;
: -t ( -n ) t @ s @ t ! sp @-- ss @ s ! ;
: +r ( n ) r @ rp ++@ rs ! r ! ;
: -r ( -n ) r @ rp @-- rs @ r ! ;
: bin ( -nn ) -t t @ ;
: @19 ( -n ) @ dup h# 00020000 and 2* or ;
: 3bit ( a-a ) h# 00000007 and pc @ h# 000000F8 and or ;
: addr ( a-a ) slot @ jump { indent }
      10bit 8bit 3bit nul nul { br }

: ++abus ( -n ) abus @ h# 00000100 ? if ; then h# 0000037F
: /++/ ( nm-n ) over dup d# 1 + or and or ;
: pc++ ++abus pc ! ;
: ar++ ++abus ar !10 ; { br }

: ?+c ( n-n ) pc @ - h# 00000200 and drop if ; then { cr }
 cy @ d# 1 and + dup d# 18 2/s d# 1 and cy ! ;
: ?+*c ( n-n ) pc @ - h# 00000200 and drop if ; then { cr }
 cy @ d# 1 and + dup - d# 18 2/s d# 1 and cy ! ;
: ?s+ ( n-n ) ar @ d# 1 ? if push s @19 + ?+*c pop then 2/ over d# 1
 and drop if h# 00020000 or then ar ! ; }block

( 0033D400 )               D# 1269 shadow{ 
 ( softsim ops common code ) { br }

: @19 ( fetch then extend sign into bit 18 )
: ?+c ( add carry for + when p9 set )
: ?+*c ( add carry for +* when p9 set ) { indent }
      ( includes sign extend in s ) }block

( 0033D800 )               D# 1270 code{ 
 ( softsim ops control )
: /f/ ( a ) [ rrq ] d# 2
: /p/ ( adc ) access abus @ 2* 2* ip ! { indent }
      dbus @ p-n ir ! pc++
: 0/ d# 0 slot ! ;
: /u status pop 'op ! 'tok assign { indent }
      update 'op xqt d# 2 pre ! ;
: +/ d# 1 slot +! ; { br }

: ret r @ /f/ -r drop ;
: ex r @ /f/ pc @ r !10 ;
: jmp ir @ addr /f/ nop ;
: call ir @ addr /f/ r @ +r pc @ r !10 ; { br }

: ur r @ dup and drop if { indent }
      ( slot0 ) /u d# -1 r +! 0/ ; { indent }
      ( slot+ ) then /u -r drop +/ ;
: jr r @ dup and drop if { indent }
      ( jump ) ir @ addr /f/ d# -1 r +! ; { indent }
      ( fall ) then pc @ /f/ -r drop ;
: jz h# 0003FFFF { -cr } : jc t @ and drop if { indent }
      ( fall ) { -cr } : fetch pc @ /f/ nop ; { indent }
      ( jump ) then jmp ;
: jp h# 00020000 jc ; }block

( 0033DC00 )               D# 1271 shadow{ 
 ( softsim ops control ) }block

( 0033E000 )               D# 1272 code{ 
 ( softsim ops read/write and alu.1 )
: /w/ ( r ) @ t @ n-p [ wrq ] or d# 1 access -t drop +/ ;
: /r/ ( r ) @ [ rrq ] d# 1 access dbus @ p-n +t +/ ; { br }

: @a ar /r/ nop ; { -cr } : !a ar /w/ nop ;
: @b b /r/ nop ; { -cr } : !b b /w/ nop ;
: @+ ar /r/ ar++ ; { -cr } : !+ ar /w/ ar++ ;
: @p pc /r/ pc++ ; { -cr } : !p pc /w/ pc++ ; { br }

: /a/ slot @ d# 3 or drop if ( slot0-2 ) { indent }
      status pop 'op ! 'tok assign { indent }
      update 'op xqt d# -1 pre +! +/ ; { cr }
 then ( prefetch ) pc @ [ rrq ] pre @ d# 0 max /p/ ; { br }

: +* /a/ t @19 ?s+ 2/ 18bit t ! ;
: 2*x /a/ t @ 2* 18bit t ! ;
: 2/x /a/ t @19 2/ t ! ;
: -x /a/ t @ h# 0003FFFF or t ! ; { br }

: +x /a/ bin + ?+c 18bit t ! ;
: andx /a/ bin and t ! ;
: orx /a/ bin or t ! ;
: t! /a/ -t drop ; }block

( 0033E400 )               D# 1273 shadow{ 
 ( softsim ops read/write and alu.1 ) }block

( 0033E800 )               D# 1274 code{ 
 ( softsim ops alu.2 and jump table )
: t@ /a/ t @ +t ; { -cr } : .x /a/ nop ;
: r@ /a/ -r +t ; { -cr } : r! /a/ -t +r ;
: s@ /a/ s @ +t ; { -cr } : b! /a/ -t 10bit b ! ;
: a@ /a/ ar @ +t ; { -cr } : a!x /a/ -t ar ! ; { br }

: s0 ( p-o ) d# 13 2/s h# 0000001F and ;
: s1 ( p-o ) d# 8 2/s h# 0000001F and ;
: s2 ( p-o ) d# 3 2/s h# 0000001F and ;
: s3 ( p-o ) 2* 2* h# 0000001F and ;
: s4 ( p-o ) drop h# 00000020 ;
: @op ( ps-o ) jump s0 s1 s2 s3 s4 { br }

: !op [ op ] assign ir @ n-p slot @ @op jump { indent }
      ret ex jmp call ur jr jz jp { indent }
      @p @+ @b @a !p !+ !b !a { indent }
      +* 2*x 2/x -x +x andx orx t! { indent }
      t@ r@ s@ a@ .x r! b! a!x { indent }
      fetch [ !op ] }block

( 0033EC00 )               D# 1275 shadow{ 
 }block

( 0033F000 )               D# 1276 code{ 
 ( softsim display ops ) :# ?op 270084357
: tab/2 ( xy ) push [ d# 11 ] * [ d# 3 ] + pop [ d# 15 ] * [ d# 3 ]
 + { indent }
      over lm at ;
: cr/2 cr d# -15 [ xy ] +! ;
: emit/2 ( c ) [ d# 48 ] + emit
: -sp/2 [ d# -11 h# 00010000 * ] nop [ xy ] +! ; { br }

: v- ( xyxy-xy ) push negate pop negate v+ ; { br }

: 'ops align strings ( ; ex jump call unext next if -if @p @+ @b @
 !p !+ !b ! +* 2* 2/ - + and or drop dup pop over a . push b! a! fetch )
 { br }

: .op ( i ) 'ops @ [ h# FFFFFFF0 ] and { indent }
      begin dup and while unpack emit/2 { indent }
      end then drop sp/2 ;
: ?more ( o ) [ h# 00000018 ] ? if drop ( t ) ; { indent }
      then [ h# 00000003 ] ? if dup or drop ( f ) ; { indent }
      then [ h# 00000004 ] and drop ( t/f ) ;
: .ops ( p ) d# 0 d# 4 for [ ?op ] xqt { indent }
      over over @op dup .op { indent }
      ?more while [ d# 1 ] + next ; then { indent }
      pop drop ; }block

( 0033F400 )               D# 1277 shadow{ 
 ( softsim display ops ) }block

( 0033F800 )               D# 1278 code{ 
 ( softsim display numbers ) :# base 16
: hex d# 16 [ base ] ! ;
: dec d# 10 [ base ] ! ;
: digits ( i-n ) d# 1 + d# 0 max d# 17 min align tbl { indent }
      [ d# 47 , d# 24 , d# 25 , d# 26 , d# 27 , ] { indent }
      [ d# 28 , d# 29 , d# 30 , d# 31 , ] { indent }
      [ d# 32 , d# 33 , d# 5 , d# 19 , ] { indent }
      [ d# 10 , d# 16 , d# 4 , d# 14 , d# 48 , ]
: digit ( i ) digits emit/2 ;
: .n ( nc ) dup push d# -1 + { indent }
      for [ base ] @ /mod next { indent }
      begin digit next ; { br }

: awake cnt? -if -shake { indent }
      if silver pop drop ; then then ;
: ?blue awake { -cr } : blue h# 004040FF color ;
: ?cyan awake { -cr } : cyan h# 0000FFFF color ;
: yellow h# 00E0E000 color ;
: ?white awake white ;
: ?green awake { -cr } : green h# 0000D000 color ;
: ?red awake red ;
: ?brk [ comb ] @ [ bail ] @ or drop { indent }
      if ; then [ xy ] @ h# 00010000 /mod { indent }
      d# 56 + swap d# 136 + h# 00003F3F color box ; }block

( 0033FC00 )               D# 1279 shadow{ 
 ( softsim display )
: base ( radix for small character number display )
: digits ( table of character values )
: digit ( display digit as small character ) { cr }
 ( ? if too low, pacman if too high, for debug )
: .n ( display ) c ( digits of ) n ( in the current ) [ base ]
: hex ( change ) [ base ] ( to hex )
: dec ( change ) [ base ] ( to decimal )
: nod nod2 ( focus on two nodes )
: switch ( swap focus nodes )
: wake? ( a node is awake if ) slp ( is { 0000006F } )
: ?white
: ?green
: ?blue
: ?red ( change to named color if awake )
: me? ( red if this node number has focus ) }block

( 00340000 )               D# 1280 code{ 
 ( softsim display directions ) { cr }
: .some ( p- -sp/2 ) h# 00000080 ? if ( r ) d# 1 emit/2 then { indent }
      h# 00000040 ? if ( d ) d# 16 emit/2 then { indent }
      h# 00000020 ? if ( l ) d# 12 emit/2 then { indent }
      h# 00000010 ? if ( u ) d# 22 emit/2 then { indent }
      drop pop drop ;
: .rdlu ( p- ) h# 000000F0 over over or and drop { indent }
      if .some ; then ( a ) d# 5 emit/2 { indent }
      ( l ) d# 12 emit/2 ( l ) d# 12 emit/2 drop pop drop ;
: .iocs ( p- i ) d# 7 emit/2 ( o ) d# 3 emit/2 { indent }
      drop pop drop ;
: .adirs ( a-? ) h# 00000100 over over or and drop if ( -n ) ;
: .dirs ( a-? ) dup n-p if h# 00015400 or h# 0003FD00 and { indent }
      while then drop ( -n ) ; { indent }
      then drop sp/2 sp/2 { indent }
      then 8bit h# 00000055 or h# 000000F0 ? if .rdlu ; { indent }
      then h# 00000008 ? if .iocs ; { indent }
      then sp/2 ( ? ) d# 47 emit/2 drop pop drop ;
: noadr ( w ) drop ; { -cr } : .10b ( w ) p-n h# 000003FF and d# 3
 .n ;
: .8b ( w ) p-n h# 000000FF and d# 2 .n ;
: .3b ( w ) d# 43 emit/2 p-n d# 7 and digit ;
: .adr ( wi ) over over @op d# -2 + drop { indent }
      -if drop drop ; then { indent }
      jump .10b .8b .3b noadr noadr }block

( 00340400 )               D# 1281 shadow{ 
 ( softsim display directions ) { cr }
 }block

( 00340800 )               D# 1282 code{ 
 ( softsim display registers )
: adr. abus @10 .adirs d# 3 .n ;
: db. dbus @ p-n d# 5 .n ;
: tr. cy @ d# 1 and drop if -sp/2 h# 00000025 emit/2 then { cr }
 t @ d# 5 .n ;
: sr. s @ d# 5 .n ;
: ar. ar @ .dirs d# 5 .n ;
: br. b @10 .adirs d# 3 .n ;
: ioc. ioc @ d# 5 .n ;
: ios. ios @ p-n d# 5 .n ;
: rqs. rqs @ d# 9 2/s h# 000000FF and h# 00000002 .n ;
: ir. ir @ d# 5 .n ;
: op. ir @ n-p slot @ @op .op ;
: pc. pc @10 .adirs d# 3 .n ;
: rr. r @ d# 5 .n ;
: sl. slot @ digit ;
: rp. rport @ d# 5 .n ;
: dp. dport @ d# 5 .n ;
: lp. lport @ d# 5 .n ;
: up. uport @ d# 5 .n ; { br }

: ?+- ( -c ) -shake if ( - ) d# 35 ; then white ( + ) d# 43 ;
: cnt. cnt @ dup and { indent }
      -if drop ?+- emit/2 ; then digit ; }block

( 00340C00 )               D# 1283 shadow{ 
 ( softsim display registers ) { br }

 ( building blocks for the 2d display, com. ) }block

( 00341000 )               D# 1284 code{ 
 ( softsim display pins )
: i/o ( m ) cyan ioc @ and drop if yellow then ;
: .io ( m ) dup i/o ios @ and if drop h# 00000001 then digit ;
: .1p h# 00020000 .io ; { -cr } : .2p .1p h# 00000002 .io ;
: .4p .1p h# 00000020 .io h# 00000008 .io h# 00000002 .io ;
: .18p h# 00001000 i/o bus @ d# 5 .n ;
: .sp { -cr } : .ap ( dummy ) red [ d# 0 ] d# 2 .n ;
: .pns pins @ jump { indent }
      nul .1p .2p .4p .18p .sp .ap
: .pins [ comb ] @ [ h# 00008000 block negate ] + [ h# 00000200 ] /
 { indent }
      dup d# -17 + drop -if drop d# 165 [ xy ] +! { indent }
      .pns ; then d# 18 mod d# -17 + drop { indent }
      -if .pns ; then h# 002C0000 [ xy ] +! .pns ;
: mv. ( ab ) i/o @ sp/2 d# 4 .n ;
: .mvs p17v h# 00020000 mv. p5v h# 00000020 mv. { indent }
      p3v h# 00000008 mv. p1v h# 00000002 mv. ;
: ?pex [ ?op ] assign ( n-n ) { indent }
      dup slot @ or drop if white ; then red
: /?op [ ?op ] assign white ; [ /?op ]
: ?pc ( n-nf ) dup pc @ or [ h# 00000240 - ] and drop { cr }
 if dup 2* 2* ip @ or [ h# 00000900 - ] and drop { cr }
 if [ d# 1 ] ; then red ?pex [ d# 0 ] ; then yellow [ d# 0 ] ;
: ?ip ( nf-n ) dup and drop { indent }
      if ?green /?op ; then ; }block

( 00341400 )               D# 1285 shadow{ 
 ( softsim display pins ) }block

( 00341800 )               D# 1286 code{ 
 ( softsim display big nodes ) :# nod 107 :# nod2 145 { cr }
 begin drop red ;
: me? ( i ) dup [ nod ] @ or drop until { indent }
      [ nod2 ] @ or drop if ; then yellow ;
: .focus ( i ) dup me? n-nn dec d# 3 .n hex ;
: stack sp @ d# 8 for dup ss @ d# 5 .n { indent }
      cr/2 d# -1 + next drop ;
: return rp @ d# 8 for d# 1 + dup rs @ d# 5 .n { indent }
      cr/2 next drop ;
: stacks white return ?red rr. cr/2 { indent }
      ?green tr. cr/2 sr. cr/2 white stack ;
: /mem. ( i ) mem @ + dup white ?pc swap d# 2 .n { indent }
      sp/2 ?ip memory @ dup p-n d# 5 .n { indent }
      sp/2 .ops .adr cr/2 ;
: mem. mem @ h# 000000B0 and mem ! d# 15 for i /mem. -next ;
: .pex ip @ dup h# 00000400 and drop if { indent }
      red -sp/2 2/ 2/ h# 000003FF and d# 3 .n sp/2 { indent }
      ir. sp/2 ir @ p-n ?pex .ops .adr ; { indent }
      then drop ;
: .big ( hvn ) dup push !inode hex { indent }
      over d# 30 + over tab/2 stacks { indent }
      tab/2 pop .focus sp/2 white ar. { indent }
      cr/2 space space space br. { indent }
      cr/2 .pex cr/2 mem. cr/2 { indent }
      ( cmd @ h. cr spbit @ h. cr ) ; }block

( 00341C00 )               D# 1287 shadow{ 
 ( softsim display big nodes ) }block

( 00342000 )               D# 1288 code{ 
 ( softsim display small nodes ) { cr }
 :# xo 0 :# yo 0 :# xs 8 [ d# 8 xs ! ] :# ys 4 [ d# 4 ys ! ]
: com. ( i ) hex [ xy ] @ push .drs .pins pop [ xy ] ! cr/2 -sp/2 silver
 ( i ) .focus white adr. cr/2 ?brk { cr }
 -sp/2 ?white sl. ?green op. cr/2 { indent }
      ?white ir. cr/2 { indent }
      ?green cnt. sp/2 ?white pc. cr/2 { indent }
      ?white ar. cr/2 { cr }
 ( -sp/2 ?cyan ?blue rqs. ) space ?white br. { cr }
 cr/2 ?cyan ioc. cr/2 ?red rr. cr/2 { cr }
 ?green tr. cr/2 sr. ;
: ?com ( i ) dup !inode vis @ dup and { indent }
      if [ h# 00010000 ] /mod tab/2 com. ; { indent }
      then drop drop ;
: coms. nnx [ xs ] @ negate + [ xo ] @ [ yo ] @ [ nnx ] * + { cr }
 [ ys ] @ for [ xs ] @ for dup ?com d# 1 + next { cr }
 over + next drop drop ;
: out? ( i-xy ) [ nnx ] /mod [ xo ] @ [ yo ] @ v- { indent }
      over over +or push over over { indent }
      [ xs ] @ [ ys ] @ v- and - pop +or drop ;
: loc ( i-l ) dup !inode out? -if drop drop d# 0 ; { cr }
 then push ( x ) [ d# 7 ] * [ d# 1 ] + { indent }
      pop ( y ) - [ ys ] @ + { 0000016F } [ d# 12 ] * ( hv ) [ d# 16 ]
 2*s + ;
: !vis [ comb ] @ [ nns d# -1 + ] { indent }
      for i loc vis ! -next [ comb ] ! ; }block

( 00342400 )               D# 1289 shadow{ 
 ( softsim display small nodes ) }block

( 00342800 )               D# 1290 code{ 
 ( softsim display map and screen ) { cr }
 :# gap 1 :# wind? -1 :# time 0
: xm ( -n ) nnx [ xs ] @ negate + ;
: ym ( -n ) nny [ ys ] @ negate + ;
: .vis ( hv ) 2/ [ yo ] @ - ym + [ d# 2 ] + + [ d# 30 ] * push { indent }
      2/ [ xo ] @ + [ d# 22 ] * pop over over at { indent }
      [ xs ] @ [ d# 22 ] * [ ys ] @ [ d# 30 ] * v+ blue box ;
: .node ( n ) nn-n dup !inode ?green d# 48 emit { indent }
      me? h# FFEA0000 [ xy ] +! d# 21 emit ;
: .line ( n ) cr d# 17 for dup .node d# 1 + -next drop ;
: .map ( hv ) over over .vis tab/2 { indent }
      d# 7 for i [ nnxmod ] * .line -next ;
: .wind ( hv ) [ wind? ] @ dup and drop if .map ; { indent }
      then d# 1 d# 1 v+ [ nod2 ] @ .big ;
: bg h# 001F1F1F color { indent }
      d# 25 for d# 46 for d# 48 emit next cr next ;
: .so ( bg ) [ comb ] @ coms. { indent }
      d# 56 d# 0 .wind d# 57 d# 22 [ nod ] @ .big cr/2 { indent }
      white [ time ] @ . cr [ gap ] @ . [ comb ] ! ;
: ok !vis show black screen text .so keyboard ; }block

( 00342C00 )               D# 1291 shadow{ 
 ( softsim display map and screen ) }block

( 00343000 )               D# 1292 code{ 
 ( softsim keyboard handler )
: wtog [ wind? ] @ d# -1 or [ wind? ] ! ;
: we d# 1 { -cr } : dx ( n ) [ xo ] swap over @ + xm
: dw ( ann ) min d# 0 max swap ! !vis ;
: ww d# -1 dx ;
: wn d# 1 { -cr } : dy ( n ) [ yo ] swap over @ + ym dw ;
: ws d# -1 dy ;
: wy+ [ ys ] @ d# 1 + d# 4 min [ ys ] ! d# 0 dy ;
: wy- [ ys ] @ d# -1 + d# 1 max [ ys ] ! d# 0 dy ;
: wx+ [ xs ] @ d# 1 + d# 8 min [ xs ] ! d# 0 dx ;
: wx- [ xs ] @ d# -1 + d# 1 max [ xs ] ! d# 0 dx ;
: ftog [ nod2 ] @ [ nod ] @ [ nod2 ] ! { indent }
      [ nmem ] @ [ n2mem ] @ [ nmem ] ! [ n2mem ] !
: nod! ( n ) dup !inode [ nod ] ! mem @ [ nmem ] ! ;
: fw d# -1
: +nod [ nod ] @ + [ d# 0 ] max [ nns d# -1 + ] min nod! ;
: fn [ nnx ] nop
: ++nod [ nod ] @ over +nod swap over + { indent }
      [ nod ] @ or drop if nod! ; then drop ;
: fs [ nnx negate ] ++nod ; { -cr } : fe d# 1 +nod ;
: mh [ d# 16 d# 64 + ] nop
: mhl [ comb ] @ swap [ nod ] @ !inode { cr }
 mem @ + [ h# 000000BF ] and dup [ nmem ] ! mem ! [ comb ] ! ;
: ml [ d# -16 ] mhl ; }block

( 00343400 )               D# 1293 shadow{ 
 ( softsim keyboard handler ) }block

( 00343800 )               D# 1294 code{ 
 ( softsim keyboard handler )
: gtog [ big ] @ d# 1 or [ gap ] @ or [ gap ] ! ;
: +gap d# 1 { -cr } : +g [ big ] @ + d# 2 max dup [ big ] ! [ gap ]
 ! ;
: ++gap d# 100 +g ; { -cr } : --gap d# -100 +g ; { -cr } : -gap d# -1
 +g ; { br }

: brk? [ bail ] @ dup and drop ;
: break ( san ) bp @ bp' ! !node 2* 2* or bp ! ;
: btog ( n ) !node bp @ bp' @ bp ! bp' ! ;
: restart d# 0 [ time ] ! [ comb ] @ power nm2m [ comb ] ! ;
: step d# 1 [ time ] +! [ comb ] @ toks tiks [ comb ] ! ;
: quick [ gap ] @ { -cr } : steps ( n ) d# 0 [ bail ] ! for { indent }
      step brk? if pop drop ; then next ;
: upto ( n ) [ time ] @ negate + d# 0 max steps ;
: go quick pause brk? if ; then key? go ; { br }

: h pad ( -n.alt ) nul nul accept nul ( ur ) ww wn ws we ( mr ) fw
 fn fs fe ( lr ) ftog mh ml wtog { cr }
 ( ul ) wy+ wx+ --gap ++gap { cr }
 ( ml ) restart gtog go quick ( ll ) wy- wx- -gap +gap ( n.alt ) [
 h# 00002500 , ] ( ur ) [ h# 0110160C , h# 0110160C , H# 0F0C1403 , ]
 ( ul ) [ H# 2B230F02 , H# 080D0E12 , H# 2B230608 , ] }block

( 00343C00 )               D# 1295 shadow{ 
 ( softsim keyboard handler ) { br }

: h ( keyboard handler ) { indent }
      [ ++ ] ( fastest faster ) { indent }
      [ fgs ] ( fast go step ) { indent }
      [ -- ] ( slowest slower ) { cr indent }
      [ ludr ] ( left up down right ) [ window ] { indent }
      [ ludr ] ( left up down right ) [ focus ] { indent }
      [ oudw ] ( other up down window ) [ memory dump ] { cr indent }
      [ . ] ( quit ) { br }

 [ note/ ] pad ( other-keys del-key space-bar alt-key ) [ also, 1st
 chars are ] ( del-key space-bar alt-key ) [ right-to-left ] }block

( 00344000 )               D# 1296 code{ 
 ( softsim connect node ports ) :# edge 0 [ d# 0 edge ! ]
: !dests ( onn-on ) !inode over dbus + push { indent }
      dup !inode over dbus + pop { indent }
      ( onaa ) over over h# 0000000F or ! swap h# 0000000F or ! ;
: row ( on-o ) [ nnx ] for dup [ nnx ] + !dests d# 1 + { indent }
      next drop ;
: rows ( non ) for over row [ nnx d# 2 * ] u+ { indent }
      next drop drop ;
: col ( on-o ) [ nny ] for dup d# 1 + !dests [ nnx ] + { indent }
      next drop ;
: cols ( non ) for over col d# 2 u+ next drop drop ; { br }

 [ dbus negate ]
: rights d# 0 [ dup rport + ] nop [ nnx 2/ ] cols ;
: lefts d# 1 [ dup lport + ] nop [ nnx 2/ d# -1 + ] cols ;
: downs d# 0 [ dup dport + ] nop [ nny 2/ ] rows ;
: ups nnx [ uport + ] nop [ nny 2/ d# -1 + ] rows ;
: edges [ nns d# -1 + ] for i !inode { indent }
      d# 0 pins ! [ ' nul ] softbed ! { indent }
      [ edge ] dup ldest ! udest ! -next ;
: connect edges rights lefts ups downs ; { cr }
 [ connect ] }block

( 00344400 )               D# 1297 shadow{ 
 ( softsim connect node ports ) { br }

 [ edge ] ( is the dummy destination for unassigned ) { cr }
 ( left and up ports )
: !dests ( using a port index /1,2,4,8/ and two ) { cr }
 ( nodes, node numbers, stores both port ) { cr }
 ( addresses in the other's *dest variable )
: row { -cr } : rows { -cr } : col { -cr } : cols ( calc neighbors
 and assign *dest )
: rights { -cr } : downs { -cr } : lefts { -cr } : ups
: edges
: connect }block

( 00344800 )               D# 1298 code{ 
 ( softsim assign node pins and wake-up )
: !l ( nn ) swap !node pins ! bus ldest ! ;
: !u ( nn ) swap !node pins ! bus udest ! ;
: l1, ( n ) d# 1 !l ; { -cr } : u1, ( n ) d# 1 !u ;
: l2, ( n ) d# 2 !l ; { -cr } : u2, ( n ) d# 2 !u ;
: u4, ( n ) d# 3 !u ; { -cr } : u18, ( nm ) swap d# 4 !u pwv ! ;
: us, ( n ) d# 5 !u ( dummy ) ;
: !an ( nn ) !node ios swap !node pwv ! d# 6 pins ! ;
: la, ( nn ) !an bus ldest ! ;
: ua, ( nn ) !an bus udest ! ; { br }

 ( assign pins ) { cr }
 ( single ) [ d# 100 l1, d# 317 l1, d# 417 l1, d# 500 l1, d# 600 l1,
 d# 217 l1, d# 517 l1, d# 715 u1, ] { cr }
 ( serdes ) [ d# 1 us, d# 701 us, ] ( spi ) [ d# 705 u4, ] { cr }
 ( async ) [ d# 708 u2, ] ( 1wire ) [ d# 200 l1, ] ( sync ) [ d# 300
 l2, ] { cr }
 ( parallel ) [ d# 7 h# 00000200 u18, d# 8 u4, d# 9 h# 00000080 u18, ]
 { cr }
 ( analog ) [ d# 117 d# 217 la, d# 617 d# 517 la, d# 709 d# 715 ua, ]
 { cr }
 [ d# 713 d# 715 ua, d# 717 d# 715 ua, ] }block

( 00344C00 )               D# 1299 shadow{ 
 ( softsim assign node pins and wake-up ) }block

( 00345000 )               D# 1300 code{ 
 unused [ see d# 150 ] ( test code for chip ) [ reclaim ] { br }

 ( ide parts ) [ d# 1372 d# 5 loads reclaim ] { br }

 ( custom code ) [ d# 1302 load ] ( exit ) { br }

 ( polyforth ) [ d# 730 load ] { cr }
 ( smtm test ) [ d# 0 node d# 1342 load exit ] { br }

 ( */ exerciser ) [ d# 402 node d# 1354 load ] { indent }
      [ d# 401 node d# 1356 load d# 400 node d# 1358 load ] { cr }
 ( serdes ) [ d# 1 node d# 1360 load d# 701 node d# 1362 load ] { cr }
 ( spi flash write ) [ d# 702 node d# 1364 load ] { cr }
 ( ana ) [ d# 715 node d# 1366 load d# 717 node d# 1368 load ] { cr }
 }block

( 00345400 )               D# 1301 shadow{ 
 ( this block is loaded to compile test code for any desired nodes.
 write *nnn node* either here before loading a node's source, or in
 the source itself. the *node* phrase compiles the appropriate rom
 for the given node so that test code may reference the rom. ) { br }

 ( things like ide and common tests are loaded here, and this base
 code is presently assigned up at the top of this area just below 1380.
 to simplify base maintenance, please use { 0000A2CF } for your own
 testing and load it from here. when we begin using personal space
 above { 0000B40F } your own tests can go there. ) }block

( 00345800 )               D# 1302 code{ 
 unused ( custom test code exit ) { br }

 ( read/write { 0000024F } bit flash ) { indent }
      [ d# 705 node d# 1364 load d# 1609 bin ] { indent }
      [ d# 706 node d# 1216 load d# 1610 bin ] { cr }
 ( read/write { 0000010F } bit flash ) { indent }
      [ d# 705 node d# 1370 load d# 1611 bin ] { cr }
 ( read image from flash to sram ) { cr }
 [ host ]
: sram ( -n ) d# 4095 lit ;
: resume ( -n adjusted ) [ d# 656 d# 18 d# 8 */ d# 4 * ] lit ; { cr }
 [ target ] { indent }
      [ d# 705 node d# 292 load d# 1612 bin ] { cr }
 ( spi speedup ) { indent }
      [ d# 705 node d# 284 load d# 1608 bin ] }block

( 00345C00 )               D# 1303 shadow{ 
 ( this load block, and the following { 0000032F } source/shadow pairs,
 are yours to do with as you please! ) }block

( 00346000 )               D# 1304 code{ 
 ( eforth rom code ) { br }

 ( sdram addr ) [ d# 9 node d# 1320 load ] { indent }
      ( ctrl ) [ d# 8 node d# 1322 load ] ( ram ) { indent }
      ( data ) [ d# 7 node d# 1324 load ] { indent }
      ( idle ) [ d# 108 node d# 1326 load ] { indent }
      ( user ) [ d# 107 node d# 1328 load ] { br }

 ( eforth stack ) [ d# 106 node d# 1310 d# 2 loads ] { indent }
      ( bitsy ) [ d# 105 node d# 1306 d# 2 loads ] { br }

 }block

( 00346400 )               D# 1305 shadow{ 
 ( load block for rom resident sdram and eforth in the ga144. loaded
 by { 0000758F } even for tapeout. ) }block

( 00346800 )               D# 1306 code{ 
 ( e4 bitsy 1of2 ) { cr }
 [ h# 000000AA org ]
: rp-- ( a-a' ) { 0000155D } d# -1 . + ;
: bs@ { -cr } : 'else ( a-w ) { 0000159D } { indent }
      @p+ !b !b . ( ' ) @p+ x@ ( ' ) { indent }
      @p+ !b @b ; ( ' ) . . . !p+ ( ' )
: rp@ ( ri-ri ) { 0000161D } over rp--
: pshbs ( w- ) { 0000163D } @p+ !b !b ; ( ' ) @p+ pshw ( ' )
: 'r@ ( ri-ri ) { 0000167D } over rp--
: @w ( a- ) { 0000169D } bs@ pshbs ;
: rfrom ( ri-r'i ) { 000016DD } over rp-- over over @w ;
: popbs ( -w ) { 0000173D } @p+ !b @b ; ( ' ) !p+ pops ( ' )
: pshr ( aw-a ) { 0000177D } { indent }
      @p+ !b !b dup ( ' ) @p+ . . @p+ ( ' ) { indent }
      !b @p+ !b . ( ' ) x! ( ' )
: rp++ { -cr } : ip++ ( a-a' ) { 000017FD } d# 1 . + ;
: tor ( ri-r'i ) { 0000183D } push popbs pshr pop ;
: rp! ( i-ri ) { 0000189D } push popbs rp++ pop ; { br }

: 'con ( ra-r'i ) { 000018FD } bs@
: 'var ( ra-r'i ) { 0000191D } dup pshbs
: 'exit ( rx-r'i ) { 0000193D } drop rp-- dup bs@ ; }block

( 00346C00 )               D# 1307 shadow{ 
 ( e4 bitsy shadow 1of2 )
: rp-- ( internal )
: x@ ( internal ) { -cr } : 'else ( eforth microcode )
: rp@ ( eforth microcode )
: pshw ( internal )
: 'r@ ( eforth microcode )
: @w ( internal )
: rfrom ( eforth microcode )
: popw ( internal )
: pshr ( internal )
: rp++ ( internal ) { -cr } : ip++ ( internal )
: tor ( eforth microcode )
: rp! ( internal )
: 'con ( eforth microcode )
: 'var ( eforth microcode )
: 'exit ( eforth microcode ) }block

( 00347000 )               D# 1308 code{ 
 ( e4 bitsy 2of2 ) { br }

 { 0000197D } begin dup 2* -if { indent }
      ( code.s-xt ) drop !b ahead [ swap ] then { indent }
      ( code.r-xt ) drop push ;' { cr }
: bitsy { 000019DD } then dup bs@ push ip++
: xxt { 00001A1D } pop -until { indent }
      ( list-xt ) push pshr pop bitsy ; { br }

 ( execute )
: 'ex { 00001A7D } ( xt-- ) popbs push xxt ;
: 'lit { 00001ABD } ( --w ) dup bs@ push ip++ pop pshbs ;
: 'if { 00001B1D } ( f-- ) popbs if { indent }
      drop ip++ ; then drop 'else ; { br }

 { 00001B9D } [ exit ] ( start is run in ide )
: start right a! ( terminal ) left b! ( stack ) { indent }
      d# -32 d# 0 ( rp.ip ) bitsy ; }block

( 00347400 )               D# 1309 shadow{ 
 ( e4 bitsy 2of2 shadow )
: 'con ( runtime constant )
: 'var ( runtime variable )
: 'exit ( runtime end call ) { br }

: btc ( label e4 interpreter ) { cr }
 ( bitsy main interpreter entry )
: xxt ( internal ) { br }

: 'ex ( runtime execute )
: 'lit ( runtime literal )
: 'if ( runtime conditional branch ) { cr }
: @io ( return the serial bit delay )
: !io ( init serial 0-autobps n-fixedbps )
: t!io ( internal )
: tx! ( transmit one character )
: ttx! ( internal )
: trx? ( internal )
: rx? ( test recieved char - 0 if no char else 18bit inverted char )
 }block

( 00347800 )               D# 1310 code{ 
 ( e4 stack 1of2 ) { cr }
 [ h# 0000003C org ]
: xa@ ( a- ) { 0000079D } @p+ !b !b ; ( ' ) @p+ sd@ ( ' )
: xa! ( a- ) { 000007DD } @p+ !b !b ; ( ' ) @p+ sd! ( ' ) { cr }
 { 0000081D } [ h# 000000AA org ]
: 'c@ { -cr } : '@ { -cr } : x@ ( a-w ) { 0000155D } xa@ @b ;
: sp++ { -cr } : char+ { -cr } : cell+
: 1+ ( w-w' ) { 0000159D } d# 1 . + ;
: popt ( p-xp't ) { 000015DD } dup sp++ over x@ ;
: sp-- { -cr } : char- { -cr } : cell-
: 1- ( w-w' ) { 0000161D } d# -1 . + ;
: psht ( pt-p' ) { 0000165D } push sp-- pop over
: x! ( wa- ) { 0000169D } xa! !b ;
: 'c! { -cr } : '! ( pwa-p'st ) { 000016DD } x!
: popts ( p-p'st ) { 000016FD } popt
: pops ( pt-p'st ) { 0000171D } push popt pop ;
: pshs ( pst-p't ) { 0000175D } push psht pop ;
: page@ ( pst-p'tw ) { 0000179D } @p+ !b @b . ( ' ) dup !p+ ; ( ' )
: pshw ( pstw-p'tw ) { 000017DD } push pshs pop ;
: page! ( ptw-p'st ) { 0000181D } @p+ !b !b . ( ' ) drop @p+ ; ( ' )
 pops ;
: sp@ { 0000187D } ( -a ) pshs psht dup pops ;
: sp! { 000018DD } ( a- ) pshs popts ; }block

( 00347C00 )               D# 1311 shadow{ 
 ( e4 stack 1of2 shadow )
: 'c@ ( runtime c@ )
: '@ ( runtime @ )
: x@ ( inline external ram )
: sp++ ( increment data stack pointer )
: char+ ( increment address by char size )
: cell+ ( increment address by cell size )
: 1+ ( increment by one )
: popt ( internal )
: sp-- ( decrement data stack pointer )
: char- ( decrement address by char size )
: cell- ( decrement address by cell size )
: 1- ( decrement by one )
: psht ( internal )
: x!
: 'c! ( runtime c! )
: '! ( runtime ! )
: popts ( internal )
: pops ( internal )
: pshs ( internal )
: page@ ( inline external ram )
: pshw ( inline external ram )
: page! ( inline external ram ) }block

( 00348000 )               D# 1312 code{ 
 ( e4 stack 2of2 )
: 'drop { 0000191D } ( w- ) drop pops ;
: 'over { 0000193D } ( ww-www ) over pshw ;
: 'dup { 0000195D } ( w-ww ) dup pshw ;
: 'swap { 0000197D } ( ab-ba ) over push push drop pop pop ;
: '2/ { 000019BD } ( w-w ) 2/ ; { -cr } : '2* { 000019DD } ( w-w )
 2* ;
: um+ { 000019FD } ( uu-uc ) over or -if { indent }
      { 00001A1D } over or . + -if
: 'nc { 00001A5D } ( -0 ) dup dup or ;
: 'cy { 00001A7D } ( -1 ) then d# 1 ; { indent }
      { 00001ABD } then over or -if + 'cy ; then + 'nc ;
: zless { 00001B1D } ( n-f ) -if dup or - ; then dup or ;
: 'or { 00001B7D } ( ww-w ) over - and
: 'xor { 00001B9D } ( ww-w ) or pops ;
: 'and { 00001BBD } ( ww-w ) and pops ;
: negate { 00001BDD } ( w-w ) 1-
: invert ( w-w' ) { 00001BFD } begin ( . ) - ;
: zeq ( w-f ) { 00001C1D } until dup or ;
: '+ ( pww-p'sw' ) { 00001C5D } + pops ; { 00001C7D } ( exit )
: swap- { 00001C7D } ( ww-w ) - . + - pops ; { 00001CBD } { br }

 { 00001CBD } [ exit ] ( start is run in ide )
: start right b! ( sdram ) { cr }
 d# 0 dup dup ( sp.s.t ) --l- ; ( bitsy ) }block

( 00348400 )               D# 1313 shadow{ 
 ( e4 stack 2of2 shadow )
: pshw ( internal )
: sp@ ( get data stack pointer )
: sp! ( set data stack pointer )
: 'drop ( runtime drop )
: 'over ( runtime over )
: 'dup ( runtime dup )
: 'swap ( runtime swap )
: zless ( runtime zero less )
: um+ ( add with carry )
: 'nc ( no carry is 0 )
: 'cy ( carry set is 1 )
: 'xor ( runtime exclusive or )
: 'and ( runtime and )
: 'or ( runtime inclusive or )
: negate ( runtime negate )
: invert ( runtime invert )
: zeq ( runtime zero equals )
: '+ ( runtime + )
: '2/ ( runtime 2/ )
: '2* ( runtime 2* ) }block

( 00348800 )               D# 1314 code{ 
 ( e4th bitsy ) { br }

: @io { 0000063D } ( --u ) @p+ ! @ . ( ' ) push t'@io ( ' ) pshw ;
 { cr }
 ( init io device 0-autobps n-fixedbps )
: !io { 0000069D } ( u-- ) popw
: t!io { 000006BD } ( u- ) @p+ ! ! ; ( ' ) @p+ t'!io ; ( ' )
: tx! { 000006FD } ( c-- ) popw
: ttx! { 0000071D } ( c- ) @p+ ! ! ; ( ' ) @p+ - ; ( ' )
: trx? { 0000075D } ( -c'0 ) @p+ ! @ ; ( ' ) !p+ t'rx? ; ( ' )
: rx? { 0000079D } ( --c'0 ) trx? pshw ; }block

( 00348C00 )               D# 1315 shadow{ 
 }block

( 00349000 )               D# 1316 code{ 
 ( e4 terminal 1of2 - serial i/o ) { br }

: getchar { 0000001D } ( delay in'0 f - delay -char f ) push over 2/
 for . unext .. ( middle of start-bit ) { cr }
 d# 7 for ( 8-data bits ) { indent }
      over for . unext .. { indent }
      h# 0001FFFF @b ( middle +/- ) { indent }
      over - and push and pop or { cr }
 2/ next { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .. h# 000000FF and - dup { cr }
 begin drop @b -until drop pop ; { br }

: putchar { 0000027D } ( delay in'0 c - delay in'0 ) { cr }
 push over pop { cr }
 2* h# 0003FE00 dup push - and pop or { cr }
 d# 10 for ( 1-start, 8-data, 2-stop bits ) { indent }
      d# 2 over over 2/ and or !b { indent }
      over for . unext .. { cr }
 2/ next drop drop ; { 0000043D } }block

( 00349400 )               D# 1317 shadow{ 
 ( note. both tx and rx are completely in stock rs232 polarity, i.e.
 mark lo space hi, data low start low. ultimately we need to invert
 the whole thing for compatibility with s40 boot node conventions but
 for testing purposes we will leave it as is and invert the rs232 board. )
 { br }

: getchar ( called after seeing leading edge of start bit. returns
 clean inverted character. ) { br }

: putchar ( takes a dirty octet of data and transmits it as startbit,
 eight data bits no parity one stop bit. ) }block

( 00349800 )               D# 1318 code{ 
 ( e4 terminal 2of2 - bitsy commands ) { br }

: baud { 0000043D } ( 0-d ) - push ( space is 0'0000.0100'1 ) { cr }
 { 0000045D } begin @b - -until ( at start-bit ) { cr }
 { 0000047D } begin @b -until ( at 1-bit ) { cr }
 { 0000049D } begin @b zif then - . -until ( at 0-bits ) { cr }
 { 000004DD } begin @b zif then . -until ( at stop-bit ) { cr }
 pop - ( n ) dup 2/ . + ( 1.5n ) ; { br }

: @io { 0000055D } ( delay - delay in'0 0 ) { indent }
      pop a! push dup or baud ! { indent }
      pop pop dup dup or ; { indent }
      begin baud
: !io { 000005FD } ( delay in'0 u - delay 0 0 ) { indent }
      until ( abandon old values )
: rx? { 0000061D } ( delay - delay 0 0 ) d# 0 dup ; { br }

: terminal { 0000065D } ( delay in'0 x ) { cr }
 begin drop @b - -if getchar then { indent }
      - 2* 2* -if drop .. r--- ( bitsy ) then { cr }
 -until ( delay in'0 -c ) - putchar dup terminal ; { 0000079D } }block

( 00349C00 )               D# 1319 shadow{ 
: @io ( return the serial bit delay ) { br }

: !io ( sets nonzero baud rate delay over garbage. if zero, waits for
 a space character to autobaud with. ) { br }

: rx? ( test for received char ) { br }

: tx! ( send one character ) { br }

: terminal ( polling loop for character receive or send ) }block

( 0034A000 )               D# 1320 code{ 
 ( sdram address-bus ) { cr }
 ( copy command to address bus ) { br }

 [ h# 000000AA org ]
: cmd ( c- ) { 0000155D } h# 0003D555 ( nop.xxx ) !b .. { indent }
      @ ( sleeps ) !b cmd ; { br }

 { 000015BD } [ exit ] ( start is run in ide )
: start right a! data b! cmd ; }block

( 0034A400 )               D# 1321 shadow{ 
 }block

( 0034A800 )               D# 1322 code{ 
 ( sdram control-pins ) { cr }
 ( each word runs the requested rise..fall cycle 12+11 ticks per cycle
 is a 42ns period ) { cr }
 [ h# 00000000 org ]
: nooop ( rfr-rfr ) { 0000001D } ( 'nooop' ) . .. !b { indent }
      .. over over .. . . !b ;
: rcol1 ( rf-rfrf ) { 0000009D } . . !b { indent }
      .. h# 0000002B .. !b ( transfer ) { indent }
      . h# 0000022E .. . . !b ; { cr }
 { 0000015D } [ h# 00000010 org ] ( 8-word page accessible to down
 port )
: cmmd ( rfr-rfr ) { 0000021D } ( '@p+ ! cmmd' ) !b { indent }
      .. over over .. . . !b ;
: rcol ( rfr-rfr ) { 0000027D } ( '@p+ ! rcol' ) !b { indent }
      over over .. rcol1 ;
: wcol ( rfr-rfr ) { 000002BD } ( '@p+ ! wcol' ) !b { indent }
      h# 0002003E h# 0002002E .. !b { indent }
      .. h# 0003022B .. !b ( transfer ) { indent }
      h# 0003023B !b .. . . !b { indent }
      h# 0002002E .. !b h# 0000002B !b ( recover ) { indent }
      .. over over .. . . !b ; { br }

 { 0000047D } [ exit ] ( start is run in ide )
: start right a! io b! h# 0000002E ( cmd-fall ) -d-- ; }block

( 0034AC00 )               D# 1323 shadow{ 
 }block

( 0034B000 )               D# 1324 code{ 
 ( sdram data-bus ) { br }

 ( db@ isn't used with 7j chip! ) { cr }
 [ h# 000000AA org ] ( called with 'db@' '...!p+' )
: db@ ( -w ) { 0000155D } @ ; ( wakeup when data ready ) { br }

 ( db! called with '@p+ db!' )
: db! ( w- ) { 0000157D } h# 00015555 !b ( .. set output state ) { indent }
      ! ( wakeup when data taken )
: inpt { 000015BD } h# 00014555 !b ; ( restore input state ) { br }

 { 000015FD } [ exit ] ( start is run in ide )
: start up a! io b! down push inpt ; }block

( 0034B400 )               D# 1325 shadow{ 
 }block

( 0034B800 )               D# 1326 code{ 
 ( sdram idle-loop ) { cr }
 [ h# 000000AA org ]
: noop ( - ) { 0000155D } @p+ ! ; ( ' ) nooop ( ' )
: cmd ( c- ) { 0000159D } h# 00005A48 ! ! ; ( '@p+ ! cmmd' ) { cr }
: idle ( m-m ) { 000015DD } @p+ ! .. ( ' ) nooop ( ' ) h# 00008003
 cmd noop d# 120 for ( 7.8us 42ns/ 5- is 181 ) { indent }
      @p+ ! .. ( ' ) nooop ( ' ) { indent }
      begin { 000016FD } @b and if { indent }
      ( ... ) @ .. @ ! ! ( user to ctrl ) { indent }
      ( ... ) *next idle ; { 0000179D } { indent }
      then drop { cr }
 next @p+ ! .. ( ' ) nooop ( ' ) idle ; { cr }
: init ( m-m ) { 0000181D } ( run only at power-up/reset ) { indent }
      d# 4761 for ( 200us 42ns/ 1- ) noop next { indent }
      noop h# 00010400 ( pre.all ) cmd noop { indent }
      h# 00008001 ( rfr.123 ) cmd noop noop { indent }
      h# 00008002 ( rfr.123 ) cmd noop noop { indent }
      h# 00000021 ( std.mode ) cmd noop noop { indent }
      h# 00004000 ( ext.mode ) cmd noop idle ; { br }

 { 00001B1D } [ exit ] ( start is run in ide )
: start h# 00000135 ( '-dl- ) a! io b! { cr }
 h# 00000800 ( n13w? ) dup dup dup dup dup dup { cr }
 dup dup dup init ; }block

( 0034BC00 )               D# 1327 shadow{ 
 }block

( 0034C000 )               D# 1328 code{ 
 ( sdram user interface ) { cr }
 [ h# 000000AA org ] ( user cmds+data from/to up or right )
: a2rc ( pa-pbc ) { 0000155D } dup ( 2* 16mw ) push 2/ ( 32mw ) { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ -if
: row! ( pr-pbc ) { 000015FD } h# 00007FFF ( row.mask ) and dup ..
 { cr }
 h# 00018000 ( activate ) or .. ! h# 00005A48 ! .. ( '@p+ ! cmmd' )
 h# 00006000 ( bank.mask ) and pop .. h# 000003FF ( col.mask ) and
 ; then over + row! ;
: sd@ ( pa-p ) { 0000177D } a2rc h# 00028400 ( read+pre ) or or { cr }
 ! h# 00005A4B ! .. ( '@p+ ! rcol' ) down b! .. { cr }
 @p+ !b @b ( ' ) @ !p+ .. ( ' ) pop b! !b ;
: sd! ( pa-p ) { 000018BD } a2rc h# 00020400 ( write+pre ) or or { cr }
 ! h# 00005A4D ! .. ( '@p+ ! wcol' ) pop b! @b .. { cr }
 down b! .. @p+ !b !b ; ( ' ) @p+ db! ( ' )
: poll ( ru-ru ) { 000019FD } io b! @b { cr }
 2* 2* -if push over .. r--- over pop then { cr }
 h# 00000800 and . if push .. ---u pop then { cr }
 drop poll ; { br }

 { 00001B9D } [ exit ] ( start is run in ide )
: start left ! d# 0 d# 0 ( r.u ) poll ; }block

( 0034C400 )               D# 1329 shadow{ 
 ( configure for sdram wiring as follows ) { cr }
 2* ( 16mw ) push ( 2/ 32mw ) [ for d# 16 mw wiring ] { cr }
 ( 2* 16mw push ) 2/ ( 32mw ) [ for 32. ] }block

( 0034C800 )               D# 1330 code{ 
 ( async ats interface ) [ d# 0 org ]
: obit ( dwn-dw ) { 0000001D } !b over push delay ;
: word ( dw-d ) { 0000005D } leap drop leap drop leap drop drop ;
: obyt ( dw-dwx ) { 000000DD } then then then d# 3 obit drop d# 7 for
 dup d# 1 and d# 3 or obit drop 2/ next d# 2 obit ;
: -out { 0000023D } ser-exec ( rdl- ) ; { 0000025D } { br }

: ok { 0000025D } h# 00031416 word -out ;
: fet { 000002BD } d# 0
: pump ( n ) for @+ word next -out ;
: stat { 0000037D } d# 9 pump ;
: bstk { 000003BD } @ push .. @ word pop dup push word .. ( @p+.push )
 h# 000049BA ! d# 7 .. dup push ! .. @p+ ! .. ( /+ ) begin !p+ . .
 unext .. begin @ word .. next .. @p+ ! pop .. ( /+ ) pop @p+ ; ..
 ! -out ; { 0000059D } }block

( 0034CC00 )               D# 1331 shadow{ 
 ( this code is loaded on top of ide boot node. )
: obit ( sends one bit 0-3/hi 1-2/low )
: word ( sends a word as { 0000006F } octets. )
: obyt ( sends and discards { 0000010F } lsb of w, lsb first, with
 one start bit hi and one stop bit low. ) }block

( 0034D000 )               D# 1332 code{ 
 }block

( 0034D400 )               D# 1333 shadow{ 
 }block

( 0034D800 )               D# 1334 code{ 
 }block

( 0034DC00 )               D# 1335 shadow{ 
 }block

( 0034E000 )               D# 1336 code{ 
 }block

( 0034E400 )               D# 1337 shadow{ 
 }block

( 0034E800 )               D# 1338 code{ 
 }block

( 0034EC00 )               D# 1339 shadow{ 
 }block

( 0034F000 )               D# 1340 code{ 
 }block

( 0034F400 )               D# 1341 shadow{ 
 }block

( 0034F800 )               D# 1342 code{ 
 ( smtm test ) [ h# 00000032 org ]
: go a! h# 0001557F !b h# 0001556A !b . pop @p+ { indent }
      ( ' ) @p+ dup 2/ . ( ' ) a ! ! h# 00000043 for { indent }
      h# 0000003F !+ . unext { indent }
      ( ' ) 2* a! push . ( ' ' ) begin @p+ !+ . unext ( ' ) { indent }
      ( ' ) @p+ push ; ( ' ) ! warm ; { cr { 0000025F } }
 [ h# 0000002A org ]
: r @p+ go ; r---
: d @p+ go ; -d--
: l @p+ go ; --l-
: u @p+ go ; ---u { cr }
 [ d# 0 org ] ( avoid node1 ) d r l
: path r l r l d l r l r d path ; }block

( 0034FC00 )               D# 1343 shadow{ 
 ( smtm test ) { br }

 ( steven's crawling memory tester ) }block

( 00350000 )               D# 1344 code{ 
 { 000001CF } ( word ga144 creeper test frame 3/25/11 ) { cr }
 ( see db007 for detailed discussion. ) { br }

 [ h# 00000036 org ]
: focus { 000006DD } ( jport ) dup dup a! dup ! @p ! dup { cr }
 ( ' ) @p b! . ! or !b ;
: creep { 0000075D { 0000086F } } dup !b push { cr }
 begin @p ! unext . { 0000079D } { cr }
 ( ' ) h# 0000003F push dup ( ' ) or a! { cr }
 ( ' ) begin @b !+ unext { 0000081D } { cr }
: wire begin @b ! @b ! @
: rip { 0000085D } dup !b -until { 0000087D } warm ; { cr }
 { 0000089D } [ d# 4 org ]
: test { 0000009D } ( n1 ) }block

( 00350400 )               D# 1345 shadow{ 
 ( creeper input side data flow iio ) { cr }
 ( @p call to focus, creep, wire, rip, or ) { cr }
 ( anywhere in the test package from { 0000009F } to { 000006BF } )
 { cr }
 ( with any n1 on the stack ) { br }

: focus ( prepares to use neighbor thru ) [ jport ] ( sets a forward
 and neighbor pc and b back. result is zero. )
: creep [ d# 67 ] ( returned as early sync. crawl to focused node,
 make it active, we become wire. copies { 0000088F } words to neighbor )
 { cr }
 ( fallthrough after copy to wire must be at ) { 0000081D }
: wire ( passes iio messages until result negative at which time this
 node and all before it return to warm. )
: rip ( argument and result must be negative to restore all nodes to
 warm state. )
: test ( can call any address from { 0000009F } to { 000006BF } and
 can do what it wants with ) [ n1. ] ( result must be positive, { 0000000F }
 normally means ok. ) }block

( 00350800 )               D# 1346 code{ 
 ( fill neighbor's memory fake test ) { cr }
 ( creeper ) [ d# 1344 load ]
: ping { 000008BD } @p ! ! . ( ' @p ) @b 2/ ( !p ) !b . { cr }
 @ !b ; { 0000091D } [ exit ]
: why d# -1 . + down a! ! ; [ exit ]
: nulltest { 000008BD } d# 1 . + !b ; { 0000091D } [ exit ]
: test { EC00000D } ( n1 ) d# 63 @p ! . ( ' ) dup or a! @p { cr }
 ! @p ! @p ( ' ) push ( ' ) begin a !+ unext . { cr }
 ! dup dup or !b drop ; { CE00000D } }block

( 00350C00 )               D# 1347 shadow{ 
 }block

( 00351000 )               D# 1348 code{ 
 ( extensive neighbor's memory test 005-035 ) { cr }
 [ h# 00000029 org ] { -cr } : err [ h# 00000005 org ]
: test ( n1 ) @p ! @p dup ( ' ) h# 0000003F push dup dup { cr }
 ! @p ! ( ' ) or dup a! . { cr }
 @p ! ( ' ) begin dup !+ unext . ( erased ) { cr }
 for { cr cr }
 h# 00019999 @p ! dup ( ' ) @p ! @ . { cr }
 ! @p ! . ( ' ) !b @p ! { cr }
 @ or if { 0000027D } pop err ; then { 0000029D } ( test1 ) { cr }
 h# 0000CCCC dup ! @p ( ' ) @ !b dup dup { cr }
 ! @ or if { 0000033D } pop err ; then { 0000035D } ( 0 test2 ) { cr }
 @p ! . ( ' ) or ! . ( erased ) { cr cr }
 drop @p ! @p ( ' ) dup ( 0 0 ) - { 007FFFFF } ! h# 0000003E { cr }
 ! @p ! ( ' ) @+ !b push { 0000001F } { cr }
 @ - if { 0000045D } pop err ; then { 0000047D } ( test3 ) { cr }
 drop @p ! ( ' ) begin @+ !b unext . { 0000001F } { cr }
 h# 0000003E for @ if pop pop
: err { 0000053D } d# 1 + !b ; then ( test4 ) { cr }
 drop next { cr }
 @p ! . . ( ' ) dup !+ . next ( erased ) { cr }
 dup dup or !b ; { 0000063D } ( 3/5/11 ) { cr }
 }block

( 00351400 )               D# 1349 shadow{ 
 ( test tests neighbor's memory ) { cr }
 ( 19999 cccc test shorts to bits two bits away ) { cr }
 ( 3ffff { 0000001F } test shorts to bits one bit away ) { cr }
 ( tests for shorts between two addresses ) { cr }
 ( by reading { 0000080F } words after each { 007FFFFF } ! ) { cr }
 }block

( 00351800 )               D# 1350 code{ 
 { 0000C88F } ( all nodes template ) [ d# 15 node d# 0 org ]
: poll io b! @b ( mask ) h# 0000AA00 { 0000007D } and if ( drop ) warm
 ; then drop ; { 000000DD }
: incr poll if d# 1 . + ; then drop d# 1 . + d# 1 ;
: run { 000001DD } d# -1 d# 0 { 0004E1EF } d# 99999 for { 0004E1EF }
 d# 44999 for incr next next h# 0000003E a! !+ !+ h# 0000600D warm
 ;
: run { 000003BD } d# 0 d# 1 begin begin while poll d# 1 . + end then
 drop d# 1 . + d# 1 end ; { cr }
 { 0000055D } [ d# 1604 bin ] }block

( 00351C00 )               D# 1351 shadow{ 
 }block

( 00352000 )               D# 1352 code{ 
 ( erase flash ) [ d# 0 org ]
: wait ( dw-dw ) { 0000001D } select dup begin drop @b -until drop
 select ;
: 2cmd ( dw-d ) { 0000009D } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 0000013D } io b! ( fast ) d# 5 ;
: fet ( ah al-d ) { 0000019D } push push set ( read ) h# 00000C00 cmd
 pop !8 pop 8obits !8 ;
: +wr ( -d ) { 0000025D } set ( wren+wrsr ) h# 00001804 2cmd { indent }
      ( hi8 zero ) dup !8 ( ebsy ) h# 0001C000 cmd ;
: ers32k { 0000031D } +wr ( wren+ers32 ) h# 00001948 2cmd { cr }
 d# 0 !8 d# 0 8obits !8 dup select ;
: ersall { 0000043D } +wr ( wren+eras ) h# 00001980 2cmd { cr }
 dup select ;
: 16ibits ( d-db ) { 000004BD } dup d# 15 for { cr }
 rbit ibit - next h# 0000FFFF and ;
: stash ( d-d ) { 0000059D } a push h# 0000003F a! 16ibits ! pop a!
 ; { 0000061D } }block

( 00352400 )               D# 1353 shadow{ 
 }block

( 00352800 )               D# 1354 code{ 
 ( hardware multiply test ) [ d# 0 org +cy ]
: clc { 0000401D } dup dup or dup . + drop ;
: d2* ( hl-hl ) { 0000405D } dup . + push dup . + pop ;
: um+ ( hln-hl ) { 000040BD } . + push dup dup or . + pop ; { 0000411D }
 [ -cy ]
: h* ( nu-hl ) { 0000011D } dup a! dup or d# 17 for +* unext a ;
: abs ( n-n ) { 0000019D } -if
: neg ( n-n ) { 000001BD } - d# 1 . + then ; { 0000021D } [ +cy ]
: u/mod ( hld-rq ) { 0000421D } clc neg
: -u/mod { 0000425D } a! d# 17 push begin begin dup . + push dup .
 + dup a . + -if drop pop *next dup . + ; then over or or pop next
 dup . + ; { 000043DD } [ -cy ]
: try { 000043DD } right b! ( ba ) @b @b h* ( r ) @b um+ ( a ) @b u/mod
 ( b ) !b ( r ) !b try ; { 000044DD } }block

( 00352C00 )               D# 1355 shadow{ 
: h* ( is simplest multiply; first arg is a signed number and second,
 the multiplier, is a full { 0000024F } bit unsigned number. )
: try ( slaves this node to another by the port given. it expects to
 receive numbers b a r and calculates b*a+r then receives a and returns
 b and r. the multiply is done using the h* here which is why b is
 signed and a is unsigned. ) }block

( 00353000 )               D# 1356 code{ 
 ( soft multiply test ) [ d# 0 org +cy ]
: clc { 0000401D } dup dup or dup . + drop ;
: d2* ( hl-hl ) { 0000405D } dup . + push dup . + pop ;
: um+ ( hln-hl ) { 000040BD } . + push dup dup or . + pop ;
: u* ( nn-hl ) { 0000411D } a! clc dup push dup or dup pop d# 17 for
 begin push d2* a -if 2* a! pop dup push . + push d# 0 . + pop pop
 *next drop ; then 2* a! pop next drop ; { 0000433D } [ -cy ]
: abs ( n-n ) { 0000033D } -if
: neg ( n-n ) { 0000035D } - d# 1 . + then ;
: *. ( ff-f ) { 000003BD } over over or push abs swap abs u* d2* d2*
 drop pop -if drop neg ; then drop ; { 000004DD } [ +cy ]
: u/mod ( hld-rq ) { 000044DD } clc neg
: -u/mod { 0000451D } a! d# 17 push begin begin dup . + push dup .
 + dup a . + -if drop pop *next dup . + ; then over or or pop next
 dup . + ; { 0000467D } ( -cy )
: try { 0000467D } right b! @b @b u* @b um+ @b u/mod !b !b try ; { 0000475D }
 }block

( 00353400 )               D# 1357 shadow{ 
 }block

( 00353800 )               D# 1358 code{ 
 ( multiply exerciser ) [ h# 00000000 org ]
: dec ( n-n ) d# -1 . + ;
: +or ( nn-n ) over - and or ;
: try ( abr-ab bad ) { 0000009D } right a! ( 12033 ! ) push dup ! over
 ! pop dup ! push over ! dup @ or @ pop or +or ;
: test ( abr-abr ) dup push try if pop ; then drop pop
: poll @b h# 00000200 and if up b! @b push ;' io b! then drop
: run ( abr-abr ) { 0000035D } if dec test ; then drop if dec over
 dec test ; then drop dec if ( -1 ) h# 0001FFFF over dec test ; then
 drop h# 0000600D ; { 0000053D }
: go { 0000053D } io b! ( 20000 ) h# 0001FFFF ( -1 ) h# 0001FFFF over
 dec run ; { br }

: -u/mod ( old ) { 000005FD } a! d# 17 push dup . begin begin { cr }
 + push dup . + dup a . + -if drop pop dup *next + ; then over or or
 pop dup next + ; { 0000079D } }block

( 00353C00 )               D# 1359 shadow{ 
: try ( exercises slave node given a test vector. for the hardware
 version a is unsigned and b is signed. but the divide is unsigned
 so b is limited to the largest positive number. ) }block

( 00354000 )               D# 1360 code{ 
 ( serdes test ) [ h# 000000AA org ] data a! h# 0003FFFE dup ! up a!
 begin @ drop unext ( rdlu ) [ d# 0 org ]
: try io b! h# 00020000 !b h# 00000147 a! d# 0 d# 10000 for d# 1 +
 dup a! next ;
: start @ io b!
: test h# 0002AAAA @b or ! test . . . . down a! . . start }block

( 00354400 )               D# 1361 shadow{ 
 }block

( 00354800 )               D# 1362 code{ 
 ( serdes test { 0000004F } ) [ h# 000000AA org ] data a! h# 00033333
 dup ! up a! h# 00020000 !b begin dup . . . . . . . . . . . . . . .
 . . . . . . ! unext . . . . . . . }block

( 00354C00 )               D# 1363 shadow{ 
 }block

( 00355000 )               D# 1364 code{ 
 ( spi flash writer michael + greg 2.1 ) [ d# 0 org ]
: 2o ( dw-dw' ) { 0000001D } obit 2* obit ;
: wait ( dw-dw ) { 0000005D } select dup begin drop @b -until drop
 select ;
: 2cmd ( dw-d ) { 000000DD } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 0000017D } io b! ( fast ) d# 5 { 0000028F } ;
: fet ( ah al-d ) { 000001DD } push push set ( read ) h# 00000C00 cmd
 pop !8 pop 8obits !8 ;
: +wr ( -d ) { 0000029D } set ( wren+wrsr ) h# 00001804 2cmd { indent }
      ( hi8 zero ) dup !8 ( ebsy ) h# 0001C000 cmd ;
: aaip ( d-d ) { 0000035D } h# 0002B400 wait !8 ;
: x8p ( hln-d asrc ) { 000003BD } +wr ( wren+aaip ) h# 00001AB4 2cmd
 { cr }
 drop push push push set pop !8 pop 8obits { cr }
 !8 ahead begin aaip [ swap ] then d# 7 for { indent }
      pop dup push push @+ { indent }
      begin 2o 2* next push aaip pop { indent }
      d# 7 pop dup push or push { indent }
      begin 2o 2* next drop next next { cr }
 ( wrdi+dbsy ) h# 00001200 wait 2cmd -++ !b rdl- ; { 0000077D }
: ers32 { 0000077D } ( h-dd +wr wren+ers32 { 0003291F } 2cmd ) { cr }
 ( over 8obits 8obits !8 dup select ; ) { 0000077D } }block

( 00355400 )               D# 1365 shadow{ 
 ( run by an adjacent node through a port. ) { cr }
 24 bit addresses ( are represented in two { 0000024F } bit words.
 for continuous bit sync, all operations must start on { 0000000F }
 mod { 0000024F } byte boundaries. ) { cr }
 [ high ] ( word contains the most significant { 0000010F } bits of
 the address shifted left { 0000014F } bits. ) { cr }
 [ low ] ( word contains the least significant { 0000020F } bits shifted
 left two bits. ) { br }

: x8p ( writes ) [ n ] ( words into flash starting at address whose )
 [ high ] ( and ) [ low ] ( parts are given. the data are read from
 wherever ) [ a ] ( points; to feed a stream through a port, ) [ a ]
 ( must be focused to the port before starting. ) { br }

: fet ( starts a read operation )
: 18ibits ( reads one word; take care with ) [ 'd' ] }block

( 00355800 )               D# 1366 code{ 
 ( take adc data ) [ d# 0 org ]
: sam+ ( -n ) { 0000001D { 00002ABF } } h# 00002155 { 000C2ABF }
: s+- ( k-n ) io b! !b up b! !b @b ;
: sam- ( -n ) { 000000DD { 00012ABF } } h# 00002955 { 000D2ABF } s+-
 ; { br }

: sam { 0000011D } h# 00000020 a! sam+ sam- d# 11 2* for { cr }
 push sam+ dup - pop . + ( !+ ) push { cr }
 push sam- dup - pop . + pop + !+ next ; { 000002DD } { br }

 [ exit ] sam+ drop }block

( 00355C00 )               D# 1367 shadow{ 
 ( this block supports taking of data manually for a/d transfer function.
 to use it, put a/d in the desired mode by editing the constants in
 sam+ and - then set desired voltage and execute sam. you will find
 a sequence of samples stored in ram at { 0000040F } ) { br }

 ( original version sampled each half cycle of the incoming clock. )
 }block

( 00356000 )               D# 1368 code{ 
 ( generate dac waves ) [ d# 0 org ]
: dly { 0000001D } d# 100 for unext ;
: sano ( n-n ) h# 0003FFDF and ; h# 00000010 or ;
: tri ( n ) { 000000FD } push h# 00000155 d# 0 begin { cr }
 d# 510 for over or dup sano !b { indent }
      dly over or d# 1 . + next { cr }
 d# 510 for over or dup sano !b { indent }
      dly over or d# -1 . + next next drop drop ;
: try { 0000039D } io b!
: sing { 000003DD } d# 1000 tri
: poll { 0000041D } @b h# 00002000 and if down b! @b push ;' io b!
 then drop sing ;
: haul { 0000053D } io b! d# -1 dup push dup push dup push dup push
 dup push dup push dup push dup push push h# 00000155 h# 000000AA over
 over over over over over ( / ) dup dup
: spin { 000006DD } begin !b ( . . ) unext ( !b !b !b !b !b !b !b !b )
 spin ; { 000006FD } [ exit ] { cr }
 h# 00000155 h# 000001D5 h# 00000055 h# 000000D5 h# 000000AA h# 000000D5
 h# 00000055 h# 000001D5 ( / ) }block

( 00356400 )               D# 1369 shadow{ 
 }block

( 00356800 )               D# 1370 code{ 
 ( spi flash { 0000010F } bits ) [ d# 0 org ]
: 2o ( dw-dw' ) { 0000001D } obit 2* obit ;
: wait ( dw-dw ) { 0000005D } select dup begin drop @b -until drop
 select ;
: 2cmd ( dw-d ) { 000000DD } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 0000017D } io b! ( fast ) d# 5 ;
: fet ( ah al-d ) { 000001DD } push push set ( read ) h# 00000C00 cmd
 pop !8 pop 8obits !8 ;
: 16ibits ( d-db ) { 0000029D } dup d# 15 for { cr }
 rbit ibit - next h# 0000FFFF and ;
: +wr ( -d ) { 0000037D } set ( wren+wrsr ) h# 00001804 2cmd { cr }
 ( hi8 zero ) dup !8 ( ebsy ) h# 0001C000 cmd ;
: aaip ( d-d ) { 0000043D } h# 0002B400 wait !8 ;
: ers { 0000049D } +wr ( wren+eras ) h# 00001980 2cmd dup select ;
: wp ( hln-d asrc ) { 0000051D } +wr ( wren+aaip ) h# 00001AB4 2cmd
 { cr }
 drop push push push set pop !8 pop 8obits { cr }
 !8 ahead begin aaip [ swap ] then @+ 8obits !8 { cr }
 next ( wrdi+dbsy ) h# 00001200 wait 2cmd -++ !b rdl- ;
: stash ( d-d ) { 0000077D } a push h# 0000003F a! 16ibits ! pop a!
 ; { 000007FD } }block

( 00356C00 )               D# 1371 shadow{ 
 ( run by an adjacent node through a port. ) { cr }
 24 bit addresses ( are represented in two { 0000024F } bit words.
 for continuous bit sync, all operations must start on { 0000000F }
 mod { 0000024F } byte boundaries. ) { cr }
 [ high ] ( word contains the most significant { 0000010F } bits of
 the address shifted left { 0000014F } bits. ) { cr }
 [ low ] ( word contains the least significant { 0000020F } bits shifted
 left two bits. ) { br }

: wp ( writes ) [ n ] ( words into flash starting at address whose )
 [ high ] ( and ) [ low ] ( parts are given. the data are read from
 wherever ) [ a ] ( points; to feed a stream through a port, ) [ a ]
 ( must be focused to the port before starting. ) { br }

: fet ( starts a read operation )
: 16ibits ( reads one word; take care with ) [ 'd' ] }block

( 00357000 )               D# 1372 code{ 
 { 0000C80F } ( ide via async boot ) [ d# 708 node d# 0 org ]
: obit ( dwn-dw ) { 0000001D } !b over push delay ;
: word ( dw-d ) { 0000005D } leap drop leap drop leap drop drop ;
: obyt ( dw-dwx ) { 000000DD } then then then d# 3 obit drop d# 7 for
 dup d# 1 and d# 3 or obit drop 2/ next d# 2 obit ;
: -out { 0000023D } ser-exec ( rdl- ) ; { 0000025D } { br }

: ok { 0000025D } h# 00031416 word -out ;
: fet { 000002BD } d# 0
: pump ( n ) for @+ word next -out ;
: stat { 0000037D } d# 9 pump ;
: bstk { 000003BD } @ push .. @ word pop dup push word .. ( @p+.push )
 h# 000049BA ! d# 7 .. dup push ! .. @p+ ! .. ( /+ ) begin !p+ . .
 unext .. begin @ word .. next .. @p+ ! pop .. ( /+ ) pop @p+ ; ..
 ! -out ; { cr }
 { 0000059D } [ d# 1600 bin ] }block

( 00357400 )               D# 1373 shadow{ 
 }block

( 00357800 )               D# 1374 code{ 
 { 0000C82F } ( ide via sync boot ) [ d# 300 node d# 0 org ]
: 1bit ( wx-w'x ) drop -if d# 3 ahead [ swap ] then d# 2 { cr }
 then !b 2* dup ;
: word ( w ) { 000000DD } d# 8 dup for begin drop @b -until 1bit begin
 drop @b - -until 1bit next drop drop ;
: +out ( x ) { 000001FD } begin drop @b - -until drop d# 3 !b ;
: -out ( x ) { 0000027D } begin drop @b -until { cr }
 drop d# 2 !b d# 1 !b ser-exec ; { br }

: ok { 0000031D } dup +out h# 00031416 word dup -out ;
: fet { 0000039D } d# 0
: pump ( n ) dup +out for @+ word next dup -out ;
: stat { 0000047D } d# 9 pump ;
: bstk { 000004BD } +out @ dup push . @ word word ( / @p+.push ) h# 000049BA
 ! d# 7 . ( / ) dup push ! . ( / ) @p+ ! . . ( /+ ) begin !p+ . . unext
 ( / ) begin @ word ( / ) next ( / ) @p+ ! pop . ( /+ ) pop @p+ ; ( / )
 ! -out ; { cr }
 { 0000069D } [ d# 1601 bin ] }block

( 00357C00 )               D# 1375 shadow{ 
 }block

( 00358000 )               D# 1376 code{ 
 { 0000C84F } ( ide wire node ) [ d# 17 node d# 0 org ]
: fet { 0000001D } @p+ !b @ . fet !b @b ! ; { 0000007D } [ d# 5 org ]
: sto { 000000BD } @p+ !b @ . sto !b @ !b ; { 0000011D } [ h# 0000000A
 org ]
: ins { 0000015D } @p+ !b @ . ins !b ; { 000001BD } [ h# 0000000D org ]
: psh { 000001BD } @p+ !b @ . psh !b ; { 0000021D } [ h# 00000010 org ]
: stk { 0000021D } @p+ !b . . stk d# 9 for @b ! unext ; { cr }
 { 000002BD } [ d# 1602 bin ] }block

( 00358400 )               D# 1377 shadow{ 
 }block

( 00358800 )               D# 1378 code{ 
 { 0000C86F } ( ide last guy ) [ d# 16 node h# 0000001E org ]
: focus ( i0 ) { 000003DD } @p+ !b !b ; ( / ) focus ; [ d# 0 org ]
: fet { 0000001D } @p+ focus ( /+ ) @p+ a! @ !p+ ( / ) @ !b @b @p+
 ( /+ ) ; ( / ) !b ! ;
: sto { 000000BD } @p+ focus ( /+ ) @p+ a! . @p+ ( / ) @ !b @ . ( / )
 !b @p+ !b ; ( /+ ) ! ;
: ins { 0000015D } @ focus ; ( / ) ins ins
: psh { 000001BD } @p+ focus ( /+ ) @p+ ; ( / ) @ !b ;
: stk { 0000021D } @p+ focus ( /+ ) !p+ dup push !p+ ( / ) @b @b !
 dup ( / ) ! ( @p+.push ) h# 000049BA !b d# 7 ( / ) dup push !b . ( / )
 @p+ !b ( /+ ) begin !p+ . . unext ( / ) begin @b ! unext . ( / ) @p+
 !b !b ; ( /+ ) pop @p+ ; { cr }
 ( if past size-2 not ok- ) { 0000039D } [ d# 1603 bin ] }block

( 00358C00 )               D# 1379 shadow{ 
 }block

( 00359000 )               D# 1380 code{ 
 UNKNOWN ( common ) { , }
 UNKNOWN [ h# 00000155 org ] { * }
 UNKNOWN ( bomb ) { ... }
 UNKNOWN [ h# 00000145 org ] { * }
 UNKNOWN: ---u { , }
 UNKNOWN [ h# 00000175 org ] { * }
 UNKNOWN: --l- { ... }
 UNKNOWN [ h# 00000165 org ] { * }
 UNKNOWN: --lu { , }
 UNKNOWN [ h# 00000115 org ] { * }
 UNKNOWN: -d-- { ... }
 UNKNOWN [ h# 00000105 org ] { * }
 UNKNOWN: -d-u { , }
 UNKNOWN [ h# 00000135 org ] { * }
 UNKNOWN: -dl- { ... }
 UNKNOWN [ h# 00000125 org ] { * }
 UNKNOWN: -dlu { , }
 UNKNOWN [ h# 000001D5 org ] { * }
 UNKNOWN: r--- { ... }
 UNKNOWN [ h# 000001C5 org ] { * }
 UNKNOWN: r--u { , }
 UNKNOWN [ h# 000001F5 org ] { * }
 UNKNOWN: r-l- { ... }
 UNKNOWN [ h# 000001E5 org ] { * }
 UNKNOWN: r-lu { , }
 UNKNOWN [ h# 00000195 org ] { * }
 UNKNOWN: rd-- { ... }
 UNKNOWN [ h# 00000185 org ] { * }
 UNKNOWN: rd-u { , }
 UNKNOWN [ h# 000001B5 org ] { * }
 UNKNOWN: rdl- { ... }
 UNKNOWN [ h# 000001A5 org ] { * }
 UNKNOWN: rdlu { , }
 }block

( 00359400 )               D# 1381 shadow{ 
 }block

( 00359800 )               D# 1382 code{ 
 ( polynomial approximation )
: poly ( xn-xy ) pop a! push @+ a begin { indent }
      push *. pop a! @+ + a next push ; }block

( 00359C00 )               D# 1383 shadow{ 
: poly ( xn-xy ) { cr }
 ( evaluation of chebyshev polynomials using ) { cr }
 ( the horner scheme. ) { br }

 ( x is the input value. n is the length of ) { cr }
 ( the coefficient table minus 2. coefficient ) { cr }
 ( table follows inline, and execution ) { cr }
 ( continues after the final table entry. x is ) { cr }
 ( left on the stack under the result, y. ) { br }

 ( for example... )
: cos ( f-f' ) { cr }
 ( hart 3300 ) { cr }
 ( -0.0043 0.0794 -0.6459 0.5708 ) { indent }
      2* 2* . triangle dup *. d# 2 poly { indent }
      [ d# -281 , d# 5203 , d# -42329 , d# 37407 , ] { indent }
      push drop pop *. + ; }block

( 0035A000 )               D# 1384 code{ 
 ( interpolate )
: interp ( ims-v ) dup push push over { indent }
      begin 2/ unext a! { indent }
      and push @+ dup @+ - . + - { indent }
      pop a! dup dup or { indent }
      begin +* unext push drop pop . + ; }block

( 0035A400 )               D# 1385 shadow{ 
: interp ( ims-v ) { cr }
 ( to determine values for m and s ... ) { cr }
 ( let l be number of meaningful input bits. ) { cr }
 ( let n be power of 2 where 2**n + 1 is the ) { cr }
 ( number of table entries. ) { br }

 ( s equals l-n-1 ) { cr }
 ( m equals 2** l-n - 1 ) { br }

 ( so for example if you have an 8 bit adc, ) { cr }
 ( l equals 8. let n equal 2 for a 5 entry table. the table is expected
 to be at address 0, ) { cr }
 ( so to represent 0 to 1800 millivolts... ) { br }

 [ 0 org 0 , 450 , 900 , 1350 , 1800 , ] { cr }
: mv ( i-n ) h# 0000003F 5 interp ; { br }

 [ d# 0 mv ] ( gives ) [ d# 0 ] { cr }
 [ d# 128 mv ] ( gives ) [ d# 900 ] { cr }
 [ d# 256 mv ] ( gives ) [ d# 1800 ] { cr }
 ( and intermediate values are interpolated. ) }block

( 0035A800 )               D# 1386 code{ 
 ( fir or iir filter )
: taps ( yxc-y'x' ) pop a! push begin { indent }
      @+ @ push a push *.17 pop a! { indent }
      push !+ pop . + pop next @ a! ; }block

( 0035AC00 )               D# 1387 shadow{ 
: taps ( yxc-y'x' ) { cr }
 ( for example... ) { br }

: fir ( yx-y'x' ) d# 15 taps [ d# -53 , d# 0 , d# 2276 , d# 0 , d# 382
 , d# 0 , d# -1706 , d# 0 , d# -1158 , d# 0 , d# 2014 , d# 0 , d# 2406
 , d# 0 , d# -1977 , d# 0 , d# -4206 , d# 0 , d# 1289 , d# 0 , d# 6801
 , d# 0 , d# 678 , d# 0 , d# -11109 , d# 0 , d# -6250 , d# 0 , d# 23531
 , d# 0 , d# 54145 , d# 0 , ] { br }

 ( 16 taps, 16 coefficients with intermediate ) { cr }
 ( storage interleaved. ) }block

( 0035B000 )               D# 1388 code{ 
 ( routing; called with 'a relay' )
: relay ( a ) pop a! @+ push @+ zif { indent }
      drop ahead ( done ) [ swap ] then { indent }
      pop over push @p+ ( ' ) a relay ( ' ) { indent }
      !b !b !b begin @+ !b unext
: done then a push a! ; }block

( 0035B400 )               D# 1389 shadow{ 
 ( relay moves a port executable packet down ) { cr }
 ( a sequence of nodes linked by their b ) { cr }
 ( registers. the packet consists of a 1-cell ) { cr }
 ( index, a 1-cell count ) [ less one ] ( of body ) { cr }
 ( size, and the body cells. ) { br }

 ( a packet ) [ may ] ( be started from memory within ) { cr }
 ( a node, or it may simply be fed to a port. ) { br }

 ( relay assumes that b points to the next ) { cr }
 ( node in the chain. uses one return stack ) { cr }
 ( location and four data stack locations. ) { cr }
 ( it must be at the same location in every ) { cr }
 ( node. ) }block

( 0035B800 )               D# 1390 code{ 
 ( multiply )
: *.17 ( a b - a a*b ) a! d# 16 push dup dup or { indent }
      begin +* unext - +* a -if { indent }
      drop - 2* ; then drop 2* - ; }block

( 0035BC00 )               D# 1391 shadow{ 
: *.17 ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. note that the definition of ) *. { cr }
 ( contains a call to this word. ) { br }

 ( 17 bit fractions --- s.i ffff ffff ffff ffff ) }block

( 0035C000 )               D# 1392 code{ 
 ( lshift rshift )
: lsh push begin 2* unext ;
: rsh push begin 2/ unext ; }block

( 0035C400 )               D# 1393 shadow{ 
 }block

( 0035C800 )               D# 1394 code{ 
 ( triangle )
: triangle ( x-y call with; 2* 2* triangle ) { indent }
      h# 00010000 over -if drop . + ; then { indent }
      drop - . + - ; }block

( 0035CC00 )               D# 1395 shadow{ 
: triangle ( assuming an angle expressed as a ) { cr }
 ( 16 bit fraction of a revolution, ) { cr }
 [ 2* 2* triangle ] ( produces a triangle wave ) { cr }
 ( approximation to the cosine of that angle. ) }block

( 0035D000 )               D# 1396 code{ 
 ( fractional multiply )
: *. { 000016FD } ( f1 f2 - f1 f1*f2 ) *.17 { indent }
      a 2* -if drop - 2* - ; then { indent }
      drop 2* ; }block

( 0035D400 )               D# 1397 shadow{ 
: *. ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. ) { br }

 ( 16 bit fractions --- si. ffff ffff ffff ffff ) }block

( 0035D800 )               D# 1398 code{ 
 ( divide ) { cr }
 [ +cy ] { 00005A7D } ( enter ea mode )
: clc dup dup or dup . + drop ;
: --u/mod { 00005ABD } clc
: -u/mod ( hld-rq ) { 00005ADD } a! d# 17 push begin begin { indent }
      dup . + . push dup . + { indent }
      dup a . + -if { indent }
      drop pop *next dup . + ; then { indent }
      over or or . pop next dup . + ; { cr }
 [ -cy ] { 00001C3D } ( exit ea mode ) }block

( 0035DC00 )               D# 1399 shadow{ 
: clc ( clears the carry bit for addition in ) { cr }
 ( ea mode. ) { br }

 ( the following defines u/mod in ram ... ) { cr }
: u/mod ( hld-rq ) - d# 1 . + --u/mod ; { br }

 ( if the divisor is a constant, just negate ) { cr }
 ( it at edit or compile time. ) }block

( 0035E000 )               D# 1400 code{ 
 ( f18 compiler ) :# h 22 :# ip 21 :# slot 4 :# call? 0 :# cal 270078409
 :# com 108 [ macro ]
: !7 h# 00BD0489 3, h# FFFFFFFC , < drop > ;
: 2*s ?lit h# 0000E0C1 2, 1, ;
: call ( nn ) < ?dup > h# 000000B8 1, , h# 000000E9 1, [ cal ] @ here
 d# 3 + - + , ; [ forth ]
: swap swap ;
: eras ( nn ) push h# 000061FC ( call a9 ) swap block pop ( blks )
 fill ;
: node's ( -n ) [ com ] @ 2* h# 00008000 + ;
: memory ( n-a ) [ h# 00000240 - ] and node's block + ; { cr }
 [ h# 00008000 nnc d# 2 * blks eras ]
: org ( n ) dup [ h ] ! [ ip ] !
: break d# 4 [ slot ] ! ;
: p, ( n ) [ h ] @ memory ! [ h ] @ d# 1 over + over or h# 0000007F
 and or [ h ] ! ;
: s4 [ h ] @ [ ip ] ! d# 13 2*s dup [ call? ] ! p, d# 1 [ slot ] !
 ;
: s0 d# 13 2*s
: sn dup [ call? ] ! [ ip ] @ memory +! d# 1 [ slot ] +! ;
: s1 d# 8 2*s sn ;
: s2 d# 3 2*s sn ;
: s3 dup d# 3 and drop if d# 7 sn s4 ; then d# 4 / sn ;
: i, [ slot ] @ jump s0 s1 s2 s3 s4 }block

( 0035E400 )               D# 1401 shadow{ 
 ( f18 target compiler ) [ includes support for f18a addressing see
 d# 1404 ]
: h ( address of next available word in target memory here )
: ip ( address of current instruction word )
: slot ( next available instruction slot )
: call? ( was last instruction a call ? )
: call a ( compile a call )
: eras ( fills f18 memory with call 155 number )
: 2*s n ( shift left n bits )
: node's ( target node's starting memory block no. )
: memory n-a ( host address for target memory )
: org n ( set current target memory location )
: break ( break in emulator only )
: p, n ( compile pattern into target memory )
: s0-s4 ( assemble opcode into slot 0-3 )
: i, ( assemble opcode into next slot *note** simple code jump table
 using ) [ jump ] }block

( 0035E800 )               D# 1402 code{ 
 ( target )
: cnt 2/ d# -1 + ;
: defer ( -b ) pop ;
: execute ( b ) push ;
: f! ( bn ) [ sp ] + ! ;
: f@ ( n-b ) [ sp ] + @ ;
: class ( b ) [ last d# 1 + ] ! ;
: empty empt
: host d# 0 class [ d# 6 f@ ] nop [ d# 4 f@ ] nop [ d# 13 f@ ] nop
: functions ( bbb ) d# 13 f! d# 4 f! d# 6 f! ;
: . h# 0000001C i, ; ( nop )
: hhere here ;
: .. [ slot ] @ d# 4 or drop if . .. ; then d# 0 [ call? ] ! ;
: here .. [ h ] @ h# 000003FF and ; [ hhere ]
: report here d# 32 * [ d# 13 d# 16 + ] + !7 ;
: f18 ( b ) d# 1 f@ [ d# 0 + ] functions ;
: +cy here h# 00000200 over - and or org ;
: -cy here [ h# 00000200 - ] and org ;
: await [ com ] @ idle [ cal ] @ execute ; }block

( 0035EC00 )               D# 1403 shadow{ 
: defer -a ( byte address of the compiled code that follows -- used
 for forward referencing )
: execute a ( code at this address )
: f! an ( store address of code executed when a word with this function
 is interpreted )
: f@ n-a ( fetch address of function code )
: class a ( store address of code to be executed for each word subsequently
 defined )
: empty ( redefine empty to restore altered functions )
: host ( change context back to colorforth )
: functions aa ( store functions in kernel specific way )
: c18 ( save green word and number functions. set green short-number
 to n, compile to call. target words are executed to assemble instructions )
: . ( nop used to fill instruction words )
: nops ( fills rest of word with nops )
: here -a ( starts new instruction word. leaves target address as number )
: await ( generates call to node's idle ports. ) }block

( 0035F000 )               D# 1404 code{ 
 ( f18 jump instructions )
: 9same ( axa-ax ) push over pop - or [ h# 00000200 ] and drop ;
: j3 .
: j0 i, [ ip ] @ memory +! break ;
: j1 [ h ] @ 9same if over h# 00000100 and drop if swap h# 000000FF
 and swap j0 ; then then . . j3 ;
: j2 over h# 00000155 or [ h ] @ or h# 000003F8 and drop if . j3 ;
 then swap d# 7 and swap j0 ;
: -adr ( an ) swap h# 00000155 or swap [ slot ] @ jump j0 j1 j2 j3
 j0
: adr ( n-n ) [ slot ] @ d# 3 or drop if i, [ ip ] @ d# 8 * [ h ] @
 [ ip ] @ negate + + d# 8 * [ slot ] @ + break ; then . adr ;
: @h ( n-a ) d# 8 /mod + ;
: f3 ( an ) over h# 00000155 or over @h or h# 000002F8 and drop if
 abort ; then swap d# 7 and swap d# 8 / memory +! ;
: f2 dup @h 9same if over h# 00000100 and drop if swap h# 000000FF
 and swap
: f1 d# 8 / memory +! ; then then abort ;
: then ( n ) here h# 00000155 or swap d# 8 /mod swap jump f1 f1 f2
 f3 }block

( 0035F400 )               D# 1405 shadow{ 
 [ the f18a uses adr bit d# 9 for mode; d# 8 for i/o; d# 7 for rom.
 incrementer maintains bits 0-6, rest are left alone except for return
 and slot d# 0 jumps. ] { br }

: 9same ( is true if the two addresses match in bit 9 - the extended
 arithmetic mode bit. )
: -adr an ( assembles jump to known address )
: adr n-a ( assembles forward jump in slot 0,1,2. value left on stack
 is instr addr * 64 + here-ip + slot. )
: @h ( given that vlue value / 8 returns p at time the jump executes. )
: then a ( insert address for forward jump ) }block

( 0035F800 )               D# 1406 code{ 
 ( complex instructions )
: def defer here < call > ;
: call defer ( a ) d# 3 -adr ; [ call cal ! ]
: ; [ call? ] @ dup h# 00006000 or drop if dup h# 00000300 or drop
 if dup h# 00000018 or drop if d# 0 and i, break ; then then then dup
 2/ and negate [ ip ] @ memory +! ;
: -if ( -a ) d# 7 adr ;
: if ( -a ) d# 6 adr ;
: -until ( a ) d# 7 -adr ;
: until ( a ) d# 6 -adr ;
: -while ( a-aa ) d# 7 adr swap ;
: while ( a-aa ) d# 6 adr swap ;
: zif ( -a ) d# 5 adr ;
: *next ( aa-a ) swap
: next ( a ) d# 5 -adr ;
: unext ( a ) d# 4 i, drop ;
: n defer d# 8 f@ execute
: lit d# 8 i, h# 0003FFFF and ( ok in slot 3 )
: , ( n ) h# 00015555 or p, ;
: for h# 0000001D i,
: begin here ;
: ahead ( -a ) d# 2 adr ;
: end ( a ) d# 2 -adr ;
: leap ( -a ) d# 3 adr ; }block

( 0035FC00 )               D# 1407 shadow{ 
: def -a ( deferred to class. executed for every target definition
 to compile host code that compiles target call )
: call a ( compile target call )
: ; ( will be executed as a target word. the pentium macro has precedence
 while compiling )
: if/-if ( leaves address of jump on stack )
: -until a ( jump if positive to ) begin
: zif ( forward ) next ( decrements r and jumps if r! else pops and
 falls thru )
: next/for
: n ( executed for green short-numbers. all 18-bit target numbers are
 short. executes white short-number to put interpreted number on stack.
 then assembles literal instruction with number in next location. inverted
 for rom )
: , n ( compile number into target memory )
: ?lit -n ( retrieve previously compiled number )
: begin -a ( starts new instruction word. leaves properly formatted
 target address )
: ahead ( compiles fwd ref jump resolve w/then )
: leap ( like ahead but compiles a call ) }block

( 00360000 )               D# 1408 code{ 
 ( instructions )
: target n f18 def class ;
: ex { -cr } : ;' d# 1 i, break ;
: rx
: @p { -cr } : @p+ d# 8 i, ;
: @+ d# 9 i, ;
: @b h# 0000000A i, ;
: @ h# 0000000B i, ;
: !p { -cr } : !p+ h# 0000000C i, ;
: !+ h# 0000000D i, ;
: !b h# 0000000E i, ;
: ! h# 0000000F i, ; }block

( 00360400 )               D# 1409 shadow{ 
 ( words being redefined for the target computer. these host words
 can no longer be executed. although pentium macros take precedence
 during compilation, they will no longer be used. )
: f18 ( instructions )
: 0 ( ; ) ....8 ( @p ) .10 ( +* ) ..18 ( dup )
: 1 ( ex ) ...9 ( @+ ) .11 ( 2* ) ..19 ( pop )
: 2 ( j ) ....a ( @b ) .12 ( 2/ ) ..1a ( over )
: 3 ( call ) .b ( @ ) ..13 ( - ) ...1b ( a )
: 4 ( unext ) c ( !p ) .14 ( + ) ...1c ( . )
: 5 ( next ) .d ( !+ ) .15 ( and ) .1d ( push )
: 6 ( if ) ...e ( !b ) .16 ( or ) ..1e ( b! )
: 7 ( -if ) ..f ( ! ) ..17 ( drop ) 1f ( a! ) }block

( 00360800 )               D# 1410 code{ 
 ( port literals and constants )
: right ( . ) [ h# 000001D5 ] lit ; ( 0101111111 register bits )
: down ( .. ) [ h# 00000115 ] lit ; ( 0110111111 )
: left ( .. ) [ h# 00000175 ] lit ; ( 0111011111 )
: up ( .... ) [ h# 00000145 ] lit ; ( 0111101111 )
: io ( .... ) h# 0000015D lit ; ( 0111110111 )
: ldata ( . ) h# 00000171 lit ; ( 0111011011 )
: data ( .. ) h# 00000141 lit ; ( 0111101011 port calls )
: warp ( .. ) [ h# 00000157 ] lit ; ( 0111111101 )
: center h# 000001A5 lit ;
: top h# 000001B5 lit ;
: side h# 00000185 lit ;
: corner h# 00000195 lit ;
: /mod /mod ;
: spispeed d# 497 ( 0 ) lit ; [ h# 00000000 ] ( 24-bit adrs ) [ d# 4
 * d# 262144 /mod ] ( al ah ) [ h# 00000003 ] ( read cmd ) [ d# 256
 * + d# 4 * ]
: spicmd ( c.ah ) [ d# 0 + ] lit ;
: spiadr ( al ) [ d# 0 + ] lit ; }block

( 00360C00 )               D# 1411 shadow{ 
 }block

( 00361000 )               D# 1412 code{ 
 ( more instructions )
: +* h# 00000010 i, ; ( slot 3 ok )
: 2* h# 00000011 i, ;
: 2/ h# 00000012 i, ;
: - h# 00000013 i, ;
: + h# 00000014 i, ; ( slot 3 ok )
: and h# 00000015 i, ;
: or h# 00000016 i, ; ( exclusive-or )
: drop h# 00000017 i, ;
: dup h# 00000018 i, ; ( slot 3 ok )
: pop h# 00000019 i, ;
: over h# 0000001A i, ;
: a h# 0000001B i, ;
: push h# 0000001D i, ;
: b! h# 0000001E i, ;
: a! h# 0000001F i, ; }block

( 00361400 )               D# 1413 shadow{ 
: o ( replaces top-of-stack with 0. f18 instructions can't be used
 in macros - forth macros take precedence ) }block

( 00361800 )               D# 1414 code{ 
 }block

( 00361C00 )               D# 1415 shadow{ 
 }block

( 00362000 )               D# 1416 code{ 
 }block

( 00362400 )               D# 1417 shadow{ 
 }block

( 00362800 )               D# 1418 code{ 
 ( math rom anywhere ) [ d# 0 kind ] { br }

 [ h# 000000A1 org ] { cr }
 { 0000143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000153D } { -cr } : warm await ; { br }

 [ h# 000000B0 org ] { cr }
 { 0000161D } [ d# 1390 load ] ( multiply ) { cr }
 { 000016FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 0000179D } [ d# 1386 load ] ( taps ) { cr }
 { 0000189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 000019DD } [ d# 1394 load ] ( triangle ) { cr }
 { 00001A7D } [ d# 1398 load ] ( -u/mod ) { br }

 [ h# 000000AA org ] { cr }
 { 0000155D } [ d# 1382 load ] ( polynomial approximation ) { cr }
 { 0000161D } }block

( 00362C00 )               D# 1419 shadow{ 
 }block

( 00363000 )               D# 1420 code{ 
 ( serdes boot top/bot ) [ d# 6 kind h# 000000AA reset ] { br }

 [ h# 000000A1 org ] { cr }
 { 0000143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000153D } { -cr } : warm await ; { cr }
: cold { 0000155D } h# 00003141 a! h# 0003FFFE dup ! rdlu cold ; { br }

 { 0000161D } [ d# 1390 load ] ( multiply ) { cr }
 { 000016FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 0000179D } [ d# 1386 load ] ( taps ) { cr }
 { 0000189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 000019DD } [ d# 1394 load ] ( triangle ) { cr }
 { 00001A7D } [ d# 1398 load ] ( -u/mod ) { cr }
 { 00001C3D } }block

( 00363400 )               D# 1421 shadow{ 
 }block

( 00363800 )               D# 1422 code{ 
 ( sync serial boot side ) [ d# 2 kind h# 000000AA reset ] { cr { 000017FF } }
 [ h# 000000BE org ] { -cr } : sget { cr }
 [ h# 000000A1 org ] { cr }
 { 0000143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000153D } { -cr } : warm await ; { cr }
: cold { 0000155D } h# 000031A5 a! @ @b . . -if ( 0pin ) { cr }
 h# 0003FD85 ( 'rd-u 3fc00 + ) dup push dup begin { cr }
 drop @b . -if ( /pin ) *next [ swap ] then { cr }
 h# 00000185 ( 'rd-u ) push drop push ; then
: ser-exec { 000016DD } ( x-x ) sget push sget a! sget
: ser-copy { 0000173D } push zif ; then { cr }
 begin sget ( push sget pop !+ ) !+ next ;
: sget { 000017DD } ( -4/3-w ) dup leap leap
: 6in { 0000181D } then then leap leap
: 2in { 0000185D } then then 2* 2* dup begin { cr }
 . drop @b . - -until - d# 2 and dup begin { cr }
 . drop @b . . -until d# 2 and 2/ or or ; { br }

 { 0000199D } [ d# 1390 load ] ( multiply ) { cr }
 { 00001A7D } [ d# 1386 load ] ( taps ) { cr }
 { 00001B7D } [ d# 1394 load ] ( triangle ) { cr }
 { 00001C1D } }block

( 00363C00 )               D# 1423 shadow{ 
 ( sync serial boot side ) { br }

: ser-exec ( reads and processes a boot frame. )
: ser-copy ( receives ) [ n ] ( words at a, nop if n zero. ) { cr }
: sget ( receives { 0000024F } bits, first bit on falling clock edge,
 second bit on rising, and so on. ends with clock line high. data line
 must be stable by the time clock edge is seen. spins the whole time,
 no suspension. ) }block

( 00364000 )               D# 1424 code{ 
 ( async serial boot top/bot ) [ d# 1 kind h# 000000AA reset ] { cr { 000019FF } }
 [ h# 000000CB org ] { -cr } : 18ibits { cr }
 [ h# 000000A1 org ] { cr }
 { 0000143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000153D } { -cr } : warm await ;
: cold { 0000155D } h# 000031A5 ( 'rdlu ) a! @ @b .. -if
: ser-exec { 000015DD } ( x-d ) 18ibits drop push . { cr }
 18ibits drop a! . 18ibits
: ser-copy { 0000167D } ( xnx-d ) drop push zif ; { cr }
 then begin 18ibits drop !+ next ; { cr }
 then drop h# 000001B5 ( 'rdl- ) push push ;
: wait { 0000177D } ( x-1/1 ) begin . drop @b -until . drop ;
: sync { 000017DD } ( x-3/2-d ) dup dup wait or - push { cr }
 begin @b . -if . drop *next await ; { cr }
 then . drop pop - 2/ ;
: start { 000018BD } ( dw-4/2-dw,io ) { cr }
 dup wait over dup 2/ . + push
: delay { 0000191D } ( -1/1-io ) { cr }
 begin @b . -if then . drop next @b ; { br }

 { 0000197D } [ d# 1426 load ] ( 18ibits ) { cr }
 { 00001B3D } [ d# 1392 load ] ( lsh rsh ) { cr }
 { 00001BBD } }block

( 00364400 )               D# 1425 shadow{ 
 ( async serial boot. ) { cr }
: cold ( reads { 0000008F } ports, falls thru if pin high. else assumes
 a focusing call received, simulates its execution as though from warm. )
 { br }

: ser-exec ( reads and processes a boot frame. )
: ser-copy ( receives ) [ n ] ( words at a, nop if n zero. ) { cr }
: delay ( waits one bit time and samples io. enter via jump with )
 [ d ] ( in r. )
: wait ( waits for input pin to be high. )
: start ( waits for rising edge of a normally start bit, delays 1.5
 bit times and samples io. ) { br }

: sync ( waits for rising edge then measures high time, designed to
 be { 0000004F } bit-time start, followed by falling edge. returns )
 [ d ] ( for { 0000002F } bit time. times out after approx { 0000006F }
 ms, going warm. ) }block

( 00364800 )               D# 1426 code{ 
 ( more async serial )
: 18ibits { 0000197D } ( x-4/6-dwx ) { indent }
      sync sync dup start leap ( 2bits ) leap
: byte { 00001A1D } then drop start leap
: 4bits { 00001A5D } then leap
: 2bits { 00001A7D } then then leap
: 1bit { 00001A9D } ( nw,io-nw,io ) then { indent }
      push 2/ pop over or { indent }
      h# 00020000 and or over push delay ; { cr }
 { 00001B3D } }block

( 00364C00 )               D# 1427 shadow{ 
 }block

( 00365000 )               D# 1428 code{ 
 ( spi boot top/bot ) [ d# 4 kind h# 000000AA reset host ]
: --- [ h# 0000002A ] lit ; ( do, ce-, clk )
: --+ [ h# 0000002B ] lit ;
: +-- [ h# 0000003A ] lit ;
: +-+ [ h# 0000003B ] lit ;
: -++ [ h# 0000002F ] lit ; [ target ] { cr }
 [ h# 000000A1 org d# 1388 load ] ( relay ) { br }

 [ h# 000000C2 org ]
: 8obits ( dw-dw' ) d# 7 for leap ( obit ) 2* *next ;
: ibit { 000018FD } ( dw-dw' ) { indent }
      @b . -if drop - 2* ; then drop 2* - ;
: half { 0000195D } ( dwc-dw ) !b over for . . unext ;
: select { 0000199D } ( dw-dw ) -++ half --+ half ;
: obit { 00001A1D } ( dw-dw ) then { indent }
      -if +-- half +-+ half ; then
: rbit { 00001ABD } ( dw-dw ) --- half --+ half ;
: 18ibits { 00001B3D } ( d-dw ) dup d# 17 ( for ) push
: ibits begin rbit ibit - next ; { cr }
: u2/ 2/ h# 0001FFFF and ; { 00001C3D } { cr }
 [ h# 000000A9 org ] { cr }
 { 0000153D } { -cr } : warm await ; { cr }
 { 0000155D } [ d# 1430 load ] ( the rest ) { cr }
 { 0000183D } }block

( 00365400 )               D# 1429 shadow{ 
 UNKNOWN UNKNOWN ( clock management is mode 3, high when idle. ) { , , }
: ibits ( is entered by jump with count already on return stack. no
 rom effect to adding this. ) }block

( 00365800 )               D# 1430 code{ 
 ( more spi )
: cold { 0000155D } @b - .. [ h# 000001B5 ] ( 'rdl- ) -until { indent }
      spispeed spiadr push spicmd
: spi-boot { 0000161D } ( dly adrh . adrl - dly x ) { indent }
      select 8obits 8obits { indent }
      drop pop . 8obits 8obits
: spi-exec { 000016DD } ( dx-dx ) drop 18ibits { indent }
      h# 0001E000 . + [ h# 000001B5 ] ( 'rdl- ) -until { indent }
      push 18ibits a! 18ibits
: spi-copy { 0000179D } ( dn-dx ) push zif ; then begin { indent }
      18ibits ( push 18ibits pop !+ ) !+ next dup ; { 0000183D } ( was { 0000185F } )
 }block

( 00365C00 )               D# 1431 shadow{ 
 ( more spi ) { br }

 ( spi-copy reads one word per loop and the loop counter is the actual
 number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

( 00366000 )               D# 1432 code{ 
 ( analog ) [ d# 0 kind ] { br }

 [ h# 000000A1 org ] { cr }
 { 0000143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000153D } { -cr } : warm await ; { br }

 [ h# 000000B0 org ] { cr }
 { 0000161D } [ d# 1390 load ] ( multiply ) { cr }
 { 000016FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 0000179D } [ d# 1434 load ] ( -dac ) { cr }
 { 0000189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 000019DD } [ d# 1394 load ] ( triangle ) { cr }
 { 00001A7D } [ d# 1398 load ] ( -u/mod ) { br }

 [ h# 000000AA org ] { cr }
 { 0000155D } [ d# 1382 load ] ( polynomial approximation ) { cr }
 { 0000161D } }block

( 00366400 )               D# 1433 shadow{ 
 }block

( 00366800 )               D# 1434 code{ 
 ( dac )
: -dac ( legacy entry name below )
: dac27 { 0000179D } ( mcpaw-mcp ) dup push push { indent }
      over pop - . + push push h# 00000155 { indent }
      pop over or a { indent }
      begin unext !b . { indent }
      begin unext !b !b ; }block

( 00366C00 )               D# 1435 shadow{ 
 }block

( 00367000 )               D# 1436 code{ 
 ( 1-wire ) [ d# 3 kind h# 000000AA org ] { br }

 [ h# 0000009E org ]
: rcv ( s-sn ) { 000013DD } a push dup dup a! d# 17 for begin
: bit { 0000143D } @ drop @b -if { indent }
      drop - 2* - *next pop a! ; then { indent }
      drop 2* next pop a! ; { 0000151D } { br }

 [ h# 000000A9 org ]
: warm { 0000153D } await ;
: cold { 0000155D } left center a! . io b! { indent }
      dup dup h# 000000B7 ( rest ) dup push push d# 16 push { indent }
      @ drop @b [ h# 00000185 ] ( side ) -until { indent }
      drop a! . bit ; { 000016FD } ( rest ) { indent }
      push rcv a! rcv push zif ; then { indent }
      begin rcv !+ next ; { 000017DD } { br }

 { 000017DD } [ d# 1394 load ] ( triangle { 000000AF } ) { cr }
 { 0000187D } [ d# 1390 load ] ( multiply *.17 { 000000EF } ) { cr }
 { 0000195D } [ d# 1396 load ] ( fractional multiply *. { 000000AF } )
 { cr }
 { 000019FD { 0000AD0F } } ( load interpolate interp { 0000014F } )
 { cr }
 { 000019FD } [ d# 1398 load ] ( -u/mod { 000001CF } ) { cr }
 { 00001BDD } ( equals { 000013DF } ) }block

( 00367400 )               D# 1437 shadow{ 
 }block

( 00367800 )               D# 1438 code{ 
 ( null rom anywhere ) [ d# 0 kind ] { br }

 [ h# 000000A9 org ] { cr }
: warm { 0000153D } await ; }block

( 00367C00 )               D# 1439 shadow{ 
 ( default code for null rom, or for special rom to be loaded out of
 sequence. ) { br }

: warm ( is assumed by crawlers, and is also the destination of the
 call instruction that rom is initialized with. ) [ avoid clobbering
 this word since steven's test code will not work in its absence. ]
 }block


( 00368000 )               
