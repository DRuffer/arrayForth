
[ASM HEX BITS-32
200000  ORG

BITS-16
\ This code actually starts running at 0x7C00   
( 00200000 )   :Boot0    JMPS, Boot1 RB, 
BITS-32
( 00200002 )   :SectorsPerTrack   dw 0000 
\ 0B40 = 2880 512-byte sectors = 1.44MB floppy   
( 00200004 )   :SectorsToLoad   dw 020A 
( 00200006 )   :UnusedStore   dw 0000 
( 00200008 )   :NumberOfHeads   dw 0000 
( 0020000A )   :BootDrive   dw 0000 \ e.g. 80 is DOS C:, 01 is floppy B:
( 0020000C )   :LoadCX   dw 0000 
( 0020000E )   :CylindersAndSectors   dw 0000 
( 00200010 )   :StoreForDump   dw 0000 
( 00200012 )   :ScreenLoc   dw 0000 

( 00200014 )   :HexTable   d$  " 0123456789ABCDEF"

( 00200024 )   :RelocateGdt   dw 0000 0000 0000 0000 0000 0000 0000 0000 
( 00200034 )                 dw FFFF F000 9300 0000 FFFF 0000 9320 0000 
( 00200044 )                 dw 0000 0000 0000 0000 0000 0000 0000 0000 

BITS-16
( 00200054 )   :Relocate    PUSH|ALL, \ called with di = start of bootblock
( 00200055 )                  PUSH|ES, 
( 00200056 )                  MOVI|X, CX| 0200 IW, \ number of words to copy
( 00200059 )                  MOV, X| T| SI'| R| DI| 
\ point si to GDT for extended memory copy   
( 0020005B )                  ADDSI, R| SI| 24 IS, 
( 0020005E )                  XOR, X| T| AX'| R| AX| 
( 00200060 )                  MOV|SG, T| ES| R| AX| 
\ int 15 ah=87 copy extended memory   
( 00200062 )                  MOVI|B, AH| 87 IB, 
( 00200064 )                  INT, 15 IB, 
( 00200066 )                  XOR, X| T| AX'| R| AX| 
\ adjust low word of destination addr upwards   
( 00200068 )                  ADDI, X| BO| [DI]% 3E B, 0200 IW, 
\ add any carry to 3rd byte of destination   
( 0020006D )                  ADC, B| F| AL'| BO| [DI]% 40 B, 
( 00200070 )                  POP|ES, 
( 00200071 )                  POP|ALL, 
\ so adding 200 will bring it to zero   
( 00200072 )                  MOVI|X, BX| FE00 IW, 
( 00200075 )                  RET, 
( 00200076 )   :Boot1    JMPS, BootStart RB, 
( 00200078 )   :DumpToScreen    PUSH|ES, 
( 00200079 )                  PUSH|X, AX| 
( 0020007A )                  PUSH|X, CX| 
( 0020007B )                  PUSH|X, SI| 
( 0020007C )                  MOVI|X, AX| B800 IW, \ = video RAM (text mode)
( 0020007F )                  MOV|SG, T| ES| R| AX| 
( 00200081 )                  MOVI|X, CX| 4 IW, \ loop count
( 00200084 )   :DTSLoop    XOR, X| T| AX'| R| AX| 
( 00200086 )                  MOV, B| T| AL'| BO| [DI]% 11 B, \ high byte
( 00200089 )                  SHR, 1| X| R| AX| \ shift right to get high nybble
( 0020008B )                  SHR, 1| X| R| AX| 
( 0020008D )                  SHR, 1| X| R| AX| 
( 0020008F )                  SHR, 1| X| R| AX| 
( 00200091 )                  MOV, X| T| SI'| R| AX| 
( 00200093 )                  ADD, X| T| SI'| R| DI| 
( 00200095 )                  MOV, B| T| AL'| BO| [SI]% 14 B, \ index HexTable
\ load si with next screen location   
( 00200098 )                  MOV, X| T| SI'| BO| [DI]% 12 B, 
( 0020009B )                  ES:, 
( 0020009C )                  MOV, B| F| AL'| ZO| [SI]% \ write to screen
\ point to next screen location (odd byte is attribute)   
( 0020009E )                  ADDSI, BO| [DI]% 12 B, 2 IS, 
( 002000A2 )                  ANDI, X| BO| [DI]% 12 B, 07FF IW, \ keep on-screen
\ shift entire word to be displayed left 4 bits   
( 002000A7 )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000AA )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000AD )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000B0 )                  SHL, 1| X| BO| [DI]% 10 B, 
( 002000B3 )                  LOOP, DTSLoop RB, \ until word has been dumped
\ leave a space before next word is dumped   
( 002000B5 )                  ADDSI, BO| [DI]% 12 B, 2 IS, 
( 002000B9 )                  POP|X, SI| 
( 002000BA )                  POP|X, CX| 
( 002000BB )                  POP|X, AX| 
( 002000BC )                  POP|ES, 
( 002000BD )                  RET, 
\ boot starts here after two jumps   
( 002000BE )   :BootStart    SUB, X| T| DI'| R| DI| 
( 002000C0 )                  MOV|SG, T| DS| R| DI| \ zero out both DS and
( 002000C2 )                  MOV|SG, T| ES| R| DI| \ ES segment registers
( 002000C4 )                  MOVI|X, DI| 7C00 IW, 
( 002000C7 )                  STI, 
\ dl contains boot disk number,
\ see http://tldp.org/LDP/lki/lki-1.html   
( 002000C8 )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
( 002000CB )                  CALL, DumpToScreen RW, 
( 002000CE )                  OR, B| F| DL'| BO| [DI]% 0A B, 
( 002000D1 )                  MOV, B| T| DL'| BO| [DI]% 0A B, 
\ int 13 ah=08 read drive parameters   
( 002000D4 )                  MOVI|B, AH| 8 IB, 
( 002000D6 )                  PUSH|X, DI| \ does it mess with di?
( 002000D7 )                  INT, 13 IB, 
( 002000D9 )                  POP|X, DI| 
\ after BIOS call, dh is 0-based index of last head   
( 002000DA )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
( 002000DD )                  CALL, DumpToScreen RW, 
( 002000E0 )                  INC, B| R| DH| \ add 1 to get number of heads
\ store number of heads   
( 002000E2 )                  MOV, B| F| DH'| BO| [DI]% 8 B, 
( 002000E5 )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
\ dump number of heads in high byte   
( 002000E8 )                  CALL, DumpToScreen RW, 
\ after BIOS call, low 6 bits of cx are 1-based last track index,
\ high 10 bits 0-based last cylinder index   
( 002000EB )                  MOV, X| F| CX'| BO| [DI]% 10 B, 
( 002000EE )                  CALL, DumpToScreen RW, 
\ store number of cylinders and sectors   
( 002000F1 )                  MOV, X| F| CX'| BO| [DI]% 0E B, 
\ extract sectors per track   
( 002000F4 )                  ANDI, B| R| CL| 3F IB, 
\ store sectors per track   
( 002000F7 )                  MOV, B| F| CL'| BO| [DI]% 2 B, 
\ dump sectors per track (low byte)   
( 002000FA )                  MOV, X| F| CX'| BO| [DI]% 10 B, 
( 002000FD )                  CALL, DumpToScreen RW, 
\ es:bx is buffer address, adding 200 to FE00 zeroes bx   
( 00200100 )                  MOVI|X, BX| FE00 IW, 
\ ch=track, cl=sector to read   
( 00200103 )                  MOV, X| T| CX'| BO| [DI]% 0C B, 
\ dh=head, dl=drive to read   
( 00200106 )                  MOV, X| T| DX'| BO| [DI]% 0A B, 
\ total number of sectors to read   
( 00200109 )                  MOV, X| T| SI'| BO| [DI]% 4 B, 
( 0020010C )                  MOVI|X, AX| 0F00 IW, 
\ store sector data starting at F000   
( 0020010F )                  MOV|SG, T| ES| R| AX| 
( 00200111 )                  STI, 
\ have we reached number of sectors per track?   
( 00200112 )   :ReadCylinder    CMP, B| T| CL'| BO| [DI]% 2 B, 
( 00200115 )                  J, Z| N| ReadSector RB, \ continue if not, else...
( 00200117 )                  INC, B| R| DH| \ next head
( 00200119 )                  CMP, B| T| DH'| BO| [DI]% 8 B, \ reached # heads?
( 0020011C )                  J, Z| N| ReadTrack RB, \ continue if not, else...
( 0020011E )                  XOR, B| T| DH'| R| DH| \ back to head 0
( 00200120 )                  ADDI, B| R| CH| 1 IB, \ next track
\ start with first sector (only low 6 bits matter)   
( 00200123 )   :ReadTrack    ANDI, B| R| CL| 0C0 IB, 
\ next sector: sector is 1-based, so must be nonzero   
( 00200126 )   :ReadSector    INC|X, CX| 
\ es:bx is buffer address pointer for BIOS call   
( 00200127 )                  ADDI, X| R| BX| 0200 IW, 
\ int 13 ah=02 read sectors from drive   
( 0020012B )                  MOVI|X, AX| 0201 IW, 
( 0020012E )                  INT, 13 IB, 
\ ah=error code, al=actual number of sectors read   
( 00200130 )                  MOV, X| F| AX'| BO| [DI]% 10 B, 
\ check no error, and one sector read   
( 00200133 )                  DEC|X, AX| 
\ if all OK, just continue   
( 00200134 )                  J, Z| Y| NextSector RB, 
\ otherwise, show problem on screen   
( 00200136 )                  CALL, DumpToScreen RW, 
\ Relocate has side effect of resetting buffer address bx to zero   
( 00200139 )   :NextSector    CALL, Relocate RW, 
( 0020013C )                  DEC|X, SI| 
( 0020013D )                  J, Z| N| ReadCylinder RB, 
\ done loading colorForth, set es back to zero   
( 0020013F )                  XOR, X| T| AX'| R| AX| 
( 00200141 )                  MOV|SG, T| ES| R| AX| 
\ 3FB is Line Control Register (LCR) of first serial port   
( 00200143 )                  MOVI|X, DX| 03FB IW, 
\ 03 sets word length to 8 bits,
\ 80 sets ports 3F8 and 3F9 to be the baud rate divisor   
( 00200146 )                  MOVI|B, AL| 83 IB, 
( 00200148 )                  OUT|D, B'| 
\ divisor 03 sets baud rate to 38400,
\ see http://www.pelletiernet.com/helppc/8250.html   
( 00200149 )                  MOVI|B, AL| 3 IB, 
( 0020014B )                  SUBI, B| R| DL| 3 IB, \ LSBs of divisor
( 0020014E )                  OUT|D, B'| 
( 0020014F )                  XOR, X| T| AX'| R| AX| \ MSBs are 0
( 00200151 )                  INC|X, DX| \ MSBs of divisor
( 00200152 )                  OUT|D, B'| 
( 00200153 )                  MOVI|B, AL| 3 IB, \ word length 8 bits (again)
( 00200155 )                  ADDI, B| R| DL| 2 IB, \ point to LCR
\ 1) clear bit 7, now we've set the baud rate;
\ 2) this allows us to use 3F8 and 3F9 as transmit/receive buffer
\ 3) and Interrupt Enable register (IER), respectively   
( 00200158 )                  OUT|D, B'| 
\ zero all interrupt-enable bits   
( 00200159 )                  XOR, X| T| AX'| R| AX| 
( 0020015B )                  SUBI, B| R| DL| 2 IB, \ point to 3F9, IER
( 0020015E )                  OUT|D, B'| \ disable all serial port interrupts
\ enable RTS (bit 1) and DTR (bit 0)   
( 0020015F )                  MOVI|B, AL| 3 IB, 
\ point dx to Modem Control Register (MCR)   
( 00200161 )                  ADDI, B| R| DL| 3 IB, 
( 00200164 )                  OUT|D, B'| \ set the bits
( 00200165 )                  JMPS, SetVideoMode RB, 
BITS-32
( 00200167 )                 db 0 

( 00200168 )   :GdtStruct   dw 0017 7D70 0000 0000 0000 0000 0000 0000 
( 00200178 )                 dw FFFF 0000 9A00 00CF FFFF 0000 9200 00CF 

BITS-16
\ int 10 ax=4f02 set supervga video mode   
( 00200188 )   :SetVideoMode    MOVI|X, AX| 4F02 IW, 
\ 118 means 1024x768 pixels at 24 bits per pixel,
\ 4000 sets linear framebuffer:
\ http://en.wikipedia.org/wiki/VESA_BIOS_Extensions   
( 0020018B )                  MOVI|X, BX| 4118 IW, 
( 0020018E )                  INT, 10 IB, 
( 00200190 )                  CLI, 
\ size override allows us to use 32-bit registers in real mode   
( 00200191 )                  OS:, 
( 00200192 )                  XOR, X| T| AX'| R| AX| 
( 00200194 )                  OS:, 
( 00200195 )                  MOV, X| T| BX'| R| AX| 
\ zero out segment registers cs, ds, es   
( 00200197 )                  MOV|SG, F| CS| R| BX| 
( 00200199 )                  MOV|SG, T| DS| R| BX| 
( 0020019B )                  MOV|SG, T| ES| R| AX| 
( 0020019D )                  OS:, 
\ zero out registers esi and edi   
( 0020019E )                  MOV, X| T| DI'| R| AX| 
( 002001A0 )                  OS:, 
( 002001A1 )                  MOV, X| T| SI'| R| AX| 
( 002001A3 )                  MOV|SG, T| DS| R| AX| 
\ load Global Descriptor Table   
( 002001A5 )                  LGDT, MEM|% 7D68 W, \ actually GdtStruct
( 002001AA )                  MOVI|B, AL| 1 IB, 
\ see http://en.wikipedia.org/wiki/Protected_mode   
( 002001AC )                  MOV|CD, T| CR0| AX| \ set PE bit
\ selector of 8 points cs to executable segment descriptor   
( 002001AF )                  JMPFAR, 7DB4 W, 8 SG, 
BITS-32
\ now we are in Protected Mode (PM)   
( 002001B4 )   :Start32    JMPS, SetupDataSegments RB, 
( 002001B6 )   :SendSerial    PUSH|X, AX| 
( 002001B7 )                  PUSH|X, DX| 
\ fetch byte pointed to by stack return pointer   
( 002001B8 )                  MOV, X| T| DX'| BO|    [SP +1* 0] 8 B, 
( 002001BC )                  MOV, B| T| AL'| ZO| [DX] 
( 002001BE )                  MOVI|X, DX| 03F8 IL, 
( 002001C3 )                  OUT|D, B'| \ send through serial port
( 002001C4 )                  POP|X, DX| 
( 002001C5 )                  POP|X, AX| 
\ real return address is one past data byte pointer   
( 002001C6 )                  INC, X| ZO|    [SP +1* 0] 
( 002001C9 )                  RET, 
\ selector 10 points to segment descriptor
\ with executable bit cleared   
( 002001CA )   :SetupDataSegments    MOVI|B, AL| 10 IB, 
( 002001CC )                  MOV|SG, T| DS| R| AX| 
( 002001CE )                  MOV|SG, T| ES| R| AX| 
( 002001D0 )                  MOV|SG, T| SS| R| AX| 
( 002001D2 )                  MOVI|X, SP| 000A0000 IL, \ set top of stack
( 002001D7 )                  XOR, X| T| CX'| R| CX| 
\ see http://www.win.tue.nl/~aeb/linux/kbd/A20.html   
( 002001D9 )                  MOVI|B, AL| 0D1 IB, \ enable address line 20
\ this just tells the keyboard controller we want to write to it   
( 002001DB )                  OUT|P, B'| 64 P, 
\ busy-wait until keyboard controller ready   
( 002001DD )   :WaitKbdReady    IN|P, B'| 64 P, 
( 002001DF )                  ANDI|A, B'| 2 IB, 
( 002001E1 )                  J, Z| N| WaitKbdReady RB, 
\ bit 1 (value 02) is set to enable A20 address line   
( 002001E3 )                  MOVI|B, AL| 4B IB, 
( 002001E5 )                  OUT|P, B'| 60 P, 
( 002001E7 )                  MOVI|X, SI| 0009F400 IL, \ set esi to 9F400
( 002001EC )                  CALL, SendSerial RL, 
\ send ASCII 'A' through serial port   
( 002001F1 )                 d$  " A"

\ by this point, all code has been relocated to 0x200000   
( 002001F2 )                  MOVI|X, DI| Init0 IL, 
( 002001F7 )                  JMPO, R| DI| 
( 002001F9 )                 db 0 0 0 0 0 55 0AA 

( 00200200 )   :Init0    JMPS, Init1 RB, 
\ see http://www.kwant.info/howto/mirror/ser-tr.html   
( 00200202 )   :SerialOut    PUSH|X, AX| 
( 00200203 )                  PUSH|X, DX| 
\ first serial port's Line Status Register [LSR]   
( 00200204 )                  MOVI|X, DX| 03FD IL, 
( 00200209 )   :SOWaitReady    IN|D, B'| 
\ check THRE, Transmitter Holding Register Empty   
( 0020020A )                  TESTI|A, B'| 20 IB, 
( 0020020C )                  J, Z| Y| SOWaitReady RB, 
\ now point to 03F8, transmit/receive buffer   
( 0020020E )                  SUBI, B| R| DL| 5 IB, 
\ fetch return address from stack   
( 00200211 )                  MOV, X| T| AX'| BO|    [SP +1* 0] 8 B, 
\ retrieve byte at return address   
( 00200215 )                  MOV, B| T| AL'| ZO| [AX] 
( 00200217 )                  OUT|D, B'| \ send the byte out serial line
( 00200218 )                  POP|X, DX| 
( 00200219 )                  POP|X, AX| 
\ adjust return address to the opcode following data byte   
( 0020021A )                  INC, X| ZO|    [SP +1* 0] 
( 0020021D )                  RET, 
\ same as SerialOut but uses byte in AL instead of from stack   
( 0020021E )   :SerialOutAL    PUSH|X, DX| 
( 0020021F )                  PUSH|X, AX| 
( 00200220 )                  MOVI|X, DX| 03FD IL, \ serial port address
( 00200225 )   :SOAWaitReady    IN|D, B'| 
( 00200226 )                  TESTI|A, B'| 20 IB, 
( 00200228 )                  J, Z| Y| SOAWaitReady RB, 
( 0020022A )                  SUBI, B| R| DL| 5 IB, 
( 0020022D )                  POP|X, AX| 
( 0020022E )                  OUT|D, B'| 
( 0020022F )                  POP|X, DX| 
( 00200230 )                  RET, 
\ convert word in eax to hexadecimal and send out serial port   
( 00200231 )   :SerialOutHexWord    PUSH|ALL, 
( 00200232 )                  MOVI|X, CX| 8 IL, 
( 00200237 )                  MOV, X| T| DX'| R| AX| 
\ rotate 4 MSBs into low nybble   
( 00200239 )   :SerialOutNybble    ROLI, X| R| DX| 4 IS, 
( 0020023C )                  MOV, X| T| AX'| R| DX| 
( 0020023E )                  ANDI|A, X'| 0F IL, \ mask off high bits
\ index into hexadecimal translation table binary->ASCII   
( 00200243 )                  MOV, B| T| AL'| XO| [AX] 7C14 L, 
( 00200249 )                  CALL, SerialOutAL RL, 
( 0020024E )                  LOOP, SerialOutNybble RB, 
\ follow output with a space   
( 00200250 )                  CALL, SerialOut RL, 
( 00200255 )                 d$  BL

( 00200256 )                  POP|ALL, 
\ load eax with next word from esi pointer, and increment pointer   
( 00200257 )                  LODS, X'| 
( 00200258 )                  RET, 
( 00200259 )   :Init1    JMPS, Initialize RB, 
\ send carriage return and linefeed out serial port   
( 0020025B )   :SerialOutCRLF    CALL, SerialOut RL, 
( 00200260 )                 d$  CTRL M

\ send linefeed out serial port   
( 00200261 )   :SerialOutLF    CALL, SerialOut RL, 
( 00200266 )                 d$  CTRL J

( 00200267 )                  RET, 
( 00200268 )   :X_serialDump    MOV, X| T| CX'| R| AX| 
( 0020026A )                  SHRI, X| R| CX| 2 IS, 
( 0020026D )                  LODS, X'| 
( 0020026E )                  MOV, X| T| DI'| R| AX| 
( 00200270 )                  XOR, X| T| DX'| R| DX| 
( 00200272 )   :X_serialDumpLoop    TESTI, B| R| DL| 0F IB, 
( 00200275 )                  J, Z| N| X_serialDump2 RB, 
( 00200277 )                  CALL, SerialOutCRLF RL, 
( 0020027C )                  MOV, X| T| AX'| R| DI| 
( 0020027E )                  ADD, X| T| AX'| R| DX| 
( 00200280 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200283 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200285 )                  CALL, SerialOutHexWord RL, 
( 0020028A )                  CALL, SerialOut RL, 
( 0020028F )                 d$  BL

( 00200290 )   :X_serialDump2    MOV, X| T| AX'| ZO|    [DI +1* DX] 
( 00200293 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200296 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200298 )                  CALL, SerialOutHexWord RL, 
( 0020029D )                  ADDSI, R| DX| 4 IS, 
( 002002A0 )                  LOOP, X_serialDumpLoop RB, 
( 002002A2 )                  CALL, SerialOutCRLF RL, 
( 002002A7 )                  LODS, X'| 
( 002002A8 )                  RET, 
\ this seems to be dead code, nothing calls it   
( 002002A9 )   :L002002A9    PUSH|ALL, 
( 002002AA )                  MOV, X| T| DI'| BO|    [SP +1* 0] 20 B, 
( 002002AE )                  LEA, SI'| BO| [SI] 0FC B, 
( 002002B1 )                  MOV, X| F| AX'| ZO| [SI] 
( 002002B3 )                  MOV, X| T| AX'| ZO| [DI] 
( 002002B5 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002002B8 )                  MOV, X| F| AX'| ZO| [SI] 
( 002002BA )                  MOV, X| T| AX'| BO| [DI] 4 B, 
( 002002BD )                  CALL, X_serialDump RL, 
( 002002C2 )                  POP|ALL, 
( 002002C3 )                  ADDSI, ZO|    [SP +1* 0] 8 IS, 
( 002002C7 )                  RET, 
( 002002C8 )   :Initialize    CALL, SerialOutCRLF RL, 
\ adding -4 to esi to push arg onto data stack   
( 002002CD )                  LEA, SI'| BO| [SI] 0FC B, 
\ though eax doesn't contain anything useful at this point   
( 002002D0 )                  MOV, X| F| AX'| ZO| [SI] 
\ checking SerialOutHexWord before sending any real data   
( 002002D2 )                  MOVI|X, AX| 12345678 IL, 
( 002002D7 )                  CALL, SerialOutHexWord RL, 
( 002002DC )                  CALL, SerialOutCRLF RL, 
( 002002E1 )                  JMP, Start0 RL, 
( 002002E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002002F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200306 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200316 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200326 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200336 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200346 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200356 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200366 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200376 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200386 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200396 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002003F6 )                 db 0 0 0 0 0 0 0 0 0 0 

( 00200400 )   :Start0    JMP, Start RL, 
( 00200405 )                 d$  0  0  0  0E9  " M" 1B 
( 0020040B )                 d$  0  0  0  0  0 
( 00200410 )   :Version   d$  " cmcf 4.2c-pd"

( 0020041C )   :X_pauseIn    LEA, SI'| BO| [SI] 0FC B, 
( 0020041F )                  MOV, X| F| AX'| ZO| [SI] 
( 00200421 )                  PUSH|X, SI| 
( 00200422 )                  MOV|TA, X'| L00202800 L, 
( 00200427 )                  MOV, X| F| SP'| ZO| [AX] 
( 00200429 )                  ADDSI, R| AX| 4 IS, 
( 0020042C )                  JMPO, R| AX| 
( 0020042E )   :X_pauseOut    POP|X, AX| 
( 0020042F )                  MOV, X| T| SP'| ZO| [AX] 
( 00200431 )                  MOV|FA, X'| L00202800 L, 
( 00200436 )                  POP|X, SI| 
( 00200437 )                  LODS, X'| 
( 00200438 )                  RET, 
( 00200439 )   :X_pause    PUSH|X, DI| 
( 0020043A )                  CALL, X_pauseIn RL, 
( 0020043F )                  POP|X, DI| 
( 00200440 )                  RET, 
( 00200441 )   :L00200441    CALL, X_pauseOut RL, 
( 00200446 )   :L00200446   db 0F8 0FF 9 0 

( 0020044A )   :L0020044A    CALL, X_pauseOut RL, 
( 0020044F )   :L0020044F   db 0F8 0DB 9 0 

( 00200453 )   :L00200453    CALL, X_pauseOut RL, 
( 00200458 )   :L00200458   db 0F8 0B7 9 0 

( 0020045C )   :L0020045C    JMPS, L00200441 RB, 
( 0020045E )   :L0020045E    MOVI|X, DX| 0009CFFC IL, 
( 00200463 )                  MOV, X| F| CX'| ZO| [DX] 
( 00200465 )                  MOVI|X, CX| 0009DBFC IL, 
( 0020046A )                  POP, ZO| [CX] 
( 0020046C )                  LEA, CX'| BO| [CX] 0FC B, 
( 0020046F )                  MOV, X| F| DX'| ZO| [CX] 
( 00200471 )                  MOV, X| F| CX'| MEM| L0020044F L, 
( 00200477 )                  RET, 
( 00200478 )   :L00200478    MOVI|X, DX| 0009ABFC IL, 
( 0020047D )                  MOV, X| F| CX'| ZO| [DX] 
( 0020047F )                  MOVI|X, CX| 0009B7FC IL, 
( 00200484 )                  POP, ZO| [CX] 
( 00200486 )                  LEA, CX'| BO| [CX] 0FC B, 
( 00200489 )                  MOV, X| F| DX'| ZO| [CX] 
( 0020048B )                  MOV, X| F| CX'| MEM| L00200458 L, 
( 00200491 )                  RET, 
( 00200492 )   :X_nul    RET, 
( 00200493 )   :X_show    POP, MEM| L00202804 L, 
( 00200499 )                  CALL, L0020045E RL, 
( 0020049E )   :L0020049E    CALLO, MEM| L0020280C L, 
( 002004A4 )                  CALLO, MEM| L00202804 L, 
( 002004AA )                  CALLO, MEM| L00202810 L, 
( 002004B0 )                  JMPS, L0020049E RB, 
( 002004B2 )   :L002004B2    CALL, X_show RL, 
( 002004B7 )                  RET, 
( 002004B8 )   :X_freeze    POP, MEM| L00202804 L, 
( 002004BE )                  CALL, L0020045E RL, 
( 002004C3 )                  CALLO, MEM| L00202804 L, 
( 002004C9 )                  JMPS, -8 (RB,) 
( 002004CB )   :X_serve    POP, MEM| L00202808 L, 
( 002004D1 )                  CALL, L00200478 RL, 
( 002004D6 )   :X_serveLoop    CALL, X_pause RL, 
( 002004DB )                  CALLO, MEM| L00202808 L, 
( 002004E1 )                  JMPS, X_serveLoop RB, 
( 002004E3 )   :L002004E3    CALL, X_serve RL, 
( 002004E8 )                  RET, 
( 002004E9 )   :X_c    MOVI|X, SI| 0009F404 IL, 
( 002004EE )                  RET, 
( 002004EF )   :X_mark    MOV, X| T| CX'| MEM| L002027BC L, 
( 002004F5 )                  MOV, X| F| CX'| MEM| L00202798 L, 
( 002004FB )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 00200501 )                  MOV, X| F| CX'| MEM| L0020279C L, 
( 00200507 )                  MOV, X| T| CX'| MEM| L002027A4 L, 
( 0020050D )                  MOV, X| F| CX'| MEM| L002027A0 L, 
( 00200513 )                  RET, 
( 00200514 )   :X_empt    MOV, X| T| CX'| MEM| L002027A0 L, 
( 0020051A )                  MOV, X| F| CX'| MEM| L002027A4 L, 
( 00200520 )                  MOV, X| T| CX'| MEM| L0020279C L, 
( 00200526 )                  MOV, X| F| CX'| MEM| ForthMacros L, 
( 0020052C )                  MOV, X| T| CX'| MEM| L00202798 L, 
( 00200532 )                  MOV, X| F| CX'| MEM| L002027BC L, 
( 00200538 )                  MOVI, X| MEM| L002027AC L, 0 IL, 
( 00200542 )                  RET, 
( 00200543 )   :L00200543    MOV, X| T| CX'| MEM| L002027BC L, 
( 00200549 )                  PUSH|X, DI| 
( 0020054A )                  LEA, DI'| ZO|    [MEM +4* CX] L0020283C L, 
( 00200551 )                  JMPS, L00200561 RB, 
( 00200553 )   :L00200553    MOV, X| T| CX'| MEM| ForthMacros L, 
( 00200559 )                  PUSH|X, DI| 
( 0020055A )                  LEA, DI'| ZO|    [MEM +4* CX] 004CFFFC L, 
( 00200561 )   :L00200561    STD, 
( 00200562 )                  REPNZ, 
( 00200563 )                  SCAS, X'| 
( 00200564 )                  CLD, 
( 00200565 )                  POP|X, DI| 
( 00200566 )                  RET, 
( 00200567 )   :X_abort    JMPO, MEM| L00202758 L, 
( 0020056D )   :X_drop    MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200573 )                  MOV, X| F| DX'| MEM| L002027B0 L, 
( 00200579 )                  MOVI, B| ZO| [DX] 0AD IB, 
( 0020057C )                  INC, X| MEM| L002027A4 L, 
( 00200582 )                  RET, 
( 00200583 )   :X_?dup    MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200589 )                  DEC|X, DX| 
( 0020058A )                  CMP, X| F| DX'| MEM| L002027B0 L, 
( 00200590 )                  J, Z| N| X_dup RB, 
( 00200592 )                  CMPI, B| ZO| [DX] 0AD IB, 
( 00200595 )                  J, Z| N| X_dup RB, 
( 00200597 )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 0020059D )                  RET, 
( 0020059E )   :X_dup    MOV, X| T| DX'| MEM| L002027A4 L, 
( 002005A4 )                  MOVI, X| ZO| [DX] 89FC768D IL, 
( 002005AA )                  MOVI, B| BO| [DX] 4 B, 6 IB, 
( 002005AE )                  ADDSI, MEM| L002027A4 L, 5 IS, 
( 002005B5 )                  RET, 
( 002005B6 )   :L002005B6    LEA, SI'| BO| [SI] 0FC B, 
( 002005B9 )                  MOV, X| F| AX'| ZO| [SI] 
( 002005BB )                  RET, 
( 002005BC )   :L002005BC    POP, MEM| L002027CC L, 
( 002005C2 )                  RET, 
( 002005C3 )   :X_macro    CALL, L002005BC RL, 
( 002005C8 )                  PUSH|X, AX| 
( 002005C9 )                  MOV, X| T| CX'| MEM| L002027BC L, 
( 002005CF )                  INC, X| MEM| L002027BC L, 
( 002005D5 )                  LEA, CX'| ZO|    [MEM +4* CX] EncodedMacros L, 
( 002005DC )                  MOVI|X, AX| 0218 IL, 
( 002005E1 )                  JMPS, L00200601 RB, 
( 002005E3 )   :X_forth    CALL, L002005BC RL, 
( 002005E8 )   :L002005E8    PUSH|X, AX| 
( 002005E9 )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 002005EF )                  INC, X| MEM| ForthMacros L, 
( 002005F5 )                  LEA, CX'| ZO|    [MEM +4* CX] 004D0000 L, 
( 002005FC )                  MOVI|X, AX| 2800 IL, 
( 00200601 )   :L00200601    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 00200608 )                  ANDSI, R| DX| 0F0 IS, 
( 0020060B )                  MOV, X| F| DX'| ZO| [CX] 
( 0020060D )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200613 )                  MOV, X| F| DX'| ZO|    [CX +1* AX] 
( 00200616 )                  LEA, DX'| ZO|    [CX +1* AX] 
( 00200619 )                  SHRI, X| R| DX| 2 IS, 
( 0020061C )                  MOV, X| F| DX'| MEM| L002027A8 L, 
( 00200622 )                  POP|X, AX| 
( 00200623 )                  MOV, X| F| SP'| MEM| L002027B0 L, 
( 00200629 )                  MOVI, X| MEM| L00202794 L, L002005B6 IL, 
( 00200633 )                  TESTI, X| MEM| L002027AC L, -1 IL, 
( 0020063D )                  J, Z| Y| L00200645 RB, 
( 0020063F )                  JMPO, MEM| L002027AC L, 
( 00200645 )   :L00200645    RET, 
( 00200646 )   :L00200646    LEA, SI'| BO| [SI] 0FC B, 
( 00200649 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020064B )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D0004 L, 
( 00200652 )                  RET, 
( 00200653 )   :L00200653    CALL, L002005E8 RL, 
( 00200658 )                  MOVI, X| XO| [CX] 2800 L, L00200646 IL, 
( 00200662 )                  INC, X| MEM| ForthMacros L, 
( 00200668 )                  MOV, X| F| DI'| BO| [CX] 4 B, 
( 0020066B )                  INC|X, DI| 
( 0020066C )                  RET, 
( 0020066D )   :L0020066D    MOVI, X| MEM| L00202794 L, L002005B6 IL, 
( 00200677 )   :L00200677    CALL, X_?dup RL, 
( 0020067C )                  MOV, X| T| DX'| MEM| L002027B0 L, 
( 00200682 )                  MOV, X| F| DX'| MEM| ForthWords L, 
( 00200688 )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 0020068E )                  MOV, X| F| DX'| MEM| L002027B0 L, 
( 00200694 )                  MOVI, B| ZO| [DX] 0B8 IB, 
( 00200697 )                  MOV, X| F| AX'| BO| [DX] 1 B, 
( 0020069A )                  ADDSI, MEM| L002027A4 L, 5 IS, 
( 002006A1 )                  RET, 
( 002006A2 )   :L002006A2    CALLO, MEM| L00202794 L, 
( 002006A8 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] 0 L, 
( 002006AF )                  INC|X, DI| 
( 002006B0 )                  JMPS, L002006C2 RB, 
( 002006B2 )   :L002006B2    CALLO, MEM| L00202794 L, 
( 002006B8 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002006BF )                  SARI, X| R| AX| 5 IS, 
( 002006C2 )   :L002006C2    CALL, L00200677 RL, 
( 002006C7 )                  LODS, X'| 
( 002006C8 )                  RET, 
( 002006C9 )   :L002006C9    XOR, X| T| DI'| R| DI| 
( 002006CB )   :L002006CB    DEC, X| MEM| L00202788 L, 
( 002006D1 )                  J, Z| Y| L002006EF RB, 
( 002006D3 )                  LODS, X'| 
( 002006D4 )                  JMPS, L002006CB RB, 
( 002006D6 )   :L002006D6    MOVI, X| MEM| L00202794 L, L0020066D IL, 
( 002006E0 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002006E3 )                  MOV, X| F| AX'| ZO| [SI] 
( 002006E5 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002006EC )                  ANDSI, R| AX| 0F0 IS, 
( 002006EF )   :L002006EF    CALL, L00200553 RL, 
( 002006F4 )                  J|X, Z| N| X_abort RL, 
( 002006FA )                  LODS, X'| 
( 002006FB )                  JMPO, ZO|    [MEM +4* CX] 004D2800 L, 
( 00200702 )   :L00200702    CALLO, MEM| L00202794 L, 
( 00200708 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020070F )                  ANDSI, R| AX| 0F0 IS, 
( 00200712 )                  CALL, L00200543 RL, 
( 00200717 )                  J, Z| N| L00200721 RB, 
( 00200719 )                  LODS, X'| 
( 0020071A )                  JMPO, ZO|    [MEM +4* CX] MacroPointers L, 
( 00200721 )   :L00200721    CALL, L00200553 RL, 
( 00200726 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D2800 L, 
( 0020072D )   :L0020072D    J|X, Z| N| X_abort RL, 
( 00200733 )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200739 )                  MOV, X| F| DX'| MEM| L002027B0 L, 
( 0020073F )                  MOVI, B| ZO| [DX] 0E8 IB, 
( 00200742 )                  ADDSI, R| DX| 5 IS, 
( 00200745 )                  SUB, X| T| AX'| R| DX| 
( 00200747 )                  MOV, X| F| AX'| BO| [DX] 0FC B, 
( 0020074A )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 00200750 )                  LODS, X'| 
( 00200751 )                  RET, 
( 00200752 )   :L00200752    CALLO, MEM| L00202794 L, 
( 00200758 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020075F )                  ANDSI, R| AX| 0F0 IS, 
( 00200762 )                  CALL, L00200543 RL, 
( 00200767 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] MacroPointers L, 
( 0020076E )                  JMPS, L0020072D RB, 
( 00200770 )   :L00200770    MOVI, X| MEM| L00202794 L, L0020066D IL, 
( 0020077A )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020077D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020077F )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 00200786 )                  SARI, X| R| AX| 5 IS, 
( 00200789 )                  RET, 
( 0020078A )   :L0020078A    MOVI, X| MEM| L00202794 L, L0020066D IL, 
( 00200794 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200797 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200799 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] 0 L, 
( 002007A0 )                  INC|X, DI| 
( 002007A1 )                  RET, 
( 002007A2 )   :X_,    MOVI|X, CX| 4 IL, 
( 002007A7 )   :L002007A7    MOV, X| T| DX'| MEM| L002027A4 L, 
( 002007AD )                  MOV, X| F| AX'| ZO| [DX] 
( 002007AF )                  MOV, X| T| AX'| ZO| [SI] 
( 002007B1 )                  LEA, DX'| ZO|    [CX +1* DX] 
( 002007B4 )                  LEA, SI'| BO| [SI] 4 B, 
( 002007B7 )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 002007BD )                  RET, 
( 002007BE )   :X_1,    MOVI|X, CX| 1 IL, 
( 002007C3 )                  JMPS, L002007A7 RB, 
( 002007C5 )   :X_2,    MOVI|X, CX| 2 IL, 
( 002007CA )                  JMPS, L002007A7 RB, 
( 002007CC )   :X_3,    MOVI|X, CX| 3 IL, 
( 002007D1 )                  JMPS, L002007A7 RB, 
( 002007D3 )   :X_;    MOV, X| T| DX'| MEM| L002027A4 L, 
( 002007D9 )                  SUBSI, R| DX| 5 IS, 
( 002007DC )                  CMP, X| F| DX'| MEM| L002027B0 L, 
( 002007E2 )                  J, Z| N| L002007EC RB, 
( 002007E4 )                  CMPI, B| ZO| [DX] 0E8 IB, 
( 002007E7 )                  J, Z| N| L002007EC RB, 
( 002007E9 )                  INC, B| ZO| [DX] 
( 002007EB )                  RET, 
( 002007EC )   :L002007EC    MOVI, B| BO| [DX] 5 B, 0C3 IB, 
( 002007F0 )                  INC, X| MEM| L002027A4 L, 
( 002007F6 )                  RET, 
( 002007F7 )   :X_then    MOV, X| F| SP'| MEM| L002027B0 L, 
( 002007FD )                  MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200803 )                  SUB, X| T| DX'| R| AX| 
( 00200805 )                  MOV, B| F| DL'| BO| [AX] 0FF B, 
( 00200808 )                  LODS, X'| 
( 00200809 )                  RET, 
( 0020080A )   :X_begin    MOV, X| F| SP'| MEM| L002027B0 L, 
( 00200810 )   :X_here    LEA, SI'| BO| [SI] 0FC B, 
( 00200813 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200815 )                  MOV|TA, X'| L002027A4 L, 
( 0020081A )                  RET, 
( 0020081B )   :X_?lit    MOV, X| T| DX'| MEM| L002027A4 L, 
( 00200821 )                  LEA, DX'| BO| [DX] 0FB B, 
( 00200824 )                  CMP, X| F| DX'| MEM| L002027B0 L, 
( 0020082A )                  J, Z| N| X_?lit2 RB, 
( 0020082C )                  CMPI, B| ZO| [DX] 0B8 IB, 
( 0020082F )                  J, Z| N| X_?lit2 RB, 
( 00200831 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200834 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200836 )                  MOV|TA, X'| ForthWords L, 
( 0020083B )                  MOV|FA, X'| L002027B0 L, 
( 00200840 )                  MOV, X| T| AX'| BO| [DX] 1 B, 
( 00200843 )                  CMPI, X| BO| [DX] 0FB B, 89FC768D IL, 
( 0020084A )                  J, Z| Y| X_?lit1 RB, 
( 0020084C )                  MOV, X| F| DX'| MEM| L002027A4 L, 
( 00200852 )                  JMP, X_drop RL, 
( 00200857 )   :X_?lit1    ADDSI, MEM| L002027A4 L, 0F6 IS, 
( 0020085E )                  RET, 
( 0020085F )   :X_?lit2    XOR, X| T| DX'| R| DX| 
( 00200861 )                  RET, 
( 00200862 )   :X_less    CMP, X| F| AX'| ZO| [SI] 
( 00200864 )                  J, S| Y| X_less1 RB, 
( 00200866 )                  XOR, X| T| CX'| R| CX| 
( 00200868 )   :X_less1    RET, 
( 00200869 )   :L00200869    TESTI, X| ZO|    [MEM +4* DI] -4 L, -10 IL, 
( 00200874 )                  J, Z| N| L00200878 RB, 
( 00200876 )                  POP|X, DI| 
( 00200877 )                  POP|X, DI| 
( 00200878 )   :L00200878    RET, 
( 00200879 )   :X_jump    POP|X, DX| 
( 0020087A )                  ADD, X| T| DX'| R| AX| 
( 0020087C )                  LEA, DX'| BO|    [DX +4* AX] 5 B, 
( 00200880 )                  ADD, X| T| DX'| BO| [DX] 0FC B, 
( 00200883 )                  LODS, X'| 
( 00200884 )                  JMPO, R| DX| 
( 00200886 )   :X_load    ADD, X| T| AX'| MEM| L00202748 L, 
( 0020088C )                  SHLI, X| R| AX| 8 IS, 
( 0020088F )                  PUSH|X, DI| 
( 00200890 )                  MOV, X| T| DI'| R| AX| 
( 00200892 )                  LODS, X'| 
( 00200893 )   :X_load1    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 0020089A )                  INC|X, DI| 
( 0020089B )                  ANDSI, R| DX| 0F IS, 
( 0020089E )                  CALLO, ZO|    [MEM +4* DX] 002027C0 L, 
( 002008A5 )                  JMPS, X_load1 RB, 
( 002008A7 )                 d$  0 

( 002008A8 )   :X_top    MOV, X| T| CX'| MEM| L00202818 L, 
( 002008AE )                  SHLI, X| R| CX| 10 IS, 
( 002008B1 )                  ADDSI, R| CX| 3 IS, 
( 002008B4 )                  MOV, X| F| CX'| MEM| L00202814 L, 
( 002008BA )                  MOV, X| F| CX'| MEM| 00202820 L, 
( 002008C0 )                  RET, 
( 002008C1 )   :L002008C1    OS:, 
( 002008C2 )                  MOV, X| T| CX'| MEM| L00202816 L, 
( 002008C8 )                  OS:, 
( 002008C9 )                  CMP, X| T| CX'| MEM| L0020281C L, 
( 002008CF )                  J, S| Y| X_cr1 RB, 
( 002008D1 )   :X_cr    MOV, X| T| CX'| MEM| L00202818 L, 
( 002008D7 )                  SHLI, X| R| CX| 10 IS, 
( 002008DA )                  OS:, 
( 002008DB )                  MOV, X| T| CX'| MEM| L00202814 L, 
( 002008E1 )                  ADDSI, R| CX| 1E IS, 
( 002008E4 )                  MOV, X| F| CX'| MEM| L00202814 L, 
( 002008EA )   :X_cr1    RET, 
( 002008EB )   :L002008EB    LEA, SI'| BO| [SI] 0FC B, 
( 002008EE )                  MOV, X| F| AX'| ZO| [SI] 
( 002008F0 )                  MOVI|X, AX| 00FFFFFF IL, 
( 002008F5 )   :X_color    MOV|FA, X'| L00202834 L, 
( 002008FA )                  LODS, X'| 
( 002008FB )                  RET, 
\ 1) pci [a - n] fetches a cell from PCI configuration space
\ 2) given address. uses config mechanism as defined by PCI
\ 3) local bus spec 2.0   
( 002008FC )   :X_pci    MOVI|X, DX| 0CF8 IL, 
( 00200901 )                  OUT|D, X'| 
( 00200902 )                  LEA, DX'| BO| [DX] 4 B, 
( 00200905 )                  IN|D, X'| 
( 00200906 )                  RET, 
\ 1) device [n - a] given class number in high byte of n,
\ 2) return configuration register for first device,
\ 3) searching downwards, matching it. if none found,
\ 4) returns configuration register for last device examined   
( 00200907 )   :X_devic    LEA, SI'| BO| [SI] 0FC B, 
( 0020090A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020090C )                  MOVI|X, AX| 80080008 IL, 
( 00200911 )                  MOVI|X, CX| 0FE IL, 
( 00200916 )   :X_devic1    LEA, SI'| BO| [SI] 0FC B, 
( 00200919 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020091B )                  CALL, X_pci RL, 
( 00200920 )                  ANDI|A, X'| FF000000 IL, 
( 00200925 )                  XOR, X| T| AX'| BO| [SI] 4 B, 
( 00200928 )                  LODS, X'| 
( 00200929 )                  J, Z| Y| X_devic2 RB, 
( 0020092B )                  SUBI|A, X'| 0800 IL, 
( 00200930 )                  DEC|X, CX| 
( 00200931 )                  J, Z| N| X_devic1 RB, 
( 00200933 )   :X_devic2    LEA, SI'| BO| [SI] 4 B, 
( 00200936 )                  LEA, AX'| BO| [AX] 0F8 B, 
( 00200939 )                  RET, 
\ 03 is PCI class code for display device   
( 0020093A )   :InitDisplay    MOVI|X, AX| 03000000 IL, 
( 0020093F )                  CALL, X_devic RL, 
( 00200944 )                  LEA, AX'| BO| [AX] 10 B, 
( 00200947 )                  MOVI|B, CL| 6 IB, 
( 00200949 )   :L00200949    LEA, SI'| BO| [SI] 0FC B, 
( 0020094C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020094E )                  CALL, X_pci RL, 
( 00200953 )                  ANDI|A, B'| 0FB IB, 
( 00200955 )                  XORI|A, B'| 8 IB, 
( 00200957 )                  J, Z| Y| L0020096F RB, 
( 00200959 )                  LODS, X'| 
( 0020095A )                  LEA, AX'| BO| [AX] 4 B, 
( 0020095D )                  DEC|X, CX| 
( 0020095E )                  J, Z| N| L00200949 RB, 
( 00200960 )                  LEA, AX'| BO| [AX] 0E8 B, 
( 00200963 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200966 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200968 )                  CALL, X_pci RL, 
( 0020096D )                  ANDI|A, B'| 0F0 IB, 
( 0020096F )   :L0020096F    MOV|FA, X'| L00202830 L, 
( 00200974 )                  LODS, X'| 
( 00200975 )                  RET, 
( 00200976 )   :X_fifo    LODS, X'| 
( 00200977 )   :X_graph    RET, 
( 00200978 )   :X_switch    PUSH|X, SI| 
( 00200979 )                  MOV, X| T| SI'| MEM| L0020282C L, 
( 0020097F )                  PUSH|X, DI| 
( 00200980 )                  MOV, X| T| DI'| MEM| L00202830 L, 
( 00200986 )                  MOVI|X, CX| 000C0000 IL, 
( 0020098B )                  REPZ, 
( 0020098C )                  MOVS, X'| 
( 0020098D )                  POP|X, DI| 
( 0020098E )                  POP|X, SI| 
( 0020098F )                  RET, 
( 00200990 )   :L00200990    CALL, X_switch RL, 
( 00200995 )                  JMP, X_pause RL, 
( 0020099A )   :L0020099A    MOV, X| T| DI'| MEM| L00202814 L, 
( 002009A0 )                  MOV, X| T| CX'| R| DI| 
( 002009A2 )                  OS:, 
( 002009A3 )                  TEST, X| CX'| R| CX| 
( 002009A5 )                  J, S| N| L002009A9 RB, 
( 002009A7 )                  XOR, X| T| CX'| R| CX| 
( 002009A9 )   :L002009A9    ANDI, X| R| CX| FFFF IL, 
( 002009AF )                  MOV, X| F| CX'| MEM| L0020283C L, 
( 002009B5 )                  IMULI, CX'| R| CX| 1000 IL, 
( 002009BB )                  SARI, X| R| DI| 10 IS, 
( 002009BE )                  J, S| N| L002009C2 RB, 
( 002009C0 )                  XOR, X| T| DI'| R| DI| 
( 002009C2 )   :L002009C2    MOV, X| F| DI'| MEM| L00202838 L, 
( 002009C8 )                  LEA, DI'| ZO|    [CX +4* DI] 
( 002009CB )                  ADD, X| T| DI'| MEM| L00202828 L, 
( 002009D1 )                  RET, 
( 002009D2 )   :L002009D2    OS:, 
( 002009D3 )                  LODS, X'| 
( 002009D4 )                  XCHG, B| AL'| R| AH| 
( 002009D6 )                  MOVI|X, CX| 10 IL, 
( 002009DB )   :L002009DB    OS:, 
( 002009DC )                  SHL, 1| X| R| AX| 
( 002009DE )                  J, C| N| L002009E2 RB, 
( 002009E0 )                  MOV, X| F| DX'| ZO| [DI] 
( 002009E2 )   :L002009E2    ADDSI, R| DI| 4 IS, 
( 002009E5 )                  DEC|X, CX| 
( 002009E6 )                  J, Z| N| L002009DB RB, 
( 002009E8 )                  RET, 
( 002009E9 )   :L002009E9    OS:, 
( 002009EA )                  LODS, X'| 
( 002009EB )                  XCHG, B| AL'| R| AH| 
( 002009ED )                  MOVI|X, CX| 10 IL, 
( 002009F2 )   :L002009F2    SHL, 1| X| R| AX| 
( 002009F4 )                  J, C| N| L00200A07 RB, 
( 002009F6 )                  MOV, X| F| DX'| ZO| [DI] 
( 002009F8 )                  MOV, X| F| DX'| BO| [DI] 4 B, 
( 002009FB )                  MOV, X| F| DX'| XO| [DI] 1000 L, 
( 00200A01 )                  MOV, X| F| DX'| XO| [DI] 1004 L, 
( 00200A07 )   :L00200A07    ADDSI, R| DI| 8 IS, 
( 00200A0A )                  DEC|X, CX| 
( 00200A0B )                  J, Z| N| L002009F2 RB, 
( 00200A0D )                  RET, 
( 00200A0E )   :X_emit    CALL, L002008C1 RL, 
( 00200A13 )                  PUSH|X, SI| 
( 00200A14 )                  PUSH|X, DI| 
( 00200A15 )                  PUSH|X, DX| 
( 00200A16 )                  IMULSI, AX'| R| AX| 30 IS, 
( 00200A19 )                  LEA, SI'| XO| [AX] IconImages L, 
( 00200A1F )                  CALL, L0020099A RL, 
( 00200A24 )                  MOV, X| T| DX'| MEM| L00202834 L, 
( 00200A2A )                  MOVI|X, CX| 18 IL, 
( 00200A2F )   :X_emit1    PUSH|X, CX| 
( 00200A30 )                  CALL, L002009D2 RL, 
( 00200A35 )                  ADDI, X| R| DI| 0FC0 IL, 
( 00200A3B )                  POP|X, CX| 
( 00200A3C )                  DEC|X, CX| 
( 00200A3D )                  J, Z| N| X_emit1 RB, 
( 00200A3F )                  POP|X, DX| 
( 00200A40 )                  POP|X, DI| 
( 00200A41 )                  POP|X, SI| 
( 00200A42 )                  LODS, X'| 
( 00200A43 )   :X_space    ADDI, X| MEM| L00202814 L, 00160000 IL, 
( 00200A4D )                  RET, 
( 00200A4E )   :X_2emit    PUSH|X, SI| 
( 00200A4F )                  PUSH|X, DI| 
( 00200A50 )                  PUSH|X, DX| 
( 00200A51 )                  IMULSI, AX'| R| AX| 30 IS, 
( 00200A54 )                  LEA, SI'| XO| [AX] IconImages L, 
( 00200A5A )                  CALL, L0020099A RL, 
( 00200A5F )                  MOV, X| T| DX'| MEM| L00202834 L, 
( 00200A65 )                  MOVI|X, CX| 18 IL, 
( 00200A6A )   :X_2emit1    PUSH|X, CX| 
( 00200A6B )                  CALL, L002009E9 RL, 
( 00200A70 )                  ADDI, X| R| DI| 1F80 IL, 
( 00200A76 )                  POP|X, CX| 
( 00200A77 )                  DEC|X, CX| 
( 00200A78 )                  J, Z| N| X_2emit1 RB, 
( 00200A7A )                  POP|X, DX| 
( 00200A7B )                  POP|X, DI| 
( 00200A7C )                  POP|X, SI| 
( 00200A7D )                  ADDI, X| MEM| L00202814 L, 002C0000 IL, 
( 00200A87 )                  LODS, X'| 
( 00200A88 )                  RET, 
( 00200A89 )   :X_text    CALL, L002008EB RL, 
( 00200A8E )                  MOVI, X| MEM| L00202818 L, 3 IL, 
( 00200A98 )                  MOVI, X| MEM| L0020281C L, 03F4 IL, 
( 00200AA2 )                  JMP, X_top RL, 
( 00200AA7 )   :X_line    CALL, L0020099A RL, 
( 00200AAC )                  MOV, X| T| CX'| ZO| [SI] 
( 00200AAE )                  SHL, 1| X| R| CX| 
( 00200AB0 )                  SHL, 1| X| R| CX| 
( 00200AB2 )                  SUB, X| T| DI'| R| CX| 
( 00200AB4 )                  MOV, X| T| CX'| R| AX| 
( 00200AB6 )                  MOV|TA, X'| L00202834 L, 
( 00200ABB )                  REPZ, 
( 00200ABC )                  STOS, X'| 
( 00200ABD )                  INC, X| MEM| L00202814 L, 
( 00200AC3 )                  LODS, X'| 
( 00200AC4 )                  LODS, X'| 
( 00200AC5 )                  RET, 
( 00200AC6 )   :X_box    CALL, L0020099A RL, 
( 00200ACB )                  CMPI|A, X'| 0301 IL, 
( 00200AD0 )                  J, S| Y| X_box1 RB, 
( 00200AD2 )                  MOVI|X, AX| 0300 IL, 
( 00200AD7 )   :X_box1    MOV, X| T| CX'| R| AX| 
( 00200AD9 )                  SUB, X| T| CX'| MEM| L0020283C L, 
( 00200ADF )                  J, LE| Y| X_box4 RB, 
( 00200AE1 )                  CMPI, X| ZO| [SI] 0401 IL, 
( 00200AE7 )                  J, S| Y| X_box2 RB, 
( 00200AE9 )                  MOVI, X| ZO| [SI] 0400 IL, 
( 00200AEF )   :X_box2    MOV|TA, X'| L00202838 L, 
( 00200AF4 )                  SUB, X| F| AX'| ZO| [SI] 
( 00200AF6 )                  J, LE| Y| X_box4 RB, 
( 00200AF8 )                  MOVI|X, DX| 0400 IL, 
( 00200AFD )                  SUB, X| T| DX'| ZO| [SI] 
( 00200AFF )                  SHLI, X| R| DX| 2 IS, 
( 00200B02 )                  MOV|TA, X'| L00202834 L, 
( 00200B07 )   :X_box3    PUSH|X, CX| 
( 00200B08 )                  MOV, X| T| CX'| ZO| [SI] 
( 00200B0A )                  REPZ, 
( 00200B0B )                  STOS, X'| 
( 00200B0C )                  ADD, X| T| DI'| R| DX| 
( 00200B0E )                  POP|X, CX| 
( 00200B0F )                  DEC|X, CX| 
( 00200B10 )                  J, Z| N| X_box3 RB, 
( 00200B12 )   :X_box4    LODS, X'| 
( 00200B13 )                  LODS, X'| 
( 00200B14 )                  RET, 
( 00200B15 )   :X_color0FF    LEA, SI'| BO| [SI] 0FC B, 
( 00200B18 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B1A )                  MOVI|X, AX| FFFF IL, 
( 00200B1F )                  JMP, X_color RL, 
( 00200B24 )   :X_colorF0F    LEA, SI'| BO| [SI] 0FC B, 
( 00200B27 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B29 )                  MOVI|X, AX| 00FF00FF IL, 
( 00200B2E )                  JMP, X_color RL, 
( 00200B33 )   :X_colorCCC    LEA, SI'| BO| [SI] 0FC B, 
( 00200B36 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B38 )                  MOVI|X, AX| 00C0C0C0 IL, 
( 00200B3D )                  JMP, X_color RL, 
( 00200B42 )   :X_color44F    LEA, SI'| BO| [SI] 0FC B, 
( 00200B45 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B47 )                  MOVI|X, AX| 004040FF IL, 
( 00200B4C )                  JMP, X_color RL, 
( 00200B51 )   :X_colorF00    LEA, SI'| BO| [SI] 0FC B, 
( 00200B54 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B56 )                  MOVI|X, AX| 00FF0000 IL, 
( 00200B5B )                  JMP, X_color RL, 
( 00200B60 )   :X_color80F0    LEA, SI'| BO| [SI] 0FC B, 
( 00200B63 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B65 )                  MOVI|X, AX| 8000FF00 IL, 
( 00200B6A )                  JMP, X_color RL, 
( 00200B6F )   :L00200B6F   db 0 0 0 0 0 0 0 0 0 0 
( 00200B79 )   :L00200B79   db 0 

( 00200B7A )   :L00200B7A    PUSH|X, SI| 
( 00200B7B )                  MOVI|X, CX| 0A IL, 
( 00200B80 )                  LEA, DI'| MEM| L00200B6F L, 
( 00200B86 )                  LEA, SI'| BO| [DI] 1 B, 
( 00200B89 )                  REPZ, 
( 00200B8A )                  MOVS, B'| 
( 00200B8B )                  POP|X, SI| 
( 00200B8C )                  MOV|FA, B'| L00200B79 L, 
( 00200B91 )                  LODS, X'| 
( 00200B92 )                  RET, 
( 00200B93 )   :L00200B93    LEA, SI'| BO| [SI] 0FC B, 
( 00200B96 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200B98 )                  MOVI|X, CX| 0B IL, 
( 00200B9D )                  LEA, DI'| MEM| L00200B6F L, 
( 00200BA3 )                  XOR, X| T| AX'| R| AX| 
( 00200BA5 )                  REPZ, 
( 00200BA6 )                  STOS, B'| 
( 00200BA7 )                  LODS, X'| 
( 00200BA8 )                  RET, 
( 00200BA9 )   :X_down    LEA, SI'| BO| [SI] 0FC B, 
( 00200BAC )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BAE )                  XOR, X| T| DX'| R| DX| 
( 00200BB0 )                  MOVI|X, CX| 1E IL, 
( 00200BB5 )                  DIV|AD, X| R| CX| 
( 00200BB7 )                  MOV, X| T| AX'| R| DX| 
( 00200BB9 )                  ADDI, X| R| DX| 00037FE5 IL, 
( 00200BBF )                  MOV, X| F| DX'| MEM| L00202814 L, 
( 00200BC5 )                  TEST, X| AX'| R| AX| 
( 00200BC7 )                  MOVI|X, AX| 0 IL, 
( 00200BCC )                  J, Z| N| X_down1 RB, 
( 00200BCE )                  INC|X, AX| 
( 00200BCF )   :X_down1    RET, 
( 00200BD0 )   :L00200BD0    LEA, SI'| BO| [SI] 0FC B, 
( 00200BD3 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BD5 )                  XOR, X| T| AX'| R| AX| 
( 00200BD7 )                  MOV|FA, X'| L00202814 L, 
( 00200BDC )                  CALL, X_color RL, 
( 00200BE1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200BE4 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BE6 )                  MOVI|X, AX| 0400 IL, 
( 00200BEB )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200BEE )                  MOV, X| F| AX'| ZO| [SI] 
( 00200BF0 )                  MOVI|X, AX| 0300 IL, 
( 00200BF5 )                  JMP, X_box RL, 
( 00200BFA )   :X_lm    MOV|FA, X'| L00202818 L, 
( 00200BFF )                  LODS, X'| 
( 00200C00 )                  RET, 
( 00200C01 )   :X_rm    MOV|FA, X'| L0020281C L, 
( 00200C06 )                  LODS, X'| 
( 00200C07 )                  RET, 
( 00200C08 )   :X_at    OS:, 
( 00200C09 )                  MOV|FA, X'| L00202814 L, 
( 00200C0E )                  LODS, X'| 
( 00200C0F )                  OS:, 
( 00200C10 )                  MOV|FA, X'| L00202816 L, 
( 00200C15 )                  LODS, X'| 
( 00200C16 )                  RET, 
( 00200C17 )   :X_+at    OS:, 
( 00200C18 )                  ADD, X| F| AX'| MEM| L00202814 L, 
( 00200C1E )                  LODS, X'| 
( 00200C1F )                  OS:, 
( 00200C20 )                  ADD, X| F| AX'| MEM| L00202816 L, 
( 00200C26 )                  LODS, X'| 
( 00200C27 )                  RET, 
( 00200C28 )   :X_octant    LEA, SI'| BO| [SI] 0FC B, 
( 00200C2B )                  MOV, X| F| AX'| ZO| [SI] 
( 00200C2D )                  MOVI|X, AX| 43 IL, 
( 00200C32 )                  MOV, X| T| DX'| BO| [SI] 4 B, 
( 00200C35 )                  TEST, X| DX'| R| DX| 
( 00200C37 )                  J, S| N| X_octant1 RB, 
( 00200C39 )                  NEG, X| R| DX| 
( 00200C3B )                  MOV, X| F| DX'| BO| [SI] 4 B, 
( 00200C3E )                  XORI|A, B'| 1 IB, 
( 00200C40 )   :X_octant1    CMP, X| T| DX'| ZO| [SI] 
( 00200C42 )                  J, S| N| X_octant2 RB, 
( 00200C44 )                  XORI|A, B'| 4 IB, 
( 00200C46 )   :X_octant2    RET, 
( 00200C47 )   :digitChars   db 18 19 1A 1B 1C 1D 1E 1F 20 21 5 13 0A 10 4 0E 

( 00200C57 )   :L00200C57    LEA, SI'| BO| [SI] 0FC B, 
( 00200C5A )                  MOV, X| F| AX'| ZO| [SI] 
( 00200C5C )   :X_digit    PUSH|X, CX| 
( 00200C5D )                  MOV, B| T| AL'| XO| [AX] digitChars L, 
( 00200C63 )                  CALL, X_emit RL, 
( 00200C68 )                  POP|X, CX| 
( 00200C69 )                  RET, 
( 00200C6A )   :L00200C6A    ROLI, X| R| AX| 4 IS, 
( 00200C6D )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200C70 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200C72 )                  ANDSI, R| AX| 0F IS, 
( 00200C75 )                  RET, 
( 00200C76 )   :X_h.n    MOV, X| T| DX'| R| AX| 
( 00200C78 )                  NEG, X| R| AX| 
( 00200C7A )                  LEA, CX'| ZO|    [MEM +4* AX] 20 L, 
( 00200C81 )                  LODS, X'| 
( 00200C82 )                  ROL, V| X| R| AX| 
( 00200C84 )                  MOV, X| T| CX'| R| DX| 
( 00200C86 )                  JMPS, X_h.1 RB, 
( 00200C88 )   :X_h.    MOVI|X, CX| 8 IL, 
( 00200C8D )   :X_h.1    CALL, L00200C6A RL, 
( 00200C92 )                  CALL, X_digit RL, 
( 00200C97 )                  DEC|X, CX| 
( 00200C98 )                  J, Z| N| X_h.1 RB, 
( 00200C9A )                  LODS, X'| 
( 00200C9B )                  RET, 
( 00200C9C )   :L00200C9C    MOVI|X, CX| 7 IL, 
( 00200CA1 )   :L00200CA1    CALL, L00200C6A RL, 
( 00200CA6 )                  J, Z| N| L00200CC1 RB, 
( 00200CA8 )                  LODS, X'| 
( 00200CA9 )                  DEC|X, CX| 
( 00200CAA )                  J, Z| N| L00200CA1 RB, 
( 00200CAC )                  INC|X, CX| 
( 00200CAD )   :L00200CAD    CALL, L00200C6A RL, 
( 00200CB2 )   :L00200CB2    CALL, X_digit RL, 
( 00200CB7 )                  DEC|X, CX| 
( 00200CB8 )                  J, Z| N| L00200CAD RB, 
( 00200CBA )                  CALL, X_space RL, 
( 00200CBF )                  LODS, X'| 
( 00200CC0 )                  RET, 
( 00200CC1 )   :L00200CC1    INC|X, CX| 
( 00200CC2 )                  JMPS, L00200CB2 RB, 
( 00200CC4 )   :X_?.    CMPSI, MEM| L00202770 L, 0A IS, 
( 00200CCB )                  J, Z| N| L00200C9C RB, 
( 00200CCD )   :X_.    MOV, X| T| DX'| R| AX| 
( 00200CCF )                  TEST, X| DX'| R| DX| 
( 00200CD1 )                  J, S| N| X_.1 RB, 
( 00200CD3 )                  NEG, X| R| DX| 
( 00200CD5 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200CD8 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200CDA )                  MOVI|X, AX| 23 IL, 
( 00200CDF )                  CALL, X_emit RL, 
( 00200CE4 )   :X_.1    MOVI|X, CX| 8 IL, 
( 00200CE9 )   :X_.2    MOV, X| T| AX'| R| DX| 
( 00200CEB )                  XOR, X| T| DX'| R| DX| 
( 00200CED )                  DIV|AD, X| ZO|    [MEM +4* CX] FixedData L, 
( 00200CF4 )                  TEST, X| AX'| R| AX| 
( 00200CF6 )                  J, Z| N| X_.4 RB, 
( 00200CF8 )                  DEC|X, CX| 
( 00200CF9 )                  J, S| N| X_.2 RB, 
( 00200CFB )                  JMPS, X_.5 RB, 
( 00200CFD )   :X_.3    MOV, X| T| AX'| R| DX| 
( 00200CFF )                  XOR, X| T| DX'| R| DX| 
( 00200D01 )                  DIV|AD, X| ZO|    [MEM +4* CX] FixedData L, 
( 00200D08 )   :X_.4    CALL, L00200C57 RL, 
( 00200D0D )                  DEC|X, CX| 
( 00200D0E )                  J, S| N| X_.3 RB, 
( 00200D10 )   :X_.5    MOV, X| T| AX'| R| DX| 
( 00200D12 )                  CALL, L00200C57 RL, 
( 00200D17 )                  CALL, X_space RL, 
( 00200D1C )                  LODS, X'| 
( 00200D1D )                  RET, 
( 00200D1E )   :L00200D1E    ADDSI, R| DI| 0C IS, 
( 00200D21 )                  CALL, L00200D2E RL, 
( 00200D26 )                  CALL, X_space RL, 
( 00200D2B )                  SUBSI, R| DI| 10 IS, 
( 00200D2E )   :L00200D2E    MOVI|X, CX| 4 IL, 
( 00200D33 )   :L00200D33    PUSH|X, CX| 
( 00200D34 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200D37 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200D39 )                  XOR, X| T| AX'| R| AX| 
( 00200D3B )                  MOV, B| T| AL'| BO| [DI] 4 B, 
( 00200D3E )                  INC|X, DI| 
( 00200D3F )                  CALL, X_emit RL, 
( 00200D44 )                  POP|X, CX| 
( 00200D45 )                  DEC|X, CX| 
( 00200D46 )                  J, Z| N| L00200D33 RB, 
( 00200D48 )                  RET, 
( 00200D49 )   :L00200D49    MOVI|X, DI| 0009F3FC IL, 
( 00200D4E )   :L00200D4E    MOV, X| T| DX'| MEM| L00200446 L, 
( 00200D54 )                  CMP, X| F| DI'| ZO| [DX] 
( 00200D56 )                  J, C| N| 11 (RB,) 
( 00200D58 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200D5B )                  MOV, X| F| AX'| ZO| [SI] 
( 00200D5D )                  MOV, X| T| AX'| ZO| [DI] 
( 00200D5F )                  SUBSI, R| DI| 4 IS, 
( 00200D62 )                  CALL, X_?. RL, 
( 00200D67 )   :L00200D67    JMPS, L00200D4E RB, 
( 00200D69 )                  RET, 
( 00200D6A )                 db 49 0D 20 0 0 0F4 9 0 46 4 20 0 92 4 20 0 

( 00200D7A )   :X_keybo    CALL, X_text RL, 
( 00200D7F )                  MOV, X| T| DI'| MEM| L00202768 L, 
( 00200D85 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00200D88 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200D8A )                  MOV|TA, X'| L00202778 L, 
( 00200D8F )                  CALL, X_color RL, 
( 00200D94 )                  MOV|TA, X'| L00202760 L, 
( 00200D99 )                  ADDSI, R| AX| 0 IS, 
( 00200D9C )                  MOV|FA, X'| L00202818 L, 
( 00200DA1 )                  MOV, X| T| DX'| R| AX| 
( 00200DA3 )                  ADDI, X| R| DX| 0C6 IL, 
( 00200DA9 )                  MOV, X| F| DX'| MEM| L0020281C L, 
( 00200DAF )                  SHLI, X| R| AX| 10 IS, 
( 00200DB2 )                  ADD, X| T| AX'| MEM| L00202764 L, 
( 00200DB8 )                  MOV|FA, X'| L00202814 L, 
( 00200DBD )                  CALL, L00200D1E RL, 
( 00200DC2 )                  CALL, L00200D1E RL, 
( 00200DC7 )                  CALL, L00200D1E RL, 
( 00200DCC )                  CALL, X_cr RL, 
( 00200DD1 )                  ADDI, X| MEM| L00202814 L, 00580000 IL, 
( 00200DDB )                  MOV, X| T| DI'| MEM| L0020276C L, 
( 00200DE1 )                  ADDSI, R| DI| 0C IS, 
( 00200DE4 )                  MOVI|X, CX| 3 IL, 
( 00200DE9 )                  CALL, L00200D33 RL, 
( 00200DEE )                  OS:, 
( 00200DEF )                  SUBSI, MEM| L00202814 L, 1E IS, 
( 00200DF6 )                  OS:, 
( 00200DF7 )                  MOVI, X| MEM| L00202816 L, 0235 IW, 
( 00200DFF )                  LEA, DI'| MEM| 00200B6B L, 
( 00200E05 )                  MOVI|X, CX| 0B IL, 
( 00200E0A )                  CALL, L00200D33 RL, 
( 00200E0F )                  OS:, 
( 00200E10 )                  MOVI, X| MEM| L00202818 L, 3 IW, 
( 00200E18 )                  OS:, 
( 00200E19 )                  MOVI, X| MEM| L00202816 L, 3 IW, 
( 00200E21 )                 db 0FF 15 76 0D 20 0 8D 76 0FC 89 6 0B8 0 0FF 0FF 0 
( 00200E31 )                 db 0E8 0BF 
( 00200E33 )   :L00200E33   db 0FA 0FF 0FF 66 83 5 14 28 20 0 1E 0C7 5 18 
( 00200E41 )                 db 28 20 0 3 0 0 0 66 0C7 5 
( 00200E4B )   :L00200E4B   db 16 28 20 0 3 0 
( 00200E51 )                 db 0FF 25 
( 00200E53 )   :L00200E53   db 6A 0D 20 0 0D 0A 1 0C 14 2 6 8 13 9 
( 00200E61 )                 db 0F 11 
( 00200E63 )   :L00200E63   db 12 0B 0E 7 5 3 4 16 17 24 15 10 19 1A 
( 00200E71 )                 db 1B 0 1C 1D 1E 18 1F 20 21 2F 29 28 
( 00200E7D )   :L00200E7D   db 2A 2C 

( 00200E7F )   :L00200E7F   db 26 22 25 2E 2D 27 2B 23 19 1A 1B 0 1C 
( 00200E8C )   :L00200E8C   db 1D 1E 18 
( 00200E8F )                 db 1F 20 21 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00200E9F )                 db 19 1A 1B 0 1C 1D 1E 18 1F 20 21 0 0 5 13 0A 
( 00200EAF )                 db 0 10 4 0E 0 0 
( 00200EB5 )   :L00200EB5   db 0 0 

( 00200EB7 )   :L00200EB7    CMPI|A, B'| 4 IB, 
( 00200EB9 )                  J, S| Y| 9 (RB,) 
( 00200EBB )                  MOV, X| T| DX'| MEM| L00202768 L, 
( 00200EC1 )                  MOV, B| T| AL'| ZO|    [AX +1* DX] 
( 00200EC4 )                  RET, 
( 00200EC5 )                 dl 13121110 05040000 0706 15140000 
( 00200ED5 )                 dl 1716 0B0A0908 0 1B1A1918 
( 00200EE5 )                 dl 0D0C0100 0F0E 768D0203 

( 00200EF1 )   :L00200EF1    CLD, 
( 00200EF2 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200EF4 )                  XOR, X| T| AX'| R| AX| 
( 00200EF6 )                  CALL, X_pause RL, 
( 00200EFB )   :L00200EFB    IN|P, B'| 64 P, 
( 00200EFD )                  TESTI|A, B'| 1 IB, 
( 00200EFF )                  J, Z| Y| L00200EFB RB, 
( 00200F01 )                  IN|P, B'| 60 P, 
( 00200F03 )                  TESTI|A, B'| 0F0 IB, 
( 00200F05 )                  J, Z| Y| L00200EFB RB, 
( 00200F07 )                  CMPI|A, B'| 3A IB, 
( 00200F09 )                  J, C| N| L00200EFB RB, 
( 00200F0B )                  MOV, B| T| AL'| XO| [AX] L00200EB5 L, 
( 00200F11 )                  RET, 
( 00200F12 )                 db 90 0 0B 18 2 19 3 1A 4 1B 5 1C 6 1D 7 1E 
( 00200F22 )                 db 8 1F 9 20 0A 21 1E 5 30 13 2E 0A 20 10 12 4 
( 00200F32 )                 db 21 0E 22 0D 23 14 17 7 24 22 25 24 26 0C 32 9 
( 00200F42 )                 db 31 6 18 3 19 12 10 17 13 1 1F 8 14 2 16 16 
( 00200F52 )                 db 2F 11 11 0F 2D 15 15 0B 2C 26 0C 23 34 25 35 27 
( 00200F62 )                 db 27 28 28 29 82 2A 8D 2B 83 2C 89 2D 33 2E 0B5 2F 
( 00200F72 )                 db 39 80 1C 81 0E 82 1 83 3B 84 29 30 

( 00200F7E )   :X_qkey    LEA, SI'| BO| [SI] 0FC B, 
( 00200F81 )                  MOV, X| F| AX'| ZO| [SI] 
( 00200F83 )                  XOR, X| T| AX'| R| AX| 
( 00200F85 )                  CALL, X_pause RL, 
( 00200F8A )   :X_qkey1    IN|P, B'| 64 P, 
( 00200F8C )                  TESTI|A, B'| 1 IB, 
( 00200F8E )                  J, Z| Y| X_qkey1 RB, 
( 00200F90 )                  IN|P, B'| 60 P, 
( 00200F92 )                  MOV, X| T| CX'| R| AX| 
( 00200F94 )                  ANDI, B| R| CL| 7F IB, 
( 00200F97 )                  CMPI, B| R| CL| 2A IB, 
( 00200F9A )                  J, Z| Y| X_qkey2 RB, 
( 00200F9C )                  CMPI, B| R| CL| 36 IB, 
( 00200F9F )                  J, Z| N| X_qkey3 RB, 
( 00200FA1 )   :X_qkey2    ANDI|A, B'| 80 IB, 
( 00200FA3 )                  XORI|A, B'| 80 IB, 
( 00200FA5 )                  MOV|FA, X'| L0020278C L, 
( 00200FAA )                  JMPS, X_qkey1 RB, 
( 00200FAC )   :X_qkey3    OR, B| T| AL'| R| AL| 
( 00200FAE )                  J, S| Y| X_qkey1 RB, 
( 00200FB0 )                  ANDI|A, B'| 7F IB, 
( 00200FB2 )                  OR, X| T| AX'| MEM| L0020278C L, 
( 00200FB8 )                  MOVI|X, DX| 00200F14 IL, 
( 00200FBD )                  MOVI|X, CX| 35 IL, 
( 00200FC2 )   :X_qkey4    CMP, B| F| AL'| ZO| [DX] 
( 00200FC4 )                  J, Z| Y| X_qkey5 RB, 
( 00200FC6 )                  ADDSI, R| DX| 2 IS, 
( 00200FC9 )                  LOOP, X_qkey4 RB, 
( 00200FCB )                  XOR, X| T| AX'| R| AX| 
( 00200FCD )                  RET, 
( 00200FCE )   :X_qkey5    MOV, B| T| AL'| BO| [DX] 1 B, 
( 00200FD1 )                  SUBI, X| R| DX| 00200F14 IL, 
( 00200FD7 )                  SHR, 1| X| R| DX| 
( 00200FD9 )                  MOV, X| F| DX'| MEM| L00202790 L, 
( 00200FDF )                  TESTI|A, X'| 80 IL, 
( 00200FE4 )                  RET, 
( 00200FE5 )   :L00200FE5   db 1F 12 20 0 1F 12 20 0 1F 12 20 0 71 12 20 0 
( 00200FF5 )                 db 0 0 5 0 
( 00200FF9 )   :L00200FF9   db 2C 11 20 0 0C4 10 20 0 6A 10 20 0 
( 00201005 )                 db 96 12 20 0 15 25 5 0 
( 0020100D )   :L0020100D   db 1F 12 20 0 
( 00201011 )   :L00201011   db 1F 12 20 0 
( 00201015 )                 db 5D 11 20 0 83 12 20 0 
( 0020101D )   :L0020101D   db 0 21 2D 0 
( 00201021 )   :L00201021   db 2C 11 20 0 
( 00201025 )                 db 0C4 10 20 0 6A 10 20 0 0A8 12 20 0 15 25 2D 0 
( 00201035 )   :L00201035   db 1F 12 20 0 53 11 20 0 70 12 20 0 
( 00201041 )   :L00201041   db 0FB 11 20 0 
( 00201045 )                 db 23 5 
( 00201047 )   :L00201047   db 0E 0 
( 00201049 )   :L00201049   db 5A 11 20 0 17 12 20 0 0B0 11 20 0 
( 00201055 )                 db 5A 11 20 0 15 25 0 0 
( 0020105D )   :L0020105D   db 1C 

( 0020105E )   :L0020105E    MOV, B| T| CL'| MEM| L0020105D L, 
( 00201064 )                  ADDI, B| R| CL| 4 IB, 
( 00201067 )                  SHL, V| X| ZO| [SI] 
( 00201069 )                  RET, 
( 0020106A )   :L0020106A    CALL, L0020105E RL, 
( 0020106F )                  LODS, X'| 
( 00201070 )                  RET, 
( 00201071 )   :L00201071    CALL, L0020105E RL, 
( 00201076 )                  INC, X| MEM| L00202788 L, 
( 0020107C )                  MOVI, B| MEM| L0020105D L, 1C IB, 
( 00201083 )                  SUB, B| F| CH'| MEM| L0020105D L, 
( 00201089 )                  MOV, X| T| AX'| R| DX| 
( 0020108B )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020108E )                  MOV, X| F| AX'| ZO| [SI] 
( 00201090 )                  RET, 
( 00201091 )   :L00201091    ADDSI, R| AX| 50 IS, 
( 00201094 )                  MOVI|B, CL| 7 IB, 
( 00201096 )                  JMPS, L002010A5 RB, 
( 00201098 )   :L00201098    CMPI|A, B'| 10 IB, 
( 0020109A )                  J, C| N| L00201091 RB, 
( 0020109C )                  MOVI|B, CL| 4 IB, 
( 0020109E )                  TESTI|A, B'| 8 IB, 
( 002010A0 )                  J, Z| Y| L002010A5 RB, 
( 002010A2 )                  INC|X, CX| 
( 002010A3 )                  XORI|A, B'| 18 IB, 
( 002010A5 )   :L002010A5    MOV, X| T| DX'| R| AX| 
( 002010A7 )                  MOV, B| T| CH'| R| CL| 
( 002010A9 )   :L002010A9    CMP, B| F| CL'| MEM| L0020105D L, 
( 002010AF )                  J, C| N| L002010B9 RB, 
( 002010B1 )                  SHR, 1| B| R| AL| 
( 002010B3 )                  J, C| Y| L00201071 RB, 
( 002010B5 )                  DEC, B| R| CL| 
( 002010B7 )                  JMPS, L002010A9 RB, 
( 002010B9 )   :L002010B9    SHL, V| X| ZO| [SI] 
( 002010BB )                  XOR, X| F| AX'| ZO| [SI] 
( 002010BD )                  SUB, B| F| CL'| MEM| L0020105D L, 
( 002010C3 )                  RET, 
( 002010C4 )   :L002010C4    CALL, L00200B93 RL, 
( 002010C9 )                  MOV|TA, X'| L00202788 L, 
( 002010CE )                  LEA, SI'| ZO|    [SI +4* AX] 
( 002010D1 )                  LODS, X'| 
( 002010D2 )                  JMPO, MEM| L00202750 L, 
( 002010D8 )   :L002010D8    CALL, L00200B93 RL, 
( 002010DD )                  MOVI, X| MEM| L00202788 L, 1 IL, 
( 002010E7 )                  MOVI, X| MEM| L0020277C L, 1 IL, 
( 002010F1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002010F4 )                  MOV, X| F| AX'| ZO| [SI] 
( 002010F6 )                  MOVI, X| ZO| [SI] 0 IL, 
( 002010FC )                  MOVI, B| MEM| L0020105D L, 1C IB, 
( 00201103 )   :L00201103    CALL, L00200EB7 RL, 
( 00201108 )                  J, S| N| L00201113 RB, 
( 0020110A )                  MOV, X| T| DX'| MEM| L0020276C L, 
( 00201110 )                  JMPO, ZO|    [DX +4* AX] 
( 00201113 )   :L00201113    TEST, B| AL'| R| AL| 
( 00201115 )                  J, Z| Y| 15 (RB,) 
( 00201117 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020111A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020111C )                  CALL, L00200B7A RL, 
( 00201121 )                  CALL, L00201098 RL, 
( 00201126 )                  INC, X| MEM| L0020277C L, 
( 0020112C )                  LODS, X'| 
( 0020112D )                  CALL, -243 (RL,) 
( 00201132 )                  JMPS, L00201103 RB, 
( 00201134 )                 db 0E 0A 0 0 0 0 0C 0 0 0 0F 0 0D 0 0 0B 
( 00201144 )                 db 0 0 0 0 0 1 2 3 4 5 6 7 8 9 
( 00201152 )   :L00201152   db 0 

( 00201153 )   :L00201153    MOV|FA, B'| L00201152 L, 
( 00201158 )                  JMPS, L002011A3 RB, 
( 0020115A )   :L0020115A    LODS, X'| 
( 0020115B )                  JMPS, L0020116C RB, 
( 0020115D )   :L0020115D    CALLO, MEM| L00202774 L, 
( 00201163 )                  MOVI, B| MEM| L00201152 L, 0 IB, 
( 0020116A )                  XOR, X| T| AX'| R| AX| 
( 0020116C )   :L0020116C    CALL, -282 (RL,) 
( 00201171 )                  CALL, L00200EB7 RL, 
( 00201176 )                  J, S| N| L00201181 RB, 
( 00201178 )                  MOV, X| T| DX'| MEM| L0020276C L, 
( 0020117E )                  JMPO, ZO|    [DX +4* AX] 
( 00201181 )   :L00201181    TEST, B| AL'| R| AL| 
( 00201183 )                  J, Z| Y| L0020115A RB, 
( 00201185 )                  MOV, B| T| AL'| XO| [AX] 00201130 L, 
( 0020118B )                  TESTI, B| MEM| L00201152 L, 1F IB, 
( 00201192 )                  J, Z| Y| L00201196 RB, 
( 00201194 )                  NEG, X| R| AX| 
( 00201196 )   :L00201196    MOV, X| T| DX'| ZO| [SI] 
( 00201198 )                  IMUL, DX'| MEM| L00202770 L, 
( 0020119F )                  ADD, X| T| DX'| R| AX| 
( 002011A1 )                  MOV, X| F| DX'| ZO| [SI] 
( 002011A3 )   :L002011A3    LODS, X'| 
( 002011A4 )                  MOVI, X| MEM| L0020276C L, L00201049 IL, 
( 002011AE )                  JMPS, L0020116C RB, 
( 002011B0 )   :L002011B0    LODS, X'| 
( 002011B1 )                  CALLO, MEM| L00202784 L, 
( 002011B7 )                  JMPO, MEM| L00202750 L, 
( 002011BD )   :L002011BD    MOVI, X| MEM| L00202770 L, 0A IL, 
( 002011C7 )                  MOVI, X| MEM| L0020276C L, L00201035 IL, 
( 002011D1 )                  MOVI, X| MEM| L00202768 L, 00200E83 IL, 
( 002011DB )                  RET, 
( 002011DC )   :L002011DC    MOVI, X| MEM| L00202770 L, 10 IL, 
( 002011E6 )                  MOVI, X| MEM| L0020276C L, L00201035 IL, 
( 002011F0 )                  MOVI, X| MEM| L00202768 L, 00200E9B IL, 
( 002011FA )                  RET, 
( 002011FB )   :L002011FB    XORI, X| MEM| L00202774 L, 61 IL, 
( 00201205 )                  XORI, B| MEM| L00201047 L, 2F IB, 
( 0020120C )                  CALLO, MEM| L00202774 L, 
( 00201212 )                  JMP, L0020115A RL, 
( 00201217 )   :L00201217    LODS, X'| 
( 00201218 )                  LODS, X'| 
( 00201219 )                  JMPO, MEM| L00202750 L, 
( 0020121F )   :L0020121F    LODS, X'| 
( 00201220 )                  JMPS, X_accept2 RB, 
( 00201222 )   :X_accept    MOVI, X| MEM| L0020276C L, L0020100D IL, 
( 0020122C )                  LEA, DI'| MEM| L00200E53 L, 
( 00201232 )   :X_accept1    MOV, X| F| DI'| MEM| L00202768 L, 
( 00201238 )   :X_accept2    TESTI, X| MEM| L00202754 L, -1 IL, 
( 00201242 )                  J, Z| Y| X_accept3 RB, 
( 00201244 )                  JMPO, MEM| L00202754 L, 
( 0020124A )   :X_accept3    CALL, -360 (RL,) 
( 0020124F )                  CMPI|A, B'| 4 IB, 
( 00201251 )                  J, S| N| X_accept4 RB, 
( 00201253 )                  MOV, X| T| DX'| MEM| L0020276C L, 
( 00201259 )                  JMPO, ZO|    [DX +4* AX] 
( 0020125C )   :X_accept4    ADDSI, MEM| L0020276C L, 14 IS, 
( 00201263 )                  CALL, L002010D8 RL, 
( 00201268 )                  CALLO, MEM| L00202780 L, 
( 0020126E )                  JMPS, X_accept RB, 
( 00201270 )   :L00201270    LODS, X'| 
( 00201271 )   :L00201271    MOVI, X| MEM| L0020276C L, L0020100D IL, 
( 0020127B )                  LEA, DI'| MEM| L00200E53 L, 
( 00201281 )                  JMPS, L00201293 RB, 
( 00201283 )   :L00201283    MOVI, X| MEM| L0020276C L, L00200FE5 IL, 
( 0020128D )                  LEA, DI'| MEM| 00200E6B L, 
( 00201293 )   :L00201293    LODS, X'| 
( 00201294 )                  JMPS, X_accept1 RB, 
( 00201296 )   :L00201296    MOVI, X| MEM| L0020276C L, L00201021 IL, 
( 002012A0 )                  LEA, DI'| MEM| L00200E53 L, 
( 002012A6 )                  JMPS, L002012B8 RB, 
( 002012A8 )   :L002012A8    MOVI, X| MEM| L0020276C L, L00200FF9 IL, 
( 002012B2 )                  LEA, DI'| MEM| 00200E6B L, 
( 002012B8 )   :L002012B8    MOV, X| F| DI'| MEM| L00202768 L, 
( 002012BE )                  JMP, -197 (RL,) 
( 002012C3 )   :X_unpac    LEA, SI'| BO| [SI] 0FC B, 
( 002012C6 )                  MOV, X| F| AX'| ZO| [SI] 
( 002012C8 )                  TEST, X| AX'| R| AX| 
( 002012CA )                  J, S| Y| X_unpac1 RB, 
( 002012CC )                  SHLI, X| ZO| [SI] 4 IS, 
( 002012CF )                  ROLI, X| R| AX| 4 IS, 
( 002012D2 )                  ANDSI, R| AX| 7 IS, 
( 002012D5 )                  RET, 
( 002012D6 )   :X_unpac1    SHL, 1| X| R| AX| 
( 002012D8 )                  J, S| Y| X_unpac2 RB, 
( 002012DA )                  SHLI, X| ZO| [SI] 5 IS, 
( 002012DD )                  ROLI, X| R| AX| 4 IS, 
( 002012E0 )                  ANDSI, R| AX| 7 IS, 
( 002012E3 )                  XORI|A, B'| 8 IB, 
( 002012E5 )                  RET, 
( 002012E6 )   :X_unpac2    SHLI, X| ZO| [SI] 7 IS, 
( 002012E9 )                  ROLI, X| R| AX| 6 IS, 
( 002012EC )                  ANDSI, R| AX| 3F IS, 
( 002012EF )                  SUBI|A, B'| 10 IB, 
( 002012F1 )                  RET, 
( 002012F2 )   :L002012F2    LEA, SI'| BO| [SI] 0FC B, 
( 002012F5 )                  MOV, X| F| AX'| ZO| [SI] 
( 002012F7 )                  INC, X| ZO| [SI] 
( 002012F9 )                  CMP, X| F| DI'| MEM| L00202734 L, 
( 002012FF )                  J, Z| N| L00201306 RB, 
( 00201301 )                  MOV|FA, X'| L00202734 L, 
( 00201306 )   :L00201306    CMP, X| T| AX'| MEM| L00202734 L, 
( 0020130C )                  J, Z| Y| 10 (RB,) 
( 0020130E )                  J, S| N| C (RB,) 
( 00201310 )                  MOV, X| F| DI'| MEM| L0020273C L, 
( 00201316 )   :L00201316    MOV, X| F| DI'| MEM| L00202738 L, 
( 0020131C )                  LODS, X'| 
( 0020131D )                  RET, 
( 0020131E )                  MOV, X| F| DI'| MEM| L00202738 L, 
( 00201324 )                  SUBI, X| MEM| L00202814 L, 00160000 IL, 
( 0020132E )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201331 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201333 )                  MOVI|X, AX| 00E04000 IL, 
( 00201338 )                  CALL, X_color RL, 
( 0020133D )                  MOVI|X, AX| 30 IL, 
( 00201342 )                  OS:, 
( 00201343 )                  MOV, X| T| CX'| MEM| L00202816 L, 
( 00201349 )                  OS:, 
( 0020134A )                  CMP, X| T| CX'| MEM| L0020281C L, 
( 00201350 )                  J, S| Y| 10 (RB,) 
( 00201352 )                  CALL, X_emit RL, 
( 00201357 )                  SUBI, X| MEM| L00202814 L, 00160000 IL, 
( 00201361 )   :L00201361    RET, 
( 00201362 )                  JMP, X_emit RL, 
( 00201367 )   :L00201367    CALL, L002008EB RL, 
( 0020136C )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020136F )                  MOV, X| F| AX'| ZO| [SI] 
( 00201371 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 00201378 )                  ANDSI, R| AX| 0F0 IS, 
( 0020137B )                  CALL, X_unpac RL, 
( 00201380 )                  J, Z| Y| 7 (RB,) 
( 00201382 )                  CALL, X_emit RL, 
( 00201387 )                  JMPS, -E (RB,) 
( 00201389 )                  CALL, X_space RL, 
( 0020138E )                  LODS, X'| 
( 0020138F )                  LODS, X'| 
( 00201390 )                  RET, 
( 00201391 )   :L00201391    OS:, 
( 00201392 )                  MOV, X| T| CX'| MEM| L00202816 L, 
( 00201398 )                  OS:, 
( 00201399 )                  CMP, X| T| CX'| MEM| L00202818 L, 
( 0020139F )                  J, Z| Y| 5 (RB,) 
( 002013A1 )                  CALL, X_cr RL, 
( 002013A6 )                  CALL, X_colorF00 RL, 
( 002013AB )                  JMPS, -41 (RB,) 
( 002013AD )   :L002013AD    CALL, X_color80F0 RL, 
( 002013B2 )                  JMPS, -48 (RB,) 
( 002013B4 )   :L002013B4    CALL, X_color0FF RL, 
( 002013B9 )                  JMPS, -4F (RB,) 
( 002013BB )   :L002013BB    LEA, SI'| BO| [SI] 0FC B, 
( 002013BE )                  MOV, X| F| AX'| ZO| [SI] 
( 002013C0 )                  MOVI|X, AX| 00FFFF00 IL, 
( 002013C5 )                  CALL, X_color RL, 
( 002013CA )                  JMPS, -60 (RB,) 
( 002013CC )   :L002013CC    CALL, L002008EB RL, 
( 002013D1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002013D4 )                  MOV, X| F| AX'| ZO| [SI] 
( 002013D6 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002013DD )                  ANDSI, R| AX| 0F0 IS, 
( 002013E0 )                  CALL, X_unpac RL, 
( 002013E5 )                  ADDI|A, B'| 30 IB, 
( 002013E7 )                  CALL, X_emit RL, 
( 002013EC )                  JMPS, -73 (RB,) 
( 002013EE )   :L002013EE    CALL, L002008EB RL, 
( 002013F3 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002013F6 )                  MOV, X| F| AX'| ZO| [SI] 
( 002013F8 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 002013FF )                  ANDSI, R| AX| 0F0 IS, 
( 00201402 )                  CALL, X_unpac RL, 
( 00201407 )                  J, Z| Y| -80 (RB,) 
( 00201409 )                  ADDI|A, B'| 30 IB, 
( 0020140B )                  CALL, X_emit RL, 
( 00201410 )                  JMPS, -10 (RB,) 
( 00201412 )   :L00201412    SUBI, X| MEM| L00202814 L, 00160000 IL, 
( 0020141C )                  TESTI, X| ZO|    [MEM +4* DI] -4 L, -10 IL, 
( 00201427 )                  J|X, Z| N| -C1 (RL,) 
( 0020142D )                  DEC|X, DI| 
( 0020142E )                  MOV, X| F| DI'| MEM| L00202740 L, 
( 00201434 )                  CALL, X_space RL, 
( 00201439 )                  CALL, L002012F2 RL, 
( 0020143E )                  POP|X, DX| 
( 0020143F )                  LODS, X'| 
( 00201440 )                  RET, 
( 00201441 )   :L00201441    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 00201448 )                  SARI, X| R| DX| 5 IS, 
( 0020144B )                  JMPS, 1C (RB,) 
( 0020144D )   :L0020144D    MOVI, X| MEM| L00202724 L, X_. IL, 
( 00201457 )                  CALL, X_colorF0F RL, 
( 0020145C )                  CALL, -F5 (RL,) 
( 00201461 )   :L00201461    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 00201468 )                  INC|X, DI| 
( 00201469 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020146C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020146E )                  MOVI|X, AX| F800 IL, 
( 00201473 )                  CMPI, X| MEM| L00202724 L, X_. IL, 
( 0020147D )                  J, Z| Y| 36 (RB,) 
( 0020147F )                  MOVI|X, AX| C000 IL, 
( 00201484 )                  JMPS, 2F (RB,) 
( 00201486 )   :L00201486    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 0020148D )                  SARI, X| R| DX| 5 IS, 
( 00201490 )                  JMPS, 8 (RB,) 
( 00201492 )   :L00201492    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 00201499 )                  INC|X, DI| 
( 0020149A )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020149D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020149F )                  MOVI|X, AX| 00FFFF00 IL, 
( 002014A4 )                  CMPI, X| MEM| L00202724 L, X_. IL, 
( 002014AE )                  J, Z| Y| 5 (RB,) 
( 002014B0 )                  MOVI|X, AX| 00C0C000 IL, 
( 002014B5 )                  CALL, X_color RL, 
( 002014BA )                  LEA, SI'| BO| [SI] 0FC B, 
( 002014BD )                  MOV, X| F| AX'| ZO| [SI] 
( 002014BF )                  MOV, X| T| AX'| R| DX| 
( 002014C1 )   :L002014C1    JMPO, MEM| L00202724 L, 
( 002014C7 )   :L002014C7    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 002014CE )                  SARI, X| R| DX| 5 IS, 
( 002014D1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002014D4 )                  MOV, X| F| AX'| ZO| [SI] 
( 002014D6 )                  MOVI|X, AX| 00FFFFFF IL, 
( 002014DB )                  CMPI, X| MEM| L00202724 L, X_. IL, 
( 002014E5 )                  J, Z| Y| 5 (RB,) 
( 002014E7 )                  MOVI|X, AX| 00C0C0C0 IL, 
( 002014EC )                  JMPS, -39 (RB,) 
( 002014EE )   :L002014EE   dw 0000 

( 002014F0 )                 dl L00201412 L002013BB L00201492 L00201391 
( 00201500 )                 dl L002013AD L00201461 L00201441 L002013B4 
( 00201510 )                 dl L00201486 L00201367 L002013CC L002013EE 
( 00201520 )                 dl L0020144D X_nul X_nul L002014C7 

( 00201530 )   :X_+list    CALL, X_text RL, 
( 00201535 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201538 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020153A )                  XOR, X| T| AX'| R| AX| 
( 0020153C )                  MOV, X| T| DI'| MEM| L00202728 L, 
( 00201542 )                  ADD, X| T| DI'| MEM| L00202748 L, 
( 00201548 )                  SHLI, X| R| DI| 8 IS, 
( 0020154B )                  MOV, X| F| DI'| MEM| L0020273C L, 
( 00201551 )                  MOV, X| F| DI'| MEM| L00202738 L, 
( 00201557 )                  TESTI, X| ZO|    [MEM +4* DI] 0 L, 0F IL, 
( 00201562 )                  J, Z| Y| 5 (RB,) 
( 00201564 )                  CALL, L002012F2 RL, 
( 00201569 )                  MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 00201570 )                  INC|X, DI| 
( 00201571 )                  MOVI, X| MEM| L00202724 L, X_. IL, 
( 0020157B )                  TESTI, B| R| DL| 10 IB, 
( 0020157E )                  J, Z| Y| A (RB,) 
( 00201580 )                  MOVI, X| MEM| L00202724 L, L00200C9C IL, 
( 0020158A )                  ANDSI, R| DX| 0F IS, 
( 0020158D )                  CALLO, ZO|    [MEM +4* DX] 002014F0 L, 
( 00201594 )                  JMPS, -3F (RB,) 
( 00201596 )   :X_lis    CALL, X_show RL, 
( 0020159B )                  CALL, L00200BD0 RL, 
( 002015A0 )                  CALL, X_+list RL, 
( 002015A5 )                  JMP, X_keybo RL, 
( 002015AA )                 db 0 0 0 0FF 0FF 0 0 0 0 0 0 0 0FF 0 0 0C0 
( 002015BA )                 db 0 0 0 0 0 0 0 0 0 0 0FF 0FF 0 0 0 0 
( 002015CA )                 db 0 0 0FF 0FF 0FF 0 0FF 0FF 0FF 0 0FF 0FF 0FF 0 0FF 80 
( 002015DA )                 db 80 0 0C0 0C0 0C0 0 0FF 0 0 0 0 0 0 0 
( 002015E8 )   :L002015E8   db 0 0 
( 002015EA )                 db 0 0 
( 002015EC )   :L002015EC   db 1 

( 002015ED )   :L002015ED    DEC, X| MEM| L00202734 L, 
( 002015F3 )                  J, S| N| L002015FB RB, 
( 002015F5 )   :L002015F5    INC, X| MEM| L00202734 L, 
( 002015FB )   :L002015FB    RET, 
( 002015FC )   :L002015FC    SUBSI, MEM| L00202734 L, 8 IS, 
( 00201603 )                  J, S| N| L0020160F RB, 
( 00201605 )                  MOVI, X| MEM| L00202734 L, 0 IL, 
( 0020160F )   :L0020160F    RET, 
( 00201610 )   :L00201610    ADDSI, MEM| L00202734 L, 8 IS, 
( 00201617 )                  RET, 
( 00201618 )   :L00201618    ADDSI, MEM| L00202728 L, 2 IS, 
( 0020161F )                  RET, 
( 00201620 )   :L00201620    CMPSI, MEM| L00202728 L, 14 IS, 
( 00201627 )                  J, S| Y| L00201630 RB, 
( 00201629 )                  SUBSI, MEM| L00202728 L, 2 IS, 
( 00201630 )   :L00201630    RET, 
( 00201631 )   :L00201631    MOV, X| T| CX'| MEM| L00202728 L, 
( 00201637 )                  XCHG, X| CX'| MEM| L0020272C L, 
( 0020163D )                  MOV, X| F| CX'| MEM| L00202728 L, 
( 00201643 )                  RET, 
( 00201644 )   :L00201644    XORSI, MEM| L00202728 L, 1 IS, 
( 0020164B )                  RET, 
( 0020164C )   :L0020164C    MOV, X| T| CX'| MEM| L00202740 L, 
( 00201652 )                  ADD, X| T| CX'| MEM| L00202788 L, 
( 00201658 )                  XOR, X| T| CX'| MEM| L00202740 L, 
( 0020165E )                  ANDI, X| R| CX| FFFFFF00 IL, 
( 00201664 )                  J, Z| Y| L00201671 RB, 
( 00201666 )                  MOV, X| T| CX'| MEM| L00202788 L, 
( 0020166C )   :L0020166C    LODS, X'| 
( 0020166D )                  DEC|X, CX| 
( 0020166E )                  J, Z| N| L0020166C RB, 
( 00201670 )                  RET, 
( 00201671 )   :L00201671    PUSH|X, SI| 
( 00201672 )                  MOV, X| T| SI'| MEM| L00202740 L, 
( 00201678 )                  MOV, X| T| CX'| R| SI| 
( 0020167A )                  DEC|X, SI| 
( 0020167B )                  MOV, X| T| DI'| R| SI| 
( 0020167D )                  ADD, X| T| DI'| MEM| L00202788 L, 
( 00201683 )                  SHLI, X| R| DI| 2 IS, 
( 00201686 )                  SUB, X| T| CX'| MEM| L00202738 L, 
( 0020168C )                  J, S| Y| L00201695 RB, 
( 0020168E )                  SHLI, X| R| SI| 2 IS, 
( 00201691 )                  STD, 
( 00201692 )                  REPZ, 
( 00201693 )                  MOVS, X'| 
( 00201694 )                  CLD, 
( 00201695 )   :L00201695    POP|X, SI| 
( 00201696 )                  SHRI, X| R| DI| 2 IS, 
( 00201699 )                  INC|X, DI| 
( 0020169A )                  MOV, X| F| DI'| MEM| L00202734 L, 
( 002016A0 )                  MOV, X| T| CX'| MEM| L00202788 L, 
( 002016A6 )   :L002016A6    DEC|X, DI| 
( 002016A7 )                  MOV, X| F| AX'| ZO|    [MEM +4* DI] 0 L, 
( 002016AE )                  LODS, X'| 
( 002016AF )                  DEC|X, CX| 
( 002016B0 )                  J, Z| N| L002016A6 RB, 
( 002016B2 )                  RET, 
( 002016B3 )   :L002016B3    CALL, L0020164C RL, 
( 002016B8 )                  MOV, B| T| CL'| MEM| L002015EC L, 
( 002016BE )                  XOR, B| F| CL'| ZO|    [MEM +4* DI] 0 L, 
( 002016C5 )                  CMPI, B| R| CL| 3 IB, 
( 002016C8 )                  J, Z| N| L002016DB RB, 
( 002016CA )                  MOVI, B| MEM| L002015EC L, 4 IB, 
( 002016D1 )                  MOVI, X| MEM| L00202778 L, C000 IL, 
( 002016DB )   :L002016DB    RET, 
( 002016DC )   :L002016DC    POP, MEM| L00202780 L, 
( 002016E2 )                  MOVI, X| MEM| L00202780 L, L002006C9 IL, 
( 002016EC )                  RET, 
( 002016ED )   :X_word    MOVI, X| MEM| L00202780 L, L002016DC IL, 
( 002016F7 )                  JMP, X_accept RL, 
( 002016FC )   :L002016FC    LEA, SI'| BO| [SI] 0FC B, 
( 002016FF )                  MOV, X| F| AX'| ZO| [SI] 
( 00201701 )                  MOVI|X, AX| 1 IL, 
( 00201706 )                  CMPI, B| MEM| L002015EC L, 4 IB, 
( 0020170D )                  J, Z| Y| L00201711 RB, 
( 0020170F )                  MOVI|B, AL| 3 IB, 
( 00201711 )   :L00201711    CMPSI, MEM| L00202770 L, 0A IS, 
( 00201718 )                  J, Z| Y| L0020171C RB, 
( 0020171A )                  XORI|A, B'| 10 IB, 
( 0020171C )   :L0020171C    XCHG, X| AX'| ZO| [SI] 
( 0020171E )                  MOVI, X| MEM| L00202788 L, 2 IL, 
( 00201728 )                  JMPS, L002016B3 RB, 
( 0020172A )   :L0020172A    TESTI, B| MEM| L002015EC L, 0A IB, 
( 00201731 )                  J, Z| N| L0020176F RB, 
( 00201733 )                  MOV, X| T| DX'| R| AX| 
( 00201735 )                  ANDI, X| R| DX| FC000000 IL, 
( 0020173B )                  J, Z| Y| L00201745 RB, 
( 0020173D )                  CMPI, X| R| DX| FC000000 IL, 
( 00201743 )                  J, Z| N| L002016FC RB, 
( 00201745 )   :L00201745    SHLI, X| R| AX| 5 IS, 
( 00201748 )                  XORI|A, B'| 2 IB, 
( 0020174A )                  CMPI, B| MEM| L002015EC L, 4 IB, 
( 00201751 )                  J, Z| Y| L00201755 RB, 
( 00201753 )                  XORI|A, B'| 0B IB, 
( 00201755 )   :L00201755    CMPSI, MEM| L00202770 L, 0A IS, 
( 0020175C )                  J, Z| Y| L00201760 RB, 
( 0020175E )                  XORI|A, B'| 10 IB, 
( 00201760 )   :L00201760    MOVI, X| MEM| L00202788 L, 1 IL, 
( 0020176A )                  JMP, L002016B3 RL, 
( 0020176F )   :L0020176F    CMPI, B| MEM| L002015EC L, 9 IB, 
( 00201776 )                  J, Z| N| L00201784 RB, 
( 00201778 )                  MOV, X| T| DX'| R| AX| 
( 0020177A )                  SHLI, X| R| DX| 5 IS, 
( 0020177D )                  SARI, X| R| DX| 5 IS, 
( 00201780 )                  CMP, X| T| DX'| R| AX| 
( 00201782 )                  J, Z| Y| L00201786 RB, 
( 00201784 )   :L00201784    LODS, X'| 
( 00201785 )                  RET, 
( 00201786 )   :L00201786    SHLI, X| R| AX| 5 IS, 
( 00201789 )                  XORI|A, B'| 6 IB, 
( 0020178B )                  JMPS, L00201755 RB, 
( 0020178D )   :L0020178D    LEA, SI'| BO| [SI] 0FC B, 
( 00201790 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201792 )                  MOV|TA, X'| L00202738 L, 
( 00201797 )                  SUB, X| T| AX'| MEM| L0020273C L, 
( 0020179D )                  J, Z| Y| L002017C6 RB, 
( 0020179F )                  MOV, X| T| CX'| R| AX| 
( 002017A1 )                  XCHG|AX, DX| 
( 002017A2 )                  PUSH|X, SI| 
( 002017A3 )                  MOV, X| T| SI'| MEM| L00202738 L, 
( 002017A9 )                  LEA, SI'| ZO|    [MEM +4* SI] -4 L, 
( 002017B0 )                  MOV, X| T| DI'| MEM| L00202744 L, 
( 002017B6 )   :L002017B6    STD, 
( 002017B7 )                  LODS, X'| 
( 002017B8 )                  CLD, 
( 002017B9 )                  STOS, X'| 
( 002017BA )                  DEC|X, CX| 
( 002017BB )                  J, Z| N| L002017B6 RB, 
( 002017BD )                  XCHG|AX, DX| 
( 002017BE )                  STOS, X'| 
( 002017BF )                  MOV, X| F| DI'| MEM| L00202744 L, 
( 002017C5 )                  POP|X, SI| 
( 002017C6 )   :L002017C6    LODS, X'| 
( 002017C7 )                  RET, 
( 002017C8 )   :L002017C8    CALL, L0020178D RL, 
( 002017CD )                  MOV, X| T| DI'| MEM| L0020273C L, 
( 002017D3 )                  MOV, X| T| CX'| MEM| L00202740 L, 
( 002017D9 )                  SUB, X| T| CX'| R| DI| 
( 002017DB )                  SHLI, X| R| DI| 2 IS, 
( 002017DE )                  PUSH|X, SI| 
( 002017DF )                  MOV, X| T| SI'| MEM| L00202738 L, 
( 002017E5 )                  SHLI, X| R| SI| 2 IS, 
( 002017E8 )                  REPZ, 
( 002017E9 )                  MOVS, X'| 
( 002017EA )                  POP|X, SI| 
( 002017EB )                  JMP, L002015ED RL, 
( 002017F0 )   :L002017F0    CALL, L0020178D RL, 
( 002017F5 )                  JMP, L002015ED RL, 
( 002017FA )   :L002017FA    MOVI|B, AL| 1 IB, 
( 002017FC )                  JMPS, L0020181C RB, 
( 002017FE )   :L002017FE    MOVI|B, AL| 3 IB, 
( 00201800 )                  JMPS, L0020181C RB, 
( 00201802 )   :L00201802    MOVI|B, AL| 4 IB, 
( 00201804 )                  JMPS, L0020181C RB, 
( 00201806 )   :L00201806    MOVI|B, AL| 9 IB, 
( 00201808 )                  JMPS, L0020181C RB, 
( 0020180A )   :L0020180A    MOVI|B, AL| 0A IB, 
( 0020180C )                  JMPS, L0020181C RB, 
( 0020180E )   :L0020180E    MOVI|B, AL| 0B IB, 
( 00201810 )                  JMPS, L0020181C RB, 
( 00201812 )   :L00201812    MOVI|B, AL| 0D IB, 
( 00201814 )                  JMPS, L0020181C RB, 
( 00201816 )   :L00201816    MOVI|B, AL| 0E IB, 
( 00201818 )                  JMPS, L0020181C RB, 
( 0020181A )   :L0020181A    MOVI|B, AL| 7 IB, 
( 0020181C )   :L0020181C    MOV|FA, B'| L002015EC L, 
( 00201821 )                  MOVI, X| MEM| L00202780 L, L002016B3 IL, 
( 0020182B )                  MOV, X| T| AX'| ZO|    [MEM +4* AX] 002015A8 L, 
( 00201832 )   :L00201832    MOV|FA, X'| L00202778 L, 
( 00201837 )                  POP|X, AX| 
( 00201838 )                  LODS, X'| 
( 00201839 )                  JMP, X_accept RL, 
( 0020183E )   :L0020183E    LEA, SI'| BO| [SI] 0FC B, 
( 00201841 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201843 )                  XOR, X| T| AX'| R| AX| 
( 00201845 )                  INC, X| MEM| L00202788 L, 
( 0020184B )                  JMP, L002016B3 RL, 
( 00201850 )   :L00201850    MOVI, B| MEM| L002015EC L, 0C IB, 
( 00201857 )                  MOVI|X, AX| 00FF00FF IL, 
( 0020185C )                  MOVI, X| MEM| L00202780 L, L0020183E IL, 
( 00201866 )                  JMPS, L00201832 RB, 
( 00201868 )   :L00201868    POP|X, AX| 
( 00201869 )   :L00201869    LODS, X'| 
( 0020186A )                  MOVI, X| MEM| L00202780 L, L002006C9 IL, 
( 00201874 )                  MOVI, X| MEM| L00202784 L, X_nul IL, 
( 0020187E )                  MOVI, B| MEM| L0020101D L, 0 IB, 
( 00201885 )                  MOVI, X| MEM| L00202730 L, 0 IL, 
( 0020188F )                  MOVI, X| MEM| L00201011 L, L0020121F IL, 
( 00201899 )                  MOVI, X| MEM| L00202778 L, 00FFFF00 IL, 
( 002018A3 )                  JMP, X_accept RL, 
( 002018A8 )   :L002018A8    MOV, X| T| DX'| MEM| L00202744 L, 
( 002018AE )                  CMPI, X| R| DX| 00094C00 IL, 
( 002018B4 )                  J, Z| N| 1 (RB,) 
( 002018B6 )                  RET, 
( 002018B7 )                  SUBSI, R| DX| 8 IS, 
( 002018BA )                  MOV, X| T| CX'| BO| [DX] 4 B, 
( 002018BD )                  MOV, X| F| CX'| MEM| L00202788 L, 
( 002018C3 )                  LEA, SI'| BO| [SI] 0FC B, 
( 002018C6 )                  MOV, X| F| AX'| ZO| [SI] 
( 002018C8 )                  MOV, X| T| AX'| ZO| [DX] 
( 002018CA )                  SUBSI, R| DX| 4 IS, 
( 002018CD )                  DEC|X, CX| 
( 002018CE )                  J, Z| N| -D (RB,) 
( 002018D0 )                  ADDSI, R| DX| 4 IS, 
( 002018D3 )                  MOV, X| F| DX'| MEM| L00202744 L, 
( 002018D9 )                  JMP, L0020164C RL, 
( 002018DE )   :L002018DE   dw 0000 

( 002018E0 )                 dl X_nul L002017C8 L00201868 L002018A8 
( 002018F0 )                 dl L002017FA L002017FE L00201802 L00201644 
( 00201900 )                 dl L002015ED L002015FC L00201610 L002015F5 
( 00201910 )                 dl L00201620 L00201850 L0020181A L00201618 
( 00201920 )                 dl X_nul L0020180E L0020180A L00201806 
( 00201930 )                 dl X_nul 
( 00201934 )   :L00201934   dl X_nul X_nul L00201631 
( 00201940 )                 dl L00201812 
( 00201944 )   :L00201944   dl L00201816 X_nul L002017F0 

( 00201950 )                 db 15 25 7 0 0B 1 0D 2D 0C 16 10 1 23 9 0A 2B 
( 00201960 )                 db 0 38 3A 2 0 10 0E 22 5 13 0 24 91 1C 20 0 
( 00201970 )                 db 0AD 0EB 42 

( 00201973 )   :X_edit    MOV, X| T| CX'| MEM| L00202728 L, 
( 00201979 )                  MOV, X| F| CX'| MEM| L0020272C L, 
( 0020197F )                  MOV|FA, X'| L00202728 L, 
( 00201984 )                  LODS, X'| 
( 00201985 )   :X_e    CALL, X_lis RL, 
( 0020198A )   :X_+e    CALLO, MEM| 0020196C L, 
( 00201990 )                  MOVI, X| MEM| L00202784 L, L0020172A IL, 
( 0020199A )                  MOVI, X| MEM| L00202730 L, 1 IL, 
( 002019A4 )                  MOVI, B| MEM| L0020101D L, 25 IB, 
( 002019AB )   :X_e2    MOVI, X| MEM| L00201011 L, 00201970 IL, 
( 002019B5 )                  MOVI, X| MEM| L0020276C L, 00201940 IL, 
( 002019BF )                  MOVI, X| MEM| L00202768 L, 00201950 IL, 
( 002019C9 )   :X_e3    MOVI, X| MEM| L00202778 L, 00FFFF00 IL, 
( 002019D3 )                  CALL, -AE9 (RL,) 
( 002019D8 )                  CALLO, ZO|    [MEM +4* AX] 002018E0 L, 
( 002019DF )                  LODS, X'| 
( 002019E0 )                  JMPS, -F (RB,) 
( 002019E2 )   :X_pad    POP|X, DX| 
( 002019E3 )                  MOV, X| F| DX'| MEM| L002015E8 L, 
( 002019E9 )                  ADDI, X| R| DX| 8C IL, 
( 002019EF )                  MOV, X| F| DX'| MEM| L00202768 L, 
( 002019F5 )                  SUBSI, R| DX| 10 IS, 
( 002019F8 )                  MOV, X| F| DX'| MEM| L0020276C L, 
( 002019FE )   :X_pad1    CALL, -B14 (RL,) 
( 00201A03 )                  MOV, X| T| DX'| MEM| L002015E8 L, 
( 00201A09 )                  ADD, X| T| DX'| R| AX| 
( 00201A0B )                  LEA, DX'| BO|    [DX +4* AX] 5 B, 
( 00201A0F )                  ADD, X| T| DX'| BO| [DX] 0FC B, 
( 00201A12 )                  LODS, X'| 
( 00201A13 )   :L00201A13    CALLO, R| DX| 
( 00201A15 )                  JMPS, X_pad1 RB, 
( 00201A17 )   :L00201A17   db 0 0 0 0 
( 00201A1B )   :L00201A1B   db 0 0 0 0 0 0 0 0 17 0F 4 1 
( 00201A27 )                 db 0 0 0 0 0 0 0 0 

( 00201A2F )   :L00201A2F    XORSI, MEM| L00202774 L, 61 IS, 
( 00201A36 )                  XORI, B| MEM| L00201041 L, 2F IB, 
( 00201A3D )                  CALLO, MEM| L00202774 L, 
( 00201A43 )                  MOVI, X| MEM| L00201A17 L, 0 IL, 
( 00201A4D )                  CMPSI, MEM| L00202770 L, 10 IS, 
( 00201A54 )                  J, Z| N| A (RB,) 
( 00201A56 )                  MOVI, X| MEM| L00201A17 L, 00150414 IL, 
( 00201A60 )                  MOVI, X| MEM| L00202768 L, L00201A13 IL, 
( 00201A6A )                  MOVI, X| MEM| L0020276C L, L00201A17 IL, 
( 00201A74 )                  RET, 
( 00201A75 )   :L00201A75    CALL, L00201A2F RL, 
( 00201A7A )                  JMPS, L00201AF5 RB, 
( 00201A7C )                 dl L002011B0 L002011B0 L00201217 L00201AF5 
( 00201A8C )                 dl L00201A75 FFF0FEE8 

( 00201A94 )                  INC, X| R| DI| 
( 00201A96 )   :L00201A96    ADDI|A, X'| L00201A1B IL, 
( 00201A9B )                  PUSH|ES, 
( 00201A9C )                  PUSH|SS, 
( 00201A9D )                  OR, X| F| AX'| ZO| [AX] 
( 00201A9F )                  CALL, -67 (RL,) 
( 00201AA4 )                  MOVI, B| MEM| L00201152 L, 0 IB, 
( 00201AAB )                  MOV|TA, X'| L00202790 L, 
( 00201AB0 )                  CALL, X_qkey RL, 
( 00201AB5 )                  J, Z| Y| 7 (RB,) 
( 00201AB7 )                  JMPO, ZO|    [MEM +4* AX] 0020187C L, 
( 00201ABE )                  TEST, X| AX'| R| AX| 
( 00201AC0 )                  J, LE| Y| L00201AF5 RB, 
( 00201AC2 )                  CMPI|A, B'| 23 IB, 
( 00201AC4 )                  J, Z| Y| 27 (RB,) 
( 00201AC6 )                  MOV|TA, X'| L00202790 L, 
( 00201ACB )                  CMP, X| T| AX'| MEM| L00202770 L, 
( 00201AD1 )                  J, S| N| 18 (RB,) 
( 00201AD3 )                  TESTI, B| MEM| L00201152 L, 0FF IB, 
( 00201ADA )                  J, Z| Y| 2 (RB,) 
( 00201ADC )                  NEG, X| R| AX| 
( 00201ADE )                  MOV, X| T| DX'| ZO| [SI] 
( 00201AE0 )                  IMUL, DX'| MEM| L00202770 L, 
( 00201AE7 )                  ADD, X| T| DX'| R| AX| 
( 00201AE9 )                  MOV, X| F| DX'| ZO| [SI] 
( 00201AEB )                  JMPS, L00201AF5 RB, 
( 00201AED )                  XOR, X| F| AX'| MEM| L00201152 L, 
( 00201AF3 )                  NEG, X| ZO| [SI] 
( 00201AF5 )   :L00201AF5    LODS, X'| 
( 00201AF6 )                  JMPS, -48 (RB,) 
( 00201AF8 )   :L00201AF8    PUSHI|B, 10 IB, 
( 00201AFA )                  AND, B| F| AL'| ZO| [AX] 
( 00201AFC )                  PUSHI|B, 10 IB, 
( 00201AFE )                  AND, B| F| AL'| ZO| [AX] 
( 00201B00 )                  LES, DX'| ZO| [AX] 
( 00201B02 )                  AND, B| F| AL'| ZO| [AX] 
( 00201B04 )                  MOVI, X| MEM| L00201A1B L, 02150402 IL, 
( 00201B0E )                  CALL, L00200B93 RL, 
( 00201B13 )                  MOVI, X| MEM| L00202788 L, 1 IL, 
( 00201B1D )                  MOVI, X| MEM| L0020277C L, 1 IL, 
( 00201B27 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201B2A )                  MOV, X| F| AX'| ZO| [SI] 
( 00201B2C )                  MOVI, X| ZO| [SI] 0 IL, 
( 00201B32 )                  MOVI, B| MEM| L0020105D L, 1C IB, 
( 00201B39 )                  J, Z| Y| E (RB,) 
( 00201B3B )                  CMPI|A, X'| 83 IL, 
( 00201B40 )                  J, S| N| 7 (RB,) 
( 00201B42 )                  JMPO, ZO|    [MEM +4* AX] 002018F8 L, 
( 00201B49 )                  TEST, X| AX'| R| AX| 
( 00201B4B )                  J, LE| Y| 1C (RB,) 
( 00201B4D )                  CMPI|A, X'| 30 IL, 
( 00201B52 )                  J, S| N| 15 (RB,) 
( 00201B54 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201B57 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201B59 )                  CALL, L00200B7A RL, 
( 00201B5E )                  CALL, L00201098 RL, 
( 00201B63 )                  INC, X| MEM| L0020277C L, 
( 00201B69 )                  LODS, X'| 
( 00201B6A )                  CALL, X_qkey RL, 
( 00201B6F )                  JMPS, -38 (RB,) 
( 00201B71 )                  CALL, L00201A2F RL, 
( 00201B76 )                  JMP, L0020121F RL, 
( 00201B7B )                  JMPO, MEM| L00201011 L, 
( 00201B81 )                  POP|DS, 
( 00201B82 )                  ADC, B| T| AH'| ZO| [AX] 
( 00201B84 )                  ADD, B| F| BL'| ZO| [DI] 
( 00201B86 )                  ADC, B| T| AH'| ZO| [AX] 
( 00201B88 )                  ADD, B| F| BL'| ZO| [DI] 
( 00201B8A )                  ADC, B| T| AH'| ZO| [AX] 
( 00201B8C )                  ADD, B| F| BH'| BO| [BX] 1B B, 
( 00201B8F )                  AND, B| F| AL'| ZO| [AX] 
( 00201B91 )                  J, O| N| 1B (RB,) 
( 00201B93 )                  AND, B| F| AL'| ZO| [AX] 
( 00201B95 )                  MOVI, X| MEM| L00201A1B L, 0 IL, 
( 00201B9F )                  MOVI, X| MEM| L0020276C L, L00201A17 IL, 
( 00201BA9 )                  MOVI, X| MEM| L00202768 L, L00201A13 IL, 
( 00201BB3 )                  CALL, X_qkey RL, 
( 00201BB8 )                  J, Z| Y| 7 (RB,) 
( 00201BBA )                  JMPO, ZO|    [MEM +4* AX] 00201981 L, 
( 00201BC1 )                  CMPI|A, B'| 30 IB, 
( 00201BC3 )                  J, Z| N| D (RB,) 
( 00201BC5 )                  MOVI, X| MEM| L00201A1B L, 02150402 IL, 
( 00201BCF )                  LODS, X'| 
( 00201BD0 )                  JMPS, -1F (RB,) 
( 00201BD2 )                  TEST, X| AX'| R| AX| 
( 00201BD4 )                  J, LE| Y| 30 (RB,) 
( 00201BD6 )                  TESTI, X| MEM| L00201A1B L, -1 IL, 
( 00201BE0 )                  J, Z| N| D (RB,) 
( 00201BE2 )                  CMPI, B| MEM| L00202790 L, 0A IB, 
( 00201BE9 )                  J|X, S| Y| -15F (RL,) 
( 00201BEF )                  CMPI|A, X'| 30 IL, 
( 00201BF4 )                  J, S| N| 10 (RB,) 
( 00201BF6 )                  CALL, -F7 (RL,) 
( 00201BFB )                  CALLO, MEM| L00202780 L, 
( 00201C01 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201C04 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201C06 )                  LODS, X'| 
( 00201C07 )                  JMP, X_accept RL, 
( 00201C0C )   :X_qwert    MOVI, X| MEM| L00202754 L, 00201B95 IL, 
( 00201C16 )                  RET, 
( 00201C17 )   :L00201C17    SUBI, X| R| DI| 00081200 IL, 
( 00201C1D )                  J, C| Y| L00201C48 RB, 
( 00201C1F )                  ADDI, X| R| DI| 1200 IL, 
( 00201C25 )                  MOV, X| T| AX'| R| DI| 
( 00201C27 )                  ANDI|A, X'| 0FF IL, 
( 00201C2C )                  SHRI, X| R| DI| 8 IS, 
( 00201C2F )                  CMPI, X| R| DI| 05A0 IL, 
( 00201C35 )                  J, C| N| L00201C48 RB, 
( 00201C37 )                  MOV|FA, X'| L00202734 L, 
( 00201C3C )                  MOV, X| F| DI'| MEM| L00202728 L, 
( 00201C42 )                  CALLO, MEM| L0020275C L, 
( 00201C48 )   :L00201C48    MOVI|X, SP| 000A0000 IL, 
( 00201C4D )                  CMPI, X| R| SI| 0009F400 IL, 
( 00201C53 )                  J, C| Y| L00201C5A RB, 
( 00201C55 )                  MOVI|X, SI| 0009F400 IL, 
( 00201C5A )   :L00201C5A    MOVI, X| MEM| L002027CC L, L002005E8 IL, 
( 00201C64 )                  MOVI, X| MEM| L002027D0 L, L00200702 IL, 
( 00201C6E )                  MOVI, X| MEM| L002027D4 L, L002006A2 IL, 
( 00201C78 )                  MOVI, X| MEM| 002027D8 L, L002006B2 IL, 
( 00201C82 )                  MOVI|X, AX| 2F IL, 
( 00201C87 )                  CALL, L00200B7A RL, 
( 00201C8C )                  JMP, X_accept RL, 
( 00201C91 )   :X_no-ret    POP|X, CX| 
( 00201C92 )                  MOVI|X, SP| 000A0000 IL, 
( 00201C97 )                  JMPO, R| CX| 
( 00201C99 )   :X_r?    LEA, SI'| BO| [SI] 0FC B, 
( 00201C9C )                  MOV, X| F| AX'| ZO| [SI] 
( 00201C9E )                  MOVI|X, AX| 000A0000 IL, 
( 00201CA3 )                  SUB, X| T| AX'| R| SP| 
( 00201CA5 )                  SHR, 1| X| R| AX| 
( 00201CA7 )                  SHR, 1| X| R| AX| 
( 00201CA9 )                  RET, 
( 00201CAA )   :X_boot    MOVI|B, AL| 0FE IB, 
( 00201CAC )                  OUT|P, B'| 64 P, 
( 00201CAE )   :X_bootLoop    JMPS, X_bootLoop RB, 
( 00201CB0 )   :X_erase    MOV, X| T| CX'| R| AX| 
( 00201CB2 )                  SHLI, X| R| CX| 8 IS, 
( 00201CB5 )                  LODS, X'| 
( 00201CB6 )                  PUSH|X, DI| 
( 00201CB7 )                  MOV, X| T| DI'| R| AX| 
( 00201CB9 )                  SHLI, X| R| DI| 0A IS, 
( 00201CBC )                  XOR, X| T| AX'| R| AX| 
( 00201CBE )                  REPZ, 
( 00201CBF )                  STOS, X'| 
( 00201CC0 )                  POP|X, DI| 
( 00201CC1 )                  LODS, X'| 
( 00201CC2 )                  RET, 
( 00201CC3 )   :X_copy    CMPSI, R| AX| 0C IS, 
( 00201CC6 )                  J|X, C| Y| X_abort RL, 
( 00201CCC )                  PUSH|X, DI| 
( 00201CCD )                  MOV, X| T| DI'| R| AX| 
( 00201CCF )                  SHLI, X| R| DI| 0A IS, 
( 00201CD2 )                  PUSH|X, SI| 
( 00201CD3 )                  MOV, X| T| SI'| MEM| L00202728 L, 
( 00201CD9 )                  SHLI, X| R| SI| 0A IS, 
( 00201CDC )                  MOVI|X, CX| 0200 IL, 
( 00201CE1 )                  REPZ, 
( 00201CE2 )                  MOVS, X'| 
( 00201CE3 )                  POP|X, SI| 
( 00201CE4 )                  POP|X, DI| 
( 00201CE5 )                  MOV|FA, X'| L00202728 L, 
( 00201CEA )                  LODS, X'| 
( 00201CEB )                  RET, 
( 00201CEC )   :X_debu    MOVI, X| MEM| L00202814 L, 000302B5 IL, 
( 00201CF6 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201CF9 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201CFB )                  MOV|TA, X'| L00200446 L, 
( 00201D00 )                  PUSH, ZO| [AX] 
( 00201D02 )                  CALL, L00200C9C RL, 
( 00201D07 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201D0A )                  MOV, X| F| AX'| ZO| [SI] 
( 00201D0C )                  POP|X, AX| 
( 00201D0D )                  CALL, L00200C9C RL, 
( 00201D12 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201D15 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201D17 )                  MOV|TA, X'| L0020044F L, 
( 00201D1C )                  CALL, L00200C9C RL, 
( 00201D21 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201D24 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201D26 )                  MOV, X| T| AX'| R| SI| 
( 00201D28 )                  JMP, L00200C9C RL, 
( 00201D2D )   :L00201D2D    DEC, X| MEM| L00202788 L, 
( 00201D33 )                  J, Z| Y| L00201D38 RB, 
( 00201D35 )                  LODS, X'| 
( 00201D36 )                  JMPS, L00201D2D RB, 
( 00201D38 )   :L00201D38    RET, 
( 00201D39 )   :X_tic    CALL, X_word RL, 
( 00201D3E )                  CALL, L00201D2D RL, 
( 00201D43 )                  CALL, L00200553 RL, 
( 00201D48 )                  J|X, Z| N| X_abort RL, 
( 00201D4E )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D2800 L, 
( 00201D55 )                  RET, 
( 00201D56 )   :X_itick    ANDI|A, X'| -10 IL, 
( 00201D5B )                  CALL, L00200553 RL, 
( 00201D60 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 004D2800 L, 
( 00201D67 )                  RET, 
( 00201D68 )   :X_winver    LEA, SI'| BO| [SI] 0FC B, 
( 00201D6B )                  MOV, X| F| AX'| ZO| [SI] 
( 00201D6D )                  MOVI|X, AX| 0 IL, 
( 00201D72 )                  OR, X| T| AX'| R| AX| 
( 00201D74 )                  RET, 
( 00201D75 )                 db 0 0 
( 00201D77 )   :L00201D77   db 0 
( 00201D78 )   :L00201D78   db 1 
( 00201D79 )   :L00201D79   db 0 
( 00201D7A )   :L00201D7A   db 0 
( 00201D7B )   :L00201D7B   db 0 
( 00201D7C )   :L00201D7C   db 0 0 1 2 12 1B 0FF 

( 00201D83 )   :L00201D83    ADD, B| F| AH'| BO| [SI] 0BA B, 
( 00201D86 )                  HLT, 
( 00201D87 )   :L00201D87    ADD, X| T| BP'| R| SP| 
( 00201D89 )                  OUT|P, B'| 0E1 P, 
( 00201D8B )                  SHL, 1| B| R| AL| 
( 00201D8D )                  J, C| N| -7 (RB,) 
( 00201D8F )                  INC|X, DX| 
( 00201D90 )                  TEST, B| AL'| R| AL| 
( 00201D92 )                  RET, 
( 00201D93 )   :L00201D93    LEA, DX'| MEM| L00201D7A L, 
( 00201D99 )                  MOV, B| F| AL'| ZO| [DX] 
( 00201D9B )                  PUSH|X, SI| 
( 00201D9C )                  MOV, X| T| SI'| R| DX| 
( 00201D9E )                  CALL, -1F (RL,) 
( 00201DA3 )                  J, S| N| 5 (RB,) 
( 00201DA5 )                  IN|D, B'| 
( 00201DA6 )                  OUT|P, B'| 0E1 P, 
( 00201DA8 )                  JMPS, -C (RB,) 
( 00201DAA )                  LODS, B'| 
( 00201DAB )                  MOVI|B, AH| 1E IB, 
( 00201DAD )                  OUT|D, B'| 
( 00201DAE )                  OUT|P, B'| 0E1 P, 
( 00201DB0 )                  DEC, B| R| AH| 
( 00201DB2 )                  J, Z| N| -6 (RB,) 
( 00201DB4 )                  LOOP, -18 (RB,) 
( 00201DB6 )                  POP|X, SI| 
( 00201DB7 )                  RET, 
( 00201DB8 )   :L00201DB8    MOVI|B, AL| 8 IB, 
( 00201DBA )                  MOVI|B, CL| 1 IB, 
( 00201DBC )                  CALL, L00201D93 RL, 
( 00201DC1 )                  CALL, -42 (RL,) 
( 00201DC6 )                  IN|D, B'| 
( 00201DC7 )                  OUT|P, B'| 0E1 P, 
( 00201DC9 )                  CMPI|A, B'| 80 IB, 
( 00201DCB )                  RET, 
( 00201DCC )   :L00201DCC    OUT|P, B'| 0B P, 
( 00201DCE )                  CALL, L00201DB8 RL, 
( 00201DD3 )                  J, Z| N| -7 (RB,) 
( 00201DD5 )                  MOVI|B, AL| 0F IB, 
( 00201DD7 )                  MOVI|B, CL| 3 IB, 
( 00201DD9 )                  CALL, L00201D93 RL, 
( 00201DDE )                  CALL, L00201DB8 RL, 
( 00201DE3 )                  J, Z| Y| -7 (RB,) 
( 00201DE5 )                  RET, 
( 00201DE6 )   :L00201DE6    MOVI, X| MEM| L00202744 L, 00094C00 IL, 
( 00201DF0 )                  MOVI|B, AL| 0C IB, 
( 00201DF2 )                  OS:, 
( 00201DF3 )                  MOVI|X, DX| 03F2 IW, 
( 00201DF6 )                  MOVI|B, AH| 0F IB, 
( 00201DF8 )                  OUT|D, B'| 
( 00201DF9 )                  OUT|P, B'| 0E1 P, 
( 00201DFB )                  DEC, B| R| AH| 
( 00201DFD )                  J, Z| N| -6 (RB,) 
( 00201DFF )                  RET, 
( 00201E00 )   :L00201E00    MOVI|B, AL| 1C IB, 
( 00201E02 )                  CALL, -15 (RL,) 
( 00201E07 )                  MOVI|X, CX| 047868C0 IL, 
( 00201E0C )                  LOOP, -2 (RB,) 
( 00201E0E )                  MOVI|B, AL| 7 IB, 
( 00201E10 )                  MOVI|B, CL| 2 IB, 
( 00201E12 )                  JMPS, -3B (RB,) 
( 00201E14 )                  OUT|P, B'| 5 P, 
( 00201E16 )                  MOV, B| T| AL'| R| AH| 
( 00201E18 )                  OUT|P, B'| 5 P, 
( 00201E1A )                  MOVI|X, AX| 00094C00 IL, 
( 00201E1F )                  OUT|P, B'| 4 P, 
( 00201E21 )                  MOV, B| T| AL'| R| AH| 
( 00201E23 )                  OUT|P, B'| 4 P, 
( 00201E25 )                  SHRI, X| R| AX| 10 IS, 
( 00201E28 )                  OUT|P, B'| 81 P, 
( 00201E2A )                  MOVI|B, AL| 0B IB, 
( 00201E2C )                  OUT|P, B'| 0F P, 
( 00201E2E )                  OS:, 
( 00201E2F )                  MOVI, X| MEM| L00201D7B L, 02A1 IW, 
( 00201E37 )                  MOVI|B, AL| 3 IB, 
( 00201E39 )                  MOVI|B, CL| 3 IB, 
( 00201E3B )                  CALL, L00201D93 RL, 
( 00201E40 )                  OS:, 
( 00201E41 )                  MOVI, X| MEM| L00201D7B L, 0 IW, 
( 00201E49 )                  MOVI, B| MEM| L00201D78 L, 0 IB, 
( 00201E50 )                  RET, 
( 00201E51 )   :L00201E51    MOVI|B, CL| 9 IB, 
( 00201E53 )                  CALL, L00201D93 RL, 
( 00201E58 )                  INC, B| MEM| L00201D7C L, 
( 00201E5E )                  CALL, -DF (RL,) 
( 00201E63 )                  J, S| N| -7 (RB,) 
( 00201E65 )                  RET, 
( 00201E66 )   :L00201E66    MOVI|B, AL| 16 IB, 
( 00201E68 )                  CALL, L00201DCC RL, 
( 00201E6D )                  MOVI|B, AL| 0E6 IB, 
( 00201E6F )                  CALL, L00201E51 RL, 
( 00201E74 )                  PUSH|X, SI| 
( 00201E75 )                  MOVI|X, SI| 00094C00 IL, 
( 00201E7A )                  MOVI|X, CX| 1200 IL, 
( 00201E7F )                  REPZ, 
( 00201E80 )                  MOVS, X'| 
( 00201E81 )                  POP|X, SI| 
( 00201E82 )                  RET, 
( 00201E83 )   :L00201E83    MOVI|X, DI| 00094C00 IL, 
( 00201E88 )                  MOVI|X, CX| 1200 IL, 
( 00201E8D )                  REPZ, 
( 00201E8E )                  MOVS, X'| 
( 00201E8F )                  MOVI|B, AL| 1A IB, 
( 00201E91 )                  CALL, L00201DCC RL, 
( 00201E96 )                  MOVI|B, AL| 0C5 IB, 
( 00201E98 )                  JMPS, L00201E51 RB, 
( 00201E9A )                  MOV|FA, B'| L00201D7C L, 
( 00201E9F )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201EA2 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201EA4 )                  OS:, 
( 00201EA5 )                  MOVI|X, DX| 03F2 IW, 
( 00201EA8 )                  IN|D, B'| 
( 00201EA9 )                  OUT|P, B'| 0E1 P, 
( 00201EAB )                  TESTI|A, B'| 10 IB, 
( 00201EAD )                  J, Z| N| L00201EB4 RB, 
( 00201EAF )                  JMP, L00201E00 RL, 
( 00201EB4 )   :L00201EB4    RET, 
( 00201EB5 )   :L00201EB5    XOR, X| T| CX'| R| CX| 
( 00201EB7 )                  TESTI, B| MEM| L00201D78 L, 0FF IB, 
( 00201EBE )                  J, Z| Y| 10 (RB,) 
( 00201EC0 )                  LEA, SI'| BO| [SI] 0FC B, 
( 00201EC3 )                  MOV, X| F| AX'| ZO| [SI] 
( 00201EC5 )                  MOVI|X, AX| 47FF IL, 
( 00201ECA )                  CALL, -BB (RL,) 
( 00201ECF )                  LODS, X'| 
( 00201ED0 )                  RET, 
( 00201ED1 )   :X_read    CALL, L00201EB5 RL, 
( 00201ED6 )                  CALL, -41 (RL,) 
( 00201EDB )                  PUSH|X, DI| 
( 00201EDC )                  MOV, X| T| DI'| BO| [SI] 4 B, 
( 00201EDF )                  SHLI, X| R| DI| 2 IS, 
( 00201EE2 )                  CALL, L00201E66 RL, 
( 00201EE7 )                  POP|X, DI| 
( 00201EE8 )   :X_read1    LODS, X'| 
( 00201EE9 )                  INC|X, AX| 
( 00201EEA )                  ADDI, X| ZO| [SI] 1200 IL, 
( 00201EF0 )                  RET, 
( 00201EF1 )   :X_write    CALL, L00201EB5 RL, 
( 00201EF6 )                  CALL, -61 (RL,) 
( 00201EFB )                  PUSH|X, SI| 
( 00201EFC )                  MOV, X| T| SI'| BO| [SI] 4 B, 
( 00201EFF )                  SHLI, X| R| SI| 2 IS, 
( 00201F02 )                  CALL, L00201E83 RL, 
( 00201F07 )                  POP|X, SI| 
( 00201F08 )                  JMPS, X_read1 RB, 
( 00201F0A )   :X_stop    LEA, SI'| BO| [SI] 0FC B, 
( 00201F0D )                  MOV, X| F| AX'| ZO| [SI] 
( 00201F0F )                  CALL, L00201DE6 RL, 
( 00201F14 )                  LODS, X'| 
( 00201F15 )                  RET, 
( 00201F16 )   :L00201F16    MOVI|B, AL| 1A IB, 
( 00201F18 )                  CALL, L00201DCC RL, 
( 00201F1D )                  MOV, X| T| DX'| R| SI| 
( 00201F1F )                  MOVI|B, CL| 6 IB, 
( 00201F21 )                  CALL, -18B (RL,) 
( 00201F26 )   :L00201F26    CALL, -1A7 (RL,) 
( 00201F2B )                  J, S| N| L00201F26 RB, 
( 00201F2D )                  RET, 
( 00201F2E )   :X_format    PUSH|X, AX| 
( 00201F2F )                  MOVI|X, AX| 47 IL, 
( 00201F34 )                  XOR, X| T| CX'| R| CX| 
( 00201F36 )                  CALL, -127 (RL,) 
( 00201F3B )                  POP|X, AX| 
( 00201F3C )                  CALL, -A7 (RL,) 
( 00201F41 )                  PUSH|X, SI| 
( 00201F42 )                  MOV, X| T| SI'| BO| [SI] 4 B, 
( 00201F45 )                  SHLI, X| R| SI| 2 IS, 
( 00201F48 )                  CALL, L00201F16 RL, 
( 00201F4D )                  POP|X, SI| 
( 00201F4E )                  MOVI|X, AX| 47FF IL, 
( 00201F53 )                  CALL, -144 (RL,) 
( 00201F58 )                  LODS, X'| 
( 00201F59 )                  RET, 
( 00201F5A )   :X_warm    LEA, SI'| BO| [SI] 0FC B, 
( 00201F5D )                  MOV, X| F| AX'| ZO| [SI] 
( 00201F5F )   :Start    CALL, InitDisplay RL, 
( 00201F64 )                  CALL, L002004B2 RL, 
( 00201F69 )                  CALL, L002004E3 RL, 
( 00201F6E )                  CALL, X_stop RL, 
( 00201F73 )                  MOVI, B| MEM| L00201D78 L, 1 IB, 
\ 95 high-level Forth words embedded in kernel   
( 00201F7A )                  MOVI, X| MEM| ForthMacros L, 63 IL, 
\ 6 high-level Forth macros   
( 00201F84 )                  MOVI, X| MEM| L002027BC L, 6 IL, 
( 00201F8E )                  MOVI, X| MEM| L00202744 L, 00094C00 IL, 
( 00201F98 )                  PUSH|X, SI| 
\ point to Shannon-encoded high-level Forth words   
( 00201F99 )                  LEA, SI'| MEM| EncodedWords L, 
( 00201F9F )                  MOVI|X, DI| 004D0000 IL, \ move to higher memory
( 00201FA4 )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 00201FAA )                  REPZ, 
( 00201FAB )                  MOVS, X'| 
\ point to list of code pointers for high-level Forth words   
( 00201FAC )                  LEA, SI'| MEM| WordPointers L, 
( 00201FB2 )                  MOVI|X, DI| 004D2800 IL, \ move to high memory
( 00201FB7 )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 00201FBD )                  REPZ, 
( 00201FBE )                  MOVS, X'| 
( 00201FBF )                  POP|X, SI| 
( 00201FC0 )                  MOVI, X| MEM| L002027A4 L, 004D5000 IL, 
( 00201FCA )                  MOVI, X| MEM| L0020275C L, X_nul IL, 
( 00201FD4 )                  MOVI, X| MEM| L00202754 L, 0 IL, 
( 00201FDE )                  MOVI, X| MEM| L00202748 L, 0800 IL, 
( 00201FE8 )                  MOVI|X, AX| 12 IL, 
\ load block 18, the startup block of high-level code   
( 00201FED )                  CALL, X_load RL, 
( 00201FF2 )                  JMP, X_accept RL, 
( 00201FF7 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202007 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202017 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 

( 00202024 )   :X_nc    LEA, SI'| BO| [SI] 0FC B, 
( 00202027 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202029 )                  MOVI|X, AX| 000809D3 IL, 
( 0020202E )                  RET, 
( 0020202F )   :X_xy    LEA, SI'| BO| [SI] 0FC B, 
( 00202032 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202034 )                  MOVI|X, AX| 00080A05 IL, 
( 00202039 )                  RET, 
( 0020203A )   :X_fov    LEA, SI'| BO| [SI] 0FC B, 
( 0020203D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020203F )                  MOVI|X, AX| 00080A09 IL, 
( 00202044 )                  RET, 
( 00202045 )   :X_sp    LEA, SI'| BO| [SI] 0FC B, 
( 00202048 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020204A )                  MOVI|X, AX| 000809F0 IL, 
( 0020204F )                  RET, 
( 00202050 )   :X_last    LEA, SI'| BO| [SI] 0FC B, 
( 00202053 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202055 )                  MOVI|X, AX| 000809EA IL, 
( 0020205A )                  RET, 
( 0020205B )   :X_blk    LEA, SI'| BO| [SI] 0FC B, 
( 0020205E )                  MOV, X| F| AX'| ZO| [SI] 
( 00202060 )                  MOVI|X, AX| 000809CA IL, 
( 00202065 )                  RET, 
( 00202066 )   :X_curs    LEA, SI'| BO| [SI] 0FC B, 
( 00202069 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020206B )                  MOVI|X, AX| 000809CD IL, 
( 00202070 )                  RET, 
( 00202071 )   :X_ekt    LEA, SI'| BO| [SI] 0FC B, 
( 00202074 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202076 )                  MOVI|X, AX| 00080638 IL, 
( 0020207B )                  RET, 
( 0020207C )   :X_cpoint    LEA, SI'| BO| [SI] 0FC B, 
( 0020207F )                  MOV, X| F| AX'| ZO| [SI] 
( 00202081 )                  MOVI|X, AX| 000809D7 IL, 
( 00202086 )                  RET, 
( 00202087 )   :X_words    LEA, SI'| BO| [SI] 0FC B, 
( 0020208A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020208C )                  MOVI|X, AX| 000809E2 IL, 
( 00202091 )                  RET, 
( 00202092 )   :X_digin    LEA, SI'| BO| [SI] 0FC B, 
( 00202095 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202097 )                  MOVI|X, AX| 000809E4 IL, 
( 0020209C )                  RET, 
( 0020209D )   :X_actc    LEA, SI'| BO| [SI] 0FC B, 
( 002020A0 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020A2 )                  MOVI|X, AX| 0008056B IL, 
( 002020A7 )                  RET, 
( 002020A8 )   :X_h    LEA, SI'| BO| [SI] 0FC B, 
( 002020AB )                  MOV, X| F| AX'| ZO| [SI] 
( 002020AD )                  MOVI|X, AX| 000809E9 IL, 
( 002020B2 )                  RET, 
( 002020B3 )   :X_offset    LEA, SI'| BO| [SI] 0FC B, 
( 002020B6 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020B8 )                  MOVI|X, AX| 000809D2 IL, 
( 002020BD )                  RET, 
( 002020BE )   :X_aper    LEA, SI'| BO| [SI] 0FC B, 
( 002020C1 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020C3 )                  MOVI|X, AX| 00080A0B IL, 
( 002020C8 )                  RET, 
( 002020C9 )   :X_vesa    LEA, SI'| BO| [SI] 0FC B, 
( 002020CC )                  MOV, X| F| AX'| ZO| [SI] 
( 002020CE )                  MOVI|X, AX| 00080063 IL, 
( 002020D3 )                  RET, 
( 002020D4 )   :X_trash    LEA, SI'| BO| [SI] 0FC B, 
( 002020D7 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020D9 )                  MOVI|X, AX| 000809D1 IL, 
( 002020DE )                  RET, 
( 002020DF )   :X_buffe    LEA, SI'| BO| [SI] 0FC B, 
( 002020E2 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020E4 )                  MOVI|X, AX| 00025300 IL, 
( 002020E9 )                  RET, 
( 002020EA )   :X_cad    LEA, SI'| BO| [SI] 0FC B, 
( 002020ED )                  MOV, X| F| AX'| ZO| [SI] 
( 002020EF )                  MOVI|X, AX| 000809CE IL, 
( 002020F4 )                  RET, 
( 002020F5 )   :X_pcad    LEA, SI'| BO| [SI] 0FC B, 
( 002020F8 )                  MOV, X| F| AX'| ZO| [SI] 
( 002020FA )                  MOVI|X, AX| 000809CF IL, 
( 002020FF )                  RET, 
( 00202100 )   :X_hsvv    LEA, SI'| BO| [SI] 0FC B, 
( 00202103 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202105 )                  MOVI|X, AX| 000807FE IL, 
( 0020210A )                  RET, 
( 0020210B )   :X_displ    LEA, SI'| BO| [SI] 0FC B, 
( 0020210E )                  MOV, X| F| AX'| ZO| [SI] 
( 00202110 )                  MOVI|X, AX| 0008053C IL, 
( 00202115 )                  RET, 
( 00202116 )   :X_forths    LEA, SI'| BO| [SI] 0FC B, 
( 00202119 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020211B )                  MOVI|X, AX| 000809EE IL, 
( 00202120 )                  RET, 
( 00202121 )   :X_macros    LEA, SI'| BO| [SI] 0FC B, 
( 00202124 )                  MOV, X| F| AX'| ZO| [SI] 
( 00202126 )                  MOVI|X, AX| 000809EF IL, 
( 0020212B )                  RET, 
( 0020212C )   :X_'stk    LEA, SI'| BO| [SI] 0FC B, 
( 0020212F )                  MOV, X| F| AX'| ZO| [SI] 
( 00202131 )                  MOVI|X, AX| 0008035A IL, 
( 00202136 )                  RET, 
( 00202137 )   :X_'msg    LEA, SI'| BO| [SI] 0FC B, 
( 0020213A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020213C )                  MOVI|X, AX| 0008035D IL, 
( 00202141 )                  RET, 
( 00202142 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202152 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202162 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202172 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202182 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202192 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021A2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021B2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021C2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021D2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021E2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002021F2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202202 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202212 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202222 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202232 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202242 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202252 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202262 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202272 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202282 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202292 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022A2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022B2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022C2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022D2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022E2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002022F2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202302 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202312 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202322 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202332 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202342 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202352 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202362 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202372 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202382 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202392 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023A2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023B2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023C2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023D2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023E2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002023F2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202402 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202412 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202422 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202432 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202442 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202452 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202462 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202472 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202482 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202492 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024A2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024B2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024C2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024D2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024E2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002024F2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202502 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202512 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202522 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202532 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202542 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202552 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202562 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202572 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202582 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202592 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025A2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025B2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025C2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025D2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025E2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002025F2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202602 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202612 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202622 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202632 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202642 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202652 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202662 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202672 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202682 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 00202692 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026A2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026B2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026C2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026D2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026E2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 002026F2 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 

( 00202700 )   :FixedData   db 0A 0 0 0 64 0 0 0 0E8 3 0 0 10 27 0 0 
( 00202710 )                 db 0A0 86 1 0 40 42 0F 0 80 96 98 0 0 0E1 0F5 5 
( 00202720 )                 db 0 0CA 9A 3B 

( 00202724 )   :L00202724   dl X_. 
( 00202728 )   :L00202728   dl 12 
( 0020272C )   :L0020272C   dl 0288 
( 00202730 )   :L00202730   dl 0 
( 00202734 )   :L00202734   dl 0 
( 00202738 )   :L00202738   dl 0 
( 0020273C )   :L0020273C   dl 0 
( 00202740 )   :L00202740   dl 0 
( 00202744 )   :L00202744   dl 00094C00 
( 00202748 )   :L00202748   dl 0 
( 0020274C )   :L0020274C   dl 50 
( 00202750 )   :L00202750   dl X_accept 
( 00202754 )   :L00202754   dl 0 
( 00202758 )   :L00202758   dl L00201C17 
( 0020275C )   :L0020275C   dl 0 
( 00202760 )   :L00202760   dl 033D 
( 00202764 )   :L00202764   dl 028B 
( 00202768 )   :L00202768   dl L00200E53 
( 0020276C )   :L0020276C   dl L0020100D 
( 00202770 )   :L00202770   dl 0A 
( 00202774 )   :L00202774   dl L002011BD 
( 00202778 )   :L00202778   dl 00FFFF00 
( 0020277C )   :L0020277C   dl 1 
( 00202780 )   :L00202780   dl L002006C9 
( 00202784 )   :L00202784   dl X_nul 
( 00202788 )   :L00202788   dl 1 
( 0020278C )   :L0020278C   dl 0 
( 00202790 )   :L00202790   dl 0 
( 00202794 )   :L00202794   dl L002005B6 
( 00202798 )   :L00202798   dl 6 
( 0020279C )   :L0020279C   dl 63 
( 002027A0 )   :L002027A0   dl 00100000 
( 002027A4 )   :L002027A4   dl 00100000 
( 002027A8 )   :L002027A8   dl 0 
( 002027AC )   :L002027AC   dl 0 
( 002027B0 )   :L002027B0   dl 0 
( 002027B4 )   :ForthWords   dl 0 
( 002027B8 )   :ForthMacros   dl 63 
( 002027BC )   :L002027BC   dl 6 L00200869 
( 002027C4 )                 dl L002006D6 
( 002027C8 )   :L002027C8   dl L0020078A 
( 002027CC )   :L002027CC   dl L002005E8 
( 002027D0 )   :L002027D0   dl L00200702 
( 002027D4 )   :L002027D4   dl L002006A2 L002006B2 L00200752 L00200770 
( 002027E4 )                 dl X_nul X_nul X_nul L00200653 
( 002027F4 )                 dl X_nul X_nul 
( 002027FC )   :L002027FC   dl X_nul 
( 00202800 )   :L00202800   dl L00200446 
( 00202804 )   :L00202804   dl X_nul 
( 00202808 )   :L00202808   dl X_nul 
( 0020280C )   :L0020280C   dl X_graph 
( 00202810 )   :L00202810   dl L00200990 

( 00202814 )   :L00202814   dw 0003 
( 00202816 )   :L00202816   dw 0003 
( 00202818 )   :L00202818   dw 0003 0000 
( 0020281C )   :L0020281C   dw 03F4 0000 0000 0000 
( 00202824 )   :L00202824   dw 4B00 0000 
( 00202828 )   :L00202828   dw 0000 01F0 
( 0020282C )   :L0020282C   dw 0000 01F0 
( 00202830 )   :L00202830   dw 0000 0000 
( 00202834 )   :L00202834   dw F7DE 0000 
( 00202838 )   :L00202838   dw 0000 0000 
( 0020283C )   :L0020283C   dw 0000 0000 

( 00202840 )   :EncodedMacros names ; dup ?dup drop 
( 00202850 )               names then begin _ _ 
( 00202860 )               names _ _ _ _ 
( 00202870 )               names _ _ _ _ 
( 00202880 )               names _ _ _ _ 
( 00202890 )               names _ _ _ _ 
( 002028A0 )               names _ _ _ _ 
( 002028B0 )               names _ _ _ _ 
( 002028C0 )               names _ _ _ _ 
( 002028D0 )               names _ _ _ _ 
( 002028E0 )               names _ _ _ _ 
( 002028F0 )               names _ _ _ _ 
( 00202900 )               names _ _ _ _ 
( 00202910 )               names _ _ _ _ 
( 00202920 )               names _ _ _ _ 
( 00202930 )               names _ _ _ _ 
( 00202940 )               names _ _ _ _ 
( 00202950 )               names _ _ _ _ 
( 00202960 )               names _ _ _ _ 
( 00202970 )               names _ _ _ _ 
( 00202980 )               names _ _ _ _ 
( 00202990 )               names _ _ _ _ 
( 002029A0 )               names _ _ _ _ 
( 002029B0 )               names _ _ _ _ 
( 002029C0 )               names _ _ _ _ 
( 002029D0 )               names _ _ _ _ 
( 002029E0 )               names _ _ _ _ 
( 002029F0 )               names _ _ _ _ 
( 00202A00 )               names _ _ _ _ 
( 00202A10 )               names _ _ _ _ 
( 00202A20 )               names _ _ _ _ 
( 00202A30 )               names _ _ _ _ 
( 00202A40 )               names _ _ _ _ 
( 00202A50 )               names _ _ 

( 00202A58 )   :MacroPointers   dl X_; X_dup X_?dup X_drop 
( 00202A68 )                 dl X_then X_begin 0 0 
( 00202A78 )                 dl 0 0 0 0 
( 00202A88 )                 dl 0 0 0 0 
( 00202A98 )                 dl 0 0 0 0 
( 00202AA8 )                 dl 0 0 0 0 
( 00202AB8 )                 dl 0 0 0 0 
( 00202AC8 )                 dl 0 0 0 0 
( 00202AD8 )                 dl 0 0 0 0 
( 00202AE8 )                 dl 0 0 0 0 
( 00202AF8 )                 dl 0 0 0 0 
( 00202B08 )                 dl 0 0 0 0 
( 00202B18 )                 dl 0 0 0 0 
( 00202B28 )                 dl 0 0 0 0 
( 00202B38 )                 dl 0 0 0 0 
( 00202B48 )                 dl 0 0 0 0 
( 00202B58 )                 dl 0 0 0 0 
( 00202B68 )                 dl 0 0 0 0 
( 00202B78 )                 dl 0 0 0 0 
( 00202B88 )                 dl 0 0 0 0 
( 00202B98 )                 dl 0 0 0 0 
( 00202BA8 )                 dl 0 0 0 0 
( 00202BB8 )                 dl 0 0 0 0 
( 00202BC8 )                 dl 0 0 0 0 
( 00202BD8 )                 dl 0 0 0 0 
( 00202BE8 )                 dl 0 0 0 0 
( 00202BF8 )                 dl 0 0 0 0 
( 00202C08 )                 dl 0 0 0 0 
( 00202C18 )                 dl 0 0 0 0 
( 00202C28 )                 dl 0 0 0 0 
( 00202C38 )                 dl 0 0 0 0 
( 00202C48 )                 dl 0 0 0 0 
( 00202C58 )                 dl 0 0 0 0 
( 00202C68 )                 dl 0 0 

( 00202C70 )   :EncodedWords names forths macros boot warm 
( 00202C80 )               names pause macro forth c 
( 00202C90 )               names stop read write nc 
( 00202CA0 )               names format show serve load 
( 00202CB0 )               names here ?lit 3, 2, 
( 00202CC0 )               names 1, , less jump 
( 00202CD0 )               names pci devic accept pad 
( 00202CE0 )               names erase copy mark empt 
( 00202CF0 )               names emit digit 2emit . 
( 00202D00 )               names h. h.n cr space 
( 00202D10 )               names down edit e lm 
( 00202D20 )               names rm graph switch freeze 
( 00202D30 )               names text top keybo debu 
( 00202D40 )               names at +at xy fov 
( 00202D50 )               names fifo box line color 
( 00202D60 )               names octant sp last unpac 
( 00202D70 )               names blk curs word ekt 
( 00202D80 )               names abort h buffe offset 
( 00202D90 )               names tic winver aper vesa 
( 00202DA0 )               names trash hsvv tsim cpoint 
( 00202DB0 )               names words qkey digin qwert 
( 00202DC0 )               names no-ret r? nul cad 
( 00202DD0 )               names pcad displ actc +list 
( 00202DE0 )               names itick lis +e 'stk 
( 00202DF0 )               names 'msg ?. _ 

( 00202DFC )   :WordPointers   dl X_forths X_macros X_boot X_warm 
( 00202E0C )                 dl X_pause X_macro X_forth X_c 
( 00202E1C )                 dl X_stop X_read X_write X_nc 
( 00202E2C )                 dl X_format X_show X_serve X_load 
( 00202E3C )                 dl X_here X_?lit X_3, X_2, 
( 00202E4C )                 dl X_1, X_, X_less X_jump 
( 00202E5C )                 dl X_pci X_devic X_accept X_pad 
( 00202E6C )                 dl X_erase X_copy X_mark X_empt 
( 00202E7C )                 dl X_emit X_digit X_2emit X_. 
( 00202E8C )                 dl X_h. X_h.n X_cr X_space 
( 00202E9C )                 dl X_down X_edit X_e X_lm 
( 00202EAC )                 dl X_rm X_graph X_switch X_freeze 
( 00202EBC )                 dl X_text X_top X_keybo X_debu 
( 00202ECC )                 dl X_at X_+at X_xy X_fov 
( 00202EDC )                 dl X_fifo X_box X_line X_color 
( 00202EEC )                 dl X_octant X_sp X_last X_unpac 
( 00202EFC )                 dl X_blk X_curs X_word X_ekt 
( 00202F0C )                 dl X_abort X_h X_buffe X_offset 
( 00202F1C )                 dl X_tic X_winver X_aper X_vesa 
( 00202F2C )                 dl X_trash X_hsvv X_nc X_cpoint 
( 00202F3C )                 dl X_words X_qkey X_digin X_qwert 
( 00202F4C )                 dl X_no-ret X_r? X_nul X_cad 
( 00202F5C )                 dl X_pcad X_displ X_actc X_+list 
( 00202F6C )                 dl X_itick X_lis X_+e X_'stk 
( 00202F7C )                 dl X_'msg X_?. 0 0 
( 00202F8C )                 dl 0 0 0 0 
( 00202F9C )                 dl 0 0 0 0 
( 00202FAC )                 dl 0 0 0 0 
( 00202FBC )                 dl 0 0 0 0 
( 00202FCC )                 dl 0 0 0 0 
( 00202FDC )                 dl 0 0 0 0 
( 00202FEC )                 dl 0 0 0 0 
( 00202FFC )                 dl 0 

( 00203000 )   :IconImages icons{ 
0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000000000000000 
0 0000000000000000 1 0000000000000000 2 0000001110000000 3 0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   1110001111111000   0011111111111100   0001111111111000 
  0000000000000000   1111011111111110   0011111111111100   0111111111111110 
  0000000000000000   1111111111111111   0011111111111100   0111111111111110 
  0000000000000000   1111110000000111   0000001111000000   1111100000011111 
  0000000000000000   1111100000000001   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111100000011111 
  0000000000000000   1111000000000000   0000001111000000   0111111111111110 
  0000000000000000   1111000000000000   0000001111000000   0111111111111110 
  0000000000000000   1111000000000000   0000001111000000   0001111111111000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000001111000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0001111111111000   0001111111111000   1110001111111000   0000000000000000 
  0111111111111110   0111111111111110   1111011111111110   0000001111000000 
  0111111111111111   0111111111111110   1111111111111110   0000001111000000 
  1111000000001111   0000000000011111   1111110000011111   0000001111000000 
  1111000000001111   0000000000001111   1111100000001111   0000001111000000 
  1111000000011111   0000000000001111   1111000000001111   0000001111000000 
  1111111111111110   0011111111111111   1111000000001111   0000001111000000 
  1111111111111100   0111111111111111   1111000000001111   0000001111000000 
  1111000000000000   1111100000001111   1111000000001111   0000001111000000 
  1111000000000000   1111000000001111   1111000000001111   0000001111000000 
  1111100000000000   1111000000011111   1111000000001111   0000001111000000 
  0111111111111110   0111111111111111   1111000000001111   0000001111000000 
  0111111111111110   0111111111111111   1111000000001111   0000001111000000 
  0001111111111000   0001111111110111   1111000000001111   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0001111111111000   1101110000111100   0001111111111000   1111000000001111 
  0111111111111110   1111111001111110   0111111111111110   1111000000001111 
  0111111111111110   1111111111111111   0111111111111110   1111000000001111 
  1111100000000010   1111111111111111   1111100000001111   1111000000001111 
  1111000000000000   1111001111001111   1111000000000001   1111000000001111 
  1111000000000000   1110000110000111   1111000000000000   1111000000001111 
  0111111111111100   1110000000000111   1111000000000000   1111000000001111 
  0011111111111110   1110000000000111   1111000000000000   1111000000001111 
  0000000000001111   1110000000000111   1111000000000000   1111100000011111 
  0000000000001111   1110000000000111   1111000000000001   0111110000111111 
  0100000000011111   1110000000000111   1111100000001111   0111111111111111 
  0111111111111110   1110000000000111   0111111111111110   0001111111111111 
  0111111111111110   1110000000000111   0111111111111110   0000011111101111 
  0001111111111000   1110000000000111   0001111111111000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0110000000011111 
  0000000000000000   0000000000000000   0000000000000000   0111111111111110 
  0000000000000000   0000000000000000   0000000000000000   0111111111111110 
  0000000000000000   0000000000000000   0000000000000000   0011111111111000 

0 0000111100000000 0 0000000000000000 0 0000000111111000 0 0000000000000000 
C 0000011110000000 D 0000000000000000 E 0000001111111100 F 0000000000000000 
  0000011110000000   0000000000000000   0000011110001100   0000000000000000 
  0000011110000000   0000000000000000   0000011110000000   0000000000000000 
  0000011110000000   0000000000000000   0000011110000000   0000000000000000 
  0000011110000000   0001111111100111   0011111111110000   1100000000000011 
  0000011110000000   0111111111110111   0011111111110000   1110000000000111 
  0000011110000000   0111111111111111   0011111111110000   1110000000000111 
  0000011110000000   1111100000011111   0000011110000000   1110000000000111 
  0000011110000000   1111000000001111   0000011110000000   1111000110001111 
  0000011110000000   1111000000001111   0000011110000000   0111000110001110 
  0000011110000000   1111000000001111   0000011110000000   0111000110001110 
  0000011110000000   1111000000001111   0000011110000000   0111101111011110 
  0000011110000000   1111000000001111   0000011110000000   0011101111011100 
  0000011110000000   1111100000011111   0000011110000000   0011111111111100 
  0000011110000000   0111111111111111   0000011110000000   0001111001111000 
  0000011111000000   0111111111111111   0000011110000000   0001111001111000 
  0000011111000000   0001111111111111   0000011110000000   0000110000110000 
  0000001111100000   0000000000001111   0000011110000000   0000110000110000 
  0000000000000000   0000000000001111   0000000000000000   0000000000000000 
  0000000000000000   0110000000011111   0000000000000000   0000000000000000 
  0000000000000000   0111111111111110   0000000000000000   0000000000000000 
  0000000000000000   0111111111111110   0000000000000000   0000000000000000 
  0000000000000000   0001111111111000   0000000000000000   0000000000000000 

1 0000000000001111 1 0000000000000000 1 0000000000000000 1 1111000000000000 
0 0000000000001111 1 0000000000000000 2 0000000000000000 3 1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0001111111101111   1110000000000111   1110011111111000   1111011111111000 
  0111111111111111   1110000000000111   1111111111111110   1111111111111110 
  0111111111111111   1111000000001111   1111111111111110   1111111111111110 
  1111100000011111   0111000000001110   1111100000011111   1111100000011111 
  1111000000001111   0111100000011110   1111000000001111   1111000000001111 
  1111000000001111   0011100000011100   1111000000001111   1111000000001111 
  1111000000001111   0011110000111100   1111000000001111   1111000000001111 
  1111000000001111   0001110000111000   1111000000001111   1111000000001111 
  1111000000001111   0001111001111000   1111000000001111   1111000000001111 
  1111000000001111   0000111001110000   1111000000001111   1111000000001111 
  1111100000011111   0000111111110000   1111100000011111   1111100000011111 
  0111111111111111   0000011111100000   1111111111111110   1111111111111110 
  0111111111111111   0000001111000000   1111111111111110   1110111111111110 
  0001111111101111   0000000110000000   1111011111111000   1110011111111000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 

1 1111000000000000 1 0000000000000000 1 0000000000000000 1 0000000000000000 
4 1111000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111011111111000   1111000000001111   1111000000001111   0001111111100111 
  1111111111111110   1111100000011111   1111000000001111   0111111111110111 
  1111111111111110   0111110000111110   1111000000001111   0111111111111111 
  1111100000011111   0011111001111100   1111000000001111   1111100000011111 
  1111000000001111   0001111111111000   1111000000001111   1111000000001111 
  1111000000001111   0000111111110000   1111000000001111   1111000000001111 
  1111000000001111   0000011111100000   1111000000001111   1111000000001111 
  1111000000001111   0000011111100000   1111000000001111   1111000000001111 
  1111000000001111   0000111111110000   1111000000001111   1111000000001111 
  1111000000001111   0001111111111000   1111000000001111   1111000000001111 
  1111000000001111   0011111001111100   1111100000011111   1111100000011111 
  1111000000001111   0111110000111110   0111111111111110   0111111111111111 
  1111000000001111   1111100000011111   0111111111111110   0111111111111111 
  1111000000001111   1111000000001111   0001111111111000   0001111111101111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001110 

1 0001111111111000 1 0000000111100000 1 0001111111111000 1 0001111111111000 
8 0111111111111110 9 0000001111100000 A 0111111111111110 B 0111111111111110 
  0111111111111110   0000011111100000   0111111111111110   0111111111111110 
  1111100000011111   0000111111100000   1111000000011111   1111000000011111 
  1111000000001111   0000111111100000   0000000000001111   0000000000001111 
  1111000000001111   0000110111100000   0000000000001111   0000000000001111 
  1111000000001111   0000100111100000   0000000000001111   0000000000001111 
  1111000000001111   0000000111100000   0000000000011111   0000000000011111 
  1111000000001111   0000000111100000   0001111111111110   0000011111111110 
  1111000000001111   0000000111100000   0111111111111110   0000011111111100 
  1111000000001111   0000000111100000   0111111111111000   0000011111111110 
  1111000000001111   0000000111100000   1111100000000000   0000000000011111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111100000011111   0000000111100000   1111000000000000   1111000000011111 
  0111111111111110   0000000111100000   1111111111111111   0111111111111110 
  0111111111111110   0000000111100000   1111111111111111   0111111111111110 
  0001111111111000   0000000111100000   1111111111111111   0001111111111000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

1 1111000011110000 1 1111111111111111 1 0001111111111000 1 1111111111111111 
C 1111000011110000 D 1111111111111111 E 0111111111111110 F 1111111111111111 
  1111000011110000   1111111111111111   0111111111111111   1111111111111111 
  1111000011110000   1111000000000000   1111100000001111   0000000000000111 
  1111000011110000   1111000000000000   1111000000000000   0000000000001111 
  1111000011110000   1111000000000000   1111000000000000   0000000000011111 
  1111000011110000   1111000000000000   1111000000000000   0000000000111110 
  1111000011110000   1111000000000000   1111000000000000   0000000001111100 
  1111111111111111   1111111111111000   1111011111111000   0000000011111000 
  1111111111111111   1111111111111110   1111111111111110   0000000111110000 
  1111111111111111   1111111111111110   1111111111111111   0000001111100000 
  0000000011110000   0000000000011111   1111100000011111   0000011111000000 
  0000000011110000   0000000000001111   1111000000001111   0000111110000000 
  0000000011110000   0000000000001111   1111000000001111   0001111100000000 
  0000000011110000   0000000000001111   1111000000001111   0011111000000000 
  0000000011110000   1111000000011111   1111100000011111   0111110000000000 
  0000000011110000   1111111111111110   0111111111111110   1111100000000000 
  0000000011110000   0111111111111110   0111111111111110   1111000000000000 
  0000000011110000   0001111111111000   0001111111111000   1110000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

2 0001111111111000 2 0001111111111000 2 0000000001111000 2 0000000000000000 
0 0111111111111110 1 0111111111111110 2 0000000001111000 3 0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  1111100000011111   1111100000011111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000001111000   0000000000000000 
  1111100000011111   1111100000011111   0000000001111000   0000000000000000 
  0111111111111110   1111111111111111   0000000001111000   0001111111111100 
  0011111111111100   0111111111111111   0000000001111000   0011111111111100 
  0111111111111110   0001111111101111   0000000001111000   0011111111111000 
  1111100000011111   0000000000001111   0000000001111000   0000000000000000 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111100000011111   1111000000011111   0000000001111000   0000000000000000 
  0111111111111110   1111111111111110   0000000001111000   0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  0001111111111000   0001111111111000   0000000001111000   0000000000000000 
  0000000000000000   0000000000000000   0000000001111000   0000000000000000 
  0000000000000000   0000000000000000   0011110011111000   0000000000000000 
  0000000000000000   0000000000000000   0011111111110000   0000000000000000 
  0000000000000000   0000000000000000   0001111111110000   0000000000000000 
  0000000000000000   0000000000000000   0000111111000000   0000000000000000 

2 1111000000000000 2 0000000000000000 2 0000000000000000 2 0000000000001111 
4 1111000000000000 5 0000000000000000 6 0000000000000000 7 0000000000011111 
  1111000000000000   0000000000000000   0000000000000000   0000000000011111 
  1111000000000000   0000000000000000   0000000000000000   0000000000111110 
  1111000000000000   0000000000000000   0000000000000000   0000000001111100 
  1111000000111100   0000000000000000   0000000000000000   0000000001111100 
  1111000011111100   0000000000000000   1111111111111111   0000000011111000 
  1111001111111100   0000000000000000   1111111111111111   0000000111110000 
  1111111111100000   0000000000000000   1111111111111111   0000000111110000 
  1111111110000000   0000000000000000   0000000000011111   0000001111100000 
  1111111100000000   0000000000000000   0000000000111111   0000011111000000 
  1111111100000000   0000000000000000   0000000011111110   0000011111000000 
  1111111111000000   0000000000000000   0000001111111000   0000111110000000 
  1111111111110000   0000011100000000   0000111111100000   0001111100000000 
  1111001111111100   0000111110000000   0011111110000000   0001111100000000 
  1111000111111111   0001111111000000   1111111000000000   0011111000000000 
  1111000001111111   0001111111000000   1111111111111111   0111110000000000 
  1111000000011111   0001111111000000   1111111111111111   1111110000000000 
  1111000000000111   0000111110000000   1111111111111111   1111100000000000 
  0000000000000000   0000011100000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

2 0000000000000000 2 0000000011110000 2 0000000110000000 2 0000000000000000 
8 0000000000000000 9 0000000011110000 A 0000000110000000 B 0000000000000000 
  0000000000000000   0000000111100000   0000001111000000   0000000000000000 
  0000011100000000   0000000111100000   0000001111000000   0000000000000000 
  0000111110000000   0000000111000000   0000001111000000   0000001111000000 
  0001111111000000   0000000111000000   0000011111100000   0000001111000000 
  0001111111000000   0000001110000000   0000011111100000   0000001111000000 
  0001111111000000   0000001110000000   0000011111100000   0000001111000000 
  0000111110000000   0000001100000000   0000011111100000   0011111111111100 
  0000011100000000   0000001100000000   0000001111000000   0011111111111100 
  0000000000000000   0000001000000000   0000001111000000   0011111111111100 
  0000000000000000   0000001000000000   0000000110000000   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000001111000000 
  0000011100000000   0000000000000000   0000000000000000   0000001111000000 
  0000111110000000   0000000000000000   0000000110000000   0000001111000000 
  0001111111000000   0000000000000000   0000001111000000   0000000000000000 
  0001111111000000   0000000000000000   0000011111100000   0000000000000000 
  0001111111000000   0000000000000000   0000011111100000   0000000000000000 
  0000111111000000   0000000000000000   0000001111000000   0000000000000000 
  0000011111000000   0000000000000000   0000000110000000   0000000000000000 
  0000001110000000   0000000000000000   0000000000000000   0000000000000000 
  0000011100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111000000000   0000000000000000   0000000000000000   0000000000000000 
  0001110000000000   0000000000000000   0000000000000000   0000000000000000 

2 0001111111111000 2 0000000000000000 2 0000000000000000 2 0001111111111000 
C 0111111111111110 D 0000000000000000 E 0000000000000000 F 0111111111111110 
  0111111111111110   0000000000000000   0000000000000000   0111111111111110 
  1111000000001111   0000000000000000   0000000000000000   1111000000001111 
  1110000000000111   0000100000010000   0000000000000000   1111000000000111 
  1110000000000111   0001110000111000   0000000000000000   0000000000000111 
  1110000110000111   0011111001111100   0000000000000000   0000000000001111 
  1110001111000111   0001111111111000   0000000000000000   0000000000111110 
  1110001111000111   0000111111110000   0000000000000000   0000000011111000 
  1110001111000111   0000011111100000   0000000000000000   0000001111100000 
  1110001111111110   0000111111110000   0000000000000000   0000001111000000 
  1110001111111110   0001111111111000   0000000000000000   0000001111000000 
  1110000111111000   0011111001111100   0000000000000000   0000000000000000 
  1110000000000000   0001110000111000   0000011100000000   0000000000000000 
  1110000000000000   0000100000010000   0000111110000000   0000000110000000 
  1111000000001111   0000000000000000   0001111111000000   0000001111000000 
  0111111111111110   0000000000000000   0001111111000000   0000011111100000 
  0111111111111110   0000000000000000   0001111111000000   0000011111100000 
  0001111111111000   0000000000000000   0000111111000000   0000001111000000 
  0000000000000000   0000000000000000   0000011111000000   0000000110000000 
  0000000000000000   0000000000000000   0000001110000000   0000000000000000 
  0000000000000000   0000000000000000   0000011100000000   0000000000000000 
  0000000000000000   0000000000000000   0000111000000000   0000000000000000 
  0000000000000000   0000000000000000   0001110000000000   0000000000000000 

3 1111111111110000 3 0000000000000000 3 0000000000000000 3 0000000000000000 
0 1111111111111100 1 0000000000000000 2 0001100000000000 3 0000000000000000 
  1111111111111110   0000000000000000   0001100000000000   0000000000000000 
  0111111111111110   0110111000000000   0111111000000000   0011111000000000 
  0011111111111111   0111111100000000   0111111000000000   0111111100000000 
  0001111111111111   0111000100000000   0001100000000000   0110001100000000 
  0000111111111111   0110000000000000   0001100000000000   0110001100000000 
  0000011111111111   0110000000000000   0001100000000000   0110001100000000 
  0000001111111111   0110000000000000   0001100000000000   0110001100000000 
  0000000111111111   0110000000000000   0001100000000000   0111111100000000 
  0000000011111111   0110000000000000   0001110000000000   0011111000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000111111111   0000000000000000   0000000000000000   0000000000000000 
  0000001111111111   0000000000000000   0000000000000000   0000000000000000 
  0000011111111111   0000000000000000   0000000000000000   0000000000000000 
  0000111111111111   0000000000000000   0000000000000000   0000000000000000 
  0001111111111111   0000000000000000   0000000000000000   0000000000000000 
  0011111111111111   0000000000000000   0000000000000000   0000000000000000 
  0111111111111110   0000000000000000   0000000000000000   0000000000000000 
  1111111111111110   0000000000000000   0000000000000000   0000000000000000 
  1111111111111100   0000000000000000   0000000000000000   0000000000000000 
  1111111111110000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000000000000000 3 0001100000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0001100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0011111000000000   0001111000000000   0110111000000000   0000000000000000 
  0111111100000000   0011111100000000   0111111100000000   0011100000000000 
  0110001100000000   0000001100000000   0111001100000000   0001100000000000 
  0111111100000000   0011111100000000   0110001100000000   0001100000000000 
  0111111000000000   0111111100000000   0110001100000000   0001100000000000 
  0110000000000000   0110001100000000   0110001100000000   0001100000000000 
  0111111100000000   0111111100000000   0110001100000000   0001100000000000 
  0011111000000000   0011101110000000   0110001100000000   0001110000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000000000000000 3 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0011111000000000   0110001100000000   0011111000000000   0110001100000000 
  0111111100000000   0111011100000000   0111111100000000   0110001100000000 
  0110000000000000   0111111100000000   0110000100000000   0110001100000000 
  0111111000000000   0110101100000000   0110000000000000   0110001100000000 
  0011111100000000   0110001100000000   0110000000000000   0111111100000000 
  0000001100000000   0110001100000000   0110000100000000   0011111100000000 
  0111111100000000   0110001100000000   0111111100000000   0000001100000000 
  0011111000000000   0110001100000000   0011111000000000   0100001100000000 
  0000000000000000   0000000000000000   0000000000000000   0111111100000000 
  0000000000000000   0000000000000000   0000000000000000   0011111000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000111000000000 3 0000000000000000 
C 0011100000000000 D 0000000000000000 E 0001101000000000 F 0000000000000000 
  0001100000000000   0000000000000000   0001100000000000   0000000000000000 
  0001100000000000   0011101100000000   0111111000000000   1110001110000000 
  0001100000000000   0111111100000000   0111111000000000   0110001100000000 
  0001100000000000   0110001100000000   0001100000000000   0110001100000000 
  0001100000000000   0110001100000000   0001100000000000   0110101100000000 
  0001100000000000   0111111100000000   0001100000000000   0111111100000000 
  0001100000000000   0011111100000000   0001100000000000   0111111100000000 
  0001100000000000   0000001100000000   0001100000000000   0111011100000000 
  0001110000000000   0100001100000000   0001100000000000   0110001100000000 
  0000000000000000   0111111100000000   0000000000000000   0000000000000000 
  0000000000000000   0011111000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0000001100000000 4 0000000000000000 4 0000000000000000 4 0110000000000000 
0 0000001100000000 1 0000000000000000 2 0000000000000000 3 0110000000000000 
  0000001100000000   0000000000000000   0000000000000000   0110000000000000 
  0011101100000000   0110001100000000   0110111000000000   0110111000000000 
  0111111100000000   0110001100000000   0111111100000000   0111111100000000 
  0110001100000000   0110001100000000   0110001100000000   0110001100000000 
  0110001100000000   0110001100000000   0110001100000000   0110001100000000 
  0110001100000000   0111011100000000   0110001100000000   0110001100000000 
  0110001100000000   0011111000000000   0110001100000000   0110001100000000 
  0111111100000000   0001110000000000   0111111100000000   0111111100000000 
  0011101100000000   0000100000000000   0110111000000000   0110111000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0110000000000000 4 0000000000000000 4 0000000000000000 4 0000000000000000 
4 0110000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0110000000000000   0000000000000000   0000000000000000   0000000000000000 
  0110111000000000   0110001100000000   0110001100000000   0011101100000000 
  0111111100000000   0111011100000000   0110001100000000   0111111100000000 
  0111001100000000   0011011000000000   0110001100000000   0110001100000000 
  0110001100000000   0001110000000000   0110001100000000   0110001100000000 
  0110001100000000   0001110000000000   0110001100000000   0110001100000000 
  0110001100000000   0011011000000000   0110001100000000   0110001100000000 
  0110001100000000   0111011100000000   0111111100000000   0111111100000000 
  0110001100000000   0110001100000000   0011111000000000   0011101100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0011111000000000 4 0000110000000000 4 0011111000000000 4 0011111000000000 
8 0111111100000000 9 0001110000000000 A 0111111100000000 B 0111111100000000 
  0110001100000000   0011110000000000   0110001100000000   0110001100000000 
  0110001100000000   0000110000000000   0000001100000000   0000001100000000 
  0110001100000000   0000110000000000   0000011100000000   0000111100000000 
  0110001100000000   0000110000000000   0000111000000000   0000111100000000 
  0110001100000000   0000110000000000   0001110000000000   0000001100000000 
  0110001100000000   0000110000000000   0011100000000000   0110001100000000 
  0110001100000000   0000110000000000   0111000000000000   0110001100000000 
  0111111100000000   0011111100000000   0111111100000000   0111111100000000 
  0011111000000000   0011111100000000   0111111100000000   0011111000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0000011000000000 4 0111111100000000 4 0011111000000000 4 0111111100000000 
C 0110011000000000 D 0111111100000000 E 0111111100000000 F 0111111100000000 
  0110011000000000   0110000000000000   0110001100000000   0000001100000000 
  0110011000000000   0110000000000000   0110000000000000   0000001100000000 
  0110011000000000   0111111000000000   0111111000000000   0000011100000000 
  0111111100000000   0111111100000000   0111111100000000   0000111000000000 
  0111111100000000   0000001100000000   0110001100000000   0001110000000000 
  0000011000000000   0000001100000000   0110001100000000   0001100000000000 
  0000011000000000   0110001100000000   0110001100000000   0001100000000000 
  0000011000000000   0111111100000000   0111111100000000   0001100000000000 
  0000011000000000   0011111000000000   0011111000000000   0001100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0011111000000000 5 0011111000000000 5 0000011000000000 5 0000000000000000 
0 0111111100000000 1 0111111100000000 2 0000011000000000 3 0000000000000000 
  0110001100000000   0110001100000000   0000000000000000   0000000000000000 
  0110001100000000   0110001100000000   0000000000000000   0000000000000000 
  0111111100000000   0111111100000000   0000111000000000   0001111100000000 
  0111111100000000   0011111100000000   0000011000000000   0011111000000000 
  0110001100000000   0000001100000000   0000011000000000   0000000000000000 
  0110001100000000   0000001100000000   0000011000000000   0000000000000000 
  0110001100000000   0110001100000000   0000011000000000   0000000000000000 
  0111111100000000   0111111100000000   0000011000000000   0000000000000000 
  0011111000000000   0011111000000000   0000011000000000   0000000000000000 
  0000000000000000   0000000000000000   0110011000000000   0000000000000000 
  0000000000000000   0000000000000000   0111111000000000   0000000000000000 
  0000000000000000   0000000000000000   0011110000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0110000000000000 5 0000000000000000 5 0000000000000000 5 0000001100000000 
4 0110000000000000 5 0000000000000000 6 0000000000000000 7 0000011100000000 
  0110000000000000   0000000000000000   0000000000000000   0000011000000000 
  0110011000000000   0000000000000000   0000000000000000   0000111000000000 
  0110111000000000   0000000000000000   0111111100000000   0000110000000000 
  0111110000000000   0000000000000000   0111111100000000   0001110000000000 
  0111100000000000   0000000000000000   0000111000000000   0001100000000000 
  0111100000000000   0001100000000000   0001110000000000   0011100000000000 
  0111110000000000   0011110000000000   0011100000000000   0011000000000000 
  0110111000000000   0011110000000000   0111111100000000   0111000000000000 
  0110011100000000   0001100000000000   0111111100000000   0110000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0000000000000000 5 0000111100000000 5 0001100000000000 5 0000000000000000 
8 0000000000000000 9 0000111000000000 A 0001100000000000 B 0000000000000000 
  0001100000000000   0001110000000000   0011110000000000   0000000000000000 
  0011110000000000   0001100000000000   0011110000000000   0000000000000000 
  0011110000000000   0011000000000000   0011110000000000   0001100000000000 
  0001100000000000   0000000000000000   0001100000000000   0001100000000000 
  0000000000000000   0000000000000000   0001100000000000   0111111000000000 
  0001100000000000   0000000000000000   0000000000000000   0111111000000000 
  0011110000000000   0000000000000000   0000000000000000   0001100000000000 
  0011110000000000   0000000000000000   0001100000000000   0001100000000000 
  0001100000000000   0000000000000000   0001100000000000   0000000000000000 
  0011000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0011111000000000 5 0000000000000000 5 0000000000000000 5 0011111000000000 
C 0111111100000000 D 0000000000000000 E 0000000000000000 F 0111111100000000 
  0110001100000000   0000000000000000   0000000000000000   0110001100000000 
  0110001100000000   0000000000000000   0000000000000000   0000011100000000 
  0110101100000000   0110011000000000   0000000000000000   0000111000000000 
  0110111100000000   0111111000000000   0000000000000000   0001110000000000 
  0110111000000000   0011110000000000   0000000000000000   0001100000000000 
  0110000000000000   0011110000000000   0001100000000000   0000000000000000 
  0110001100000000   0111111000000000   0011110000000000   0000000000000000 
  0111111100000000   0110011000000000   0011110000000000   0001100000000000 
  0011111000000000   0000000000000000   0001100000000000   0001100000000000 
  0000000000000000   0000000000000000   0011000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0111111000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
0 0111111100000000 1 0000000000000000 2 0000000000000000 3 0000000000000000 
  0011111100000000   0000000000000000   0000000000000000   0000000000000000 
  0001111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0001111100000000   0000000000000000   0000000000000000   0000000000000000 
  0011111100000000   0000000000000000   0000000000000000   0000000000000000 
  0111111100000000   0000000000000000   0000000000000000   0000000000000000 
  0111111000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
C 0000000000000000 D 0000000000000000 E 0000000000000000 F 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
0 0000000000000000 1 0000000000000000 2 0000000000000000 3 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
C 0000000000000000 D 0000000000000000 E 0000000000000000 F 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
}icons

( 00204800 )               D# 18 code{ 
 :# ns -522 :# nblk 1440 :# nc 15 ( 144a12 01g 42c/01w/22a copyright
 2009-2011 greenarrays,inc ) { , }
 [ d# 20 load d# 22 load d# 24 load ] ( colors ) [ d# 28 load ]
: abuf [ d# 10000 ] ; { * }
: cbuf [ d# 29000 ] ; { , }
 ( decompress ) [ mark d# 30 load restore empt ]
: env [ d# 34 ] winver 2* + ; [ env ] ( ironment ) [ load ] { , }
 [ d# 44 d# 2 loads d# 62 d# 5 loads d# 88 load d# 84 load ] { , , }
: floppy [ d# 52 ] ; { * . }
     
: dump [ d# 48 ] load ; { * }
: flush save ;
: icons { . }
      [ d# 54 ] ; { * }
: audit [ d# 90 ] ; { * }
: index [ d# 76 ] ; { * }
: html [ d# 176 ] ; { , , }
 [ mark empty ] ( arrayforth ) [ d# 144 load qwerty seeb ] { , }
 ( application tools ) [ d# 202 d# 2 loads mark empty ] { , , }
 [ exit ] ( or compile any following... )
: q { 584F } [ d# 660 ] load ; [ mark empty ] }block

( 00204C00 )               D# 19 shadow{ 
 ( x86 colorforth and arrayforth tm )
: ns ( number of sectors compressed if neg, ) { cr }
 ( last compressed if pos. )
: nblk ( number of uncompressed blocks. )
: nc ( no. of compressed cylinders, deprecated ) { cr }
 [ these vars must be first things in block! ] { br }

: abuf ( starting block of { 6F } mb audit buffer )
: cbuf ( starting block of { 6F } mb compression buffer )
: floppy ( utilities for floppy format and ops. )
: dump ( compile memory display background task )
: flush ( eases concurrent use of pf/ef. )
: icons ( compile icon editor )
: audit ( utility for reconciliation and merging )
: index ( file listing first lines of blocks )
: html ( colorforth source to 2-up html file ) { , , }
 ( saying ) [ qwerty ] enables ( the qwerty keyboard mode till next
 boot. ) { cr }
 [ seeb ] ( toggles blue word display ) on. }block

( 00205000 )               D# 20 code{ 
 ( macros ) [ macro ]
: swap h# 168B 2, H# -3D74F977 , ;
: 0 < ?dup > h# C031 2, ; { -cr }
: if h# 74 2, here ;
: -if h# 79 2, here ; { -cr }
: while ( n-nn ) < if > swap ;
: -while ( n-nn ) < -if > swap ; { -cr }
: a < ?dup > h# C28B 2, ;
: a! ?lit if h# BA 1, , ; then h# D08B 2, < drop > ;
: 2* h# E0D1 2, ; { * }
: 4@ ( b-n ) h# 8B 2, ; [ forth ]
: a, 2* 2* , ; [ macro ]
: @ ?lit if < ?dup > h# 58B 2, a, ; then h# 85048B 3, 0 , ;
: ! ?lit if ?lit if h# 5C7 2, swap a, , ; then h# 589 2, a, < drop >
 ; then < a! > h# 950489 3, 0 , < drop > ;
: nip h# 4768D 3, ;
: + ?lit if h# 5 1, , ; then h# 603 2, < nip > ;
: or h# 633
: binary ?lit if swap d# 2 + 1, , ; then 2, < nip > ;
: and h# 623 < binary > ; { -cr }
: +or h# 60B < binary > ;
: u+ ?lit if h# 681 2, , ; then h# 44601 3, < drop > ;
: ? ?lit h# A9 1, , ; { -cr }
: over < ?dup > h# 4468B 3, ; }block

( 00205400 )               D# 21 shadow{ 
 ( pentium macros' 1, 2, 3, , compile 1-4 bytes )
: drop ( lodsd, flags unchanged, why sp is in esi - in kernel )
: then ( fix address - in kernel )
: swap ( sp xchg )
: 0 ( 0 0 xor, macro 0 identical to number 0 )
: if ( jz, flags set, max 127 bytes, leave address )
: -if ( jns, same )
: a ( 2 0 mov, never used? )
: a! ( 0 2 mov, unoptimized )
: 2* ( shift left )
: 4@ ( fetch word on byte boundary. )
: a, ( compile word address )
: @/! ( fetch/store from/to word address, or eax )
: nip swap drop
: +/or/and ( number or sp with eax )
: u+ ( add to 2nd number, number or sp )
: ? ( test bits, set flags, literal only! )
: over ( sp 4 + @ ) }block

( 00205800 )               D# 22 code{ 
 ( - macros )
: push ?lit if h# 68 1, , ; then h# 50 1, < drop > ;
: pop < ?dup > h# 58 1, ;
: - h# D0F7 2, ;
: *end swap
: end h# EB
: loop 1, here - + 1, ;
: until h# 74 < loop > ;
: -until h# 79 < loop > ;
: for < push begin > ;
: *next swap
: next H# 75240CFF
: 0next , here - + 1, h# 4C483 3, ;
: -next H# 79240CFF < 0next > ;
: i < ?dup > h# 24048B 3, ;
: +! ?lit if ?lit if h# 581 2, swap a, , ; then h# 501 2, a, < drop >
 ; then < a! > h# 950401 3, 0 , < drop > ;
: nop h# 90 1, ;
: align here - d# 3 and drop if < nop align > ; then ;
: or! < a! > h# 950409 3, 0 , < drop > ;
: * h# 6AF0F 3, < nip > ;
: */ h# C88B 2, < drop > H# -608D109 , < nip > ;
: /mod < swap > h# 99 1, H# 16893EF7 , ;
: / < /mod nip > ;
: mod < /mod drop > ; }block

( 00205C00 )               D# 23 shadow{ 
: push ( lit to sp; eax to sp )
: pop ( sp to eax )
: - ( ones-complement )
: begin -a ( current code address - byte )
: while a-aa ( if-escape from any structure usage example begin xxx
 while xxx next xxx then )
: for n ( push count onto return stack, ) begin
: *next aa-aa ( swap ) for ( and ) if ( addresses )
: next a ( decrement count, jnz to ) for, ( pop return stack when done )
: -next a ( same, jns - loop includes 0 )
: i -n ( copy loop index to data stack )
: *end aa-aa ( swap ) end ( and ) if ( addresses )
: end a ( jmp to ) begin
: +! na ( add to memory, 2 literals optimized )
: align ( next call to end on word boundary )
: or! na ( inclusive-or to memory, unoptimized )
: * mm-p ( 32-bit product )
: */ mnd-q ( 64-bit product, then quotient )
: /mod nd-rq ( remainder and quotient )
: / nd-q ( quotient )
: mod nd-r ( remainder ) }block

( 00206000 )               D# 24 code{ 
 ( - compiled macros )
: 2/ ( n-n ) h# F8D1 2, ; { -cr }
: time ( -n ) < ?dup > h# 310F 2, ;
: 7push h# 57 1, ; { -cr }
: 7pop h# 5F 1, ; [ forth ]
: @ @ ; { -cr }
: ! ! ; { -cr }
: + + ; { -cr }
: - - ;
: */ */ ; { -cr }
: * * ; { -cr }
: / / ; { -cr }
: 2/ 2/ ;
: dup dup ; { -cr }
: drop drop ; { -cr }
: nip ( ab-b ) nip ;
: over over ; { -cr }
: swap swap ; { -cr }
: and and ;
: or or ; { -cr }
: +or +or ; { -cr }
: +! +! ;
: exit 7pop 7pop ; { -cr }
: negate ( n-n ) - d# 1 + ;
: min ( nn-n ) less if drop ; then swap drop ;
: abs ( n-u ) dup negate
: max ( nn-n ) less if swap then drop ;
: v+ ( vv-v ) push u+ pop + ;
: loads ( bn ) for dup push load pop d# 2 + next drop ;
: writes ( acn ) for write next drop drop ;
: reads ( acn ) for read next drop drop ; [ macro ]
: dann < then > ;
: then ( a-a ) here over negate + d# 128 + { cr }
 d# -256 and drop if abort dann < dann > ; [ forth ] }block

( 00206400 )               D# 25 shadow{ 
: 2/ ( arithmetic right shift )
: time ( pentium cycle counter, calibrate to actual clock rate )
: 7push/7pop ( save/restore save register 7, edi )
: @-drop ( these macros redefined in ) forth ( so they may be executed )
: +or ( and ) negate ( when you just can't use - )
: min ( and ) max ( minimum and maximum )
: abs ( absolute value )
: v+ ( add 2-vectors )
: exit ( terminates interpretation of a block. )
: loads ( load successive blocks )
: nc ( number of cylinders booted and saved )
: writes ( address, cylinder, cylinder count )
: reads ( address, cylinder, count. ) [ floppy access note do not hit
 any keys while floppy is being written - wait for light to go out ]
: then ( aborts on jump out of range. ) }block

( 00206800 )               D# 26 code{ 
 }block

( 00206C00 )               D# 27 shadow{ 
 }block

( 00207000 )               D# 28 code{ 
 ( colors etc )
: -offset ( n-n ) [ offset ] @ negate + ;
: block [ offset ] @ +
: blks h# 100 * ;
: wrtboot [ d# 0 block ] d# 0 d# 1 writes stop ;
: white h# FFFFFF color ;
: red h# FF0000 color ;
: green h# FF00 color ;
: blue h# FF color ;
: silver h# BFBFBF color ;
: black d# 0 color ;
: 5* d# 5 for 2emit next ;
: cf d# 25 dup at red h# B h# 5 h# 1 h# 1 h# 5 5* green h# 14 h# 2
 h# 1 h# 3 h# E 5* ( chip ) d# 25 d# 550 at red h# 1C h# 1C h# 19 h# 5
 h# D 5* ;
: fill ( nan ) for over over ! d# 1 + next drop drop ;
: move ( sdn ) for over @ over ! d# 1 + d# 1 u+ next drop drop ;
: erase ( bn ) push d# 0 swap block pop blks fill ;
: copy ( n ) [ blk ] @ block over block d# 512 move [ blk ] ! ; }block

( 00207400 )               D# 29 shadow{ 
: block n-a ( block number to word address )
: wrtboot ( write boot and kernel )
: colors ( specified as rgb' 888 bits )
: at xy ( set current screen position - in kernel )
: box xy ( lower-right of colored rectangle - in kernel )
: 5* emit ( five characters in reverse order )
: cf ( display double-size colorforth )
: fill n an ( writes n into a cell string )
: move sdn ( copies a cell string from s to d )
: erase bn ( zeroes a string of blocks )
: copy n ( copies current editor block and its shadow to the given
 block ) }block

( 00207800 )               D# 30 code{ 
 ( decompress ) [ empt d# 32 load ]
: char ( -n ) 0 b! ( ?new ) d# 4 bits b d# 8 and drop if b d# 4 and
 drop if d# 3 bits d# 7 ; then d# 1 bits d# 5 ; then d# 4 b h# F and
 drop if ; then
: eob ( n ) drop pop drop ;
: chars ( n-n ) char ?full c! 2*c b or chars ;
: word ( n ) d# 28 [ nb ] ! dup chars tbits ;
: short ( n ) d# 28 bits
: t, d# -4 [ nb ] ! b tbits ;
: number ( n ) 0 b! d# 1 bits t,
: 32bits d# 16 bits d# 16 bits b , ;
: variable ( n ) word 32bits ;
: tag ( -n ) b h# F and dup jump eob word number word word number short
 word short word word word variable short word short
: words ( ?new ) d# 4 bits tag words ;
: range ( ann ) over block [ h ] ! dup push erase [ aa ] ! 0 [ na ]
 ! begin words [ h ] @ d# 256 + d# -256 and [ h ] ! next ;
: restore [ ns ] @ dup and -if abs [ ns ] ! d# 36 block [ cbuf ] block
 [ d# 18 blks nc @ d# -2 + * ] move [ cbuf block ] d# 36 [ nblk @ d# -36
 + ] range ; then drop ; }block

( 00207C00 )               D# 31 shadow{ 
: char ( examine high bits; shift 4, 5 or 7 bits )
: eob ( end of block )
: chars ( shift characters until 0 )
: word ( shift characters, then tag )
: short ( 28-bit value+tag )
: number ( 1-bit base+tag, value in next word )
: 32bits ( for values )
: variable ( word, value )
: tag ( vector )
: words ( examine tags )
: range ( process each block )
: move ( blocks 72 thru 1419 to 3000 )
: res ( restore compressed blocks ) }block

( 00208000 )               D# 32 code{ 
 ( - more ) [ macro ] ( uses ebx )
: b < ?dup > h# C38B 2, ;
: b! h# D88B 2, < drop > ;
: c! h# C88B 2, < drop > ;
: 2*d h# C3A50F 3, ;
: 2*c h# E0D3 2, ; [ forth ] :# na 24 :# nb 8 :# h 67510272 :# an 0
 :# aa 74623108 :# nz 4
: ?new [ na ] @ dup and drop if ; then
: new [ aa ] @ @ [ an ] ! d# 1 [ aa ] +! d# 32 [ na ] ! ;
: shift ( n-n ) dup negate dup [ nb ] +! [ na ] +! c! [ an ] @ 2*d
 2*c [ an ] ! ;
: bits ( n ) ?new dup negate [ na ] @ + -if dup push + shift new pop
 negate shift ; then drop shift ;
: tbits ( nn ) [ nb ] @ d# 8 + c! 2*c or
: , [ h ] @ ! d# 1 [ h ] +! ;
: tz ( nn-n ) over [ nz ] ! dup negate push + b begin dup d# 1 and
 drop if drop drop pop drop [ nz ] @ ; then 2/ next b! dup [ nz ] @
 - + - [ nb ] +! pop drop ;
: ?full ( n-n ) [ nb ] @ dup and -if tz dup push d# -4 + [ nb ] +!
 tbits 0 dup pop dup - d# 29 + [ nb ] ! ; then drop ; }block

( 00208400 )               D# 33 shadow{ 
: b ( pop ebx, register 3, into eax )
: c! ( push eax into register 1, ecx )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: na ( bits remaining in source word )
: nb ( bits remaining in ebx )
: h ( destination address )
: , ( store at destination )
: ?new ( fetch new word if necessary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: tbits ( fill ebx with tag )
: ?full ( is there room in ebx? )
: bits ( shift bits into ebx. overflow into next word ) }block

( 00208800 )               D# 34 code{ 
 ( native system dependencies ) [ macro ]
: p@ < a! ?dup > h# EC 1, ; [ forth ]
: key? h# 64 p@ d# 1 and drop if h# 60 p@ h# 80 and drop if ; then
 pop drop then ;
: clock [ d# 40 ] load ;
: altfrm ( -b ) [ aper @ d# 1024 d# 768 * d# -4 * + ] ;
: topram ( -b ) [ H# 30000000 ] ;
: !work ( n ) block d# 0 over [ d# 1 ] + @ [ d# 35 ] + [ d# 36 ] /
 writes stop ;
: @rest ( nn ) push [ d# 36 ] + block [ d# 2 ] pop reads stop ;
: @back ( n ) dup block d# 0 [ d# 2 ] reads dup [ d# 18 ] + block dup
 @ [ d# 18 block @ ] or drop if drop [ d# 78 ] @rest ; then dup [ d# 1 ]
 + @ dup and -if nip abs [ d# 35 ] + [ d# 36 ] / [ d# -2 ] + @rest
 ; then drop drop [ d# 78 ] @rest ;
: !back ( n ) block d# 0 [ nblk ] @ [ d# 18 ] / writes stop ;
: @cyls ( acn ) reads stop ;
: screen d# 0 dup at d# 1024 d# 768 box ;
: utime ( -n ) d# 0 ; { br }

: serial ( -n ) [ d# 108 ] ; }block

( 00208C00 )               D# 35 shadow{ 
: key? ( exits calling defn if key struck )
: clock ( loads time of day suppt )
: altfrm ( byte addr of alternate frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads
 only active part of compressed ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color )
: utime ( null definition for now for compatability ) }block

( 00209000 )               D# 36 code{ 
 ( windows system dependencies )
: key? [ keych ] @ d# 0 or drop if pop drop ; then ;
: beep ; { * }
: clock d# 38 load ;
: topram { * }
: altfrm ( -b ) [ endram d# -4096 d# 768 * + ] ;
: !work ( n ) dup block [ d# 1 ] + @ [ d# 1 ] + 2/ wwork ;
: @back ( n ) dup d# 19 rback dup [ d# 18 ] + block dup @ { , }
 [ d# 18 block @ ] or drop if drop [ d# 1440 ] rback ; then { , }
 dup [ d# 1 ] + @ dup and -if nip abs [ d# 1 ] + 2/ rback ; { , }
 then drop [ d# 3 ] + @ rback ;
: !back ( n ) [ nblk ] @ wback ;
: @cyls ( acn ) [ abuf ] @back push [ d# 18 ] * [ abuf ] + block { , }
 swap pop [ d# 18 d# 256 * ] * move ;
: screen d# 0 dup at d# 868 for d# 0 d# 1024 line next { , }
 d# 0 dup at ; { * }
: serial ( -n ) [ d# 112 ] ;
: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 3 d# 0 { F } [ d# 3 ]
 { , }
 pop pop swap [ d# 4 ] * fcreate ; { , }
 :# flng 30 [ flng d# 4 * dup ]
: frd ( anh-n ) push push push [ d# 0 + ] pop pop swap { , }
 pop fread { * }
: frw? ( ok-n ) if drop [ flng ] @ then ;
: fwr ( anh-n ) push push push [ d# 0 + ] pop pop swap { , }
 pop fwrite frw? ; { * }
: r/o [ H# -80000000 ] ;
: w/o [ H# 40000000 ] ; { * ... }
     
: r/w [ r/o w/o + ] ; }block

( 00209400 )               D# 37 shadow{ 
: key? ( exits calling defn if key struck )
: save ( writes full disk image )
: beep ( alert in hardsim )
: clock ( loads time of day suppt )
: altfrm ( byte adr of alt frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads
 only active part of compressed, and only active part of straight disks
 with vars ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color ) { br }

: fopen ( opens an existing win32 file given word adr of name and access
 code of ) r/o w/o ( or ) r/w. ( returns handle, indicators nz if it's
 good. the alternate value { 6F } enables sharing for read and write;
 necessary to open a file sf has open with clib. )
: frd ( and ) fwr ( read and write on things with win32 handles. )
 }block

( 00209800 )               D# 38 code{ 
 ( - clock )
: sec ( -n ) utime [ d# 60 d# 60 * d# 24 * ] mod ;
: minute ( -n ) sec d# 60 / ; }block

( 00209C00 )               D# 39 shadow{ 
: utime ( returns unix time in sec since epoch 0000z fri 1/01/1970 )
: sec ( seconds since midnight needs unsigned mod by time we are all
 dead )
: min ( minutes past midnight ) }block

( 0020A000 )               D# 40 code{ 
 ( native clock ) [ macro ] ( pentium timer )
: p@ < a! ?dup > h# EC 1, ;
: p! < a! > h# EE 1, < drop > ; [ forth ]
: ms d# 100000 * for next ;
: ca h# 70 p! h# 71 ;
: c@ ca p@ ;
: c! ca p! ;
: !bcd push d# 10 /mod d# 16 * + pop c! ;
: !hm d# 100 /mod d# 4 !bcd d# 2 !bcd 0 dup c! ;
: bcd c@ d# 16 /mod d# 10 * + ;
: sec0 d# 4 bcd d# 60 * d# 2 bcd + d# 60 * d# 0 bcd + ;
: sec sec0 d# 2 ms dup sec0 or drop if drop sec ; then ;
: minute sec d# 60 / ;
: hms sec d# 60 /mod d# 60 /mod d# 100 * + d# 100 * + ;
: ymd d# 9 bcd d# 100 * d# 8 bcd + d# 100 * d# 7 bcd + ;
: day d# 6 c@ d# -1 + ;
: hi d# 10 c@ h# 80 and drop if ; then hi ;
: lo d# 10 c@ h# 80 and drop if lo ; then ;
: cal hi lo time - hi lo time + ( 748 ) ;
: beep h# B6 h# 43 p! h# EE h# 42 p! 0 h# 42 p! ( on ) h# 61 p@ d# 3
 or h# 61 p! d# 50000000 for next ( off ) h# 61 p@ d# 3 or h# 61 p!
 ; }block

( 0020A400 )               D# 41 shadow{ 
 }block

( 0020A800 )               D# 42 code{ 
 }block

( 0020AC00 )               D# 43 shadow{ 
 }block

( 0020B000 )               D# 44 code{ 
 ( logo and watermark )
: logo show black screen d# 800 d# 710 blue box d# 600 d# 50 at d# 1024
 d# 620 red box d# 200 d# 100 at d# 700 d# 500 green box { 24F } ( list )
 text cf keyboard ; [ logo ] { , , }
: -safe ( a-f ) negate here + H# -80000000 and drop ;
: ?logo sp d# 17 + @ -safe if logo ; then ;
: empty empt ?logo ; { , , }
: 2u.r ( nw ) d# -1 + dup push for d# 10 /mod next h# F and { , }
 begin [ d# 0 ] + if pop [ d# 1 ] + { * }
: .lo for [ d# 24 ] + 2emit next ; then drop space space next [ d# 1 ]
 .lo ;
: ?ec blk d# 2 + @ d# 0 + drop if red ; then silver ;
: watermark show black screen d# 765 d# 603 at { , }
 [ blk ] @ ?ec d# 6 2u.r +list keyboard ; { , , }
: +buf ( n-n ) [ blk ] @ over or if { , ... }
      over or [ blk d# 1 + ] ! ; then drop ; { , , }
: edit ( n ) +buf [ blk ] ! { * }
: e watermark +e ;
: list ( n ) +buf [ blk ] ! lis ; { * }
: l [ blk ] @ list ; }block

( 0020B400 )               D# 45 shadow{ 
 ( logo and editor display extensions. ) { , }
 ( empty smart for less display wanking ) { , , }
: logo ( displays colorforth logo )
: -safe ( returns true flag if addr is past ) [ here. ]
: ?logo ( displays logo screen if current display ) { , }
 ( generator has been forgotten. )
: empty ( switches to ) logo ( display only if current display has
 been forgotten. ) { , , }
 editor display ( is extended to show block no. ) { , }
 ( being edited above the keyboard hints, colored red if the editor
 is 'hot'. )
: +buf ( preserves ) blk ( if new block is different )
: list ( displays the given block without entering the editor. )
: l ( lists the current editor block. ) }block

( 0020B800 )               D# 46 code{ 
 ( miscellaneous )
: !dict ( fmh ) [ h ] ! [ macros ] ! [ forths ] ! ;
: interp ( b ) align load ; ( temp ) [ d# 9 here d# 4 / d# -1 + +! ]
: finish [ cad ] @ interp ; { , , }
: -kbd ( -t ) 7push pop dup and drop ;
: fh ( n-b ) -kbd if 7push pop [ d# 0 block ] { , }
 [ negate ] + d# 256 / + ; then [ blk ] @ + ;
: paws pause ; { * }
: pause dup paws drop ; }block

( 0020BC00 )               D# 47 shadow{ 
: !dict ( resets dictionary to a saved state )
: interp ( is a temp patch for missing interpreter entry point. )
: finish ( executes at same stack level as load but starts interpreting
 at editor's current cursor position. ) { , , }
: -kbd ( returns true/nonzero flag if a word that calls it is being
 interpreted from a block as opposed to from the keyboard. use with
 caution from deep within an app that might have monkeyed with register { EF } )
: fh ( from here, block number relative to editor or interpreter block
 as appropriate. )
: pause ( is redefined to push an extra item onto stack while displaying
 for symmetry with kbd. ) }block

( 0020C000 )               D# 48 code{ 
 ( dump ) [ empty ] :# x 75678960 :# y -79635296
: 5-8 d# 8 /mod d# 32 /mod d# 32 /mod h# 100 * + h# 100 * + h# 100
 * swap d# 4 * + ;
: one dup @ dup 5-8 h. space h. space dup h. cr ;
: lines for one d# -1 + next drop ;
: dump [ x ] !
: r show black screen [ x ] @ d# 15 + d# 16 text lines keyboard ;
: it @ + @ dup h. space ;
: lines for white i [ x ] it i [ y ] it or drop if red then i . cr
 -next ;
: cmp show blue screen text d# 19 lines red [ x ] @ h. space [ y ]
 @ h. keyboard ;
: u d# 16
: +xy dup [ x ] +! [ y ] +! ;
: d d# -16 +xy ;
: ati H# -BF00000 ( ff7fc000 ) or ( agp graphics reg )
: byte d# 4 / dump ;
: fix for d# 0 over ! d# 1 + next ; [ dump ] }block

( 0020C400 )               D# 49 shadow{ 
 ( does not say empty, compiles on top of application )
: x -a ( current address )
: one a-a ( line of display )
: lines an
: dump a ( background task continually displays memory --- takes address
 -- displays three cols with address on right contents in middle and-
 the left col is f18 instruction view )
: u ( increment address )
: d ( decrement )
: ati ( address of agp graphic registers )
: byte a ( byte address dump )
: fix an-a ( test word ) }block

( 0020C800 )               D# 50 code{ 
 ( timing ) :# tmt 286630312 :# tmn -162350156 :# tmp 64245270 :# secs 0
: tmclr d# 0 [ tmt ] ! d# 0 [ tmn ] ! d# 0 [ tmp ] ! d# 0 [ secs ]
 ! ;
: tms ( a ) time - [ d# 1 ] + swap +! ;
: tme ( a ) time swap +! ;
: tare [ tmt ] tms pause [ tmt ] tme ;
: 0tare [ tmn ] tms switch [ tmn ] tme ;
: counter utime negate [ secs ] +! ;
: timer utime [ secs ] +! ; }block

( 0020CC00 )               D# 51 shadow{ 
 }block

( 0020D000 )               D# 52 code{ 
 ( floppy utility ) [ empty ] :# hd 1 :# ad 152338
: array pop 2/ 2/ ;
: com align array [ H# 1202004D , h# 6C 2, ]
: word ( n ) [ ad ] @ ! d# 1 [ ad ] +! ;
: sectors ( cs-c ) buffer [ ad ] ! d# 18 for over [ hd ] @ h# 100 *
 + over d# 18 mod d# 1 + h# 10000 * + h# 2000000 + word d# 1 + next
 drop ;
: head ( ch-c ) dup [ hd ] ! h# 400 * H# 1202004D + [ com ] ! dup 2*
 - d# 1801 + sectors format ;
: cylinders ( n ) push [ com ] d# 0 pop for d# 0 head d# 1 head d# 1
 + next ( stop ) drop drop ;
: format ( nc @ ) d# 80 cylinders stop ;
: archive [ d# 0 block ] d# 0 [ nc ] @ writes stop ;
: check [ abuf block ] d# 0 [ nc ] @ reads stop ;
: ati H# 10CD4123 [ vesa ] ! ; ( setup for ati video card )
: nvidia H# 10CD4118 [ vesa ] ! ; ( for nvidia card then save ) }block

( 0020D400 )               D# 53 shadow{ 
: format ( issue format command 30 cyl - in kernel )
: hd ( disk head )
: ad ( current address in ) buffer
: buffer ( usual floppy cylinder buffer )
: array ( return word address )
: com ( format command )
: word ( store word into command string )
: sectors ( build sector table )
: head ( build sectors for selected head )
: cylinders ( sectors advance 1 for each cylinder - to allow time for
 head step )
: format ( only desired cylinders to save time )
: bytes ( arguments for crc )
: archive ( verify save' compute crc, save, read-back, recompute crc
 - first 64 bytes used by floppy read/write -- the two crc numbers
 should be the same ! ) }block

( 0020D800 )               D# 54 code{ 
 ( icons ) [ empty macro ]
: @w h# 8B66 3, ;
: !w < a! > h# 28966 3, < drop > ;
: *byte h# C486 2, ; [ forth ] :# ic 11 :# cu 167
: sq [ xy ] @ h# 10000 /mod d# 16 + swap d# 16 + box { cr }
 d# 17 d# 0 +at ;
: loc [ ic ] @ [ d# 16 d# 24 d# 8 */ ] * [ d# 12 block d# 4 * ] + ;
: 0/1 h# 8000 ? if green sq ; then blue sq ;
: row dup @w *byte d# 16 for 0/1 2* next drop { cr }
 [ d# -17 d# 16 * ] d# 17 +at ;
: ikon loc d# 24 for row d# 2 + next drop ;
: adj d# 17 * swap ;
: cursor [ cu ] @ d# 16 /mod adj adj over over at { cr }
 red d# 52 u+ d# 52 + box ;
: line ( i-in ) for dup emit d# 1 + next ;
: set ( xy ) over lm at d# 0 d# 10 for d# 12 line cr next { cr }
 d# 8 line drop ;
: ok show black screen cursor d# 18 dup at ikon { cr }
 text [ ic ] @ dup . h. d# 400 d# 60 set keyboard ; [ d# 56 load ok
 h ] }block

( 0020DC00 )               D# 55 shadow{ 
 ( draw big-bits icon )
: @w a-n ( fetch 16-bit word from byte address )
: !w na ( store same )
: *byte n-n ( swap bytes )
: ic -a ( current icon )
: cu -a ( cursor )
: sq ( draw small square )
: xy -a ( current screen position, set by ) at
: loc -a ( location of current icons bit-map )
: 0/1 n-n ( color square depending on bit 15 )
: row a-a ( draw row of icon )
: ikon ( draw big-bits icon )
: adj nn-nn ( magnify cursor position )
: cursor ( draw red box for cursor )
: ok ( background task to continually draw icon, icon number at top )
 }block

( 0020E000 )               D# 56 code{ 
 ( - control panel )
: +ic d# 1 [ ic ] +! ;
: -ic [ ic ] @ d# -1 + d# 0 max [ ic ] ! ;
: bit [ cu ] @ 2/ 2/ 2/ 2/ 2* loc + h# 10000 [ cu ] @ h# F and d# 1
 + for 2/ next *byte ;
: toggle bit over @w or swap !w ;
: td toggle
: d d# 16
: wrap [ cu ] @ + [ d# 16 d# 24 * ] dup u+ /mod drop [ cu ] ! ;
: tu toggle
: u d# -16 wrap ;
: tr toggle
: r d# 1 wrap ;
: tl toggle
: l d# -1 wrap ;
: h pad nul nul accept nul tl tu td tr l u d r -ic nul nul +ic nul
 nul nul nul nul nul nul nul nul nul nul nul [ h# 2500 , h# 110160C
 dup , , H# 2B000023 , d# 0 , d# 0 , d# 0 , ] }block

( 0020E400 )               D# 57 shadow{ 
 ( edit icon ) }block

( 0020E800 )               D# 58 code{ 
 }block

( 0020EC00 )               D# 59 shadow{ 
 }block

( 0020F000 )               D# 60 code{ 
 ( serial 3f8 2e8 1050 ) [ macro ]
: p@ < a! dup > h# EC 1, ;
: p! < a! > h# EE 1, < drop > ;
: 1@ h# 8A 2, ;
: 1! < a! > h# 288 2, < drop > ; [ forth ]
: r [ d# 0 + ] + ;
: 9600 d# 12 ;
: 115200 d# 1 ;
: b/s h# 83 [ d# 3 r ] p! d# 115200 [ d# 0 r ] p! d# 0 [ d# 1 r ] p!
 d# 3 [ d# 3 r ] p! ;
: init b/s ( 16550 ) d# 1 [ d# 2 r ] p! d# 0 [ d# 4 r ] p! ;
: xmit ( n ) [ d# 5 r ] p@ h# 20 and drop if [ d# 0 r ] p! ; then ( pause )
 xmit ;
: cts [ d# 6 r ] p@ h# 30 and h# 30 or drop if cts ; then xmit ;
: st [ d# 6 r ] p@
: xbits h# 30 and h# 10 / dup d# 1 and 2* 2* + 2/ ;
: st! [ d# 4 r ] p! ;
: ?rcv [ d# 5 r ] p@ d# 1 and drop if [ d# 0 r ] p@ then ;
: rcv ?rcv if ; then ( pause ) rcv ; }block

( 0020F400 )               D# 61 shadow{ 
: p@ p-n ( fetch byte from port )
: p! np ( store byte to port )
: 1@ a-n ( fetch byte from byte address )
: 1! na ( store byte to byte address )
: r n-p ( convert relative to absolute port address. base port on stack
 at compile time. compiled as literal at yellow-green transition )
: 9600
: 115200 ( baud-rate divisors. these are names, not numbers )
: b/s ( set baud rate. edit to change )
: init ( initialize uart )
: xmit n ( wait for ready and transmit byte )
: cts n ( wait for clear-to-send then xmit )
: st -n ( fetch status byte )
: xbits n-n ( exchange status bits )
: st! n ( store control byte )
: ?rcv ( fetch byte if ready. set flag to be tested by ) if
: rcv -n ( wait for ready and fetch byte ) }block

( 0020F800 )               D# 62 code{ 
 ( word search ) [ macro ]
: bt ( nm-n ) [ H# 68BD08B ] , [ H# F04768D ] , [ H# -2DE43D5D ] ,
 ; [ forth ]
: tag? ( nm-n ) over h# F and swap bt drop ;
: red? ( n-nm ) [ h# 1008 ] tag? if [ h# 4092 ] ; then [ h# 1008 ]
 ;
: t2 ( nn-nn ) d# 1 +
: t1 ( nn-nn ) d# 1 [ curs ] +!
: t0 ( nn-nn ) d# 1 + ;
: map ( nnn-nn ) h# F and jump { indent }
      t0 t1 t2 t1 t1 t2 t1 t1 { indent }
      t1 t1 t1 t1 t2 t1 t1 t1
: tcurs ( nn-n ) over block push d# -1 [ curs ] ! d# 0
: tcu1 ( nnn-n ) dup i + @ map over over negate + drop -if t1 drop
 drop pop drop ; then tcu1 ;
: -curs ( - ) [ curs ] @ d# -1 + d# 0 max [ curs ] ! ; [ here ]
: tpoint [ blk ] @ [ curs ] @ tcurs drop -curs ; [ cpoint ! ] }block

( 0020FC00 )               D# 63 shadow{ 
 ( word search tcurs )
: bt ( returns nz and less if bit n of m is set. pops t to 2, bit test
 index t mask 2, 2-2-sbb to set nz if carry. )
: tag? ( nz and less if bit in m indexed by tag of token n is 1. )
: t2 nn-nn ( 2 cell - big nums, var )
: t1 nn-nn ( 1 cell )
: t0 nn-nn ( extensions, undefined )
: map end n wrd-end n ( inc n and maybe curs )
: tcurs blk offset-blk ( convert offset to tokens in curs )
: -curs - ( decrement curs to zero )
: tpoint - ( fix abort to point cursor correctly, except if last word
 in block ) }block

( 00210000 )               D# 64 code{ 
 ( - more ) :# fmask -16 :# fnn -999030764 { cr }
 :# fna 67146240 :# fbits 4104 [ d# 18 block fna ! ]
: +shad ( a-a ) dup [ fna ] @ or d# 256 and + ;
: 1word ( -n ) word [ words ] @
: 1wz d# 2 less drop if drop ; then nip d# -1 + 1wz ;
: want? ( nm-n ) tag? if or ; then drop drop d# -1 ;
: -found ( na ) @ [ fbits ] @ want? [ fmask ] @ and drop ;
: reedit ( fna ) nip dup d# 1 + [ fna ] ! { indent }
      h# 100 /mod -offset swap tcurs swap { indent }
      dup and drop if dup [ blk ] ! then edit ;
: find 1word h# 5E9A { -cr }
: fnd+ d# 18 block d# -16
: fnd ( nbam ) [ fmask ] ! [ fna ] ! [ fbits ] ! d# 16 or [ fnn ] !
 d# 0
: f ( f ) [ fnn ] @ d# 16 or [ fna ] @ begin { indent }
      +shad [ nblk ] @ block less drop while { indent }
      over over -found while d# 1 + end { indent }
      then reedit ; then drop drop drop ;
: def 1word [ h# 1008 ] fnd+ ; [ here ekt d# 21 + ! ]
: fkc drop [ pcad ] @ @ [ h# 140 ] tag? if [ d# 32 ] / edit ; { cr }
 then red? fnd+ ( blk @ ) dup ; [ here ekt d# 22 + ! ]
: fk drop ( drop ) [ cad ] @ [ fna ] ! d# 1 f ( blk @ ) dup ;
: from ( n ) 1word swap [ h# 5E9A ] swap block [ d# -16 ] fnd ;
: literal ( n ) h# 20 * [ h# 140 ] d# 18 block [ d# -32 ] fnd ; }block

( 00210400 )               D# 65 shadow{ 
 ( word search )
: +shad ( skips shadows if in one and skipping. )
: 1word -n ( return 1st cell of word from kbd. )
: find ( finds following short word, starting in block 18, regardless
 of color. )
: def ( finds only definitions. )
: f ( find next occurrence of word last found )
: fk ( 'f' key in edit keyboard. drops key and block number and behaves
 like f except continues search from current editor position in current
 kind of block src/shad. )
: fkc ( if word left of cursor is a number, list that block. if red
 or magenta definition, searches for references. otherwise searches
 for definitions. )
: from n- ( like find but start from block number )
: literal n- ( finds any equivalent literal ) }block

( 00210800 )               D# 66 code{ 
 ( editor recolor ) [ d# 8 display + @ d# 13 display + ! ]
: array pop 2/ 2/ + @ ; ( 1-4-9 2-5 8-6-15 )
: reclr align array { cr }
 [ d# 0 , d# 4 , d# 5 , d# 3 , d# 9 , d# 2 , d# 15 , d# 7 , ] { cr }
 [ d# 6 , d# 1 , d# 10 , d# 11 , d# 12 , d# 13 , d# 14 , d# 8 , ]
: wadr ( -a ) [ pcad ] @ [ blk ] @ max ; [ here ekt d# 20 + ! ]
: change wadr @ h# F and reclr wadr @ h# -10 and or wadr ! ; [ H# 220E100A
 ekt d# 33 + ! ] { br }

 ( obsolete comment cases ) [ H# F000000 ekt d# 32 + ! ] { cr }
 [ ekt d# 16 + @ dup ekt d# 17 + ! ekt d# 18 + ! ] }block

( 00210C00 )               D# 67 shadow{ 
 ( tags ) { cr }
 ( extend ) [ execute 32-bit ] ( define ) { cr }
 compile 32-bit [ 27-bit ] < immediate > { cr }
 27-bit ( comment cap caps ) { cr }
 ( variable address blue 27-bit ) { br }

: array ( fetch new tag )
: reclr ( table of color cycles )
: wadr -a ( address of word to left of cursor )
: change ( color of word to left of cursor )
: 220e100a ( 0a-c 10-d 0e-f 22-j ) }block

( 00211000 )               D# 68 code{ 
 ( blue words ) :# ?blu 255 [ d# 0 ?blu ! ]
: -w@ ( -n ) 7push pop d# -1 + @ ; { * }
: .blu [ ?blu ] @ color
: type1 [ d# 9 display + @ d# 5 + ] push ; { , , }
 [ here ] { * }
: blu ; { * }
: -blue ( b-t ) dup d# 1 + 4@ + [ d# -5 + ] or { , ... }
      drop ; { , , }
: d03 ( -a ) [ d# 3 display + ] ; { . . . }
      [ here ]
: exr [ d03 @ ] nop [ d03 ] ! red type1 ;
: -cr blu [ d# 0 + ] nop [ d03 ] ! ; { * }
: sp/2 h# B0000 [ xy ] +! ; { , , }
: bs [ xy d# 1 + ] @ d# 21 + h# 10000 * [ xy ] @ less { , ... }
      drop drop if h# -160000 [ xy ] +! then ;
: wd ( nn-/n ) over or if d# 0 and drop ; { , ... }
      then nip pop pop drop push d# 1 or drop ;
: simple ( -w ) -w@ d# -16 and { , }
 ( * ) H# -6000000 wd if bs .blu -cr bs ; then { , }
 ( , ) h# -4000000 wd if bs .blu cr ; then { , }
 ( . ) H# -16000000 wd if .blu bs ; then { , }
 ( .. ) H# -142C0000 wd if .blu bs ; then { , }
 ( ... ) H# -14285800 wd if .blu bs ; then ; }block

( 00211400 )               D# 69 shadow{ 
 ( blue and grey words ) { * }
: must ( fit into one cell! ) { , , }
: -w@ ( returns word being interpreted by display )
: .blu ( display blue word )
: type1 ( displays word with color already set ) { , , }
: exr ( one-shot red display suppressing cr )
: -cr ( arms exr for next red word encountered. )
: s/2 ( halfspace for reports. ) { , , }
: bs ( backspace protecting left margin )
: wd ( is a factor of ) simple ( to test shannon codes )
: simple ( returns regular blue word for execution but handles special
 words internally. ) { , , }
: exb ( display and execute blue word iff found in dictionary. ) }block

( 00211800 )               D# 70 code{ 
 ( - blue and grey ) { , , }
 [ here d# 14 display + ! ]
: exb simple .blu itick if drop ; then { , }
 dup -blue if drop ; then push ( drop ) ; { , , }
: seeb [ ?blu ] @ h# FF or [ ?blu ] ! ;
: ?seeb ( -t ) [ ?blu ] @ [ d# 0 ] + drop ; { , , }
: @lit -w@ d# 32 / ; ( grey ) [ here display d# 13 + ! ]
: tadr h# C0C0C0 color @lit d# 1024 /mod swap { , }
 d# 2 over d# -256 and drop if d# 1 + then h.n { , }
 d# 0 + if d# 39 emit dup d# 1 h.n then drop space ; { , , }
 ( old blue words )
: br blu cr cr ; { * }
: tab ( n ) for space next ;
: indent blu cr d# 3 tab ; { * }
: kr cr ; { * }
: cr blu kr ; }block

( 00211C00 )               D# 71 shadow{ 
: seeb ( toggle display of blue words )
: ?seeb ( set flag non-zero if blue words visible ) { , , }
: @lit ( fetch 27-bit literal from current word )
: tadr ( display target address ) { , , }
: br ( blank line )
: tab ( advance n spaces )
: indent ( 5 spaces ) }block

( 00212000 )               D# 72 code{ 
 ( convert cf character to/from ascii ) { cr }
 [ macro ]
: 1@ h# 8A 2, ; { -cr }
: 1! < a! > h# 288 2, < drop > ; [ forth ]
: string pop ;
: cf-ii align string { cr }
 [ H# 6F747200 , H# 696E6165 , H# 79636D73 , H# 7766676C , ] { cr }
 [ H# 62707664 , H# 71757868 , H# 33323130 , H# 37363534 , ] { cr }
 [ H# 2D6A3938 , H# 2F7A2E6B , H# 2B21273B , H# 3F2C2A40 , ]
: ch h# -10 and unpack [ cf-ii ] + 1@ h# FF and ; { br }

: ii-cf string { cr }
 [ h# 2A00 , h# 2B , H# 2B2D0000 , H# 2725232E , ] { cr }
 [ H# 1B1A1918 , H# 1F1E1D1C , H# 28292120 , H# 2F000000 , ] { cr }
 [ H# 3A43355C , H# 3D3E3440 , H# 54523744 , H# 3336393C , ] { cr }
 [ H# 38314742 , H# 3F414632 , h# 563B45 , H# 23000000 , ] { cr }
 [ H# A13052C , H# D0E0410 , H# 24220714 , h# 306090C , ] { cr }
 [ H# 8011712 , H# F111602 , h# 260B15 , ]
: chc h# -20 + [ ii-cf ] + 1@ h# FF and ; { br }

: set1 H# 3D21223A H# 3E2C203C
: !8 ( nn- ) [ cf-ii h# 2C + 2/ 2/ ] ! [ cf-ii h# 28 + 2/ 2/ ] ! ;
: set0 H# 2B21273B H# 3F2C2A40 !8 ; }block

( 00212400 )               D# 73 shadow{ 
 ( colorforth to ascii and ascii to colorforth )
: cf-ii ( otr inae ycms wfgl bpvd quxh ) { indent }
      ( 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? ) { indent }
      ( cba@ gfed 02ih onml srqp wvut 1yx ) { indent }
      ( cba@ gfed 02ih onml srqp wvut 1yx ) { br }

 [ to facilitate pathnames and html strings... ]
: set1 ( modifies cf-ii table. ) { cr }
 ; ( to colon, ) ' ( to doublequote, ) + ( to equal, ) { cr }
 @ ( to lessthan, ) * ( to blank, ) ? ( to greaterthan )
: set0 ( restores original cf-ii table. ) }block

( 00212800 )               D# 74 code{ 
 ( pathname input ) [ -nat d# 72 load set1 ]
: strng ( n-a ) pop + ;
: fnam ( n-a ) align strng [ here d# 80 + h ! ] :# hld 12
: emt ( n- ) [ hld ] @ fnam 1! d# 1 [ hld ] +! ;
: +shan ch emt dup and if +shan ; then drop ; { br }

: ,src 7@+ @
: xx dup and if +shan 7@+ @ dup d# 15 and drop { cr }
 while then [ d# 0 ] and emt 7dec ; then xx ;
: named ( string ) d# 0 [ hld ] ! -kbd if ,src ; { cr }
 then ( keyboard ) d# 0 word d# 0 { cr }
 begin push dup and while end then drop { cr }
 begin pop dup and while +shan end then emt ; { cr }
: onam ( n-a ) align strng [ here d# 80 + h ! ]
: bnam ( n-a ) align strng [ here d# 80 + h ! ]
: !str ( b ) push named [ d# 0 fnam ] d# 4 / pop d# 4 / [ d# 20 ] move
 ;
: onamed d# 0 onam !str ; [ onamed ] ( okadwork.cf )
: bnamed d# 0 bnam !str ; [ bnamed ] ( okadback.cf ) { cr }
 [ d# 0 onam 'ofn ! d# 0 bnam 'bfn ! ] }block

( 00212C00 )               D# 75 shadow{ 
 ( filename input )
: strng ( defines an array of bytes. )
: fnam ( is a zero terminated ascii string consisting of ) hld ( chars
 including the null. ) emt ( appends a character to this string. )
: +shan ( appends a shannon word to fnam. ) { br }

: named ( returns the byte address of a null terminated ascii string
 representing the following colorforth string, which may follow in
 either source code or in keyboard input. ) { cr }
 ( example ) [ named ] ( //./a; ) { br }

: onamed ( and ) bnamed ( override the default .cf ) { cr }
 ( filenames used by save and audit ) }block

( 00213000 )               D# 76 code{ 
 ( index ) [ empty -nat ] { cr }
 :# pad 278806528 [ abuf block d# 4 * pad ! ] { cr }
 :# hld 278821284 [ pad @ hld ! ] :# pos 2 [ d# 0 pos ! ]
: nxt ( a-an ) dup d# 1 + swap @ ;
: -eol? [ pos ] @ [ d# 47 ] or drop ;
: .sp d# 32
: .ch ( c ) -eol? if [ hld ] @ 1! d# 1 [ hld ] +! d# 1 [ pos ] +! ;
 { indent }
      then drop ;
: crlf d# 0 [ pos ] ! d# 13 .ch d# 10 .ch ; { br }

: .hd ( n ) [ d# -10 ] + -if [ h# 3A ] + .ch ; then [ h# 41 ] + .ch
 ;
: .dec ( n ) [ d# 0 ] + -if h# 2D .ch negate then [ d# -1 ] swap { cr }
 begin [ d# 10 ] /mod dup and while end then drop
: spit ( -1 ... ) begin .hd [ d# 0 ] + -until drop ; { br }

: hd ( n-nn ) dup [ h# F ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n ) [ d# -1 ] swap begin hd H# FFFFFFF and while end then
 drop spit ; { cr }
 [ d# 78 load ] { br }

 [ named ] ( index.txt ) [ exit d# 18 d# 1440 run ] }block

( 00213400 )               D# 77 shadow{ 
 ( index )
: hld ( place in file )
: spot ( in line )
: nxt ( fetch next word )
: emit ( ascii character, won't go past column { 90F } )
: space ( written to file )
: crlf ( to file )
: digit ( hex digit to file )
: .h ( print hex number )
: .d ( decimal number ) { br }

 [ usage example in bottom line. ] }block

( 00213800 )               D# 78 code{ 
 ( - more )
: word ( n ) .sp [ h# -10 ] and
: cont ( n ) dup and if ch .ch cont ; then drop ;
: short ( n ) .sp 2/ 2/ 2/ 2/ dup d# 1 and drop { indent }
      if 2/ .hex ; then 2/ .dec ;
: variable ( an-a ) word d# 0
: long ( an-a ) .sp push nxt pop h# 10 and drop { indent }
      if .hex ; then .dec ;
: eol ( n ) begin drop d# 47 [ pos ] ! ;
: tag ( a-a ) dup and until dup h# F and jump { cr }
 cont word long eol word long short word { cr }
 short word word word variable short eol short
: ?sp ( nl-n ) + -if .sp then ;
: line ( n ) d# -100 ?sp d# -900 ?sp d# 1000 + { indent }
      dup .dec space block d# 0 [ pos ] ! { indent }
      begin -eol? while nxt tag end { indent }
      then drop crlf ;
: run ( 1st lst+1 ) [ pad ] @ [ hld ] ! over negate + 2/ { indent }
      for dup line [ d# 2 ] + next drop
: sav d# 0 d# 32 d# 2 d# 0 d# 0 w/o [ d# 0 fnam ] fcreate dup push
 { cr }
 [ pad ] @ [ hld ] @ over negate + pop fwr drop fclose ; }block

( 00213C00 )               D# 79 shadow{ 
 ( index.1 )
: short ( number )
: literal ( long number )
: word ( text, not number )
: cont ( inuation word )
: variable ( name and value )
: eol ( red word means end of line )
: tag ( vector table )
: words ( print maximum n words or to eol )
: run [ first-block last+1 ] { cr }
 ( prints first line of each block in range ) { cr }
 ( to a log file ) [ in windows ] }block

( 00214000 )               D# 80 code{ 
 ( qx ) :# ?qxc 271547905 :# qb 0 [ d# 82 load ]
: ?c ( n-n ) green dup [ blk ] @ or drop if white then ;
: !qx [ ?qxc ] assign ?c ; [ !qx ] { , , }
: nx [ qb ] @ d# 120 + { * }
: qx ( n !qx ) d# 0 max abuf /mod { , ... }
      push d# 2 /mod d# 60 / d# 120 * + pop abuf * + [ qb ] ! { , }
 show black screen white d# 0 d# 60 for dup d# 30 /mod { , ... }
      d# 42 * swap tab/2 [ qb ] @ over 2* + [ ?qxc ] xqt { , ... }
      dup .r .cmt d# 1 + next drop keyboard ;
: bx [ qb ] @ d# -120 + qx ; { -cr }
: ax [ blk ] @ qx ;
: sx [ qb ] @ d# 1 or qx ;
: ox [ qb ] @ [ abuf ] /mod d# 1 or [ abuf ] * + qx ; }block

( 00214400 )               D# 81 shadow{ 
 ( index page overview display ) { br }

: qx ( shows the heading comments of the index page in which block )
 [ n ] ( lies, source or shadow. ) { br }

: nx ( shows the next page and ) bx ( the preceding. )
: sx ( toggles between source and shadows for the current page. ) { br }

: ax ( shows the page in which the current editor block lies. ) this
 block is displayed in green }block

( 00214800 )               D# 82 code{ 
 ( - formatting ) :# ws 271547521
: tab/2 ( xy ) push [ d# 11 ] * [ d# 3 ] + pop [ d# 15 ] * [ d# 3 ]
 + { cr }
 over lm at ; { -cr }
: emit/2 ( c ) [ d# 48 ] + emit
: -sp/2 [ d# -11 h# 10000 * ] nop [ xy ] +! ; { br }

: /bl [ ws ] assign nop ; { -cr }
: /sp [ ws ] assign sp/2 ;
: .r ( n ) [ d# 4 ] for d# 10 /mod next h# F and [ d# 4 ] for [ d# 0 ]
 + if { cr }
 pop [ d# 1 ] + { -cr }
: .lo for [ d# 24 ] + emit/2 next ; { cr }
 then drop [ ws ] xqt next [ d# 1 ] .lo ; [ /sp ]
: .n ( n ) [ d# 32 ] / /bl .r /sp ;
: .s/2 ( n ) [ d# 0 ] + if unpack emit/2 .s/2 ; then drop ;
: .wd ( n ) [ h# 8200 ] tag? if sp/2 then [ h# 8000 ] tag? if .n ;
 then d# -16 and .s/2 ;
: .cmt ( n ) d# 18 less drop if drop ; then block d# 7 for dup @ [
 d# 0 ] + while [ h# 8201 ] tag? while .wd { cr }
 [ d# 1 ] + next drop ; then then pop drop drop drop ; }block

( 00214C00 )               D# 83 shadow{ 
 ( index page overview display ) { br }

 ( these definitions are necessary due to the way in which colorforth
 kernel is factored. ) }block

( 00215000 )               D# 84 code{ 
 ( resident compress ) [ d# 86 load ]
: short d# 4 rbits d# 28 bits ;
: lit d# 4 rbits 2/ 2/ 2/ 2/ d# 1 rbits
: 32bits drop d# 1 + dup @ d# 16 bits d# 16 bits ;
: variable 1word 32bits ;
: /whit ( n-n ) d# -16 and d# 9 or atom ;
: tag ( an-an ) dup h# F and jump cont atom lit atom atom lit short
 atom short atom /whit /whit variable short atom short
: atoms ( a ) dup @ dup and if tag drop d# 1 + atoms ; then d# 4 bits
 drop drop ;
: range ( nn-an ) here/4 here4 push new for dup block atoms d# 1 +
 next drop 0 d# 31 bits drop pop here4 over negate + ;
: !lng ( nw ) [ d# 127 ] + [ d# 128 ] / [ d# 72 ] + dup ( nsec ) [
 d# 0 ] block [ d# 1 ] + ! dup negate [ ns ] ! [ d# 35 ] + [ d# 36 ]
 / [ nc ] ! ;
: save 7push [ h ] @ push [ cbuf d# 36 + block d# 4 * ] h ! d# 36 [ nblk
 @ d# -36 + ] range ( an ) !lng drop 0 block [ cbuf ] block [ d# 36
 blks ] move [ cbuf ] !work [ ns ] @ abs [ ns ] ! pop [ h ] ! 7pop
 ; }block

( 00215400 )               D# 85 shadow{ 
: short ( tag, then 28bit value+base )
: lit ( tag, then base )
: 32bits ( from next word. 2 chunks )
: variable ( single word, then 32-bits )
: /whit ( replaces a word's tag with 9, making it a lowercase comment. )
: tag ( identify kind of word ) [ note /whit used for tags h# A and
 h# B to convert these deprecated capitalized comments to lower case.
 when all source of interest has been compressed at least once this
 may be removed. ]
: atoms ( scan thru block. 8 0s eob )
: range ( process blocks, number and count. 31 0s eof )
: sve ( compress blocks 72 thru 1419 )
: flop ( write floppy; save number of cylinders ) }block

( 00215800 )               D# 86 code{ 
 ( - more ) [ macro ] ( uses ebx )
: r3@ < ?dup > h# C38B 2, ;
: r1! h# C88B 2, < drop > ;
: 2*d h# C3A50F 3, ;
: 2*c h# E0D3 2, ;
: 2/r h# C8D3 2, ; [ forth ] :# nb 13
: here/4 here d# 3 and if 1, here/4 ; then drop ;
: here4 here 2/ 2/ ;
: new d# 32 [ nb ] ! ;
: shift ( nn-n ) dup negate [ nb ] +! r1! 2*d 2*c ;
: rbits dup r1! swap 2/r swap
: bits ( nn-n ) dup negate [ nb ] @ + -if dup push + shift r3@ , new
 pop negate shift ; then drop shift ;
: char -if 2* -if 2/ d# 7 bits ; then 2/ H# -80000000 or d# 5 bits
 ; then d# 4 bits ;
: chars dup and if char chars ; then ;
: 1word d# 4 rbits chars d# 4 bits ;
: atom ( an-an ) d# 4 rbits
: cont chars over d# 1 + @ dup and if h# F and drop if d# 4 bits ;
 then ; then drop d# 4 bits ; }block

( 00215C00 )               D# 87 shadow{ 
: r3@ ( fetches register { 6F } onto stack. )
: r1! ( stores top of stack to register 1. )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: 2/r ( rotate eax right by ecx )
: nb ( number of bits remaining in word )
: here/4 ( align to word boundary )
: here4 ( word address in dictionary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: rbits ( rotate bits to high-order position )
: bits ( shift bits into ebx; cross word boundary )
: char ( examine high bits. shift 4, 5 or 7 bits )
: chars ( shift all non-zero characters )
: 1word ( short word without continuation for variable )
: atom ( shift tag, then characters )
: cont ( continue without tag ) }block

( 00216000 )               D# 88 code{ 
 ( display text ) [ macro ]
: 7@+ ( -a ) < ?dup > h# C78B 2, h# 47 1, ; { * }
: 7dec h# 4F 1, ;
: @ret ( -b ) < ?dup > h# 24048B 3, H# 5240483 , ;
: 4@ ( b-n ) h# 8B 2, ; [ forth ]
: tick ( b-b ) dup [ d# 1 ] + 4@ + d# 5 + ;
: call h# E8 { * }
: dst 1, @ret tick here d# 3 + - + , ;
: jmp h# E9 dst ; { * }
: execute ( b ) push ; { , , }
: .shan ( n- ) dup and if unpack emit .shan ; then drop ;
: .shans ( a ) begin dup @ [ h# 8201 ] tag? while d# -16 and { , ... }
      .shan d# 1 + dup @ [ h# 8200 ] tag? drop if space { , }
 then end then drop drop ; { * }
: +str ( a-a ) + ; [ macro ]
: ,lit ( n ) < ?dup > h# B8 1, , ;
: strings ( i-a ) 7push pop < ,lit > jmp +str nop ;
: .' ( comments ) 7@+ < ,lit > call .shans nop ;
: remember [ forths ] @ < ,lit > [ macros ] @ < ,lit > [ h ] @ [ d# 15 ]
 + < ,lit > ( call ) jmp !dict nop ; [ forth ] { , , }
: ' ( -b ) -kbd if 7@+ @ itick if abort then ; { , }
 then tic ;
: eval ( a ) 7push [ d# 1 ] + push 7pop { , ... }
      [ sp d# 1 + ] @ execute 7pop ; }block

( 00216400 )               D# 89 shadow{ 
 ( various useful extensions. ) { br }

: 7@+ ( interpret only, returns adr of next word in block and skips
 over it ... 7-0-mov 7-inc )
: 7dec ( used to correct address after 7@+ )
: @ret ( fetch return address, skip bytes of code. )
: 4@ ( cell fetch on byte boundary )
: tick ( given adr of call instr, return tgt adr )
: call ( and ) jmp ( generate xfers to next word ) { br }

: .shan ( displays a shannon coded string )
: ,lit ( compiles a literal. )
: .' ( displays the following comment or comments. )
: remember used ( in a containing word to make that word restore dictionary
 to what immedately follows it. ) { br }

: strings ( starts an array of words in source. )
: ' ( interp only, returns next word's code addr. )
: execute ( is a call to the given routine adr. )
: eval ( interprets the source word whose address is given. ) }block

( 00216800 )               D# 90 code{ 
 ( disk audit utility ) [ empty d# 30 load ] :# bias 0 { , }
 :# sep 10000 [ abuf sep ! ] :# head 1439 [ d# 1439 head ! ]
: +blocks ( sdn ) 2* ( bloks ; )
: bloks ( sdn ) push swap block swap block pop [ d# 256 ] * move ;
 { * }
: n18 ( i-a ) [ abuf d# 18 + block ] + ;
: wipe [ blk ] @ d# 1 erase ( e ) lis ; { * }
: to ( n ) [ head ] ! ;
: obliterate ( lh ) over negate + erase ;
: matching ( sd ) less if swap then { , }
 dup [ bias ] ! negate + [ sep ] ! ;
: cast ( nn-n ) dup push /mod d# 1 or pop * + ;
: other ( n-n' ) [ bias ] @ negate + [ sep ] @ cast [ bias ] @ + ;
 { * }
: lesser ( n-n ) dup other min ; [ d# 92 load ]
: ?blk ( n-n?n+ ) lesser dup block over other block [ d# 256 ] for
 over @ over @ or drop if drop drop dup [ d# 1 ] + pop drop ; then
 [ d# 1 ] + [ d# 1 ] u+ next drop drop [ d# 1 ] + ; { * }
: ?blks ( sn-? ) for ?blk next drop ;
: ?bin ( kernel ) d# 0 d# 12 ?blks ( icons ) d# 12 d# 6 ?blks ;
: unpk abs [ d# 1 n18 ] ! { , }
 [ abuf d# 36 + ] block [ cbuf ] block [ d# 1404 ] blks move { , }
 [ cbuf block ] abuf d# 36 + [ d# 3 n18 ] @ [ d# -36 ] + range ;
: check [ abuf ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or { , }
 drop if ; then [ d# 1 n18 ] @ { , }
 dup and -if unpk ; then drop ; }block

( 00216C00 )               D# 91 shadow{ 
 ( disk mgmt and reconciliation utility. )
: bloks ( copies n blocks from s to d, front to back so only moves
 overlap downward safely. )
: +blocks ( copies n blocks and their shadows. )
: obliterate ( wipes from block l to block h. )
: matching ( sets up to match s to d. )
: to ( sets block no. past end of source area. )
: other ( given a block number in one of the areas returns the corresponding
 block no. in the other area. )
: lesser ( given a block number returns the lesser of the pair it is
 a member of )
: ?blks ( scans a range of blks leaving nos of any differing blks on
 the stack. )
: ?bin ( scans the binary parts of okad disk. )
: check ( reads backup to { 1770F } and decompresses if appropriate )
 }block

( 00217000 )               D# 92 code{ 
 ( - compare ) :# cvec 271553540
: blink [ cvec ] assign ( n ) dup other [ blk ] ! edit ;
: var ( nnxx-nnd ) push push d# 1 + d# 1 u+ pop pop
: *1 ( nnxx-nnd ) or ;
: *2 ( nnxx-nnd ) var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# F and jump *1 *1 *2 *1 { , ... }
      *1 *2 *1 *1 { .. }
      *1 *1 *1 *1 { .. }
      var *1 *1 *1
: ?nul ( nnxx-nnxx ) over over +or drop if ; then drop drop pop drop
 drop drop ;
: co ( naa-n ) over @ over @ ?nul tag drop if { , ... }
      drop drop [ cvec ] xqt ; then d# 1 + d# 1 u+ co ;
: com ( n-n ) dup block over other block co ;
: g [ blk ] @ lesser
: gg ( n ) blink [ head ] @ over - + drop -if drop ; { , }
 then [ d# 1 ] + com gg ;
: v [ blk ] @ other edit ;
: give [ blk ] @ dup other d# 1 bloks ;
: take [ blk ] @ dup other swap d# 1 bloks ;
: all d# 0 [ abuf ] matching [ nblk ] @ [ d# -1 ] + to [ d# 17 ] gg
 ;
: diff [ cvec ] assign red ;
: !cx [ ?qxc ] assign ( n-n ) ?c diff com ; { , }
 [ !cx ] { * }
: empty empt !qx ; }block

( 00217400 )               D# 93 shadow{ 
: blink ( displays the given block with its other set as the editor's
 'other' block )
: var ( compares a variable name, advancing pointers to skip its value. )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compares source cells given, true if diff, advancing ptrs and
 ignoring variable vals. )
: ?nul ( ends loop in co if nuls hit in both blks. )
: co ( does work of com given adrs of both blks. )
: com ( invokes editor to blink the given block if it differs from
 the other, otherwise returns. )
: g ( scans for diffs after current editor block. )
: v ( shows the other block )
: give ( writes current editor block over its twin )
: take ( writes twin over current editor block. )
: check ( reads backup to 3000 for matching. )
: all ( scans the whole usable area of the disk. )
: cvec ( is behavior on com finding difference; )
: diff ( makes it just set color for qx. )
: !cx ( makes qx aware of us, )
: empty ( redefined to kill that awareness. ) }block

( 00217800 )               D# 94 code{ 
 ( improved stack display ) :# nr 2 { , , }
: -msg [ ' nul ] 'msg ! d# 2 [ nr ] ! ;
: msg -msg pop 'msg ! ;
: rep d# -1 [ nr ] +! [ nr ] @ d# 0 + drop if ; then -msg ;
: ?msg 'msg @ -safe if -msg ; then ;
: empty empt ?msg ?logo ; { , , }
: ks0 ( -a ) 'stk d# 1 + @ d# 4 / d# -1 + ;
: ksp ( -a ) 'stk d# 2 + @ 4@ 4@ d# 4 / ;
: .s ks0 ksp negate + ( dup . ) d# 0 less drop if { , .. }
      abs . .' ( below empty ) ; then d# 0 + if { , .. .. }
      [ d# 5 ] over less drop if .' ( ... ) swap then drop { , .. .. }
      dup push ksp + begin { , }
 dup @ ?. d# -1 + next ( drop ) then drop ; { , }
 ( install ) [ ' .s 'stk ! ] ( exit ) { , , }
: -range msg rep red .' ( out of range ) ; [ macro ]
: then ( a-a ) here over negate + d# 128 + d# -256 and { , }
 drop if -range abort dann < dann > ; [ forth exit ] { , }
: dstk { * }
: z ( 'msg assign white ) { , }
 'stk d# 2 + @ d# 9 + 4@ 4@ { 8F } ( / ?. ) ; }block

( 00217C00 )               D# 95 shadow{ 
: -msg ( deactivates any current message and sets ) nr ( to default
 life span of { 4F } refreshes, which typically means ) [ two keystrokes. ]
: msg ( is std word to assign rest of defn to msg. )
: rep ( is used inside a msg to count down life. )
: ?msg ( deactivates if its code's been forgotten. )
: empty ( changes display/message only if needed. ) [ messages display
 till forgotten, or aged using rep, or are replaced by another, or
 someone says -msg, or the message otherwise monitors the situation
 and uses -msg itself. ] { , , }
: ks0 ( and ) ksp ( return empty and current stack ) { , }
 ( pointers in word units. )
: .s ( displays stack, top on right, ) [ yellow ] ( number is max number
 of entries to display. indicates stack below empty and ... when excess
 items. ) { , }
 ( factored separately so new versions may be ) { , }
 ( tested as messages with ) nos }block

( 00218000 )               D# 96 code{ 
 }block

( 00218400 )               D# 97 shadow{ 
 }block

( 00218800 )               D# 98 code{ 
 }block

( 00218C00 )               D# 99 shadow{ 
 }block

( 00219000 )               D# 100 code{ 
 }block

( 00219400 )               D# 101 shadow{ 
 }block

( 00219800 )               D# 102 code{ 
 }block

( 00219C00 )               D# 103 shadow{ 
 }block

( 0021A000 )               D# 104 code{ 
 }block

( 0021A400 )               D# 105 shadow{ 
 }block

( 0021A800 )               D# 106 code{ 
 }block

( 0021AC00 )               D# 107 shadow{ 
 }block

( 0021B000 )               D# 108 code{ 
 ( ide native async ) [ d# 0 fh orgn ! macro ]
: 1@ ( b-c ) h# 8A 2, ;
: 1! ( cb ) < a! > h# 288 2, < drop > ;
: 2@ ( b-h ) h# 8B66 3, ;
: 2! ( hb ) < a! > h# 28966 3, < drop > ;
: 4@ ( b-n ) h# 8B 2, ;
: 4! ( nb ) < a! > h# 289 2, < drop > ;
: swab ( h-h ) h# C486 2, ;
: swa4 ( n-n ) h# C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ;
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ;
: rez ( n ) h +! ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }

 :# act 0 :# vport 373 :# 0tg 1 :# 1tg 1 :# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] !
 ; { br }

 ( ser ) [ d# 110 load d# 118 load ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load d# 142 load ] ( creeper ) [ d# 140 load ] { cr }
 [ canon load ] }block

( 0021B400 )               D# 109 shadow{ 
 ( talk to chip via native rs232. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure
 given byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
 in dictionary. ) [ note that writing into such allocations invalidates
 nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. )
 { br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021B800 )               D# 110 code{ 
 ( - umbilical ) [ h# 3F8 ] ( serial ) [ d# 60 load ]
: !nam ; :# sport 0 :# bps 0
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 24576 rez ] :# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }

: @18 ( -n ) /str 4@ [ h# 3FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 3FFFF ] or [ h# 40 ] * [ h# 12 ] + /str 4! +wd ; { br }

: +ser ( -ok ) init d# 1 [ d# 0 ] + ;
: -ser ;
: reset [ d# 1 ] st! [ d# 100000 ] for next [ d# 3 ] st! ;
: toser ( bn ) for dup 1@ xmit [ d# 1 ] + next drop ;
: inser ( w ) stream swap [ d# 3 ] * for { indent }
      rcv over 1! [ d# 1 ] + next drop ; }block

( 0021BC00 )               D# 111 shadow{ 
 ( async data are 18 bits per 3 bytes. to chip word inverted, shifted
 up 6, '12' inserted, then sent low order byte first. from chip are
 tbd. ) { br }

: !nam sport ( and ) bps ( dummies for compatibility )
: 4@ ( and ) 4! ( full cell on byte address. )
: +ser ( opens serial; true if good, handle in dh. )
: -ser ( closes the handle. )
: reset ( resets the chip. )
: toser ( transmits n bytes to chip. )
: inser ( receives w f18 words from the chip. ) { br }

: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be
 present! ) }block

( 0021C000 )               D# 112 code{ 
 ( ide windows async ) [ d# 0 fh orgn ! macro ]
: 1@ ( b-c ) h# 8A 2, ; { -cr }
: 1! ( cb ) < a! > h# 288 2, < drop > ;
: 2@ ( b-h ) h# 8B66 3, ; { -cr }
: 2! ( hb ) < a! > h# 28966 3, < drop > ;
: 4@ ( b-n ) h# 8B 2, ; { -cr }
: 4! ( nb ) < a! > h# 289 2, < drop > ;
: swab ( h-h ) h# C486 2, ;
: swa4 ( n-n ) h# C80F 2, ; [ forth ] { br }

: a-b ( a-b ) 2* 2* ; { -cr }
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ; { -cr }
: rez ( n ) h +! ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }

 :# act 2 :# vport 469 :# 0tg 1 :# 1tg 1 :# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] !
 ; { br }

 ( ser ) [ d# 114 d# 3 loads ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load d# 142 load ] ( creeper ) [ d# 140 load ] { cr }
 [ canon load ] }block

( 0021C400 )               D# 113 shadow{ 
 ( talk to chip via onspec usb. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure
 given byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
 in dictionary. ) [ note that writing into such allocations invalidates
 nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. )
 { br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021C800 )               D# 114 code{ 
 ( - umbilical ) :# sport 3 [ d# 1 sport ! ]
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 24576 rez ] :# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }

: @18 ( -n ) /str 4@ [ h# 3FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 3FFFF ] or [ h# 40 ] * [ h# 12 ] + /str 4! +wd ; { br }

: snam ( -a ) align create ( //./ ) [ H# 2F2E2F2F , ] ( com ) [ h# 6D6F63
 , h# 0 , ]
: !nam [ sport ] @ d# 10 over - + drop -if d# 256 * d# 2560 /mod +
 h# 3000 + then h# 30 + snam a-b d# 7 + 4! ; [ !nam ]
: toser ( bn ) [ dh ] @ fwr drop ;
: inser ( w ) stream swap [ d# 3 ] * [ dh ] @ frd drop ; }block

( 0021CC00 )               D# 115 shadow{ 
 ( async data are 18 bits per 3 bytes. to chip word inverted, shifted
 up 6, '12' inserted, then sent low order byte first. from chip are
 tbd. ) { br }

: sport ( comp com port number )
: snam ( null terminated string //./comx )
: !nam ( sets port number in snam. )
: +ser ( opens serial; true if good, handle in dh. )
: -ser ( closes the handle. )
: reset ( resets chip. no inversion in rx line. )
: toser ( transmits ) [ n ] ( bytes from byteadr ) [ b ]
: inser ( receives w f18 words from the sync boot node. ) { br }

: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be
 present! ) }block

( 0021D000 )               D# 116 code{ 
 ( - com port management ) { cr }
 :# dflg 4113 [ h# 1011 dflg ! ] { cr }
 :# bps 921600 [ d# 115200 bps ! ]
: dcb ( n-a ) align strng [ here d# 32 + h ! ]
: @dcb d# 0 dcb [ dh ] @ rdcb drop ; [ d# 0 d# 0 dcb b-a d# 8 fill ]
: !dcb [ dflg ] @ [ d# 8 dcb ] 4! d# 0 dcb [ dh ] @ wdcb drop ;
: /dcb @dcb !dcb ;
: baud ( n ) @dcb [ d# 4 dcb ] 4! ( bits ) d# 8 [ d# 18 dcb ] 1! { cr }
 ( np/1sb ) d# 0 [ d# 19 dcb ] 2! !dcb ; { br }

: +ser ( -ok ) snam r/w fopen [ dh ] ! if { cr }
 [ bps ] @ baud d# 1 ; then d# 0 ;
: -ser [ dh ] @ [ d# 0 ] + if fclose d# 0 then [ dh ] ! ;
: ctl! ( n ) [ dh ] @ fesc drop ;
: reset ( lo ) [ d# 4 ] ctl! [ d# 500000 ] for next ( hi ) [ d# 3 ]
 ctl! ; }block

( 0021D400 )               D# 117 shadow{ 
: dcb ( structure controls mode of a com port. )
: dflg ( flags sent every time we control com port { 3F } binary always, { 21F }
 dtr on, { 201F } rts on. )
: @dcb ( and ) !dcb ( read and write com port control. ) [ dflg ] ( is
 always included in the setting. )
: /dcb ( sets dflg without changing anything else )
: baud ( sets baud rate and character framing. ) { br }

: +ser ( opens serial; true if good, handle in dh. )
: -ser ( closes the handle. )
: reset ( resets chip. no inversion in rx line. ) }block

( 0021D800 )               D# 118 code{ 
 ( - node { 588F } boot frames )
: wos ( -n ) d# 0 ;
: /frame ( nw xfr jmp ) -stream [ h# 10000 ] + !18 !18 [ d# 1 ] + 2/
 ( words ) 2* ( actual { -11 } + ) !18 ;
: +frame ( wn ) for dup @ !18 [ d# 1 ] + next drop ;
: +ram ( w n node ) nn-n 2* [ h# 8000 ] + block u+ for dup @ [ h# 15555 ]
 or !18 [ d# 1 ] + next drop ;
: !frame ( f ) drop stream [ bi ] @ toser ; { br }

: exec [ h# AE ] ;
: talk cold -ser +ser if drop reset h# 40 d# 0 [ exec ] /frame h# 0
 h# 40 [ d# 1600 ] +ram [ wos ] !frame ( good ) ; then ( bad ) -ser
 drop h# BAD dup abort ; { cr }
: exch ( w n f n ) push push dup [ h# 2 ] + [ d# -2 ] and [ vport ]
 @ pop /frame [ vport ] @ [ h# 12000 ] + !18 dup - [ h# 1 ] and drop
 if [ vport ] @ [ h# 10000 ] + !18 then +frame [ wos ] !frame pop inser
 -stream ; { br }

: ok [ h# 12 ] ;
: fet [ h# 15 ] ;
: stat [ h# 1B ] ;
: bstk [ h# 1D ] ; }block

( 0021DC00 )               D# 119 shadow{ 
 ( boot frames begin with a 3 word header; ) { indent }
      100xx ( jump to xx when done ) { indent }
      ddd ( mem/port adr to store payload ) { indent }
      n ( transfer length ) { indent }
      [ n ] ( words of payload, none if ) [ n ] ( is 0. )
: /frame ( heads a new given ) [ even ] ( words of payload, destination
 addr, final jump addr. )
: +frame ( appends words to payload. )
: +ram ( appends a string of code from binary produced by ) compile
 ( for the given ) [ node. ]
: !frame ( transmits frame given ) [ wos ] ( or ) [ wos! ] { br }

: talk ( prepares chip for control thru node 19. )
: exch ( performs a transaction with target given addr and length of
 port stream, stream end action in boot node, and number of words reply. )
 { cr }
: ok ( stream end to simply ack completion; ) fet ( pumps one word
 from target; ) bstk ( shepherds stack dump; ) stat ( pumps ten. )
 exec ( is next boot frame. ) }block

( 0021E000 )               D# 120 code{ 
 ( - node { 588F } paths )
: line ( ncd ) swap push swap { indent }
      begin dup , over + -next drop drop ;
: count ( nc-ncd ) dup [ d# 100 ] mod [ d# 0 ] + if { cr }
 ( horz ) swap drop [ d# 1 ] ; ( vert ) then drop [ d# 100 ] / [ d# 100 ]
 ;
: to ( nn ) over negate + -if { cr }
 ( back ) negate count negate line ; { cr }
 ( forw ) then count line ; { br }

: 0pa align create [ d# 708 d# 700 to d# 600 d# 0 to ] { cr }
 [ d# 1 d# 17 to d# 117 d# 717 to d# 716 d# 708 to d# -1 , ]
: 1pa align create [ d# 708 , d# 608 , d# -1 , ]
: 2pa align create [ d# 708 d# 717 to d# 617 d# 17 to ] { cr }
 [ d# 16 d# 0 to d# 100 , d# 101 d# 116 to d# 216 d# 200 to ] { cr }
 [ d# 300 d# 316 to d# 416 d# 400 to d# 500 d# 516 to ] { cr }
 [ d# 616 d# 600 to d# 700 d# 708 to d# -1 , ] }block

( 0021E400 )               D# 121 shadow{ 
: 0pth 1pth 2pth ( are manually set route lists for using the north,
 south, and west ports of node 19. end list is marked by -1 ) { br }

 ( customize these paths by replacing entries in ) paths ( table after
 loading ide. ) }block

( 0021E800 )               D# 122 code{ 
 ( - boot target adjacent ) :# 'wall 271579048
: swall ( nn-i ) over over or [ d# 1 ] and drop if or [ d# 2 ] and
 ; then { 14F } [ d# 100 ] / swap { 14F } [ d# 100 ] / or [ d# 2 ]
 and [ d# 1 ] + ;
: wall ( nn-i ) [ 'wall ] xqt ; [ ' swall 'wall ! ] { br }

: do! align create ( @p+a!.@p+ ) [ h# 4AB7 , ] { indent }
      [ h# 0 , h# 0 , ] ( !;;; ) [ h# B555 , ]
: do@ align create ( ...@p+ ) [ h# 2C9B7 , ] { indent }
      [ h# 0 , ] ( a!@!p+; ) [ h# 2BE35 , ]
: doi align create [ h# 10000 , ]
: dopu align create ( @p+; ) [ h# 5555 , h# 0 , ]
: dostk align create ( !p+dup-push!p+ ) [ h# CDBE , ] { br }

: aa@ ( a-n ) [ do@ d# 1 + ] ! do@ [ d# 3 ] fet [ d# 1 ] exch @18 ;
: aa! ( na ) [ do! d# 1 + ] ! [ do! d# 2 + ] ! do! [ d# 4 ] ok [ d# 1 ]
 exch ;
: acall ( a ) [ h# 10000 ] +
: ains ( w ) [ doi ] ! doi [ d# 1 ] ok [ d# 1 ] exch ;
: apsh ( n ) [ dopu d# 1 + ] ! dopu [ d# 2 ] ok [ d# 1 ] exch ;
: astk dostk [ d# 1 ] bstk [ d# 10 ] exch ; }block

( 0021EC00 )               D# 123 shadow{ 
 ( this code supports boot node controlling one of its immediate neighbors
 directly. ) [ these all begin with focusing call and each must return! ]
 { cr }
: port ( returns port for 0-3 rdlu ndx, then edges )
: wall ( is index for port between two nodes )
: 'wall ( vectors the active ) wall ( definition )
: swall ( is standard ) wall ( definition ) { br }

: doxxx ( port execution templates for target. )
: aa@ ( fetches from memory or port in target onto our stack here. )
: aa! ( stores a value from our stack here to port or memory in target. )
: ains ( executes an arbitrary instruction word which must end by returning. )
: acall ( executes a target word which must return or jump to ports. )
: apsh ( pushes a number onto target stack. )
: astk ( queries target stack nondestructively. ) }block

( 0021F000 )               D# 124 code{ 
 ( - stream components ) :# 'pth 67894616
: nstream ( an-n'w ) swap [ 'pth ] ! [ d# -2 ] + -if [ d# 0 ] pop drop
 ; then ( pre ) [ d# 2 ] ;
: ?path ( i-n ) [ 'pth ] @ + @ ;
: side ( n-a ) [ 'pth ] @ + dup @ swap [ d# 1 ] + @ wall port ;
: /hdr ( w-w ) dup [ d# -2 ] and [ d# 0 ] side [ exec ] /frame ( pre )
 [ d# 0 ] side [ h# 12000 ] + !18 [ d# -1 ] + dup [ d# 1 ] and drop
 if [ d# 0 ] side [ h# 10000 ] + !18 then [ d# -1 ] + ; { br }

: +pump ( nw-nw ) [ d# -8 ] + ( @p+b!@p+@p+ ) [ h# 4B17 ] !18 { cr }
 [ h# 1 ] side dup !18 dup [ h# 10000 ] + !18 [ h# 12000 ] + !18 { cr }
 ( !b!b.@p+ ) [ h# 9BB7 ] !18 ( w ) dup [ d# -1 ] + !18 { cr }
 ( dup-push-if ) [ h# 24861 ] !18 ( @p+!b.unext ) [ h# 5BB4 ] !18 ;
: +load ( w n nb nd ) push push ( @p+a!.@p+ ) [ h# 4AB7 ] !18 ( a )
 over !18 ( n ) [ d# -1 ] + !18 ( dup-push-if ) [ h# 24861 ] !18 { cr }
 ( @p+!+.unxt ) [ h# 58B4 ] !18 pop pop +ram ;
: +post ( p @p+b!.@p+ ) [ h# 4BB7 ] !18 [ d# 1 ] side !18 [ d# 0 ]
 side !18 ( a!@p+push; ) [ h# 2BDBD ] !18 ( p ) !18 ; }block

( 0021F400 )               D# 125 shadow{ 
 ( templates and load streams )
: 'pth ( current posn in path list of nodes. )
: nstream ( given addr of path tbl, nodes away, gives no of wire nodes
 and total stream length )
: ?path ( returns node number relative to current posn in selected
 path. )
: side ( gives adr of ) 0 ( near, ) 1 ( far side next node )
: /hdr ( starts a stream of given length; if odd, we leave out jump
 after waking 1st node. ) { br }

: +pump ( makes port pump thru next node; its ram load and init postamble
 must be out of w. )
: +load ( builds a program load from binary given node ram addr, word
 count, words to take from binary, and node number. caller must append
 any words not taken from binary. )
: +post ( follows a node's ram load to set b to out, a to in, and jump
 to ) p. }block

( 0021F800 )               D# 126 code{ 
 ( - umbilical plumbing ) :# 'foc 271580094
: using ( nn ) wall port [ vport ] ! ;
: avail ( n-p ) [ d# 1000 ] mod nn-n idle ; { br }

: +path ( n'wn-n'w ) dup [ 'pth ] +! negate u+ ; { br }

: unfoc ( -a ) [ 'foc ] assign [ d# 1 ] ?path avail ; [ unfoc ]
: foc ( -a ) [ 'foc ] assign [ d# 0 ] side ; { br }

: rip ( nw-nw ) [ d# 0 ] u+ if ( post ) [ d# -5 ] + +pump [ d# 1 ]
 +path rip [ d# -1 ] +path then [ 'foc ] xqt +post ;
: rips ( an-n'w ) nstream over [ d# 13 ] * + [ d# 5 ] + /hdr rip
: hose ( nw ) drop drop d# 0 ?path d# 1 ?path using [ wos ] !frame
 ; { br }

: wire ( nw-nw ) [ d# 0 ] u+ if ( wire ) [ h# 16 d# 10 + negate ] +
 +pump [ d# 1 ] +path wire [ d# -1 ] +path ( wire ) h# 0 [ h# 16 ]
 dup [ d# 1602 ] +load [ d# 0 ] side +post ; then ( last ) h# 0 [ h# 20 ]
 dup [ d# -1 ] + { , }
 [ d# 1603 ] +load [ d# 1 ] side [ h# 12000 ] + !18 [ d# 0 ] side +post
 ;
: wires ( an-n'w ) nstream over [ d# 18 ] ( lwire ) [ h# 16 + ] * +
 [ d# 10 ] ( llast ) [ h# 20 + ] + nop /hdr wire hose ; }block

( 0021FC00 )               D# 127 shadow{ 
 ( this block creates and destroys umbilical wiring within the chip. )
 { br }

: using ( sets ) vport ( between given pair of nodes. )
: avail ( is idle pc val for given node. the initial mod is to support
 multichip ide. ) { br }

: +path ( steps ) pos ( to, ) neg ( away from target. ) { br }

: wires ( builds wire for path table ) [ a. ] ( entry zero is boot
 node. ) [ n ] ( is number of nodes away from boot in path; ) 0 ( no
 uut, ) 1 ( no wire, uut is meighbor, ) 2 ( neighbor is last guy, )
 3 [ n-2 ] ( wire nodes then last guy. generates call at end of last
 guy pgm that last guy sends target for focus. )
: rips ( rips out a wire built by ) wire
: foc ( sets ) [ 'foc ] ( to leave ripped wires focused on ide boot
 node; ) unfoc ( restores ) [ 'foc ] ( to default. ) }block

( 00220000 )               D# 128 code{ 
 ( - routing control )
: targets ( -a ) [ act ] @ align tbl [ 0tg , 1tg , 2tg , ]
: paths ( -a ) [ act ] @ align tbl [ here 0pa , 1pa , 2pa , ] { -cr }
: 'pths [ d# 0 + b-a ] ; { br }

: path ( i ) [ act ] ! paths dup @ swap [ d# 1 ] + @ wall port [ vport ]
 ! ;
: node ( n ) [ d# 3 ] for i [ d# -1 ] + path paths targets @ + @ over
 or drop while next drop ; then pop drop drop ; { br }

: -hook ( i ) path targets @ [ d# 1 ] or drop if paths targets @ rips
 [ d# 1 ] targets ! then ;
: hook ( i n ) swap -hook [ d# 2 ] begin over over paths + @ or drop
 while dup paths + @ [ d# 0 ] + drop -if drop drop ; then [ d# 1 ]
 + end then dup targets ! paths swap wires drop ; { br }

: ?adj pop [ d# 1 ] + dup 4@ swap [ d# 4 ] + targets @ d# 1 or drop
 if push drop ; then + push ; }block

( 00220400 )               D# 129 shadow{ 
 ( these functions support route setup and selection for internal wiring. )
 { br }

: targets ( table of target index variables. )
: paths ( table of route lists. ) { br }

: path ( selects active path ) [ i ] ( 0,1,2 )
: node ( selects path whose target is node ) [ n ] { br }

: -hook ( rips out any wiring on path ) [ i ]
: hook ( hooks up path ) [ i ] ( to node ) [ n ] ( ripping out any
 old wiring on that path. ) { br }

: ?adj ( executes following word and exits defn if selected path is
 to adjacent node, otherwise skips following word. ) }block

( 00220800 )               D# 130 code{ 
 ( - target anywhere )
: dor! align create [ h# 12005 , h# 0 , h# 0 , ]
: dor@ align create [ h# 12000 , h# 0 , ]
: dori align create [ h# 1200A , h# 0 , ]
: dorp align create [ h# 1200D , h# 0 , ]
: dorst align create [ h# 12010 , ]
: stak align create [ d# 40 rez ] { br }

: r@ ( a-n ) ?adj aa@ [ dor@ d# 1 + ] ! dor@ [ d# 2 ] fet [ d# 1 ]
 exch @18 ;
: r! ( na ) ?adj aa! [ dor! d# 1 + ] ! [ dor! d# 2 + ] ! dor! [ d# 3 ]
 ok [ d# 1 ] exch ;
: call ( a ) [ h# 10000 ] +
: rins ( w ) ?adj ains [ dori d# 1 + ] ! dori [ d# 2 ] ok [ d# 1 ]
 exch ;
: lit' ( n ) ?adj apsh [ dorp d# 1 + ] ! dorp [ d# 2 ] ok [ d# 1 ]
 exch ;
: aupd astk
: @stk @18 ( s ) [ stak d# 1 + ] ! @18 ( t ) [ stak ] ! [ stak d# 2
 + ] d# 8 for @18 over ! [ d# 1 ] + next drop ;
: upd ?adj aupd dorst [ d# 1 ] stat [ d# 10 ] exch @stk ;
: lit lit' upd ;
: boot ( a n nd ) nn-n swap push 2* d# 32768 + block over + swap begin
 over @ [ h# 15555 ] or over r! [ d# 1 ] + [ d# 1 ] u+ next drop drop
 ; }block

( 00220C00 )               D# 131 shadow{ 
 ( these operations work on any target node. ) { br }

: dorx ( port templates for remote target. ) { br }

: r@ r! rins lit call ( are the specific names for the primitives using
 appropriate sequences for adjacent or remote target nodes. ) { br }

: boot ( loads code into current remote node from binary image for
 node ) [ nd ] ( from addr ) [ a ] ( in both image and ram for ) [ n ]
 ( words. ) }block

( 00221000 )               D# 132 code{ 
 ( - remote instructions )
: compile recompile ; { -cr }
: canon [ d# 138 ] ;
: focus paths targets @ + dup @ swap d# -1 + @ wall port call ;
: virgin paths targets @ + @ avail call ; { br }

: rop ( n ) [ h# A ] or [ d# 13 ] for 2* next ( ;s ) [ h# 1555 ] +
 rins upd ;
: @b [ h# A ] rop ; { -cr }
: @a [ h# B ] rop ; { -cr }
: @+ [ h# 9 ] rop ;
: !b [ h# E ] rop ; { -cr }
: !a [ h# F ] rop ; { -cr }
: !+ [ h# D ] rop ;
: r+* [ h# 10 ] rop ;
: r2* [ h# 11 ] rop ; { -cr }
: r2/ [ h# 12 ] rop ;
: r- [ h# 13 ] rop ; { -cr }
: r+ [ h# 14 ] rop ;
: rand [ h# 15 ] rop ; { -cr }
: ror [ h# 16 ] rop ;
: rdrop [ h# 17 ] rop ; { -cr }
: rdup [ h# 18 ] rop ;
: rover [ h# 1A ] rop ;
: ra! [ h# 1F ] rop ; { -cr }
: ra@ [ h# 1B ] rop ;
: rb! [ h# 1E ] rop ; { br }

: up h# 145 ; { -cr }
: data h# 141 ; { -cr }
: down h# 115 ;
: left h# 175 ; { -cr }
: ldata h# 171 ; { -cr }
: right h# 1D5 ;
: io h# 15D ; }block

( 00221400 )               D# 133 shadow{ 
 ( single instruction words that may be executed by the target. these
 must end with return for s40 restriction compliance. ) { br }

 ( the following won't work on s40 due to bug 1. )
: r@p+ [ h# C ] rop ;
: psh ( n ) r@p+ ( value ) rins ; }block

( 00221800 )               D# 134 code{ 
 ( indicator panel ) [ d# 135 load ] ( node stack / upd ) { .s br }

 ( path, via, hops, tgt - green selected ) { .pth br }

 ( mem dump / ?ram or ?rom ) { .ram }
      }block

( 00221C00 )               D# 135 shadow{ 
 ( code for panel )
: panel [ d# 134 ] list ;
: .s blu silver cr cr [ stak d# 6 + ] d# 4 for dup @ d# 5 h.n space
 [ d# 1 ] + next [ d# -5 ] + cr d# 6 for dup @ d# 5 h.n space [ d# -1 ]
 + next drop ;
: ?color ( nn-nn ) over over or drop if silver ; then green ;
: .pth blu [ act ] @ cr d# 3 for cr i [ d# -1 ] + path [ act ] @ ?color
 . paths dup [ d# 1 ] + @ . targets @ dup . + @ . next path ; { br }

: /ram align create [ d# 64 a-b rez ]
: rsp ( n dup ) d# 1 and drop if sp/2 then ;
: .ram blu silver cr [ /ram ] d# 64 for i [ d# 7 ] and ?zero drop if
 cr space then i rsp dup @ d# 5 h.n i d# 1 and drop if space then [
 d# 1 ] + next drop ; }block

( 00222000 )               D# 136 code{ 
 ( - tester )
: ent d# 0 ;
: n6tst d# 0 d# 64 d# 6 boot ent call d# 0 r@ dup d# 123 + dup d# 0
 r! d# 0 r@ or if abort then drop d# 0 r! ( upd ) ;
: rot ( n-n ) [ h# 3FFFF ] and 2* [ h# 40000 ] /mod + ;
: sto ( n ) dup [ d# 63 ] for rot dup i r! -next drop { cr }
 [ d# 63 ] for rot i r@ over over or { indent }
      drop if i abort then drop -next drop ;
: pat ( n ) [ d# 18 ] for dup sto rot next drop ;
: ramtst d# 0 sto h# 3FFFF sto d# 1 pat h# 3FFFE pat ;
: one ( n ) [ d# 2 ] swap hook pause ( n6tst ) ramtst ;
: ?ok ( n-t ) [ 2pa @ nn-n ] or ;
: all ( n ) nn-n [ d# 1 ] + for i [ d# -1 ] + ?ok drop if i [ d# -1 ]
 + n-nn one then next ;
: !dac ( n i ) d# 2 swap hook h# 155 or io r! ;
: !dacs ( n ) dup d# 709 !dac dup d# 713 !dac dup d# 717 !dac dup d# 617
 !dac d# 117 !dac ;
: nn ( n-n ) d# -1 + dup !dacs ;
: ms d# 100000 * for next ;
: watch begin upd pause d# 1000 ms key? end ;
: ?ram d# 0 { -cr }
: suck ( a ) ra@ [ /ram ] d# 64 for over r@ over ! [ d# 1 ] + [ d# 1 ]
 u+ next drop drop ra! ;
: ?rom [ h# 80 ] suck ; }block

( 00222400 )               D# 137 shadow{ 
 ( this test routine tester loads and runs the code compiled for node
 6 on all other nodes except the root, stopping if a node crashes or,
 possibly, other failure criteria are met ) { br }

: one ( runs the test routine from node 6 compilation, entry point )
 ent ( , on node ) [ n ] ( . aborts if we cannot write and read back
 memory. ) [ select desired path at start. ]
: all ( tries the test starting with node n and going down to node
 zero, skipping node 19. ) { br }

: watch ( displays live stack from current node. this and other interactive
 functions can be enabled in a running program by placing a definition
 like this in outer loop... )
: poll @b h# 200 and if up b! @b push ;' h# 15D b! then drop ; { br }

: !dac ( sets given output value in node i )
: !dacs ( sets given value in all dacs. ) }block

( 00222800 )               D# 138 code{ 
 ( - canonical words )
: -canon remember
: @ ( a-n ) r@ ;
: ! ( na ) r! ; ( call lit upd rins boot !b already ok )
: +* r+* ;
: 2* r2* ;
: 2/ r2/ ;
: - r- ;
: + r+ ;
: and rand ;
: or ror ;
: drop rdrop ;
: dup rdup ;
: over rover ;
: a! ra! ;
: a ra@ ;
: b! rb! ; }block

( 00222C00 )               D# 139 shadow{ 
 ( the final step in loading the ide is to redefine the canonical forth
 words to operate on the target node. this is done as a separate step
 so that you may define any sort of exerciser before losing access
 to host colorforth words. ) }block

( 00223000 )               D# 140 code{ 
 ( - ide ats support )
: zxch ( w n f n ) push push dup { 5F } ( + { -31 } and ) [ vport ]
 @ pop /frame ( vport @ { 24001F } + !18 dup - { 3F } and drop if vport
 @ { 20001F } + !18 then ) +frame [ wos ] !frame pop inser -stream
 ; { br }

: dox align create ( @p call ) [ h# 56A9 , ] ( arg ) [ h# 0 , ]
: xchg ( cmd arg - result ) [ dox d# 1 + ] ! [ dox ] ! dox [ h# 2 ]
 fet [ d# 1 ] ( exch ) zxch @18 ; { br }

: pfocus paths targets @ + dup @ swap d# -1 + @ wall port dup call
 lit rb! ;
: vtest ( arg.ent-ans ) h# 5600 or swap xchg ;
: test ( arg-ans ) h# 4 vtest ;
: tfocus ( port ) h# 5636 swap [ h# 10000 ] + xchg drop ;
: creep h# 563A [ d# 67 ] xchg drop ;
: rip h# 5602 h# 20000 xchg drop ; { br }

: zfocus ( node ) paths targets @ + @ wall port { cr }
 h# 10000 or dup dup r! h# 5636 over r! dup dup r! { cr }
 lit' ra! ; }block

( 00223400 )               D# 141 shadow{ 
 ( this block interchanges ats commands with any node adjacent to the
 ide boot node. ) { br }

: pfocus ( must be used after booting package into an adjacent node
 and before using the following words. focuses that node properly on
 the boot node with both ) p ( and ) b ( - ) [ note! after pfocus regular
 ide functions may not be done against nodes in this path until ] rip
 [ has restored them to ] warm [ state. ] { br }

: tfocus ( performs ats focus function to select port thru which test
 and creep operate. use ide port names. )
: test ( executes test w/ ) [ arg ] ( giving positive ) [ ans. ]
: creep ( creeps into focused node, making it active and changing current
 active to wire. )
: rip ( tears out ats connection to active node returning it and all
 wire nodes to warm states. ) { cr }
: zfocus ( used by hand in ide to effectively tfocus the ide node under
 test on a given tgt node ) [ works whether or not r! preserves a ]
 }block

( 00223800 )               D# 142 code{ 
 ( - all-nodes tester )
: fwall ( -n ) paths targets @ + dup @ swap [ d# -1 ] + @ wall ;
: fport ( -a ) fwall port ;
: fbit ( -n ) fwall align tbl { cr }
 ( r ) [ h# 8000 , ] ( d ) [ h# 2000 , ] ( l ) [ h# 800 , ] ( u ) [
 h# 200 , ]
: nodes ( -n ) d# 0 begin [ d# 1 ] + { cr }
 dup paths + [ d# 1 ] + @ [ d# 0 ] + drop -until paths @ { cr }
 over paths + @ or drop if ; then [ d# -1 ] + ;
: !one ( i ) [ d# 2 ] path d# 2 swap paths + @ hook { cr }
 d# 0 d# 64 [ d# 1604 ] boot fbit d# 2 r! { CF } d# 14 call ;
: !all [ d# 2 ] path nodes { 50F } for pause i !one next ;
: ?one ( i-f ) [ d# 2 ] path d# 2 swap paths + @ hook pause { cr }
 h# 3E r@ { 3C201F } h# 8D00 or h# 3F r@ { 2FBF } h# 430E or +or drop
 if upd ?ram d# 0 dup or drop ; then d# 1 dup and drop ;
: ?all [ d# 2 ] path d# 0 nodes { 50F } for d# 1 + pause dup ?one while
 next drop ; then pop drop ;
: zz for i next ;
: z d# 1 ?one upd ; }block

( 00223C00 )               D# 143 shadow{ 
 ( manage running a test in all nodes )
: fwall ( returns rdlu for feeding node )
: fport ( returns port from feeding node. )
: fbit ( returns io mask bit for feed node write. )
: nodes ( returns number of nodes in current path. )
: !one ( programs and starts the node whose index is given in 1..nodes )
: !all ( programs all nodes in the current path. ) }block

( 00224000 )               D# 144 code{ 
 ( arrayforth tm and okad tools and designs ) { cr }
 ( copyright 2009-2012 greenarrays, inc. ) { cr }
 :# cuco 5 :# testb 0 :# dh 272 [ d# 0 dh ! ] { cr }
 :# first -1 [ d# -1 first ! ] :# orgn 206 [ d# 0 orgn ! ]
: compile [ d# 146 ] load ;
: recompile compile [ orgn ] @ load lis ;
: softsim { -cr }
: so [ d# 148 ] load ; { br }

: -nat winver drop if ; then exit ;
: tbl ( i-n ) pop 2/ 2/ + @ ;
: xqt ( a ) @ push ; { -cr }
: assign ( a ) pop swap ! ;
: ray ( i-a ) pop 2/ 2/ + ;
: aray ( n ) < align > call ray [ d# 4 ] * [ h ] +! ; { br }

 ( ascii file names ) [ d# 74 load ] { cr }
 ( png screen capture ) [ d# 168 load ] { cr }
 ( qx ) [ d# 80 load ] ( stack ) [ d# 94 load ]
: -tape [ d# 1 ] d# 1 and ; ( for redacted systems ) { br }

 ( chip design ) [ d# 190 d# 3 loads mark empty ] { cr }
 ( okad tools { 18CF } load { 708F } load ) }block

( 00224400 )               D# 145 shadow{ 
 ( main load block for okad2 applications )
: testb ( nonzero to enable testbeds. )
: dh ( holds drive handle we are responsible for. )
: first ( execution of hardsim or softsim. initializes variables in
 either. )
: recompile ( compiles f18 code then reloads tool that depends on it
 like ide from load block in ) orgn.
: compile ( compiles relevant f18 code. ) { br }

: -nat ( exits a block if running on native system )
: tbl ( self fetching cell array. usage... )
: squared ( i-n ) align tbl [ d# 0 , d# 1 , d# 4 , d# 9 , d# 16 , ]
: xqt ( calls the code whose adr is in the var given. )
: assign ( places addr of following code in the location given and
 exits current definition. ) { br }

: ray ( defines i-a array usage ) align ray
: aray ( use after red to make ray of n cells ) }block

( 00224800 )               D# 146 code{ 
 ( f18 compiler ) [ empty c ] { cr }
 [ d# 0 d# 0 laid nns fill d# 0 d# 0 kinds nns fill ] { br }

 [ d# 1400 load ] { br }

: reset ( a ) ?rst [ com ] @ resets ! ;
: kind ( n ) [ com ] @ kinds ! ;
: node ( nn ) nn-n nns mod dup [ com ] ! d# 0 -org { cr }
 node's d# 64 eras n-nn @rom load ;
: bin ( nn ) d# 0 memory swap nn-n [ com ] ! d# 0 memory d# 64 move
 ; { br }

: program [ nns d# -1 + ] for i [ com ] ! { cr }
 i idle reset i n-nn @rom load -next { cr }
 ( special rom's ) [ d# 1304 ] load { cr }
 -tape drop if [ d# 150 ] load then ; { br }

 [ d# 1402 d# 6 loads target d# 1380 load host ]
: h' ' ; { -cr }
: ' h' d# 6 + 4@ ;
: reclaim remember [ target program empty ] }block

( 00224C00 )               D# 147 shadow{ 
 ( compiles all relevant f18 code. ) { br }

: laid ( is cleared for setting as nodes laid out )
: resets ( is set to default multiport executes for all nodes and may
 be overridden in source code using ) reset
: kinds ( is set to default testbed none and may be overridden with )
 kind ( to 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers )
: node ( starts random compilation for node ) [ nn ] ( by compiling
 node ) [ nn's ] ( rom )
: bin ( saves the binary just generated in the bin for node ) [ nn, ]
 ( which must be outside chip { F } { F } . )
: program ( compile code for multicomputers. always compiles standard
 rom; if not tapeout, the load block at { A28F } defines test environment
 which may be in rom, ram, or both. )
: reclaim ( remembers and restores dictionary ) }block

( 00225000 )               D# 148 code{ 
 ( f18 software simulator ) [ empty compile ] { , }
 ( demo bootstream ) [ d# 1242 load empty ] { , }
 ( prelude ) [ d# 1250 load ] ( boot descriptors ) [ d# 1236 load ]
 { , }
 ( engine ) [ d# 1252 d# 8 loads ] ( opcodes ) [ d# 1268 d# 4 loads ]
 { , }
 ( boot loader ) [ d# 1238 load ] { , }
 ( display ) [ d# 1276 d# 6 loads d# 1248 load d# 1288 d# 2 loads ]
 { , }
 ( preserve variables ) :# nmem 8 :# n2mem 0
: nm2m [ nod2 ] @ !node [ n2mem ] @ mem ! { , ... }
      [ nod ] @ !node [ nmem ] @ mem ! ; :# big 100
: puka ( nn-a ) nn-n 2* h# 8000 + block ;
: code ( nn nn ) puka push puka pop d# 64 move ; { , }
 ( keyboard ) [ d# 1292 d# 2 loads ] { , }
 ( ports and pins ) [ d# 1296 d# 2 loads ] { , }
 ( interactive ) [ d# 1240 load ] { , , }
: /softsim d# 0 [ time ] ! power { , }
 [ first ] @ d# 1 + if drop nm2m ; then { F } [ first ] ! { , }
 d# 100 [ big ] ! d# 1 [ gap ] ! d# -1 [ wind? ] ! { , }
 [ d# 100 ] !node [ d# 0 ] mem ! [ d# 100 ] other { , }
 [ d# 0 ] !node [ d# 0 ] mem ! [ d# 0 ] node d# 0 [ xo ] ! d# 0 [ yo ]
 ! !vis ; { , , }
 ( init and testbeds ) [ d# 216 load ] { , }
 ( start ) [ /softsim ok h ] }block

( 00225400 )               D# 149 shadow{ 
 ( comment demo bootstream if you are going to be generating your own
 for simulation. ) }block

( 00225800 )               D# 150 code{ 
 ( test code for chip ) [ reclaim ] { br }

 ( ide parts ) [ d# 1372 d# 5 loads reclaim ] { cr }
 ( all nodes ) [ d# 1350 load reclaim ] { br }

 ( ats tests ) [ d# 480 load reclaim ] { br }

 ( polyforth ) [ d# 360 load reclaim ] { cr }
 ( eforth ) [ d# 1080 load reclaim ] { br }

 ( applic code ) [ d# 200 load ] { br }

 }block

( 00225C00 )               D# 151 shadow{ 
 ( this block defines what ) compile ( does. ) { cr }
 ( the system code loaded at the start is used by common development
 tools and should generally be left alone. it goes into bins 1600..2317
 as follow ) { br { C80F } }

 ( ide code code; spi r/w/boot ) { , { D48F } }
 ( polyforth ) { , { E10F } }
 ( ---; temp sram for eforth. ) { , { ED8F } }
 ( ats/ide; --- ) { , { FA0F } }
 ( creeper modules { 2F } full ) { , { 1068F } }
 ( creeper modules { 4F } full ) { , { 1130F } }
 ( creeper modules { 6F } half ) { , { 11F8F } }
 ( creeper modules { 8F } reserved ) { , , }
 ( note that special rom leaves residue in 008 and 106. ) }block

( 00226000 )               D# 152 code{ 
 ( redact okad disk ) [ audit load ] { br }

 ( to arm this block, make ) { cr }
 ( this word white... ) [ exit ] { br }

 ( okad ) [ d# 196 d# 1244 obliterate ] { br }

 ( type save to commit changes ) }block

( 00226400 )               D# 153 shadow{ 
 ( load this block to redact an okad disk for public release or extensive
 programming. ) { br }

 additional housekeeping... { cr }
 [ d# 144 ] ( comment loading of okad application. ) { cr }
 [ d# 18 ] ( uncomment loading of application tools. ) { cr }
 [ 196ff ] ( merge in released pd software. ) }block

( 00226800 )               D# 154 code{ 
 ( c-a-c - ascii for gds only! ) [ macro ]
: 1@ h# 8A 2, ; [ forth ]
: string pop ;
: cf-ii string [ H# 6F747200 , H# 696E6165 , H# 79636D73 , H# 7766676C
 , H# 62707664 , H# 71757868 , ] ( 336a7a6b ) [ H# 33323130 , H# 37363534
 , ] ( 2d313938 - 2d7a3938 ) [ H# 5F7A3938 , ] ( 2f322e30 ) [ H# 2F6A2E6B
 , ] ( 2b213a3b ) [ H# 24213A3B , H# 3F2C2A40 , ]
: ch h# -10 and unpack [ cf-ii ] + 1@ h# FF and ;
: ii-cf string [ h# 2A00 , ] ( 0 + ) [ h# 2B , H# 2B2D0000 , H# 2725232E
 , ] ( zjk 1b262224 ) [ H# 1B1A1918 , H# 1F1E1D1C , H# 28292120 , H# 2F000000
 , H# 3A43355C , H# 3D3E3440 , ] ( 02 484a3744 kj ) [ H# 54523744 ,
 H# 3336393C , H# 38314742 , H# 3F414632 , ] ( 1 493b45 z ) [ h# 563B45
 , ] ( - ) [ H# 23000000 , H# A13052C , H# D0E0410 , ] ( 02 181a0714
 kj ) [ H# 24220714 , h# 306090C , H# 8011712 , H# F111602 , ] ( 1
 190b15 z ) [ h# 260B15 , ]
: chc h# -20 + [ ii-cf ] + 1@ h# FF and ; }block

( 00226C00 )               D# 155 shadow{ 
 ( colorforth to/from ascii w/gds specifics ) { br }

: cf-ii ( otr inae ycms wfgl bpvd quxh ) { indent }
      ( 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? ) { indent }
      ( cba@ gfed 02ih onml srqp wvut ) { indent }
      ( 1yx cba@ gfed 02ih onml srqp wvut 1yx )
: notice [ j and z transposed in cf-ii; - converts to underscore, +
 to dollar. ] }block

( 00227000 )               D# 156 code{ 
 ( big letters ) [ macro ]
: *byte h# C80F 2, ; [ forth ]
: clr [ aper d# 2 + ] ; :# sz 14 :# cur 5579776 [ d# 14 sz ! ]
: ptab ( xy ) d# 1024 * + [ aper @ d# 4 / ] + [ cur ] ! ;
: center ( n ) [ sz ] @ d# -24 * d# 768 + 2/ ptab ;
: table d# 12 * [ d# 12 block ] + ;
: 1line ( a ) [ sz ] @ for [ clr ] @ over ! d# 1 + next drop ;
: pix ( a ) [ sz ] @ for dup 1line d# 1024 + next drop ;
: row ( an-an ) d# 16 for dup and -if over pix then [ sz ] @ u+ 2*
 next d# 1024 [ sz ] @ * [ sz ] @ d# -16 * + u+ ;
: !emit table [ cur ] @ d# 12 for over @ *byte row row drop d# 1 u+
 next drop drop [ sz ] @ d# 18 * [ cur ] +! ;
: !digit d# 24 + !emit ;
: 2. ( nn ) /mod !digit !digit ;
: 4. ( n ) d# 100 /mod d# 10 2. d# 10 2. ; }block

( 00227400 )               D# 157 shadow{ 
 }block

( 00227800 )               D# 158 code{ 
 ( big clock ) [ empty d# 40 load d# 156 load ]
: hm sec d# 60 /
: sex ( n ) d# 60 /mod d# 100 mod d# 10 2. d# 10 2. ; :# t0 32458
: ?beep if ; then beep ;
: till [ t0 ] @ sec negate + green -if negate red then ?beep sex ;
: set ( n ) d# 60 * sec + [ t0 ] !
: ok show black screen blue d# 0 center hm ( till ) ;
: run dup pause drop key? run ; [ ok run ] }block

( 00227C00 )               D# 159 shadow{ 
 }block

( 00228000 )               D# 160 code{ 
 ( compare ) [ empty d# 30 load ]
: n18 ( i-a ) [ abuf d# 18 + block ] + ;
: unpk abs [ d# 1 n18 ] ! [ abuf d# 36 + ] block [ cbuf ] block [ d# 1404 ]
 blks move [ cbuf block ] abuf d# 36 + [ d# 3 n18 ] @ [ d# -36 ] +
 range ;
: check [ abuf ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or drop if
 ; then [ d# 1 n18 ] @ dup and -if unpk ; then drop ;
: blink dup [ abuf ] + [ blk ] ! edit ;
: var push push d# 1 + d# 1 u+ pop pop
: *1 or ;
: *2 var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# F and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1 *1 *1
 var *1 *1 *1
: co ( naa-n ) d# 256 for over @ over @ tag drop if drop drop pop drop
 pop drop dup d# 2 u+ ( i ) pop swap blink ; then d# 1 + d# 1 u+ next
 drop drop ;
: com ( n ) dup block over [ abuf ] + block co ;
: q ( nn ) for com d# 2 + next drop ;
: all d# 18 [ d# 1439 d# -18 + 2/ ] q ;
: old [ blk ] @ [ abuf ] mod dup [ abuf ] + [ blk ] ! copy ; }block

( 00228400 )               D# 161 shadow{ 
: check ( reads backup to { 1770F } and decompresses if appropriate )
: blink ( displays the given block with its other set as the editor's
 'other' block )
: var ( compares a variable name, advancing pointers to skip its value. )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compare compares the two source cells given, returning true
 if they differ. ignores variable differences. )
: ?nul ( ends the loop in co when nuls are found in both blocks. )
: co ( given the addresses of the two blocks does the work of com. )
: com ( invokes editor to blink the given block if it differs from
 the other, leaving stack set to continue the scan by typing q. otherwise
 returns. )
: all ( scans the whole usable area of the disk. )
: q ( scans for differences given starting block and number of source
 blocks skipping shadows. )
: note! ( return stk probably grows! ) }block

( 00228800 )               D# 162 code{ 
 }block

( 00228C00 )               D# 163 shadow{ 
 }block

( 00229000 )               D# 164 code{ 
 }block

( 00229400 )               D# 165 shadow{ 
 }block

( 00229800 )               D# 166 code{ 
 }block

( 00229C00 )               D# 167 shadow{ 
 }block

( 0022A000 )               D# 168 code{ 
 ( png empty ) [ -nat ] :# w 1024 :# hh 768 :# d 1
: frame { 3A0001F } [ aper @ d# 4 / ] ; [ d# 172 load d# 174 load ]
: -crc ( a ) here over negate + crc .. ;
: here/4 ( -a ) here d# 3 and drop if d# 0 1, here/4 ; then here d# 2
 2/s ;
: bys ( nn-b ) .. here swap , ; { cr }
 ( pallettes ) [ d# 170 load ] { br }

: !png ( awh-an ) [ d ] @ / [ hh ] ! [ d ] @ / [ w ] ! here/4 swap
 H# 474E5089 , H# A1A0A0D , ( ihdr ) H# 52444849 d# 13 bys [ w ] @
 .. [ hh ] @ .. h# 304 , h# 0 1, -crc ( plte ) pallette ( idat ) H# 54414449
 d# 0 bys swap deflate -crc ( iend ) H# 444E4549 d# 0 bys -crc here/4
 over negate + ; { br }

: 'at ( xy-a ) d# 1024 * + [ frame ] + ;
: full d# 1 [ d ] ! d# 0 dup 'at d# 1024 d# 768 !png ;
: png full wgds ; }block

( 0022A400 )               D# 169 shadow{ 
: d ( is reduction factor ) }block

( 0022A800 )               D# 170 code{ 
 ( - pallettes )
: paper H# 45544C50 d# 48 bys { cr }
 h# FFFFFF 3, h# C00000 3, h# C000 3, h# C0C000 3, { cr }
 h# C0 3, h# C000C0 3, h# C0C0 3, h# 404040 3, { cr }
 h# C0C0C0 3, h# FF0000 3, h# FF00 3, h# FFFF00 3, { cr }
 h# FF 3, h# FF00FF 3, h# FFFF 3, h# 0 3, -crc ; { br }

: crt H# 45544C50 d# 48 bys { cr }
 h# 0 3, h# C00000 3, h# C000 3, h# C0C000 3, { cr }
 h# C0 3, h# C000C0 3, h# C0C0 3, h# 404040 3, { cr }
 h# C0C0C0 3, h# FF0000 3, h# FF00 3, h# FFFF00 3, { cr }
 h# FF 3, h# FF00FF 3, h# FFFF 3, h# FFFFFF 3, -crc ; { br }

: pallette ( paper ) crt ; }block

( 0022AC00 )               D# 171 shadow{ 
 }block

( 0022B000 )               D# 172 code{ 
 ( - crc ) :# ad1 27816 :# ad2 21146 [ macro ] { br }

: 2/s ?lit h# E8C1 2, 1, ; { -cr }
: 1@ h# 8A 2, ; [ forth ]
: bit ( n-n ) d# 1 ? if d# 1 2/s H# -12477CE0 or ; { indent }
      then d# 1 2/s ;
: ,crc ( nn ) for dup d# 8 for bit next , { indent }
      d# 1 + next drop ;
: table ( -a ) align array [ d# 0 d# 256 ,crc ]
: crc ( bn-n ) d# -1 swap for over 1@ over or h# FF and table swap
 d# 8 2/s or d# 1 u+ next - nip ; { br }

: +adl ( n ) h# FF and [ ad1 ] @ + dup [ ad2 ] @ +
: adl! [ ad2 ] ! [ ad1 ] ! ;
: +mod [ ad1 ] @ d# 65521 mod [ ad2 ] @ d# 65521 mod adl! ; }block

( 0022B400 )               D# 173 shadow{ 
: 2/s ( shift right by literal )
: 1@ ( fetch byte, address in eax )
: array ( return word address in dictionary )
: bit ( process 1 bit with standard 32-bit crc )
: fill ( construct crc table for bytes )
: table ( said table )
: crc ( compute crc for a byte string )
: ad1/ad2 ( adler checksums )
: +adl ( add a byte to both checksums )
: adl! ( store checksums )
: +mod ( truncate checksums ) }block

( 0022B800 )               D# 174 code{ 
 ( - lz77 ) [ macro ] { -cr }
: *byte h# C486 2, ;
: !bx < a! > h# 289 2, < drop > ; [ forth ] { br }

: *bys dup d# 16 2/s *byte swap h# FFFF and *byte h# 10000 * + ; { -cr }
: .. *bys , ;
: 0/1 h# 80 ? if h# 7E and h# 7E or drop if d# 7 ; then h# F ; then
 d# 0 and ;
: 4b dup 0/1 h# 9 and over d# 8 2/s 0/1 h# A and +or swap d# 16 2/s
 0/1 h# C and +or ;
: pix dup @ [ d ] @ u+ 4b ;
: row 1, dup [ w ] @ 2/ dup d# 1 + dup 2, - 2, d# 0 dup 1, +adl for
 pix d# 16 * push pix pop or dup 1, +adl next drop +mod [ d ] @ d# 1024
 * + ; { br }

: deflate h# 178 2, d# 1 d# 0 adl! [ hh ] @ d# -1 + for d# 0 row next
 d# 1 row drop [ ad2 ] @ *byte 2, [ ad1 ] @ *byte 2, here over d# 4
 + negate + *bys over d# -4 + !bx ; }block

( 0022BC00 )               D# 175 shadow{ 
: 0/1 ( 0, f or 7 for dark, bright or dim ) }block

( 0022C000 )               D# 176 code{ 
 ( cf-html ) [ empty -nat ] { cr }
 :# pad 278806528 [ abuf block d# 4 * pad ! ] { cr }
 :# hld 280317057 [ pad @ hld ! d# 178 d# 6 loads ]
: estyle ,link ,t1cr ( cfhtml.css '? ) ;
: .hdr [ pad ] @ [ hld ] ! ,t1cr ( @html? @head? ) istyle { cr }
 ( estyle ) ,t1cr ( @/head? @body? @table? ) ;
: .blk ( n ) d# 0 [ pos ] ! crlf ,t1 ( @td*class+cf? ) { cr }
 dup even? if dup .dec ,t1cr ( *list ) then { cr }
 .cr block ,t1 ( @code ) d# 0 [ class ] ! d# 0 [ --cr ] ! { cr }
 begin @+ dup and while .token end then { cr }
 [ class ] @ eq? if ,t1 ( ? ) then drop drop { cr }
 begin -eol? while .nb end then .cr { cr }
 ,t1 ( @/code? ) .cr ,t1cr ( @/td? ) ;
: .sep ,t1 ( @td? ) .nb .nb ,t1 ( @/td? ) ;
: .blks ( first last+2 ) over negate + 2/ for { cr }
 ,t1 ( @tr? ) dup d# 1 or .blk .sep dup .blk { cr }
 ,t1cr ( @/tr? ) [ d# 2 ] + next drop ;
: .tlr ,t1cr ( @/table? @/body? @/html? ) sav ;
: run ( first last+2 ) .hdr .blks .tlr ; { br }

 [ named ] ( cf.html ) [ exit d# 18 d# 1440 run ] }block

( 0022C400 )               D# 177 shadow{ 
 ( colorforth to html utility ) { br }

 ( the html is created between ) [ pad ] ( and ) [ hld ] { cr }
 ( by ) .html ( and its factors ) .hdr .blks ( and ) .tlr ( , then
 written to the file last ) [ named ] ( . ) { br }

 ( uncomment ) estyle ( in ) .hdr ( to use an external ) { cr }
 ( stylesheet, maybe for printing. ) { br }

 ( pairs of blocks are formatted 2-up using html tables, with the odd/even
 blocks used to invoke ) [ .html ] ( or ) [ .blks ] ( displayed on
 the right. 'n list' is shown above the even block. ) { br }

 [ d# 176 d# 188 .html ] ( puts shadows on left, while ) { cr }
 [ d# 177 d# 189 .html ] ( puts them on the right. ) { br }

 [ seeb ] ( toggles blue-word visibility. ) { br }

 ( the last line of each block is filled ) { cr }
 ( with ) nbsp ( for column alignment. the ) [ class ] @ { cr }
 ( line closes the ) < code > ( tag of an empty block. ) }block

( 0022C800 )               D# 178 code{ 
 ( - generate html details ) { cr }
: eq? ( nn-n ) over or if drop d# -1 then - ( nz? ; )
: nz? ( n ) dup and drop ;
: even? ( n ) h# 1 or h# 1 and drop ; { br }

: @+ ( a-an ) dup d# 1 + swap @ ;
: @tag ( a-at ) dup @ h# F and ; { br }

: sc h# 3B ( semicolon )
: ch, ( c ) [ hld ] @ 1! d# 1 [ hld ] +! ;
: lb h# 7B ( left-brace ) ch, ;
: rb sc h# 7D ( right-brace ) ch,
: crlf d# 13 ch, d# 10 ch, ; { br }

: ,token ( n ) ch if ch, ,token ; then drop drop ;
: ,word ( a-a ) begin @+ ,token @tag drop until ; { cr }
 ( loop ) begin ,word
: ,comments ( a ) @tag d# 9 or drop until drop ; [ macro ] { cr }
: ,t ( words ) 7push pop < ,lit > call ,comments nop ;
: ,trb ( words ) < ,t > call rb nop ;
: ,t1 ( words ) call set1 < ,t > call set0 nop ;
: ,t1cr ( words ) < ,t1 > call crlf nop [ forth ] }block

( 0022CC00 )               D# 179 shadow{ 
: eq? { -cr }
: nz? { -cr }
: diff? { -cr }
: even? ( leave only flags ) { cr }
: @+ { -cr }
: @tag ( are common factors ) { br }

 ( the following words generate ascii text only for html tags and source
 formatting; it will not be visible in the html display. ) { br }

: sc { -cr }
: ch, { -cr }
: lb { -cr }
: rb { -cr }
: crlf ( punctuation output ) { br }

 ( the macros enable in-line output from the ) { cr }
 ( standard cf-ascii table using ) [ set0 ] ( default or the extended
 table using ) [ set1 ] { br }

: ,token ( output ascii characters for one token )
: ,word ( output a token and any extension tokens )
: ,comments ( output contiguous comment words ) { br }

: ,t ( output from current set, don't change set. )
: ,trb ,t ( output followed by ) rb
: ,t1 ( output from ) set1 ( , return to ) set0 ( at end )
: ,t1cr ,t1 ( output followed by ) crlf }block

( 0022D000 )               D# 180 code{ 
 ( - translate text and numbers ) :# pos 0 :# --bs 1
: -bol? [ pos ] @ nz? ; { * }
: -eol? [ pos ] @ d# 46 or drop ;
: .cr ,t1 ( @br? ) d# 0 [ pos ] ! ; { , }
 ( loop ) begin .cr { * }
: emit ( c ) ch, d# 1 [ pos ] +! ;
: .ch ( c ) -eol? until emit ;
: .sp -eol? if -bol? if h# 20 emit ; then then ;
: .2sp .sp { * }
: .nb h# 26 ( ampersand ) .ch ,t ( nbsp ) sc ;
: ?sp [ --bs ] @ nz? if .sp then d# 1 [ --bs ] ! ;
: -sp d# 0 [ --bs ] ! ;
: .sp.tn ( n ) ?sp ( .tn ; )
: .tn ( n ) ch if .ch .tn ; then drop drop ;
: ?ch ( n ) ?seeb if .ch ; then drop .nb ;
: ?sp.tn ( n ) ?sp ( ?tn ; )
: ?tn ( n ) ch if ?ch ?tn ; then drop drop ;
: .hd ( n ) [ d# -10 ] + -if [ h# 3A ] + .ch ; then [ h# 41 ] + .ch
 ;
: .dec ( n .sp ) ?sp [ d# 0 ] + -if h# 2D .ch negate then [ d# -1 ]
 swap begin [ d# 10 ] /mod dup and while end then drop
: spit ( -1 ... ) begin .hd [ d# 0 ] + -until drop ;
: hd ( n-nn ) dup [ h# F ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n .sp ) ?sp [ d# -1 ] swap begin hd H# FFFFFFF and { , }
 while end then drop spit ;
: .ad/s ( n ) d# 1024 /mod swap hd hd hd drop ?sp { , }
 dup and if dup .hd then drop .hd .hd { , }
 [ d# 0 ] + if [ d# 47 ] .ch dup .hd then drop ; }block

( 0022D400 )               D# 181 shadow{ 
 :# pos 0 ( character display ) [ pos ] ( ition in line )
: -bol? { -cr }
: -eol? ( test position )
: .cr ( visible crlf )
: emit ( visible character )
: .ch { -cr }
: .sp { -cr }
: .2sp { -cr }
: .nb ( quirky characteristics ) { cr }
 < note > [ .sp ] ( does nothing at left margin ) { cr }
 < note > [ .ch ] ( does ) [ .cr ] ( after 46th character ) { cr }
 < note > [ .2sp ] ( takes only one space at left margin ) { cr }
 < note > [ .nb ] ( takes only one character position. ) { br }

: .tn { -cr }
: .sp.tn ( display a token. ) { br }

: .hd { -cr }
: hd { -cr }
: spit ( are number-output factors )
: .dec { -cr }
: .hex { -cr }
: .ad/s ( display numbers ) }block

( 0022D800 )               D# 182 code{ 
 ( - translate cf token details ) { cr }
 :# class 757071881 :# --cr 0
: ,class ( a ) @ [ class ] @ over or drop ( diff? ) if { cr }
 [ class ] @ nz? if ,t1 ( @/code? @code ) then { cr }
 ,t1 ( *class+ ) dup [ class ] ! ,token ,t1 ( ? ) ; { cr }
 then drop ; [ macro ]
: ,c 7push pop < ,lit > call ,class nop ; [ forth ]
: .quirks ( n ) [ --bs ] @ d# -1 + nz? if d# 1 [ --bs ] ! drop ; { ,
 ... }
      then [ --cr ] @ nz? if .2sp drop d# 0 [ --cr ] ! ; { , ... }
      then ( class ) nz? if -bol? if .cr then then ;
: .space -eol? if .nb then ;
: .indent .cr { 8F } d# 2 for .nb next ;
: .blue ( n ) ?seeb if dup .sp.tn then { , }
 H# -6F7FFFF2 ( cr ) eq? if .cr drop ; { , }
 then H# -18DEFFF2 ( -cr ) eq? if d# 1 [ --cr ] ! drop ; { , }
 then H# -79DA6DF2 ( space ) eq? if .space drop ; { , }
 then H# 76C08C4E ( indent ) eq? if .indent drop ; { , }
 then H# -39DFFFF2 ( br ) eq? if .cr .cr then drop ;
: ?simple ( n-n ) { , ... }
      h# -3FFFFF2 eq? if ?tn .cr pop drop ; then { , ... }
      H# -5FFFFF2 eq? if ?tn -sp pop drop ; then { , ... }
      H# -15FFFFF2 eq? if ?sp.tn -sp pop drop ; then { ... }
      H# -142BFFF2 eq? if ?sp.tn -sp pop drop ; then { ... }
      H# -142857F2 eq? if ?sp.tn -sp pop drop ; then ; }block

( 0022DC00 )               D# 183 shadow{ 
 :# class 0 ( current class ) { cr }
 :# --cr 0 ( true suppresses ) [ cr ] ( before next red word ) { cr }
: ,class { -cr }
: ,c ( class defining words, cf style ) { br }

: .quirks ( handle the spacing before red words ) { br }

: .space ( blue spaces are ignored at eol! )
: .indent { 8F } ( + html leading space ) { br }

: .blue ( generate most of the blue-word effects ) }block

( 0022E000 )               D# 184 code{ 
 ( - translate cf tokens )
: sh? ( n-n ) 2/ 2/ 2/ 2/ dup 2/ swap d# 1 and drop ;
: lh? ( an-an ) push @+ pop h# 10 and drop ; { br }

: .t1 ( n ) ,c ( t1 ) .sp.tn ;
: .t2 ( an-a ) lh? if ,c ( h2 ) .hex ; then ,c ( d2 ) .dec ;
: .t3 ( n ) [ class ] @ ,c ( t3 ) .quirks ( .sp.tn ) .tn ;
: .t4 ( n ) ,c ( t4 ) .sp.tn ;
: .t5 ( an-a ) lh? if ,c ( h5 ) .hex ; then ,c ( d5 ) .dec ;
: .t6 ( n ) sh? if ,c ( h6 ) .hex ; then ,c ( d6 ) .dec ;
: .t7 ( n ) ,c ( t7 ) .sp.tn ;
: .t8 ( n ) sh? if ,c ( h8 ) .hex ; then ,c ( d8 ) .dec ;
: .t9 ( n ) ,c ( t9 ) .sp.tn ;
: .ta ( n ) ,c ( ta ) .sp.tn ;
: .tb ( n ) ,c ( tb ) .sp.tn ;
: .tc ( an-a ) ,c ( tc ) .sp.tn ,c ( dc ) @+ .dec ;
: .td ( n ) sh? ,c ( hd ) .ad/s ;
: .te ( n ) ,c ( te ) ?simple .blue ;
: .tf ( n ) sh? if ,c ( hf ) .hex ; then ,c ( df ) .dec ; { br }

: .token ( an-a ) dup h# F and jump { cr }
 .tn .t1 .t2 .t3 .t4 .t5 .t6 .t7 { cr }
 .t8 .t9 .ta .tb .tc .td .te .tf }block

( 0022E400 )               D# 185 shadow{ 
: sh? ( extract short number, true flag if hex )
: lh? ( extract long number, true flag if hex ) { br }

 ( tag ------- cf class ------- html class ) { cr }
 < .t0 > ( extension token ........ ) < same as last >
: .t1 ( execute word ........... ) [ t1 ]
: .t2 ( execute long number .... ) [ h2, d2 ]
: .t3 ( define word ........... ) { -cr }
: t3
: .t4 ( compile word ........... ) t4
: .t5 ( compile long number .... ) h5, d5
: .t6 ( compile short number ... ) h6, d6
: .t7 ( compile macro .......... ) < t7 >
: .t8 ( execute short number ... ) [ h8, d8 ]
: .t9 ( lowercase text comment . t9 )
: .ta ( capitalized text comment ta ) < deprecated >
: .tb ( uppercase text comment . tb ) < deprecated >
: .tc ( variable ............... ) :# tc 0 dc
: .td ( target address ......... hd )
: .te ( editor command ......... ) < te >
: .tf ( short number comment ... hf, df ) { br }

: .token ( translate tag-by-tag ) { indent }
      < note > ( address may be incremented ) }block

( 0022E800 )               D# 186 code{ 
 ( - stylesheet details and file output )
: vat ,t ( *vertical-align; top ) sc ;
: bcw crlf ,t ( *background-color; white ) sc ;
: wsn crlf ,t ( *white-space; nowrap ) sc ;
: fo ,t ( *font- ) ;
: ffm crlf fo { indent }
      ,t ( family; lucida*console,monospace ) sc ;
: fwb crlf fo ,t ( weight; bold ) sc ;
: fz fo ,t ( size; ) ;
: fc lb ,t ( *color; ) h# 23 ( sharp ) ch, ;
: fsi sc fo ,t ( style; italic ) rb ;
: tt sc ,t ( *text-transform; ) ; { br }

: ,link ,t1 ( @link *rel+stylesheet ) { indent }
      ,t1 ( *type+'text/css' *href+' ) ; { br }

: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 2 d# 0 d# 0 { indent }
      pop pop swap fcreate ;
: sav [ d# 0 fnam ] w/o fopen dup push { indent }
      [ pad ] @ dup negate [ hld ] @ + pop { indent }
      fwr drop fclose ; }block

( 0022EC00 )               D# 187 shadow{ 
: vat { -cr }
: bcw { -cr }
: wsn { -cr }
: fo { -cr }
: ffm { -cr }
: fwb { -cr }
: fz { -cr }
: fc { -cr }
: fsi { -cr }
: tt { cr }
 ( space-saving factors of internal stylesheet ) { br }

: ,link ( most of the external stylesheet link ) { br }

: fopen { -cr }
: sav ( open, write, close html file ) { cr }
 < note > ( byte addresses throughout ) }block

( 0022F000 )               D# 188 code{ 
 ( - internal stylesheet )
: istyle ,t1cr ( @style*type+'text/css'? ) set1 { cr }
 ,t ( td ) lb vat bcw wsn ffm fwb fz ,trb ( x-large ) ,t ( code ) lb
 fz ,t ( large ) tt ,trb ( lowercase ) { cr }
 ,t ( .t1 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .h2 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d2 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t3 ) fc ,trb ( ff0000 ) { cr }
 ,t ( .t4 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h5 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d5 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h6 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d6 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .t7 ) fc ,trb ( 00cccc ) { cr }
 ,t ( .h8 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d8 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t9 ) fc ,trb ( 444444 ) { cr }
 ,t ( .ta ) fc ,t ( 000000 ) tt ,trb ( capitalize ) { cr }
 ,t ( .tb ) fc ,t ( 000000 ) tt ,trb ( uppercase ) { cr }
 ,t ( .tc ) fc ,trb ( ff00ff ) { cr }
 ,t ( .dc ) fc ,trb ( 00ff00 ) { cr }
 ,t ( .hd ) fc ,t ( bbbbbb ) fsi { cr }
 ,t ( .te ) fc ,trb ( 0000ff ) { cr }
 ,t ( .hf ) fc ,t ( 777777 ) fsi { cr }
 ,t ( .df ) fc ,trb ( 444444 ) ,t1cr ( @/style? ) ; }block

( 0022F400 )               D# 189 shadow{ 
: istyle ( internal styles are aimed toward ) { cr }
 ( providing code examples for stand-alone use in other documents.
 although it's black-on-white, it faithfully displays the colorforth
 screen. ) { br }

 ( some cf-html rendering tests ) { br }

 [ load D# 2147483647 H# -80000000 ]
: t1 ; D# 2147483646 H# -7FFFFFFF d# 87 h# 57 < ?lit > [ d# 87 h# 57 ]
 ( rtoeani rtos ascii ) :# var 123 { cr -cr }
: quirky ^ 05 ^ { indent { AEF } { AFF } }
      [ d# -87 ] ( end ) [ h# 0 ] h# 0 { 1F } }block

( 0022F800 )               D# 190 code{ 
 ( ga144 chrt .18 design specific )
: gdsnos [ d# 440 ] ;
: nnx { 10F } [ d# 18 ] ; { -cr }
: nny { 8F } [ d# 8 ] ; { -cr }
: nns [ nnx nny * ] ;
: nnc ( nns ) [ nns d# 2 * d# 144 + ] ;
: nn-n ( n-n { 14F } ) [ d# 100 ] /mod [ nnx ] * + ;
: n-nn ( n-n ) [ nnx ] /mod { 14F } [ d# 100 ] * + ; { br }

: gapl [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 20 d# 2 * + ] ;
: gapr [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 24 d# 2 * + ] ;
: gapb [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 28 d# 2 * + ] ;
: gapt [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [
 d# 18 d# 2 * + ] ;
: ray0 ( -xy ) gapl [ d# 199 ] + gapb [ d# 199 ] + ;
: rayn ( -xy ) nnx [ d# 350 ] * nny [ d# 759 ] * d# -1 + ray0 v+ ;
 { br }

: gx [ rayn drop gapr + d# 199 + ] ;
: gy [ rayn nip gapt + d# 199 + ] ; { br }

: origin { 148F } { B2F } d# 26 d# 26 ;
: cx [ origin drop d# 2 * gx + d# 2 + ] ;
: cy [ origin nip d# 2 * gy + d# 2 + ] ;
: -cx [ cx negate ] ; { -cr }
: cx*y [ cx cy * ] ; { br }

: gfx [ d# 8 ] ; { -cr }
: gfy [ d# 16 ] ; }block

( 0022FC00 )               D# 191 shadow{ 
: gdsnos ( block for gds layer numbers )
: nnx ( and nny number of nodes/row and /column )
: nnc ( number of nodes compiled )
: nn-n ( and ) n-nn ( convert yx notation to and from linear node numbers )
: gapl, r, b, t ( distance in tiles between inner edge of padring bus
 and outer edge of core pwr )
: ray0 ( and ) rayn ( are gxy relative phys origin and upper right
 corner of node array. source of constants is ) [ xtab ] ( and ) [ ytab. ]
: gx ( and ) gy ( bounds of pad ring. ) [ always remember to check ]
 global [ reset wiring when size or placement of node array or pad
 ring are changed! ]
: cx ( and ) cy ( bounds of seal ring. )
: -cx ( negative tiles/row )
: origin ( origin of 'die' i.e. pad ring within seal ring. c coords
 rel to seal; g rel to 'die' )
: gfx ( and ) gfy ( fill cell grid ) }block

( 00230000 )               D# 192 code{ 
 ( ga144 pads, ports and resets ) { br }

: port ( i-pa ) align tbl [ h# 1D5 , h# 115 , h# 175 , h# 145 , h# 195
 , h# 185 , h# 1B5 , h# 1A5 , ]
: idle ( n-p ) [ nnx ] /mod [ nny d# -1 + ] mod [ d# 1 ] min [ d# 4 ]
 + swap [ nnx d# -1 + ] mod [ d# 1 ] min 2* + port ;
: rstadr align tbl [ h# AA , h# 195 , h# 185 , h# 1B5 , h# 1A5 , ]
: rstdef strings ( p0aa p13f p12f p11f p10f )
: ?rst ( pa-i ) [ d# 4 ] for dup i rstadr or while drop -next abort
 then drop drop pop ; }block

( 00230400 )               D# 193 shadow{ 
: port ( returns port for 0-3 rdlu then edges )
: idle ( is idle p value for given node. )
: rstadr ( and ) rstdef ( number values and white names of p straps
 rom, corn, side, top/bot, mid. )
: ?rst ( returns index of valid reset or aborts. ) }block

( 00230800 )               D# 194 code{ 
 ( ga144 node types ) { br }

: laid [ nns aray ] { -cr }
: resets [ nns aray ]
: kinds [ nns aray ] { br }

: 0's ( n ) for d# 0 , next ;
: +roms ( -ia ) align ray [ nns 0's ]
: iz ( nn i ) swap nn-n +roms ! ; { cr }
 [ d# 701 d# 2 iz d# 705 d# 10 iz d# 708 d# 6 iz ] { indent }
      [ d# 709 d# 14 iz d# 713 d# 14 iz d# 717 d# 14 iz ] { cr }
 [ d# 117 d# 14 iz d# 617 d# 14 iz ] { cr }
 [ d# 1 d# 2 iz d# 200 d# 18 iz d# 300 d# 4 iz ] { cr }
 ( eforth ) [ d# 105 d# 20 iz d# 106 d# 20 iz ] ( sdram... ) { cr }
 [ d# 7 d# 20 iz d# 8 d# 20 iz d# 9 d# 20 iz d# 107 d# 20 iz d# 108
 d# 20 iz ]
: @rom ( nn-n ) nn-n +roms @ [ d# 22 ] less if drop [ d# 1418 ] + ;
 then drop [ d# 100 ] mod [ d# 1301 ] + ; { br }

: bedtab ( -serbed ) [ cuco ] @ nn-n kinds @ ;
: ?serbed [ testb ] @ d# 0 or drop if bedtab ; then d# 0 ; }block

( 00230C00 )               D# 195 shadow{ 
: laid ( nz if node laid out )
: resets ( index of reset address )
: kinds ( kind for testbeds )
: +roms ( and ) @rom ( are here only as temporary kludges. we will
 eventually load a table from the node defns for default kind and prom
 source. )
: +roms ( array indexed by linear node number returning code number
 for rom load block. )
: iz ( sets node ) [ nn ] ( to use rom load block ) [ n ] ( codes-
 0-arith 2-serdes 4-syncboot 6-async 10-spi 14-analog 18-1wire )
: @rom ( returns block number for production rom code applicable to
 the given node. )
: ?serbed ( 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers
 for ) [ cuco ] ( if ) [ testb ] ( nz. ) }block

( 00231000 )               D# 196 code{ 
 }block

( 00231400 )               D# 197 shadow{ 
 }block

( 00231800 )               D# 198 code{ 
 }block

( 00231C00 )               D# 199 shadow{ 
 }block

( 00232000 )               D# 200 code{ 
 ( user f18 code ) [ reclaim ] { br }

 ( softsim example ) [ reclaim d# 0 node d# 1342 load ] { cr }
 ( practical example pwm code ) [ reclaim d# 842 load ] { cr }
 ( initial test pwm code ) [ reclaim d# 852 d# 3 loads ] { cr }
 ( initial potentiometer ) [ reclaim d# 858 load ] { cr }
 ( initial wire code ) [ reclaim d# 860 load ] { cr }
 ( initial scaler ) [ reclaim d# 862 load ] { cr }
 ( averaging code ) [ reclaim d# 864 load ] }block

( 00232400 )               D# 201 shadow{ 
 ( use this load block to compile your code ) { cr }
 ( for the f18 computers. ) { br }

 ( as delivered, sample code loaded here is pro- vided to facilitate
 working with examples ) { cr }
 ( presented in the user's guide. it may be ) { cr }
 ( deleted if you no longer have use for it. ) }block

( 00232800 )               D# 202 code{ 
 ( ga application tools )
: a-com [ d# 3 ] ; { * }
: a-bps d# 921600 ;
: c-com [ d# 10 ] ; { * }
: c-bps d# 921600 ;
: host d# 206 ; { * }
: target d# 208 ; { , }
 ( modules ) { * }
: sram [ d# 264 ] ; { , }
 ( utils ) { * }
: streamer [ d# 282 ] ; { * }
: loader [ d# 210 ] ; { , , }
: selftest ( port ) [ d# 708 ] load ; :# stp 3
: autotest ( port ) [ d# 712 ] load ; }block

( 00232C00 )               D# 203 shadow{ 
 ( these definitions are used in released code or documented procedures
 and shouldn't be changed or overloaded casually. ) { br }

: a-com ( and ) c-com ( are com port numbers for eval board usb ports
 a and c. )
: a-bps ( and ) c-bps ( are baud rates to which ide ) { cr }
 ( sets these usb ports. )
: host ( and ) target ( load block numbers for serial ide configured
 to work with eval board host or target chips using default usb ports. )
 { br }

 [ definitions for getting started app note ]
: selftest ( runs ats selftest on either chip via the ide com port
 number given. )
: autotest ( given host ide com port number, runs ate tests of target
 chip using sync boot. then tests ) [ serdes ] ( between the chips. )
 }block

( 00233000 )               D# 204 code{ 
 ( - user application tools ) }block

( 00233400 )               D# 205 shadow{ 
 ( this is the place to compile definitions that you wish to be available
 after ) [ empty. ] ( be sure to test compile separately before placing
 them here or you may cause { 24F } load to abort. ) }block

( 00233800 )               D# 206 code{ 
 ( evb001 host chip ide ) [ empty compile ] { br }

 [ serial load ] { cr }
 ( customize ) [ -canon d# 0 fh orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { br }

: dac ( n ) h# 155 and io r! ; { br }

 ( canon load ) }block

( 00233C00 )               D# 207 shadow{ 
 ( this load block compiles and configures the ) { cr }
 ( ide for the host chip on the eval board. it's also an example of
 configuring and customizing the ide without hacking it and breaking
 other uses of the ide. ) { br }

 ( this block starts by loading the serial ide in its standard form. )
 [ -canon ] ( forgets the mapping of canonical words like ) @ ( and )
 dup ( onto the f18 so that we may interact with x86 code and ram. )
 { cr }
 ( we then set ) [ orgn ] ( so that the ide ) compile ( will reload
 this block, and we set ) [ sport ] ( to the usb port a for normal
 ide operations on host chip. ) [ !nam ] ( updates pathname for that
 com port. ) { br }

: dac ( is defined to illustrate extending the ide ) { cr }
 [ canon load ] ( restores mapping of canonical words onto the f18.
 comment this if you wish to use the 'r-words' for all f18 operations. )
 }block

( 00234000 )               D# 208 code{ 
 ( evb001 target chip ide ) [ empty compile ] { br }

 [ serial load ] { cr }
 ( customize ) [ -canon d# 0 fh orgn ! ] { cr }
 [ c-com sport ! c-bps bps ! !nam ] { br }

: dac ( n ) h# 155 and io r! ; { br }

 ( canon load ) }block

( 00234400 )               D# 209 shadow{ 
 ( this load block compiles and configures the ) { cr }
 ( ide for the eval board's target chip. it's ) { cr }
 ( also an example of configuring and customizing the ide without hacking
 it and breaking other uses of the ide. ) { br }

 ( this block starts by loading the serial ide in its standard form. )
 [ -canon ] ( forgets the mapping of canonical words like ) @ ( and )
 dup ( onto the f18 so that we may interact with x86 code and ram. )
 { cr }
 ( we then set ) [ orgn ] ( so that the ide ) compile ( will reload
 this block, and we set ) [ sport ] ( to the usb port c for normal
 ide ops on target chip. ) { cr }
 [ !nam ] ( updates pathname for that com port. ) { br }

: dac ( is defined to illustrate extending the ide ) { cr }
 [ canon load ] ( restores mapping of canonical words onto the f18.
 comment this if you wish to use the 'r-words' for all f18 operations. )
 }block

( 00234800 )               D# 210 code{ 
 ( ide based loader ) :# pth 2 :# root 708 [ talk ] { , }
 ( tables and routing ) [ d# 2 fh d# 2 loads ] { , , }
: body follower [ d# 0 ] + drop -if { , ... }
      [ root ] @ active or drop if deliver ; then ; { , ... }
      then [ d# 1 ] +route body [ d# -1 ] +route deliver ; { , , }
: ship ( n ) dup [ pth ] ! route active [ root ] ! { , ... }
      [ d# 1 ] +route foc body unfoc [ pth ] @ -hook ; }block

( 00234C00 )               D# 211 shadow{ 
 ( ide scripting ) { , , }
: body ( recursively visit and initialize ) { , }
 ( each node in the path ) { , , }
: ship ( use given path and set foc mode ) { , }
 ( visit each node in the path then cleanup ) { , }
 ( by convention path { 4F } in the ide reaches all ) { , }
 ( nodes and is suitable for use by most apps. ) { , , }
 [ usage ] ( is simple. ) { , }
 ( 1. ) [ host ] ( or target ) [ load loader load ] { , }
 ( 2. describe the application using +node et al. 3. ) [ ship ] }block

( 00235000 )               D# 212 code{ 
 ( - configuration tables ) :# com 135
: tabl pop 2/ 2/ [ com ] @ + ;
: jsr h# E8 dst ; ( call has been clobbered already )
: table ( nn ) < align > jsr tabl for dup , next drop ;
: a-boot [ d# -1 d# 144 table ] { * }
: c-boot [ d# -1 d# 144 table ]
: b-boot [ d# -1 d# 144 table ] { * }
: p-reg [ h# A9 d# 144 table ]
: a-reg [ d# -1 d# 144 table ] { * }
: b-reg [ io d# 144 table ] { , , }
: /a ( a ) a-reg ! ; { * }
: /b ( a ) b-reg ! ; { * }
: /p ( a ) p-reg ! ;
: +node ( n ) nn-n [ com ] ! ;
: /part ( acb ) b-boot ! c-boot ! a-boot ! ;
: /ram ( b ) b-boot ! d# 64 c-boot ! d# 0 a-boot ! ;
: rammer ( -acb ) a-boot @ c-boot @ b-boot @ ; { , , }
: aaray pop 2/ 2/ [ com ] @ [ d# 11 ] * + ;
: array ( n ) < align > jsr aaray [ d# 11 ] * for d# 0 , next ;
: 'stack [ d# 144 array ] :# sp 10
: @s+ 'stack [ sp ] @ + @ d# 1 [ sp ] +! ;
: !s- ( n ) 'stack [ sp ] @ + ! d# -1 [ sp ] +! ;
: /stack ( stuff count ) { , }
 d# 10 [ sp ] ! dup !s- for !s- next ; }block

( 00235400 )               D# 213 shadow{ 
 ( - configuration tables )
: tabl
: jsr ( call from block { B0F } has been clobbered ) { , }
 ( so replace it with jsr instead )
: table ( build and initialize a table ) { , }
 ( tables hold configuration information )
: /a a ( specifies ) [ a ] ( value for current node )
: /b a ( specifies ) [ b ] ( value for current node )
: /p a ( specifies entry point for current node )
: +node n ( makes n the current node )
: /part acb ( specifies ) [ address count ] ( and ) [ bin ] { , }
 ( for code to be loaded into current node later )
: /ram b ( specifies just the bin, load all { 80F } )
: rammer -acb ( returns ) [ address count ] ( and ) [ bin ] { , }
 ( from table )
: /stack stuff count ( specifies ) [ count ] ( items to be placed on
 the stack at load time ) }block

( 00235800 )               D# 214 code{ 
 ( - routing ) :# 'rte 67894617
: route ( i ) 'pths + @ [ 'rte ] ! ;
: active ( -n ) [ 'rte ] @ @ ;
: follower ( -n ) [ 'rte ] @ [ d# 1 ] + @ ;
: +route ( n ) [ 'rte ] +! active nn-n [ com ] ! ; { , , }
: ?load c-boot @ [ d# 0 ] + drop -if ; then { , ... }
      rammer boot ; { , , }
: deliver [ pth ] @ active hook ( pause ) { , }
 ?load a-reg @ - [ d# 0 ] + drop -if { , ... }
      a-reg @ lit' ra! then { , }
 b-reg @ - [ d# 0 ] + drop -if { , ... }
      b-reg @ lit' rb! then { , }
 'stack [ d# 10 ] + @ dup and if dup { , ... }
      dup negate [ d# 10 ] + [ sp ] ! for @s+ lit' next { , ... }
      then drop { , }
 p-reg @ call ; }block

( 00235C00 )               D# 215 shadow{ 
 ( - routing )
: route i ( start on a path )
: active -n ( node being configured )
: follower -n ( next node in path )
: +route n ( change active node ) { , , }
: ?load ( load code into node now if table says to ) { , , }
: deliver ( init ram, a, b, stack, and p if ) { , }
 ( tables say to do so ) }block

( 00236000 )               D# 216 code{ 
 ( softsim configuration ) { , , }
 ( spi boot testbed { 9B8F } { 4F } loads ) { , }
 ( sync boot testbed 'addr,len' { 99CF } load ) { , , }
 ( smtm ) [ d# 0 +node d# 0 /ram d# 0 /p ] { , ... }
      [ d# 600 +node d# 600 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 500 +node d# 500 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 200 +node d# 200 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... { C8F } }
      ( +node { C8F } /ram { F } { 2F } /stack { 25F } /p ) { , ... }
      [ d# 709 +node d# 709 /ram h# 19 /p ] { , ... }
      [ d# 609 +node d# 609 /ram d# 0 /p ] { , ... }
      [ d# 509 +node d# 509 /ram d# 0 /p ] { , ... }
      [ d# 508 +node d# 508 /ram d# 0 /p ] { , ... }
      [ d# 507 +node d# 507 /ram d# 0 /p ] { , ... }
      [ d# 506 +node d# 506 /ram d# 0 /p ] { , ... }
      [ d# 505 +node d# 505 /ram d# 0 /p ] { , ... }
      [ d# 504 +node d# 504 /ram d# 0 /p ] { , ... }
      [ d# 503 +node d# 503 /ram d# 0 /p ] { , ... }
      [ d# 502 +node d# 502 /ram d# 0 /p ] { , ... }
      [ d# 501 +node d# 501 /ram d# 0 /p ] { , }
 ( /command test ) [ d# 400 +node d# 0 /ram h# 25 /a h# 12 /b ] { , }
 [ d# 9 d# 8 d# 7 d# 6 d# 5 d# 4 d# 3 d# 2 d# 1 h# 12345 d# 10 /stack
 h# A9 /p ] { , , }
 ( rom write test { 190F } +node { 27F } /p ) { , , { F } { 65F } { CEF } }
 ( break ) { , { F } { 17DF } { 258F } }
 ( break ) }block

( 00236400 )               D# 217 shadow{ 
 ( this block is loaded by softsim to set the ) { , }
 ( configuration for a given simulation. edit it as needed to set up
 testbeds, load application code and initialize it for running, and
 set ) { , }
 ( breakpoints. ) { , , }
 [ see arrayforth user's manual for information ] { , }
 [ about these options. ] }block

( 00236800 )               D# 218 code{ 
 }block

( 00236C00 )               D# 219 shadow{ 
 }block

( 00237000 )               D# 220 code{ 
 }block

( 00237400 )               D# 221 shadow{ 
 }block

( 00237800 )               D# 222 code{ 
 }block

( 00237C00 )               D# 223 shadow{ 
 }block

( 00238000 )               D# 224 code{ 
 }block

( 00238400 )               D# 225 shadow{ 
 }block

( 00238800 )               D# 226 code{ 
 }block

( 00238C00 )               D# 227 shadow{ 
 }block

( 00239000 )               D# 228 code{ 
 }block

( 00239400 )               D# 229 shadow{ 
 }block

( 00239800 )               D# 230 code{ 
 }block

( 00239C00 )               D# 231 shadow{ 
 }block

( 0023A000 )               D# 232 code{ 
 }block

( 0023A400 )               D# 233 shadow{ 
 }block

( 0023A800 )               D# 234 code{ 
 }block

( 0023AC00 )               D# 235 shadow{ 
 }block

( 0023B000 )               D# 236 code{ 
 }block

( 0023B400 )               D# 237 shadow{ 
 }block

( 0023B800 )               D# 238 code{ 
 }block

( 0023BC00 )               D# 239 shadow{ 
 }block

( 0023C000 )               D# 240 code{ 
 ( framer ) [ overlay ]
: exec [ h# B6 ] ; { -cr }
: warm [ h# A9 ] ; { -cr }
: io [ h# 15D ] ; { cr }
: right [ h# 1D5 ] ; { -cr }
: down [ h# 115 ] ;
: left [ h# 175 ] ; { -cr }
: up [ h# 145 ] ; { cr }
 ( streams ) [ d# 2 fh d# 4 loads ] { br }

: body ( w-w ) follower [ d# 0 ] + drop -if { cr }
 ?load post ; then -load -post pump { cr }
 [ d# 1 ] +route body [ d# -1 ] +route ?load post ; { cr }
: length ( -n ) d# 1 [ 'pth ] @ [ d# 1 ] + begin dup @ - [ d# 0 ] +
 { cr }
 -while - nn-n [ com ] ! c-boot @ [ d# 0 ] + -if [ d# -4 ] + { cr }
 then ( load ) [ d# 5 ] + ( pump ) [ d# 5 ] + ( post ) @post + u+ { cr }
 [ d# 1 ] + end then drop drop ( -1pump ) [ d# -5 ] + ; { br }

: head ( a-w ) active nn-n [ com ] ! [ h# 10000 ] + !18 { cr }
 [ d# 0 ] side dup !18 length dup !18 { cr }
 swap [ h# 12000 ] + !18 [ d# 1 ] +route ;
: frame [ exec ] head [ d# -1 ] + body drop [ d# -1 ] +route { , ... }
      c-boot @ [ d# 0 ] + drop -if d# 0 d# 0 d# 0 /part then { , ... }
      p-reg @ booter /root ; { , , }
 ( default path ) [ d# 22 fh load ] }block

( 0023C400 )               D# 241 shadow{ 
 ( framer load gets the stream vocabulary ) { br }

: body ( recursively make the body of a boot frame )
: length ( add up number of words in boot frame )
: head ( make boot frame header )
: frame ( make the whole boot frame ) { indent { -11 } }
      ( for focus , +3 for header ) }block

( 0023C800 )               D# 242 code{ 
 ( - framer ) :# com 131
: tabl pop 2/ 2/ [ com ] @ + ;
: table ( nn ) < align > call tabl for dup , next drop ;
: a-boot [ d# -1 d# 144 table ] { * }
: c-boot [ d# -1 d# 144 table ]
: b-boot [ d# -1 d# 144 table ] { * }
: p-reg [ h# A9 d# 144 table ]
: a-reg [ d# -1 d# 144 table ] { * }
: b-reg [ io d# 144 table ]
: inits [ d# 1 d# 144 table ] { * }
: init d# 11 inits ! ;
: /a ( a ) a-reg ! init ; { * }
: /b ( a ) b-reg ! init ;
: /p ( a ) p-reg ! ;
: +node ( n ) nn-n [ com ] ! ;
: /part ( acb ) b-boot ! c-boot ! a-boot ! ;
: /ram ( b ) b-boot ! d# 64 c-boot ! d# 0 a-boot ! ;
: booter ( -acb ) a-boot @ c-boot @ b-boot @ ; { , , }
: aaray pop 2/ 2/ [ com ] @ [ d# 11 ] * + ;
: array ( n ) < align > call aaray [ d# 11 ] * for d# 0 , next ;
: 'stack [ d# 144 array ] :# sp 10
: @s+ 'stack [ sp ] @ + @ d# 1 [ sp ] +! ;
: !s- ( n ) 'stack [ sp ] @ + ! d# -1 [ sp ] +! ;
: /stack ( stuff count ) init { , }
 d# 10 [ sp ] ! dup !s- for !s- next ; }block

( 0023CC00 )               D# 243 shadow{ 
 ( stream components ) [ com ] ( identfies current node )
: table ( creates an array initialized to { -11 } )
: x-boot
: x-reg ( arrays have booter and starter details )
: /p ( specifies entry point )
: /a ( initial value of a )
: /b ( initial value of b )
: +node ( connect to a node in a path ) { cr }
: /part ( from ide, specifies ram address, ) { cr }
 ( length and source ) { , }
 [ note scrub must be maintained to match the ] { , }
 [ defaults stored here! ]
: booter ( find a, c, and b for +load ) { br }

: aaray
: array
: 'stack ( an array of { 120F } { 14F } item stacks )
: @s+ ( get next item to be initialized )
: !s- ( store next item into stacks array )
: /stack ( specify stack initialization ) }block

( 0023D000 )               D# 244 code{ 
 ( - framer ) :# 'pth 67891668
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ; { -cr }
: a-b ( a-b ) 2* 2* ;
: create ( -a ) pop b-a ;
: route pop b-a { * }
: course ( a ) [ 'pth ] ! ;
: active ( -n ) [ 'pth ] @ @ ;
: follower ( -n ) [ 'pth ] @ [ d# 1 ] + @ ;
: +route ( n ) [ 'pth ] +! active nn-n [ com ] ! ; { br }

 :# wd 75753449
: 'stream ( -a ) [ nnc d# 2 * h# 8000 + block d# 1 + ] ; { cr }
 ( clear ) [ 'stream d# 1 + wd ! ]
: stream ( -ac ) [ 'stream d# 1 + ] dup [ wd ] @ - + - { , }
 dup [ 'stream d# -1 + ] ! ;
: strlen ( -n ) stream nip ;
: !18 ( n ) [ h# 15555 ] or [ wd ] @ ! d# 1 [ wd ] +! ; { br }

: wall ( nn-i ) over over or [ d# 1 ] and drop if { cr }
 or [ d# 2 ] and ; then [ d# 100 ] / swap [ d# 100 ] / or { cr }
 [ d# 2 ] and [ d# 1 ] + ;
: side ( n-a ) [ 'pth ] @ + dup @ swap [ d# 1 ] + @ wall port ; { cr }
: 0/2 ( n-0/2 ) [ d# 0 ] + drop -if [ d# 0 ] ; then [ d# 2 ] ;
: @post ( -n ) a-reg @ 0/2 b-reg @ 0/2 + { cr }
 'stack [ d# 10 ] + @ [ d# 2 ] * + [ d# 1 ] + ; }block

( 0023D400 )               D# 245 shadow{ 
 ( stream components ) { cr }
 [ 'pth ] ( points to current place in path )
: b-a ( byte to word address )
: route ( stores address of new path in ) [ 'pth ]
: course ( is user vocab for setting a path. )
: active ( return current node in path )
: follower ( return next node in path )
: +route ( move to next node in path ) { indent }
      [ pos ] ( moves forward ) [ neg ] ( moves back ) { br }

 [ wd ] ( point to next word in stream buffer )
: !18 ( stores word into stream buffer ) { br }

: wall ( given numbers of two adjacent nodes ) { cr }
 ( return index for shared port )
: side ( given numbers of two adjacent nodes ) { cr }
 ( return address of shared port ) { br }

: 0/2 ( false is 0 and true is { 4F } )
: @post ( add up the size of active node's ) { cr }
 ( postamble )
: to-do ... clean up 'stream as +2, { , }
 define -1+ as length and -2+ as { , }
 concat. }block

( 0023D800 )               D# 246 code{ 
 ( - framer )
: pump ( w-w ) [ d# -5 ] + ( @pdupa!@p ) [ h# 4DAF ] !18 { cr }
 [ d# 0 ] side [ h# 12000 ] + !18 dup [ d# -1 ] + !18 { cr }
 ( push!.. ) [ h# 2FAB2 ] !18 ( @p!unext. ) [ h# 5A72 ] !18 ;
: post a-reg @ - [ d# 0 ] + drop -if { cr }
 ( @pa!.. ) [ h# 4AB2 ] !18 a-reg @ !18 then { indent }
      b-reg @ - [ d# 0 ] + drop -if { cr }
 ( @pb!.. ) [ h# 4BB2 ] !18 b-reg @ !18 then { indent }
      'stack [ d# 10 ] + @ dup and if dup { indent }
      dup negate [ d# 10 ] + [ sp ] ! for { cr }
 ( @p .. ) [ h# 49B2 ] !18 @s+ !18 next then drop { cr }
 ( always ) p-reg @ [ h# 10000 ] + !18 ; { br }

: +ram ( acb ) nn-n 2* [ h# 8000 ] + block u+ { cr }
 for dup @ [ h# 15555 ] or !18 [ d# 1 ] + next drop ;
: +load ( acb ) push ( @pa!@p. ) [ h# 4A12 ] !18 { cr }
 over !18 dup [ d# -1 ] + !18 ( push... ) [ h# 2E9B2 ] !18 { cr }
 ( @p!+unext. ) [ h# 5872 ] !18 pop +ram ; }block

( 0023DC00 )               D# 247 shadow{ 
 ( stream components ) { br }

: pump ( store { AF } word port pump to stream buffer )
: post ( variable length word postamble, ) { cr }
 ( entry point, a, b, stack )
: +ram ( write ram contents to stream buffer )
: +load { AF } ( word load pump to stream buffer ) }block

( 0023E000 )               D# 248 code{ 
 ( - framer )
: ?load ( w-w ) c-boot @ [ d# 0 ] + drop -if ; then { cr }
 booter +load ;
: -load ( w-w ) c-boot @ [ d# 0 ] + -if drop ; then { cr }
 [ d# 5 ] + negate + ;
: -post ( w-w ) @post negate + ; { br }

: adjust begin strlen d# 7 and drop while { cr }
 d# 0 !18 end then strlen 'stream ! ;
: scrub ( n ) +node [ d# -1 ] dup dup /part { cr }
 d# -1 /a io /b warm /p ;
: fresh begin active scrub [ d# 1 ] +route { cr }
 active dup and drop -until ; { br }

: /root ( a' a c b ) push push push { cr }
 h# 10000 +or !18 pop dup !18 pop dup !18 { cr }
 [ d# 0 ] + if pop +ram ; then drop drop pop drop ; }block

( 0023E400 )               D# 249 shadow{ 
 ( stream components ) { br }

: ?load ( maybe add load pump and ram contents )
: -load ( subtract ram words from payload count ) { cr }
 ( if ram is to be loaded in active node )
: -post ( subtract length of postamble from ) { cr }
 ( payload count ) { br }

: adjust ( align stream to { 10F } { 24F } bit word boundary )
: scrub ( remove previous initialization clues ) { cr }
 ( for node n in the current path ) [ must be main- ] { , }
 [ tained whenever defaults for tables change. ]
: fresh ( scrub the entire current path to prepare for another boot
 frame ) }block

( 0023E800 )               D# 250 code{ 
 ( ers flash erase function ) [ overlay ] { cr }
 [ len ! dest ! ] { cr }
 [ serial load -canon ] { cr }
 [ a-com sport ! a-bps bps ! !nam panel ]
: esc key? esc ;
: wait esc d# 0 [ keych ] ! ;
: expand ( n-lh ) dup h# FFFF and [ d# 4 ] * swap { cr }
 h# F0000 and d# 64 / ;
: ersall [ h# 21 ] call ;
: ers32 [ h# 18 ] call ;
: ers [ dest ] @ pause { cr }
 [ d# 0 ] + drop if ersall ; then ers32 ;
: read ( a-a' ) dup expand lit' lit' [ h# C ] call [ d# -2 ] + ;
: r ( d-dw ) [ d# 2 ] + rdrop [ h# 25 ] call upd ;
: check [ dest ] @ read [ len ] @ for { cr }
 r h# FFFF or drop if pop [ d# 0 ] ; then -next [ d# -1 ] ; { cr }
 [ nores d# 285 list ] { cr }
 [ .noboot pause wait ] ( ** install noboot jumper ) { cr }
 [ talk ] ( check a-com ) [ d# 0 d# 705 hook h# 0 d# 64 d# 1613 boot ]
 { cr }
 [ .boot pause wait ] ( *** remove noboot jumper ) { cr }
 ( ers ) [ .erasing pause ersall chill ] ( check ) [ overlay ] }block

( 0023EC00 )               D# 251 shadow{ 
 ( erasing flash ) { br }

: ers ( an ) { cr }
 [ a ] ( byte address in flash on 4k boundary ) { cr }
 [ n ] ( number of ) d# 16 bit words ( to erase ) }block

( 0023F000 )               D# 252 code{ 
 ( flash writer { 24F } bit ) [ overlay ] { cr }
 [ d# 7 + d# -8 and len ! dest ! source ! ] { cr }
 [ serial load -canon ] { cr }
 [ a-com sport ! a-bps bps ! !nam talk ] { br }

 [ d# 0 d# 705 hook h# 0 d# 64 d# 1609 boot focus ] { cr }
 [ d# 0 d# 706 hook h# 0 d# 64 d# 1610 boot ] { br }

 ( flash commands { 97CF } ) [ d# 2 fh load ] { br }

 [ d# 285 list nosay ] { cr }
 [ .burning pause burn chill ] { cr }
 [ .checking pause check ] { cr }
 [ overlay ] }block

( 0023F400 )               D# 253 shadow{ 
 ( writing a boot stream into flash ) { br }

 ( force length to { F } mod { 10F } so operation ends ) { cr }
 ( at a { 20F } bit boundary ) { br }

: 18burn ( sdn ) { cr }
 [ s ] ( source address of buffer in host memory ) { cr }
 [ d ] ( destination { 10F } bit address in flash ) { cr }
 [ n ] ( length of stream in { 24F } bit words ) }block

( 0023F800 )               D# 254 code{ 
 ( - code for flash writer )
: read ( a ) left lit' ra! dup h# F0000 and d# 64 / { cr }
 swap h# FFFF and d# 4 * lit' lit' [ h# 23 ] call ;
: r left lit' ra! [ h# 29 ] call upd ;
: commence left lit' ra! [ len ] @ d# 8 / d# -1 + { cr }
 [ dest ] @ dup h# F0000 and d# 64 / lit' { cr }
 h# FFFF and d# 4 * lit' lit' [ h# 2D ] call ;
: git ( a-an ) dup [ d# 1 ] + swap @ [ h# 15555 ] or ;
: get ( a-a ) git lit' ;
: burning [ source ] @ [ len ] @ for get !+ next drop ;
: fetch ( -n ) [ h# 37 ] call { 7FF } [ h# 3A ] r@ ;
: check ( -t ) [ dest ] @ read [ source ] @ [ len ] @ { cr }
 for git fetch over ( pause ) over or { cr }
 drop if pop fail ; { cr }
 then drop drop next drop good ;
: burn commence burning ; { br }

: f d# 0 d# 706 hook fetch d# 0 d# 705 hook upd ;
: b d# 0 d# 706 hook burn ; }block

( 0023FC00 )               D# 255 shadow{ 
 }block

( 00240000 )               D# 256 code{ 
 ( exercising flash ) [ h# 20 org ]
: focus ^ 20 ^ @p dup a! .. ( / ) --l- ( / ) ! ;
: reading ^ 23 ^ ( l h ) focus @p ! .. ( / ) @p @p .. ( / ) { cr }
 ! ! .. @p ! ; ( / ) [ h# 1200E , ] ( / )
: @word ^ 29 ^ ( -n ) @p ! .. ( / ) [ h# 120D9 , ] ( / ) { cr }
 @p ! @ ; ( / ) !p .. ( / )
: writing ^ 2D ^ ( h l n ) focus { cr }
 left @p ! .. ( / ) @p a! .. ( / ) { cr }
 ! @p ! .. ( / ) @p @p @p .. ( / ) push push ! { cr }
 pop ! pop ! @p ! ; ( / ) [ h# 1201D , ] ( / )
: stash ^ 37 ^ focus @word !p ; ^ 3A ^ [ d# 0 , ] { br }

 [ exit ]
: stash ^ 37 ^ focus a push @word h# 3F a! ! pop a! ; }block

( 00240400 )               D# 257 shadow{ 
 }block

( 00240800 )               D# 258 code{ 
 ( writing flash { 10F } bits ) [ overlay ] { cr }
 [ len ! dest ! source ! ] { cr }
 [ serial load -canon ] { cr }
 [ a-com sport ! a-bps bps ! !nam talk ] { br }

 ( flash commands { 988F } ) [ d# 2 fh load ] { br }

 [ d# 0 d# 705 hook d# 0 d# 64 d# 1611 boot ] { cr }
 [ d# 285 list nosay ] ( nores ) { cr }
 [ .burning pause burn chill ] { cr }
 [ .checking pause check ] { cr }
 [ overlay ] }block

( 00240C00 )               D# 259 shadow{ 
 ( programming { 10F } bit flash ) { br }

: burn ( sdn ) { cr }
 [ s ] ( source address of buffer in host memory ) { cr }
 [ d ] ( destination { 10F } bit address in flash ) { cr }
 [ n ] ( length of stream in { 20F } bit words ) }block

( 00241000 )               D# 260 code{ 
 ( code for reading and writing flash { 10F } bits ) { cr }
: out d# 0 d# 706 hook ; { -cr }
: in d# 0 d# 705 hook ;
: read ( a-a' ) in dup dup h# F0000 and d# 64 / lit' { cr }
 h# FFFF and [ d# 4 ] * lit' [ h# E ] call rdup upd [ d# -2 ] + ;
: r ( d-dw ) [ d# 2 ] + rdrop [ h# 14 ] call upd ;
: r18 ( d-dw ) [ d# 2 ] + rdrop [ h# D9 ] call upd ;
: rr [ h# 8000 ] read r ;
: ers [ h# 24 ] call ; { -cr }
: pr [ h# 28 ] call ;
: send ( n ) left ( pause ) r! ;
: 2@+ ( b-b'h ) dup d# 2 + swap 2@ h# FFFF and swab ;
: burn in [ dest ] @ dup [ h# F0000 ] and [ d# 64 ] / lit' { cr }
 [ h# FFFF ] and [ d# 4 ] * lit' [ len ] @ lit' { cr }
 left lit' ra! pr out [ source ] @ [ len ] @ { cr }
 for 2@+ [ d# 4 ] * send -next drop ;
: check ( -t ) [ dest ] @ read drop { cr }
 [ source ] @ [ len ] @ for 2@+ { 73F } [ h# 3B ] call [ h# 3F ] r@
 or { cr }
 drop if pop drop fail ; then -next drop fair ; }block

( 00241400 )               D# 261 shadow{ 
 ( reading and writing flash ) { br }

: read ( begin at { 28F } bit flash byte address )
: r ( read the next { 20F } bit word from flash )
: r18 ( read the next { 24F } bit word from flash )
: rr ( begin and read first word at { 10001F } )
: ers ( erase whole flash )
: pr ( program assuming already erased )
: back ( back out to node { 584F } for streaming )
: send ( one word into node { 582F } , pause to display )
: 2@+ ( fetch { 20F } bit word + byte swap )
: burn n ( start programming flash in { 582F } , ) { cr }
 ( then back out to { 584F } and stream words from ) { cr }
 ( the stream buffer into { 582F } . ) }block

( 00241800 )               D# 262 code{ 
 ( default flash path for whole chip )
: line ( ncd ) swap push swap { , ... }
      begin dup , over + -next drop drop ;
: count ( nc-ncd ) dup [ d# 100 ] mod [ d# 0 ] + if { , }
 ( horz ) swap drop [ d# 1 ] ; { , }
 ( vert ) then drop [ d# 100 ] / [ d# 100 ] ;
: to ( nn ) over negate + -if { , }
 ( back ) negate count negate line ; { , }
 ( forw ) then count line ; { , , }
: entire align create [ d# 705 d# 701 to d# 700 d# 0 to ] { , }
 [ d# 1 d# 17 to d# 117 d# 101 to d# 201 d# 217 to d# 317 d# 301 to ]
 { , }
 [ d# 401 d# 417 to d# 517 d# 501 to d# 601 d# 617 to d# 717 d# 709
 to ] { , }
 [ d# -1 , ] { , , }
 ( retain asynch boot ) [ d# 708 +node h# AA /p ] }block

( 00241C00 )               D# 263 shadow{ 
: line ncd ( comma nodes into a table starting at node ) n ( for )
 c ( nodes incrementing by ) d { cr }
: /left ( extend line toward the left )
: /right ( extend line toward the right )
: /up ( extend line upward )
: /down ( extend line downward )
: entire ( default path table that ) { cr }
 ( covers the whole virginal chip ) }block

( 00242000 )               D# 264 code{ 
 ( sram cluster mk1 ) { br }

 ( load sram ) [ d# 6 fh d# 3 loads ] { indent }
      ( norm ) [ d# 12 fh ] ( degen { 18F } { 20F } fh ) [ load ] }block

( 00242400 )               D# 265 shadow{ 
 ( load block for sram cluster mk1 ) { , }
 ( as documented in an003. ) { , , }
 ( packaged as per preliminary module standards ) { , , }
 [ sram ] ( load block for f18 code ) { , }
 [ sram d# 2 + ] ( boot descriptors for cluster ) { , }
 [ sram d# 4 + ] ( optional residual path definition ) { , }
 ( f18 source code follows. ) }block

( 00242800 )               D# 266 code{ 
 ( - load descriptor ) { , , }
 ( interface ) [ d# 107 +node d# 1614 /ram down /b ] { , ... }
      ( mask ) [ h# 8A00 d# 1 /stack ] ( re ) [ h# 17 /p ] { , , }
 ( data ) [ d# 7 +node d# 1615 /ram h# 20 /p ] { , }
 ( cntl ) [ d# 8 +node d# 1616 /ram h# 20 /p ] { , }
 ( addr ) [ d# 9 +node d# 1617 /ram h# 20 /p ] }block

( 00242C00 )               D# 267 shadow{ 
 ( load descriptor for sram cluster ) { , , }
 ( this descriptor is suitable for use with ) { , }
 ( ide loader, streamer, and softsim. ) }block

( 00243000 )               D# 268 code{ 
 ( - residual paths ) { , , }
: s705 align create [ d# 705 d# 701 to d# 700 d# 0 to ] { , }
 [ d# 1 d# 6 to d# 106 d# 101 to d# 201 d# 208 to d# 108 d# 109 to ]
 { , }
 [ d# 209 d# 210 to d# 110 d# 10 to d# 11 d# 17 to d# 117 d# 111 to ]
 { , }
 [ d# 211 d# 217 to d# 317 d# 301 to d# 401 d# 417 to d# 517 d# 501
 to ] { , }
 [ d# 601 d# 617 to d# 717 d# 709 to d# -1 , ] { , , }
: s708 align create [ d# 708 d# 701 to d# 700 d# 0 to ] { , }
 [ d# 1 d# 6 to d# 106 d# 101 to d# 201 d# 208 to d# 108 d# 109 to ]
 { , }
 [ d# 209 d# 210 to d# 110 d# 10 to d# 11 d# 17 to d# 117 d# 111 to ]
 { , }
 [ d# 211 d# 217 to d# 317 d# 301 to d# 401 d# 417 to d# 517 d# 501
 to ] { , }
 [ d# 601 d# 617 to d# 717 d# 709 to d# -1 , ] }block

( 00243400 )               D# 269 shadow{ 
 ( memory clusters are often loaded before the ) { , }
 ( rest of the application so that external ram ) { , }
 ( may be initialized without burdening appli- ) { , }
 ( cation f18 code. these residual paths provide access from boot nodes
 to the rest of the chip in such cases. ) { , , }
: s705 ( residual path for spi flash boot streams. )
: s708 ( residual path for async boot or ide. ) }block

( 00243800 )               D# 270 code{ 
 ( sram.16 address-bus ) [ d# 9 node ] { cr }
 ^ AA ^ [ h# 20 org ] { br }

: start ^ 20 ^ right b! .. data a! .. h# 3 ( mask )
: cmd ( m ) ^ 26 ^ @b ( a16 ) 2* 2* over @b -if { indent }
      ^ 28 ^ - ( p04 ) and or ( a18 ) ! cmd ; { indent }
      ^ 2A ^ then ( p04 ) and or .. ( a18 ) ! cmd ; { , }
 ^ 2C ^ [ d# 1617 bin ] }block

( 00243C00 )               D# 271 shadow{ 
 ( node { 12F } suspends while waiting for a16. it uses the two lower
 page bits to output an ) { cr }
 ( 18-bit address. ) { cr indent }
      a16 ( xx.aaaa.aaaa.aaaa.aaaa ) { indent }
      p04 ( 00.0000.0000.0000.pppp ) { indent }
      a18 ( aa.aaaa.aaaa.aaaa.aapp ) { br }

 ( the code is written to minimize/equalize the time to output the
 address, which must be stable when node8 stores the 'start' command. )
 }block

( 00244000 )               D# 272 code{ 
 ( - control-pins ) [ d# 8 node host ]
: 'r-l- h# 1F5 lit ; [ target h# 0 org ] { br }

 ( 'start' pin control table 0-7 ) { cr }
 ^ 00 ^ [ h# 2556E ] ( r00 ) [ , h# 2557E ] ( r01 ) [ , ] { cr }
 ^ 02 ^ [ h# 3556E ] ( r10 ) [ , h# 3557E ] ( r11 ) [ , ] { cr }
 ^ 04 ^ [ h# 3557A ] ( w11 ) [ , h# 3556A ] ( w10 ) [ , ] { cr }
 ^ 06 ^ [ h# 2557A ] ( w01 ) [ , h# 2556A ] ( w00 ) [ , ] { cr }
 ^ 08 ^ [ h# 20 org ] { br }

: start ^ 20 ^ 'r-l- b! io a!
: cmd ^ 24 ^ @b ( stop ) ! a push h# 7 ( mask ) .. { indent }
      @b ( a16 ) !b @b ( +p/-p ) dup !b { indent }
      2/ 2/ and ( i3 ) a! .. @ ( ctrl ) pop a! { indent }
      ( start ) ! cmd ; { , }
 ^ 2C ^ [ d# 1616 bin ] }block

( 00244400 )               D# 273 shadow{ 
 ( node8 is fed a stop command during start-up, then suspends while
 waiting for a16. after starting the read or write, it again suspends
 while waiting for the stop command. ) { br }

 ( bits 4..2 of the /possibly inverted/ page value are used 'as-is'
 to index into the start table, setting two address bits, write enable,
 and chip enable. ) [ ** note that reads and writes are swapped if
 the page 'overflows' into bit4, with disastrous results ** ] { cr
 cr }
 ( cmd index ) [ .lit. ] ( pin17 pin05 pin03 pin01 ) { cr }
 ( w00 .0111 ) [ h# 2556A ] ( a19-0 a18-0 /we-0 /ce-0 ) { cr }
 ( r00 .0000 ) [ h# 2556E ] ( a19-0 a18-0 /we-1 /ce-0 ) { cr }
 ( w01 .0110 ) [ h# 2557A ] ( a19-0 a18-1 /we-0 /ce-0 ) { cr }
 ( r01 .0001 ) [ h# 2557E ] ( a19-0 a18-1 /we-1 /ce-0 ) { cr }
 ( w10 .0101 ) [ h# 3556A ] ( a19-1 a18-0 /we-0 /ce-0 ) { cr }
 ( r10 .0010 ) [ h# 3556E ] ( a19-1 a18-0 /we-1 /ce-0 ) { cr }
 ( w11 .0100 ) [ h# 3557A ] ( a19-1 a18-1 /we-0 /ce-0 ) { cr }
 ( r11 .0011 ) [ h# 3557E ] ( a19-1 a18-1 /we-1 /ce-0 ) }block

( 00244800 )               D# 274 code{ 
 ( - data-bus ) [ d# 7 node host ]
: in h# 14555 lit ; { -cr }
: out h# 15555 lit ;
: stop h# 3557F lit ; [ target ] { cr cr }
 ^ AA ^ [ h# 20 org ]
: start ^ 20 ^ left b! out io data stop { indent }
      out io data stop in io a! ( in ) ! { indent }
      down a! ( stop ) !b
: cmd ( /soid/ ) ^ 31 ^ @ ( a16 ) !b @ ( +p/-p ) -if { br }

: w16 ( /soid/p- ) ^ 33 ^ ( +p/-p ) !b { cr }
 ( /- setup + 45ns ) @ ( w ) a push push ( data ) a! { cr }
 pop ! ( io ) a! ( out ) ! { 50F } d# 13 for unext ( stop ) !b { cr }
 ( -/ ) in ! pop a! cmd ; { br }

: r16 ( /soid/p- ) ^ 3C ^ then ( +p/-p ) !b { cr }
 ( /- setup + 55ns ) a push ( data ) a! { cr }
 ( io ) drop ( out ) drop { 64F } d# 40 for unext ( stop ) !b ( -/ )
 { cr }
 @ ( w ) pop a! ! cmd ; { , }
 ^ 43 ^ [ d# 1615 bin ] }block

( 00244C00 )               D# 275 shadow{ 
 ( node7 suspends waiting for a16, passes it and page/r/w to nodes { 10F }
 and 9, finally controlling the data transfer and timing until sending
 the stop command. ) { br }

 ( the literals needed for writing are loaded ) { cr }
 ( onto the stack and used circularly to save ) { cr }
 ( time. /read's drops are free./ ) { br }

 ( ---- ) .lit. ( pin17 pin05 pin03 pin01 ) { cr }
 ( stop ) h# 3557F ( a19-1 a18-1 /we-1 /ce-1 ) }block

( 00245000 )               D# 276 code{ 
 ( - interface ) [ d# 107 node h# 0 org ]
: cx ( wp- ) ^ 00 ^ over push @ dup { , ... }
      ( a ) !b over ( p ) !b @b ( w ) pop - ( w1 ) or if { , }
 ( ne ) @ ( w2 ) dup or ( ff ) ! ; { , }
 ( eq ) then drop ( a ) !b - ( -p ) !b @ ( w2 ) !b h# FFFF ! ; { ,
 , }
: cmd ^ 0A ^ @ -if @ [ ' cx ] -until ( .e! ) - !b !b @ !b ; then ^ 0E ^
 @ -if ( mixpa ) { , }
 ( .mk! ) ^ 0F ^ - push drop drop pop if ( mia ) { , }
 ( ..stim ) ^ 11 ^ drop and @ over over 2* ahead [ swap ] { , }
 ( ..mask ) ^ 14 ^ then drop drop @ 2* over - { , }
 ( ...both ) ^ 16 ^ then and or
: re ^ 17 ^ ( m ) h# 15555 dup ahead [ swap ] { , ... }
      then ( .e@ ) ^ 19 ^ ( a ) !b ( p ) !b @b ( w ) ! ;
: cmds ( mixa ) ^ 1B ^ a! cmd { * }
: poll ( mix ) then io a! { , }
 ^ 1E ^ begin drop over over @ or and until { , }
 ^ 21 ^ over over and if ( mixt ) ^ 23 ^ and and ( mt ) { , .. }
      dup h# 10000 and if right ahead [ swap ] then { , .. }
      ^ 28 ^ drop h# 1000 over and if left ahead [ swap ] { , .. }
      ^ 2D ^ then drop { 801F } dup up then then { , ... }
      ^ 2F ^ ( mtba ) a! and or dup ! ( m ) [ ' re ] end { , }
 ^ 31 ^ then drop 2* 2* -if right cmds ; { , }
 ^ 35 ^ then 2* 2* 2* 2* -if left cmds ; { , }
 ^ 39 ^ then up cmds ; ^ 3B ^ [ d# 1614 bin ] }block

( 00245400 )               D# 277 shadow{ 
 ( node { D6F } full capability version. ) { , }
 ( polls for master requests and delivers stimuli ) { , }
 ( all requests are atomic. passes ) ex@ ( and ) ex! { , }
 ( requests on to node 007, performs ) cx? ( locally using those primitives.
 the command and stimulus mask ) [ m ] ( is maintained on the stack. )
 { , , }
 ( requests are variable length messages decoded as shown below where
 - means 18-bit inverse of { 20F } bit argument. ) { , , }
: ex@ [ +p +a ] ( fetch )
: cx? [ -w1 +p a w2 ] ( comp-and-exch )
: ex! [ -p -a w ] ( store )
: mk! [ +0 -f m ] ( f-1 enables each master whose port write bit is
 set in ) [ m. ] ( kills pending stimulus for any disabled master.
 abandons old mask. ) { , }
 ( f-0 adds a stimulus for each master whose port write bit is set
 in ) [ m. ] ( caller should not post a stimulus for any disabled master. )
 }block

( 00245800 )               D# 278 code{ 
 ( - user node 106, 108, or 207. )
: x! ( wa ) ^ 39 ^ dup dup or
: ex! ( wap ) { -cr }
: mk! ( mfp' ) ^ 3A ^ - !b - !b !b ;
: x@ ( a-w ) ^ 3C ^ dup dup or
: ex@ ( ap-w ) ^ 3D ^ !b !b @b ;
: cx? ( wapn-f ) ^ 3E ^ - !b !b !b !b @b ; ^ 40 ^ }block

( 00245C00 )               D# 279 shadow{ 
 ( example code for memory master nodes. ) { cr }
 ( memory-access words assume that addresses and data are 16-bit parameters
 with the upper two bits zero and pages are 4-bits with the upper { 1CF }
 bits zero. p.a is thus a 20-bit address. ) { br }

: ex@ [ a p ] ( - ) w ( fetch w from p.a )
: ex! [ w a p ] ( store w at p.a )
: mk! [ w f -0 ] ( set masks from w per f. )
: cx? [ w a p n ] ( - ) f ( comp-and-exch ) { br }

 cx? ( compares value at ) [ p.a ] ( to ) [ n. ] ( if same, writes )
 [ w ] ( to ) [ p.a ] ( and returns true. otherwise, only returns false. )
 x@ ( and ) x! ( are 16-bit versions to access the lowest 64k of available
 memory. ) { br }

 mk! ( sets mask from w when f is 0; ) { cr }
 ( posts stimuli when f is 1. ) }block

( 00246000 )               D# 280 code{ 
 ( - degenerate sram ) [ d# 107 node h# 0 org ] { br }

: cx ( wp- ) ^ 00 ^ over push @ dup { indent }
      ( a ) !b over ( p ) !b @b ( w ) pop - ( w1 ) or if { cr }
 ( ne ) @ ( w2 ) dup or ( ff ) ! ; { cr }
 ( eq ) then drop ( a ) !b - ( -p ) !b @ ( w2 ) !b h# FFFF ! ; { br }

: cmd ^ 0A ^ @ -if @ [ ' cx ] -until ( .e! ) - !b !b @ !b ; then ^ 0E ^
 @ ( .e@ ) ^ 0F ^ ( a ) !b ( p ) !b @b ( w ) ! ; { br }

 ^ 11 ^ [ h# 17 org ]
: start ^ 17 ^ down b! right a!
: run ^ 1B ^ cmd run ; ^ 1D ^ }block

( 00246400 )               D# 281 shadow{ 
 ( node { D6F } minimal capability version. ) { cr }
 ( single master, no polling, no stimuli. ) { cr }
 ( maximum speed, minimum power. ) { br }

 ( all requests are atomic. passes ) ex@ ( and ) ex! { cr }
 ( requests on to node 007, performs ) cx? ( locally using those primitives. )
 { br }

 ( requests are variable length messages decoded as shown below where
 - means 18-bit inverse of { 20F } bit argument. ) { br }

: ex@ [ +p +a ] ( fetch )
: cx? [ -w1 +p a w2 ] ( comp-and-exch )
: ex! [ -p -a w ] ( store ) }block

( 00246800 )               D# 282 code{ 
 ( streamer ) { cr }
 :# source 75751425 :# dest 0 :# len 2024
: stream ( -an ) [ source ] @ [ len ] @ ;
: 18burn ( sdn ) [ d# -30 fh ] load ;
: burn ( sdn ) [ d# -24 fh ] load ;
: ers ( an ) [ d# -32 fh ] load ;
: framer [ d# -42 fh ] ;
: chill d# 500 for d# 1000000 for nop next next ;
: file [ d# 12 fh ] ; { cr }
 ( feedback ) [ d# 284 load ]
: overlay remember }block

( 00246C00 )               D# 283 shadow{ 
 ( stream building utilities ) { cr }
 ( persistant streamer variables ) { cr }
 source ( word address in host memory buffer ) { cr }
 dest ( byte address in flash ) { cr }
 len ( length of stream in words )
: stream -an ( returns ) [ source ] ( an ) [ len ]
: 18burn sdn ( burn flash in { 24F } bit words )
: burn sdn ( burn flash in { 20F } bit words )
: ers an ( erase 4k blocks containing range ) [ an ]
: framer ( location of boot frame vocabulary )
: chill ( delay a long enough time to be sure ) { cr }
 ( that the previous operation is complete )
: overlay ( remember point for streamer utility ) { cr }
 ( saying ) [ overlay ] ( restores the dictionary to ) { cr }
 ( its state when overlay was defined ) }block

( 00247000 )               D# 284 code{ 
 ( flash utilties feedback ) { cr }
 :# loaded 848 :# result 0 { cr }
 :# 'say 271552571 :# 'ask 271552227
: nosay [ 'say ] assign nop ; [ nosay ]
: noask [ 'ask ] assign nop ; [ noask ]
: .now blu [ 'say ] xqt ;
: .ask blu [ 'ask ] xqt ;
: .at. blu silver [ loaded ] @ . ;
: chs ( ...n ) for emit next ; [ d# 2 fh load ]
: .res blu [ result ] @ { cr { -11 } }
 [ d# 0 ] + -if .fair ; then { cr { F } }
 [ d# -1 ] + -if drop .good ; then { cr { 2F } }
 [ d# -1 ] + -if drop .fail ; then ;
: fair d# -1 [ result ] ! ;
: good d# 0 [ result ] ! ;
: fail d# 1 [ result ] ! ;
: nores d# 2 [ result ] ! ; :# leng 2023 [ d# 36 leng ! ]
: .str blu silver .' ( stream ) space .' ( length ) { , ... }
      space [ leng ] @ . .' ( words ) space { , ... }
      [ leng ] @ d# 18 d# 8 */ . .' ( bytes ) space ; }block

( 00247400 )               D# 285 shadow{ 
 ( flash utilities ) { br .str cr .at. cr .ask cr .now br .res }
      }block

( 00247800 )               D# 286 code{ 
 ( - flash utilities feedback )
: .erasing noask ( nores ) [ 'say ] assign silver { cr }
 ( erasing ) d# 0 h# D h# 6 h# 7 h# 8 h# 5 h# 1 h# 4 d# 8 chs ;
: .burning noask ( nores ) [ 'say ] assign silver { cr }
 ( burning ) d# 0 h# D h# 6 h# 7 h# 6 h# 1 h# 16 h# 13 d# 8 chs ;
: .checking noask ( nores ) [ 'say ] assign silver { cr }
 ( checking ) d# 0 h# D h# 6 h# 7 h# 24 h# A h# 4 h# 14 h# A d# 9 chs
 ;
: .fair silver ( so far ) d# 0 h# 1 h# 5 h# E d# 0 h# 3 h# 8 d# 7 chs
 { cr }
 ( so good ) d# 0 h# 10 h# 3 h# 3 h# D d# 0 h# 3 h# 8 d# 8 chs ;
: .good green ( good ) d# 0 h# 10 h# 3 h# 3 h# D d# 5 chs ;
: .fail red ( fail ) d# 0 h# C h# 7 h# 5 h# E d# 5 chs ;
: .boot nosay ( nores ) [ 'ask ] assign green { cr }
 ( remove ) d# 0 h# 4 h# 11 h# 3 h# 9 h# 4 h# 1 d# 7 chs
: .j26 { cr }
 ( j26 ) d# 0 h# 1E h# 1A h# 22 d# 4 chs { cr }
 ( then ) d# 0 h# 6 h# 4 h# 14 h# 2 d# 5 chs { cr }
 ( press ) d# 0 h# 8 h# 8 h# 4 h# 1 h# 12 d# 6 chs { cr }
 ( key ) d# 0 h# B h# 4 h# 24 d# 4 chs ;
: .noboot nosay ( nores ) [ 'ask ] assign green { cr }
 ( install ) d# 0 h# C h# C h# 5 h# 2 h# 8 h# 6 h# 7 d# 8 chs .j26
 ; }block

( 00247C00 )               D# 287 shadow{ 
 }block

( 00248000 )               D# 288 code{ 
 ( pf to flash ) { br }

 ( read/write { 24F } bit flash ) { indent }
      [ d# 705 node d# 1364 load d# 1609 bin ] { indent }
      [ d# 706 node d# 256 load d# 1610 bin ] { cr }
 ( read/write { 10F } bit flash ) { indent }
      [ d# 705 node d# 1370 load d# 1611 bin ] { cr }
 ( erase flash ) { indent }
      [ d# 705 node d# 1352 load d# 1613 bin ] }block

( 00248400 )               D# 289 shadow{ 
 }block

( 00248800 )               D# 290 code{ 
 ( speedup spi boot ) [ d# 705 node d# 0 org ]
: start d# 5 dup spi-exec ; { cr }
 ^ 03 ^ [ d# 1608 bin ] }block

( 00248C00 )               D# 291 shadow{ 
 }block

( 00249000 )               D# 292 code{ 
 }block

( 00249400 )               D# 293 shadow{ 
 }block

( 00249800 )               D# 294 code{ 
 ( stream to file ) [ named ] ( stream.bin )
: open ( bf-h ) push push d# 0 d# 32 ( exist ) d# 2 d# 0 d# 0 { cr }
 pop pop swap fcreate ;
: change ( ac ) for dup @ [ h# 15555 ] or over ! [ d# 1 ] + { cr }
 next drop ;
: keep [ d# 0 fnam ] w/o open dup push stream change { cr }
 stream push d# 4 * pop d# 4 * pop fwr drop fclose { cr }
 stream change ; [ keep ] }block

( 00249C00 )               D# 295 shadow{ 
 ( stream to file )
: open bf-h ( b is byte address of filename )
: change ac ( stream is made as pattern not number )
: keep ( convert stream to number and write it to a file, then change
 it back to pattern ) }block

( 0024A000 )               D# 296 code{ 
 }block

( 0024A400 )               D# 297 shadow{ 
 }block

( 0024A800 )               D# 298 code{ 
 }block

( 0024AC00 )               D# 299 shadow{ 
 }block

( 0024B000 )               D# 300 code{ 
 ( dc characterization code added march 2011. ) { br }

 [ block d# 602 ] ( is code run in a node to measure power. ) { br }

 [ blocks d# 604 ] ( thru ) [ d# 636 ] ( are ide load blocks to set
 up various measurement conditions. ) }block

( 0024B400 )               D# 301 shadow{ 
 }block

( 0024B800 )               D# 302 code{ 
 ( custom test code ) [ d# 609 node h# 0 org ]
: t1 ^ 00 ^ begin begin begin begin { cr }
 unext unext unext unext t1 ;
: t2 ^ 02 ^ begin begin begin { cr }
 . unext unext unext t2 ;
: t3 ^ 04 ^ begin begin . . unext unext t3 ;
: t4 ^ 06 ^ begin . . . unext t4 ;
: t5 ^ 08 ^ begin begin begin begin { cr }
 next next next next t5 ;
: t6 ^ 0D ^ begin begin begin begin { cr }
 . . . . next next next next t6 ;
: s++ ^ 13 ^ h# 15555 dup { -cr }
: s.. dup dup dup dup dup dup dup dup ; { -cr }
: s+- h# 15555 h# 2AAAA s.. ;
: t7 ^ 1C ^ s++ { -cr }
: t78e begin begin begin drop unext unext unext t78e ; { -cr }
: t8 ^ 1F ^ s+- t78e ;
: t9 ^ 21 ^ io b! d# -1 !b begin . drop @b -until ;
: txx ^ 28 ^ s++ ( s+- )
: txxx begin ( . . . ) - unext txxx ; ^ 2A ^
: temp { 5F } h# 3FFFE { 7F } h# 3FFFF d# 999 io b! push !b begin unext
 !b ; ^ 31 ^
: temps temp temps ; ^ 33 ^ }block

( 0024BC00 )               D# 303 shadow{ 
 ( this load block, and the following { 32F } source/shadow pairs,
 are yours to do with as you please! ) }block

( 0024C000 )               D# 304 code{ 
 ( set all high z for leakage test ) [ talk ] { br }

 [ d# 0 d# 200 hook d# 0 io ! ] { cr }
 [ d# 0 d# 300 hook d# 0 io ! ] { cr }
 [ d# 0 d# 9 hook d# 0 io ! ] { cr }
 [ d# 0 d# 7 hook d# 0 io ! ] { cr }
 ( serdes already in input just focus it ) { cr }
 [ d# 0 d# 701 hook focus ] { cr }
 [ d# 2 d# 709 hook h# 155 io ! ] }block

( 0024C400 )               D# 305 shadow{ 
 }block

( 0024C800 )               D# 306 code{ 
 ( set all weak pd for wpd test ) [ talk ] { br }

 [ d# 0 d# 200 hook h# 15555 io ! ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! ] { cr { F } { 12F } }
 ( hook { F } io ! ) { cr { F } { EF } }
 ( hook { F } io ! ) { cr }
 ( serdes already in input just focus it ) { cr { F } { 57AF } }
 ( hook focus ) { cr { 4F } { 58AF } }
 ( hook { 2ABF } io ! ) }block

( 0024CC00 )               D# 307 shadow{ 
 }block

( 0024D000 )               D# 308 code{ 
 ( set all high for several tests ) [ talk ] { br }

 [ d# 0 d# 200 hook h# 30003 io ! ] { cr }
 [ d# 0 d# 300 hook h# 30003 io ! ] { cr }
 [ d# 0 d# 9 hook h# 3FFFF data ! ] { cr }
 [ d# 0 d# 7 hook h# 3FFFF data ! ] { cr }
 ( serdes already in input just focus it ) { cr { F } { 57AF } }
 ( hook focus ) { cr }
 [ d# 2 d# 709 hook h# AA io ! ] }block

( 0024D400 )               D# 309 shadow{ 
 }block

( 0024D800 )               D# 310 code{ 
 ( set all low for several tests ) [ talk ] { br }

 [ d# 0 d# 200 hook h# 20002 io ! ] { cr }
 [ d# 0 d# 300 hook h# 20002 io ! ] { cr }
 [ d# 0 d# 9 hook h# 0 data ! ] { cr }
 [ d# 0 d# 7 hook h# 0 data ! ] { cr }
 ( serdes already in input just focus it ) { cr { F } { 57AF } }
 ( hook focus ) { cr }
 [ d# 2 d# 709 hook h# 155 io ! ] }block

( 0024DC00 )               D# 311 shadow{ 
 }block

( 0024E000 )               D# 312 code{ 
 ( t04 all node access ) [ talk ] { br }

 [ ?rom pause upd pause ] { cr }
 [ d# 2 d# 708 hook pause d# 2 d# 707 hook pause ] { cr }
 [ ?ram pause upd pause ] { cr }
 [ d# 1 lit pause d# 2 lit pause d# 3 lit pause ] { cr }
 [ + pause + ] }block

( 0024E400 )               D# 313 shadow{ 
 }block

( 0024E800 )               D# 314 code{ 
 ( vt+- node { 1B2F } ) [ compile talk d# 2 d# 217 hook upd ] { cr }
: dak ( n a ) h# 5BB2 over r! swap h# 155 or swap r! ;
: try ( n ) up dak ;
: h h# 20000 io r! h# 0 try d# 100 ms d# 0 io r! { cr }
 d# 0 begin dup h# 200 or h# 200 and drop while { cr }
 dup try d# 1 + io r@ h# 20000 and drop until then ;
: l h# 30000 io r! d# 511 try d# 100 ms d# 0 io r! { cr }
 d# 255 begin dup h# 100 or h# 100 and drop while { cr }
 dup try d# -1 + io r@ - h# 20000 and drop until then ; }block

( 0024EC00 )               D# 315 shadow{ 
 }block

( 0024F000 )               D# 316 code{ 
 ( vt+- node { 40AF } ) [ compile talk d# 0 d# 517 hook upd ] { cr }
: dak ( n a ) h# 5BB2 over r! swap h# 155 or swap r! ;
: try ( n ) up dak ;
: h h# 20000 io r! h# 0 try d# 100 ms d# 0 io r! { cr }
 d# 0 begin dup h# 200 or h# 200 and drop while { cr }
 dup try d# 1 + io r@ h# 20000 and drop until then ;
: l h# 30000 io r! d# 511 try d# 100 ms d# 0 io r! { cr }
 d# 255 begin dup h# 100 or h# 100 and drop while { cr }
 dup try d# -1 + io r@ - h# 20000 and drop until then ; }block

( 0024F400 )               D# 317 shadow{ 
 }block

( 0024F800 )               D# 318 code{ 
 ( vt n7/8 ) [ compile talk ] { cr }
 [ d# 2 d# 7 hook h# 0 io ! data lit ra! focus ] { cr }
 [ d# 2 d# 8 hook h# 20000 io ! focus upd ] { cr }
: rd ( a-n @!p ) h# 39B2 over r! r@ ;
: git ( -n ) left rd ;
: go key? git d# 1 and drop if h# 30000 io r! go ; { cr }
 then h# 20000 io r! go ; [ go ] }block

( 0024FC00 )               D# 319 shadow{ 
 }block

( 00250000 )               D# 320 code{ 
 ( vt n9/8 ) [ compile talk ] { cr }
 [ d# 0 d# 9 hook h# 0 io ! data lit ra! focus ] { cr }
 [ d# 0 d# 8 hook h# 20000 io ! focus upd ] { cr }
: rd ( a-n @!p ) h# 39B2 over r! r@ ;
: git ( -n ) right rd ;
: go key? git h# 20000 and drop if h# 30000 io r! go ; { cr }
 then h# 20000 io r! go ; [ go ] }block

( 00250400 )               D# 321 shadow{ 
 }block

( 00250800 )               D# 322 code{ 
 ( t10 schmitt power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! upd ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! upd ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ d# 0 io ! upd ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! upd ] { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd ] { cr }
 }block

( 00250C00 )               D# 323 shadow{ 
 }block

( 00251000 )               D# 324 code{ 
 ( t11 suspended power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 ( susp boot- ) [ h# 0 h# 0 ] ( warm ) [ h# A9 /frame wos !frame ]
 }block

( 00251400 )               D# 325 shadow{ 
 }block

( 00251800 )               D# 326 code{ 
 ( study single node + boot power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] }block

( 00251C00 )               D# 327 shadow{ 
 }block

( 00252000 )               D# 328 code{ 
 ( t12a boot power ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 }block

( 00252400 )               D# 329 shadow{ 
 }block

( 00252800 )               D# 330 code{ 
 ( t12b boot pwr + drop same ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr { 26F } }
 [ h# 1C call ] }block

( 00252C00 )               D# 331 shadow{ 
 }block

( 00253000 )               D# 332 code{ 
 ( t12c boot pwr + drop alternating ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr { 38F } }
 [ h# 1F call ] }block

( 00253400 )               D# 333 shadow{ 
 }block

( 00253800 )               D# 334 code{ 
 ( t12d boot pwr + greg test ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 15 boot ?ram ] { cr }
 [ d# 14 call ] }block

( 00253C00 )               D# 335 shadow{ 
 }block

( 00254000 )               D# 336 code{ 
 ( t12e boot pwr + unext ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 [ d# 0 call ] }block

( 00254400 )               D# 337 shadow{ 
 }block

( 00254800 )               D# 338 code{ 
 ( sram test bd quiet i/o ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 8 hook ] ( all hi ) [ h# 3557F io ! ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 [ d# 0 d# 705 hook h# 3FFFF io ! ] { cr }
 [ d# 0 -hook ] }block

( 00254C00 )               D# 339 shadow{ 
 }block

( 00255000 )               D# 340 code{ 
 ( study single node w/boot suspended ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 1 d# 608 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 ( run { F } ) [ h# 15555 { 7FFFFF } lit dup dup dup h# 21 call ] { cr }
 ( susp boot- ) [ h# 0 h# 0 ] ( warm ) [ h# A9 /frame wos !frame ]
 }block

( 00255400 )               D# 341 shadow{ 
 }block

( 00255800 )               D# 342 code{ 
 { 582F } ( unext w/boot suspended ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 0 d# 705 hook upd d# 0 d# 64 d# 609 boot ?ram ] { cr }
 ( run ) [ d# 0 call ] { cr }
 ( susp boot- ) [ h# 0 h# 0 ] ( warm ) [ h# A9 /frame wos !frame ]
 }block

( 00255C00 )               D# 343 shadow{ 
 }block

( 00256000 )               D# 344 code{ 
 ( instr timing code ) [ d# 610 node h# 0 org ]
: set h# 3FFFE h# 3FFFF d# 999 io b! d# 1 a! ;
: t1 ^ 07 ^ set push !b begin unext !b ;
: t2 ^ 0A ^ set push !b begin next !b ;
: t3 ^ 0E ^ set push !b begin . unext !b ;
: t4 ^ 11 ^ set push !b begin . . . unext !b ;
: t5 ^ 15 ^ set push !b begin . . @ unext !b ;
: t6 ^ 19 ^ set push io a! !b begin . . @ unext !b ;
: t7 ^ 1F ^ set push !b begin . .. next !b ;
: t8 ^ 24 ^ set push !b begin . .. . .. next !b ;
: t9 ^ 2A ^ set push !b begin begin dup or push unext . . . . next
 h# 2 !b ; ^ 31 ^ }block

( 00256400 )               D# 345 shadow{ 
 }block

( 00256800 )               D# 346 code{ 
 ( study instr timing ) [ talk ] { br }

 ( no boot ) [ d# 0 d# 709 hook upd d# 0 -hook ] { cr }
 [ d# 0 d# 200 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 300 hook h# 15555 io ! pause ] { cr }
 [ d# 0 d# 9 hook ] ( input ) [ h# 15555 io ! h# 0 data ! pause ] { cr }
 [ d# 0 d# 7 hook ] ( output ) [ h# 15555 io ! h# 0 data ! pause ]
 { cr }
 ( serdes to output ) { cr }
 [ d# 0 d# 701 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! pause ] { cr }
 [ d# 0 h# 1 hook focus h# 3FFFE lit h# 3FFFE data ! ] { indent }
      [ h# 20000 io ! upd pause ] { cr }
 [ d# 0 d# 705 hook upd d# 0 d# 64 d# 610 boot ?ram ] { cr cr }
: t1 [ h# 7 ] call ; { -cr }
: t2 [ h# A ] call ;
: t3 [ h# E ] call ; { -cr }
: t4 [ h# 11 ] call ;
: t5 [ h# 15 ] call ; { -cr }
: t6 [ h# 19 ] call ;
: t7 [ h# 1F ] call ; { -cr }
: t8 [ h# 24 ] call ;
: t9 [ h# 2A ] call ; }block

( 00256C00 )               D# 347 shadow{ 
 }block

( 00257000 )               D# 348 code{ 
 }block

( 00257400 )               D# 349 shadow{ 
 }block

( 00257800 )               D# 350 code{ 
 }block

( 00257C00 )               D# 351 shadow{ 
 }block

( 00258000 )               D# 352 code{ 
 }block

( 00258400 )               D# 353 shadow{ 
 }block

( 00258800 )               D# 354 code{ 
 }block

( 00258C00 )               D# 355 shadow{ 
 }block

( 00259000 )               D# 356 code{ 
 ( mark mem test all nodes ) { cr }
 [ empty compile serial load panel talk d# 2 { F } path ] { cr }
 :# tgt 417 :# tport 277 :# times 0 { cr }
 :# runs 3 :# greg 98862 :# /max 98862 :# /tot 0 { br }

: init h# 0 [ greg ] ! d# 0 [ times ] ! d# 0 [ runs ] ! d# 0 [ /max ]
 ! d# 0 [ /tot ] ! d# 0 [ tgt ] ! d# 0 [ tport ] ! ; [ init ] { br }

: xx [ d# 0 ] test d# 0 or if d# -1 + dup [ /max ] @ max [ /max ] !
 [ greg ] ! ( drop ) rip d# 9876 d# 54321 abort then drop ; { br }

: -us ( a-a ) dup @ paths @ or drop ;
: -end ( a-a ) dup @ d# -1 or drop ;
: pt@ paths targets @ + ;
: /go pause [ d# 0 ] d# 64 d# 907 boot pfocus paths targets @ + ( ; )
: //go key? [ d# 1 ] + -us if -end if dup @ dup [ tgt ] ! over d# -1
 + @ wall port dup [ tport ] ! ( pause ) tfocus pause xx ( pause )
 creep //go ; then then drop d# 1 [ runs ] +! rip /go ;
: real { -cr }
: jj /go drop rip ; [ d# 776 list ] ( /go ) }block

( 00259400 )               D# 357 shadow{ 
 ( old code, not checked recently. )
: go ( entered with path hooked to initial adjacent node. boots it
 with package and makes it active. )
: //go ( entered with path tbl adr for the active node on stack. )
 }block

( 00259800 )               D# 358 code{ 
 ( mark burn on one weak node ) { cr }
 [ empty compile serial load panel talk d# 2 { F } path ] { cr }
 :# tgt 710 :# tport 373 :# times 0 { cr }
 :# runs 3 :# greg 0 :# /max 0 :# /tot 0 { cr }
: init h# 0 [ greg ] ! d# 0 [ times ] ! d# 0 [ runs ] ! d# 0 [ /max ]
 ! d# 0 [ /tot ] ! ; [ init ]
: kk d# 0 d# 64 d# 907 boot pfocus left tfocus ( creep right tfocus )
: //run init pause
: /con key? d# 0 test d# 0 or if dup d# 1 [ times ] +! d# -1 + dup
 [ /max ] @ max [ /max ] ! dup [ greg ] ! [ /tot ] +! then [ greg ]
 ! d# 1 [ runs ] +! [ runs ] @ { 7D0F } { 14F } d# 2 mod dup and drop
 if /con ; then pause /con ;
: /real kk d# 12345 ; [ d# 778 list ] ( /go ) }block

( 00259C00 )               D# 359 shadow{ 
 ( old code, not checked recently. )
: go ( entered with path hooked to initial adjacent node. boots it
 with package and makes it active. )
: //go ( entered with path tbl adr for the active node on stack. )
 }block

( 0025A000 )               D# 360 code{ 
 ( polyforth virtual machine ) [ reclaim ] { , , }
 ( sram cluster mk1 ) [ sram load ] { , }
 ( serial ) [ d# 38 fh d# 3 loads reclaim ] { , , }
 ( stack ) [ d# 106 node h# 39 org d# 278 load d# 14 fh d# 2 loads ]
 { , }
 ( coprocs ) [ d# 22 fh d# 4 loads ] { , }
 ( bitsy ) [ d# 105 node d# 18 fh d# 2 loads ] { , }
 ( coprocs ) [ d# 30 fh d# 4 loads ] { , , }
 ( flash to sram ) [ d# 86 fh d# 2 loads reclaim ] { , }
 ( erase and burn flash ) [ d# 288 load ] { , }
 ( spi speedup ) [ d# 290 load ] { , , }
 ( serial wires ) [ d# 102 node h# 20 org ] { , }
: start @ !b start ; ^ 21 ^ [ d# 1709 bin ] { , }
 ( ganglia ) [ d# 6 fh load ] ( snorkel ) [ d# 10 fh load ] { , }
 ( spi ) [ d# 44 fh load ] }block

( 0025A400 )               D# 361 shadow{ 
 ( this load block compiles the f18 code for all nodes in the polyforth
 vm. ) }block

( 0025A800 )               D# 362 code{ 
 }block

( 0025AC00 )               D# 363 shadow{ 
 }block

( 0025B000 )               D# 364 code{ 
 }block

( 0025B400 )               D# 365 shadow{ 
 }block

( 0025B800 )               D# 366 code{ 
 ( generate ganglia ) { , , }
 [ d# 700 node h# 20 org reclaim ] { , }
 ( rlud ) r--- --l- ---u -d-- [ d# 2 fh load ] { , }
 [ d# 1716 bin ] ^ 40 ^ { , , }
 [ d# 701 node h# 20 org reclaim ] { , }
 ( rlud ) --l- r--- ---u -d-- [ d# 2 fh load ] { , }
 [ d# 1717 bin ] ^ 40 ^ { , , }
 [ d# 600 node h# 20 org reclaim ] { , }
 ( rlud ) r--- --l- -d-- ---u [ d# 2 fh load ] { , }
 [ d# 1714 bin ] ^ 40 ^ { , , }
 [ d# 601 node h# 20 org reclaim ] { , }
 ( rlud ) --l- r--- -d-- ---u [ d# 2 fh load ] { , }
 [ d# 1715 bin ] ^ 40 ^ }block

( 0025BC00 )               D# 367 shadow{ 
 ( background nodes are filled by default with ) { , }
 ( ganglia, routing code in { 41F } to { 7FF } thus they ) { , }
 ( may support either ide or neural messaging ) { , }
 ( until node is programmed some other way. ) { , , }
 ( routing directions are geographic. ) { , ... }
      ( coded direction rlud 0123 ) { , , }
 ( four bins hold node orientations... ) { , ... { D68F } { C8F } .. { D6AF } { CAF }
 , ... { D64F } }
      ( 000 ) { .. { D66F } }
      ( 001 ) { , , }
 ( routing note- step count is relative to the node first receiving
 one of these messages. if ) { , }
 ( all counts zero will deliver to its neighbor ) { , }
 ( in direction indicated by two lsb of path. a ) { , }
 ( turn to deliver to right neighbor of turner ) [ is not expressible ]
 ( because whole field zero. ) { , }
 [ third run must never have count d# 8 or more! ] }block

( 0025C000 )               D# 368 code{ 
 ( - ganglion template ) { , , }
 ( a whence b whither ) { , }
 ( msg is focus call path cin-1 cout-1 code ) { , , { 41F } }
 ( org rlud r--- --l- ---u -d-- )
: aim ^ 24 ^ ( p-pa ) dup d# 3 and h# 20 or b! @b dup b! !b { , }
 @p ; ( / pump ) leap
: whither ^ 2A ^ ( p ) d# -4 . + aim !b ( path ) !b { , }
 ( cnts ) @ dup push !b @ dup push !b
: payload ^ 30 ^ begin @ !b unext { , ... }
      begin @b ! unext ;
: /8 ^ 32 ^ ( n-n ) 2/ 2/ 2/ ;
: pump ^ 33 ^ then pop a! @ dup
: turn ( pp ) h# 3C and if drop whither ; then { , ... }
      drop dup h# FC0 and if drop /8 /8 dup turn ; { , }
 then drop aim ( cnts ) @ push @ push payload ; { , }
 ^ 40 ^ }block

( 0025C400 )               D# 369 shadow{ 
 ( ganglia route messages much like chuck's 'sea' delivers exchanges
 of { 2F } or more word out and ) { , { 2F } }
 ( or more word reply to arbitrary nodes with ) { , }
 ( source routing. message structure is... ) { , , .. }
      focus call ( to port ) [ always there ] { , .. .. }
      pump call [ interganglion only ] { , .. .. }
      path ( see below ) [ inter only ] { , .. .. }
      reply count ( words-1 ) [ inter only ] { , .. .. }
      payload count ( words-1 ) [ inter only ] { , .. }
      payload [ always there ] { , .. }
      reply [ always there ] { , , }
 ( path has { 6F } 6-bit runs low order taken first ) { , }
 ( run encoded nnnndd path has 3 runs, ) { , ... }
      ( 2-bit direction rlud 0123 ) { , ... }
      ( 4-bit count 1-relative zero deliver immed ) { , ... ... }
      ( 3rd run must be lt { 10F } ) { , }
 ( example from 708 to 617 go down 1 and right 8 ) { , ... }
      ( 8 0 1 3 packed as 807 ) [ in octal. ] { , , }
 ( when an exchange is finished all ) { , }
 ( ganglia are back where they were ) { , }
 ( on receipt of focusing call. ) }block

( 0025C800 )               D# 370 code{ 
 ( - snorkel ) [ reclaim d# 108 node d# 0 org ]
: mk! ( fp'm )
: /! ( an-a ) ^ 00 ^ push dup - !b over - !b pop !b ;
: a+ ^ 03 ^ ( ap-ap+ ) push d# 1 . + h# 10000 over and if { , ... }
      or d# 1 then pop . + ;
: +@ ^ 0B ^ ( a-an ) a+ { * }
: /@ ^ 0C ^ ( a-an ) dup !b over !b @b ;
: @w ^ 0E ^ ( a-a'u ) /@ d# 7 for 2* 2* unext { , ... }
      push +@ pop or ;
: dma ^ 14 ^ ( x/r ) a+ @w push +@ push +@ pop begin { , ... }
      pop pop dup push over push push drop ex { , }
 next pop drop drop drop ( func ) +@ push ;
: x16 ^ 20 ^ ( x ) dma /@ ! a+ ;
: r16 ^ 23 ^ ( x ) dma @ /! a+ ;
: x18 ^ 26 ^ ( x ) dma @w ! a+ ;
: r18 ^ 29 ^ ( x ) dma @ dup push d# 7 push { , ... }
      begin 2/ 2/ unext d# 3 and /! a+ pop /! a+ ;
: fin ^ 33 ^ ( x ) dup /! ( +three ) dup - h# 8000 mk!
: idle ^ 37 ^ ( begin ) @b d# 2 dup dup or /@ ( until ) { , ... }
      push dup /! pop over @w a! ( func ) +@ push ; { , }
 ^ 40 ^ [ d# 1605 bin reclaim exit ] }block

( 0025CC00 )               D# 371 shadow{ 
 to activate snorkel ( wait till ) [ mmptr ] ( zero then write addr
 of a ) [ sequence/x ] ( to it and stim. ) { , }
 [ mmptr ] ( zeroed after stim and you may queue 2nd ) [ x ] ( by writing
 and posting another stim. ) { , , }
 x ( has { 4F } wd ) [ port address ] ( followed by one or more ) [ function/arg
 groups. ] ( all x ) { * }
: must { * }
: be ( in bottom 64k of memory! ) { , , }
 function/arg group ( is { 2F } word ) [ jump adr ] ( in snork followed
 by ) [ args ] ( if any. ) [ funcs ] ( are... ) { , }
 x/r 16/18 ( count18, adr20 ) { , }
 fin ( done-flg awaken? ) { , , }
 ( if focusing call desired it must be first word in first transmit. )
 [ nothing about this code ] { , }
 [ depends on using ganglia ... can source ide or any other reasonable
 protocol including direct stream or ad hoc node to node transfer. ]
 }block

( 0025D000 )               D# 372 code{ 
 }block

( 0025D400 )               D# 373 shadow{ 
 }block

( 0025D800 )               D# 374 code{ 
 ( pf.16 stack ) [ h# 0 org ]
: '1+ ( w-w ) ^ 00 ^ d# 1 . + { -cr }
: mask ( w-w ) ^ 02 ^ h# FFFF and ;
: '2/ ( w-w ) ^ 04 ^ 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt ) ^ 06 ^ dup '1+ over x@ ;
: 'au! ( pst-p43 ) ^ 08 ^ x!
: popst ( p-pst ) ^ 09 ^ popt
: pops ( pt-pst ) ^ 0A ^ push popt pop ;
: pop43 ( pst-p43st ) ^ 0C ^ push push popst pop pop ;
: '1- ( w-w ) ^ 0E ^ d# -1 . + mask ; ^ 11 ^ [ here h# 37 org ]
: psht ( pt-p ) ^ 37 ^ push '1- pop over ( x! ; ) ^ 39 ^ ( * ) [ org ]
: pshs ( pst-pt ) ^ 11 ^ push psht pop ;
: pshw ( pstw-ptw ) ^ 13 ^ push pshs pop ;
: 'sp! ( ptp-pst ) ^ 15 ^ pshs popst ;
: 'drop ( pst-p3s ) ^ 17 ^ drop pops ;
: 'over ( pst-pts ) ^ 18 ^ over pshw ; { br }

: sco ( x3 ) ^ 19 ^ 2* -if { cr }
 ( code.sx x4 ) ^ 1A ^ 2* ( up ) [ h# 145 ] -until -d-- ; { cr }
 ( code.sm x4 ) ^ 1D ^ then drop push ; ^ 1E ^ { br { 6F } }

 ( words to recover! ) [ h# 21 org ] }block

( 0025DC00 )               D# 375 shadow{ 
 ( the stack node abuts the memory driver. note that it includes x@
 and friends. ) { br }

: psht ( is placed so it falls into ) x! { br }

: 'name ( denotes ) vm instructions { cr }
: others ( are internal words ) { br }

 ( the external data stack grows downward, using pre-dec writes post-inc
 reads. ) { cr }
 ( the internal stack holds the vm ) [ stack pointer ] ( and cached )
 [ s ] ( and ) [ t ] { br }

 ( 16-bit words are ) [ 00.nnnn.nnnn.nnnn.nnnn ] }block

( 0025E000 )               D# 376 code{ 
 ( - stack cont'd )
: 'dup ( pst-ptt ) ^ 21 ^ dup pshw ;
: 'swap ( st-ts ) ^ 22 ^ over push push drop pop pop ;
: '2* ( w-w ) ^ 24 ^ 2* mask ;
: 'or ( pst-p3w ) ^ 25 ^ over - and
: 'xor ( pst-p3w ) ^ 26 ^ or pops ;
: 'and ( pst-p3w ) ^ 27 ^ and pops ;
: 'neg ( n-n ) ^ 28 ^ '1-
: 'inv ( w-w ) ^ 29 ^ begin - mask ;
: 'zeq ( w-f ) ^ 2A ^ until begin dup or ;
: 'zlt ( n-f ) ^ 2C ^ 2* 2* -until dup or 'inv ;
: 'um+ ( uu-uc ) ^ 2E ^ + h# 10000 over and if or d# 1 ;
: 'nop ^ 33 ^ then ( begin ) ;
: 'qdup ( pst-pst/ptt ) ^ 34 ^ ( until )
: '- ( pst-p3n ) ^ 34 ^ 'neg
: '+ ( pst-p3n ) ^ 35 ^ + mask pops ; { cr }
 ^ 37 ^ [ d# 1700 bin ] }block

( 0025E400 )               D# 377 shadow{ 
 ( notes- ) { indent }
      ( the initial sp is reset by ) [ cold ] { indent }
      ( code must fit before block 740's ) psht { indent }
      ( some optimizations are commented out ) { cr }
 ( so as not to lose the code for use later when/if some code is put
 in rom. ) }block

( 0025E800 )               D# 378 code{ 
 ( pf.16 bitsy ) [ h# 0 org ]
: 'else { -cr }
: bx@ ( a-w ) ^ 00 ^ @p !b !b . ( / ) @p x@ ( / ) { cr }
 @p !b @b ; ( / ) !p . . . ( / )
: bx!- ( aw-a' ) ^ 04 ^ @p !b !b dup ( / ) @p . . . ( / ) { cr }
 @p !b !b . ( / ) @p x! ( / )
: dec ( a-a' ) ^ 08 ^ d# -1 . + ;
: @2tos ( a- ) ^ 0A ^ bx@
: bpshw ( w- ) ^ 0B ^ @p !b !b ; ( / ) @p pshw ( / )
: 'rp@ ( rip-rip ) ^ 0D ^ push over bpshw pop ;
: 'lit ( rip-rip' ) ^ 0F ^ dup @2tos
: inc ( a-a' ) ^ 10 ^ d# 1 . + ;
: 'con ( rip-rip ) ^ 12 ^ bx@
: 'var ( rip-rip ) ^ 13 ^ dup bpshw
: 'exit ( rip-r'i'p' ) ^ 14 ^ drop push
: popi ( r.p-r'ip ) ^ 15 ^ inc
: geti ( r.p-rip ) ^ 16 ^ dup bx@ pop ; { br }

: bpopw ( -w ) ^ 18 ^ @p !b @b ; ( / ) !p pops ( / )
: 'tor ( rip-rip ) ^ 1A ^ push bx!- bpopw pop ;
: 'r@ ( rip-rip ) ^ 1D ^ over bpshw ;
: 'rfrom ( rip-rip ) ^ 1E ^ push bpshw popi ; }block

( 0025EC00 )               D# 379 shadow{ 
 ( the return stack pointer 'r', top of return stack 'i', and vm instruction
 pointer 'p' live on the stack of the bitsy node. in stack pictures
 . shows return stack on right. ) { br }

 }block

( 0025F000 )               D# 380 code{ 
 ( - bitsy cont'd )
: 'exe ( rip-rip ) ^ 20 ^ bpopw
: xxt ( ripx-rip ) ^ 21 ^ dup 2* 2* -if { cr }
 ( code ripx2 ) ^ 23 ^ 2* -if { cr }
 ( code.b ripx3 ) ^ 24 ^ 2* -if { cr }
 ( code.bx ripx4 ) ^ 25 ^ 2* ( up ) [ h# 145 ] -until -d-- ; { cr }
 ( code.bm ripx4 ) ^ 28 ^ then drop push ; { cr }
 ( code.s ripx3 ) ^ 29 ^ then @p !b push . ( / ) @p @p . . !b pop !b
 .. @p !b ; .. ( / ) sco .. { cr }
 ( hi rix2 ) ^ 2E ^ then drop push push bx!- pop pop ;
: run ( rip-rip ) ^ 31 ^ dup bx@ push inc pop xxt run ; { cr }
: 'if ( rip-rip' ) ^ 35 ^ bpopw if drop inc ; { cr }
 then drop bx@ ;
: 'rx? ^ 39 ^ @ bpshw ;
: 'tx? ^ 3A ^ @p !b @b . ( / ) !p . . @p ( / ) ! @ !b ;
: 'rp! ( rip-rip ) ^ 3D ^ push bx!- bpopw geti ; { cr }
 ^ 40 ^ [ d# 1703 bin ] }block

( 0025F400 )               D# 381 shadow{ 
 ( the bit-threaded code technique confines execution to the ) bitsy
 ( loop and a small number of code words. pseudo-instruction format
 is ) { br }

 [ xx.0aaa.aaaa.aaaa.aaaa ] ( high level call ) { cr }
 [ xx.100x.xxaa.aaaa.aaaa ] ( xt in stack node ) { cr }
 [ xx.1010.xxaa.aaaa.aaaa ] ( xt in stack up ) { cr }
 [ xx.1011.xxaa.aaaa.aaaa ] ( xt in stack down ) { cr }
 [ xx.110x.xxaa.aaaa.aaaa ] ( xt in bitsy ) { cr }
 [ xx.1110.xxaa.aaaa.aaaa ] ( xt in bitsy up ) { cr }
 [ xx.1111.xxaa.aaaa.aaaa ] ( xt in bitsy down ) { br }

 ( this version uses sco in stack node to decode all its instructions. )
 { br }

 [ d# 7 word decode for stack node ] { cr }
 ( code.s rix3 ) ^ 28 ^ then 2* -if { cr }
 ( code.sx rix4 ) ^ 29 ^ @p !b !b . ( / ) @b sco ( / ) drop ; ( code.sm )
 ^ 2C ^ then drop h# 1A000 or !b ; }block

( 0025F800 )               D# 382 code{ 
 ( stack down bxxx ) [ d# 6 node d# 0 org ]
: xqt ^ 00 ^ @b push ex
: idle ^ 01 ^ @p !b xqt ; ( / ) drop !p . . ( / ) ^ 03 ^ { br }

: ''s ^ 03 ^ @p !b @p . ( / ) pshs ( / ) psht ( / ) { cr }
 !b @p !b ; ( / ) dup pops ; ^ 08 ^ { br }

: 43xp ( op ) ^ 08 ^ @p !b !b . ( / ) pop43
: pops; ^ 0A ^ @p !b ; ( / ) pops ;
: 'ex@ ( pst-p3w ) ^ 0C ^ @p !b pops; ; ( / ) ex@
: 'ex! ( pst-p54 ) ^ 0E ^ @p 43xp ; ( / ) ex!
: 'cx? ( pst-p5f ) ^ 10 ^ @p 43xp ; ( / ) cx?
: 'mk! ( pst-p54 ) ^ 12 ^ @p 43xp ; ( / ) - ex!
: 'sus ^ 14 ^ @p !b ; ( / ) @b drop ; { , }
 ^ 16 ^ [ d# 1701 bin ] }block

( 0025FC00 )               D# 383 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

: ex@ ( and friends cost { 14F } words, two more than the { 10F } which
 they took in the stack node. )
: 'mk! ( msk f { F } inverts { F } so ex! can do the work. )
: 'sus ( suspends vm waiting for stimulus. ) }block

( 00260000 )               D# 384 code{ 
 }block

( 00260400 )               D# 385 shadow{ 
 }block

( 00260800 )               D# 386 code{ 
 ( stack up axxx ) [ d# 206 node d# 0 org ]
: xqt ^ 00 ^ @b push ex
: idle ^ 01 ^ @p !b xqt ; ( / ) drop !p . . ( / ) ^ 03 ^ { cr br }

: start ^ 03 ^ up b! idle ;
: free ^ 05 ^ @p !b pop ; ( / ) . ; .. { br }

 ^ 07 ^ [ d# 1702 bin exit ]
: who ^ 07 ^ @p !b @b @p ( / ) !p @p ; ( / ) [ d# 206 , ] + !b ; }block

( 00260C00 )               D# 387 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

 }block

( 00261000 )               D# 388 code{ 
 }block

( 00261400 )               D# 389 shadow{ 
 }block

( 00261800 )               D# 390 code{ 
 ( bitsy down fxxx ) [ d# 5 node d# 0 org ]
: xqt ^ 00 ^ @b push ex
: idle ^ 01 ^ @p !b xqt ; ( / ) drop !p . . ( / ) ^ 03 ^ { br }

: 'next ^ 03 ^ @p !b @b . ( / ) push dup !p . ( / ) { cr }
 push zif @p !b @p . ( / ) drop inc ( / ) dup bx@ { cr }
 !b @p !b ; ( / ) pop inc ; ( / ) then { cr }
 pop @p !b @p ( / ) dec ( / ) pop bx@ ; ( / ) !b drop ; { , }
 ^ 0F ^ [ d# 1704 bin ] }block

( 00261C00 )               D# 391 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

: 'next ( length is { 18F } vs { 8F } or { AF } in bitsy, argh. ) }block

( 00262000 )               D# 392 code{ 
 }block

( 00262400 )               D# 393 shadow{ 
 }block

( 00262800 )               D# 394 code{ 
 ( bitsy up exxx ) [ d# 205 node d# 0 org ]
: xqt ^ 00 ^ @b push ex
: idle ^ 01 ^ @p !b xqt ; ( / ) drop !p . . ( / ) ^ 03 ^ { br }

: start ^ 03 ^ up b! idle ;
: free ^ 05 ^ @p !b pop ; ( / ) . ; .. { br }

 ^ 07 ^ [ exit ]
: no-op ^ 03 ^ @p !b ; .. ( / ) ; .. ^ 05 ^
: upop ^ 05 ^ @p !b ; .. ( / ) bpopw ^ 07 ^
: upsh ^ 07 ^ @p !b ; .. ( / ) bpshw ^ 09 ^
: uin ^ 09 ^ ( -n ) @p !b @b ; ( / ) !p .. ^ 0B ^
: uout ^ 0B ^ ( n ) @p !b !b ; ( / ) @p .. ^ 0D ^
: uid ^ 0D ^ upop uin d# 205 . + uout upsh no-op ; { , }
 ^ 14 ^ [ d# 1705 bin ] }block

( 00262C00 )               D# 395 shadow{ 
: idle ( main program of coprocessor nodes. feeds owner instruction
 to give us the vm opcode and executes it. ) { cr }
 opcodes [ must return to idle when done. ] { cr }
 port ( code for owner ) [ must ] ( end with return. ) { br }

 }block

( 00263000 )               D# 396 code{ 
 }block

( 00263400 )               D# 397 shadow{ 
 }block

( 00263800 )               D# 398 code{ 
 ( serial transmit ) [ d# 100 node h# 0 org ]
: !bit ( im-i ) ^ 00 ^ over and { cr }
 if { F } ( dumb ) h# 25555 ( maxim { 6AAABF } ) !b drop ; { cr }
 then { 2F } ( dumb ) h# 35555 ( maxim { 4AAABF } ) !b drop ;
: putc ( dc-d ) ^ 05 ^ -
: putchar ( di-d ) ^ 06 ^ h# FF or 2* { cr }
 d# 9 for ^ 0A ^ ( 1-start, 8-data, 1-stop bit ) { indent }
      d# 1 !bit 2/ over for . unext { cr }
 next ^ 0E ^ drop ( weak-pulldown { 2AAABF } !b ) ; { br }

 ^ 0F ^ [ h# 20 org ] ( programmed with abandon )
: start io b! right a! d# 2400 ( est. { 38400F } baud ) { cr }
 ( stopbit state dumb ) h# 25555 ( maxim { 6AAABF } ) !b
: wait ( d-.d ) ^ 27 ^ @ -if ( tx! ) putchar wait ; { indent }
      then ( !io ) up a! ! .. @ right a! wait ; { br }

: send ( cd ) ^ 2F ^ over putc send ;
: send/ ( d ) ^ 31 ^ h# 40 begin dup push putc { indent }
      pop d# 1 . + h# 5F and end { , }
 ^ 3A ^ [ d# 1706 bin ] }block

( 00263C00 )               D# 399 shadow{ 
 ( notes- ) { indent }
      [ tx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. ) { br }

: putchar ( takes a clean inverted octet and transmits it low bit first
 via p17. ) { br }

: wait ( suspends while waiting for inverted character or a new delay
 value. ) { cr indent }
      [ the first terminal operation must set ] { cr }
 [ the delay! ] { indent }
      send ( and ) send/ ( test the bit timing using external loop-back. )
 }block

( 00264000 )               D# 400 code{ 
 ( - receive ) [ d# 200 node h# 28 org ]
: @bit ( cm-c ) @b - over - and push and pop or ;
: getc ( d-dc ) ^ 2B ^ dup begin drop @b -until
: getchar ( dx-dc ) ^ 2D ^ over 2/ for . unext ( 1/2 bit ) d# 8 for
 ( 1-start, 8-data, 1-stop bits ) { indent }
      h# 1FFFF @bit 2/ over for . unext { cr }
 next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ h# FF and ; { br }

: baud ( n-dd ) ^ 3A ^ if dup ; then - push { cr }
 ^ 3D ^ begin @b . -until ( at start-bit of space ) { , }
 ^ 3E ^ begin @b - -until ( at 1-bit ) { cr }
 ^ 3F ^ begin @b . zif then . -until ( at 0-bits ) { cr }
 ^ 41 ^ begin @b - zif then . -until ( stop-bit ) { cr }
 pop - ( n ) dup 2/ . + ( 1.5n ) dup ; { br }

: auto ^ 46 ^ a push up a! @ baud ! pop a! dup !
: idle ( d ) ^ 4C ^ @b -if getchar - { indent }
      @b 2* - -if over ! then drop drop idle ; then h# 200 and .. if
 auto ; then drop idle ; { br }

 ^ 58 ^ [ h# 20 org ] ( programmed with some abandon )
: start io b! h# 5555 !b right a! d# 2400 idle ; { , }
 ^ 27 ^ [ d# 1707 bin ] }block

( 00264400 )               D# 401 shadow{ 
 ( notes- ) { indent }
      [ rx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received
 characters may have one stop bit. ) { br }

: getchar ( called after seeing leading edge of start bit. returns
 clean inverted character. must be called before start bit begins! )
 { br }

: baud ( space is 1...1'0010.0000'0 ) { indent }
      ( stop bits ---' .hex..20. '--- start ) { br }

: idle }block

( 00264800 )               D# 402 code{ 
 ( - interface ) [ d# 104 node h# 20 org ] { cr }
 ( programmed with abandon )
: start io b! right a! ahead
: rx? ^ 24 ^ h# 400 and .. if ( avail ) up a! @ then
: rtn ( w- ) ^ 29 ^ h# FFFF and right a! ! { cr }
: idle ^ 2D ^ then @b 2* .. [ ' rx? ] -until { indent }
      ( not read ) 2* [ ' idle ] -until { indent }
      ( write ) @ 2* 2* 2/ 2/ .. -if
: tx! ( c- ) ^ 33 ^ @b h# 1000 and if ( full ) drop rtn ; { indent }
      ( room ) then left a! over ! rtn ;
: iox ( c- ) ^ 3A ^ then left a! ! { indent }
      up a! begin @ - -until - rtn ; { , }
 ^ 40 ^ [ d# 1708 bin ] }block

( 00264C00 )               D# 403 shadow{ 
 ( notes- ) { indent }
      idle ( is a polling loop waiting for ) { cr }
 [ right ] ( reading - ) [ rx? ] ( returns ) 16-bit inv { indent }
      character ( from recv queue or ) d# 0 ( if ) { indent }
      ( queue is empty. ) { cr }
 [ right ] ( writing - do ) [ tx! ] ( for ) 16-bit inv { indent }
      character ( or ) [ iox ] ( for ) 16-bit pos { indent }
      bit delay ( input. ) { cr indent }
      [ tx! ] ( returns the ) 16-bit inv character ( when the xmit
 queue is full and ) d# 0 ( otherwise. ) { cr indent }
      [ iox ] ( suspends until it puts the ) 16-bit pos bit delay ( in
 the xmit queue and again while it discards any ) inv characters ( in
 the recv queue before the new ) pos bit delay ( arrives. ) }block

( 00265000 )               D# 404 code{ 
 ( spi flash sst25wf080 ) [ reclaim d# 705 node d# 0 org ]
: entry ^ 00 ^ pop a! ( delay ) @
: nxt ^ 01 ^ ( d-d ) @ push ex . nxt ; { , , }
: null ^ 03 ^ ( d ) dup !
: done ^ 04 ^ ( d ) -++ !b await ;
: cmd ^ 07 ^ ( d ) dup select
: out ^ 08 ^ ( d ) @ for @ 2* 2* 8obits zif { , ... }
      drop ( pop drop ) ; then 8obits drop next ;
: byte ^ 10 ^ ( d-dw ) dup dup or
: +byte ^ 11 ^ ( dw-dw ) d# 7 push begin begin { , ... }
      --- !b --+ !b . @b -while { , ... ... }
      drop - 2* - next ; then drop 2* next ;
: bytin ^ 1E ^ ( d ) @ for byte zif ! done ; { , ... }
      then +byte ! next done ;
: wout ^ 25 ^ ( d ) @ push .. zif begin { , .. }
      select h# 2B400 8obits drop [ swap ] then { , .. .. }
      @ 2* 2* 8obits 8obits drop select dup { , ... ... }
      begin drop @b -until drop next null ;
: slob ^ 33 ^ ( d-dw ) dup dup or
: +slob ^ 34 ^ ( dw-dw ) d# 7 push ibits ;
: slowin ^ 37 ^ ( d ) @ for slob zif ! done ; { , ... }
      then +slob ! next done ; { , }
 ^ 3E ^ [ d# 1606 bin reclaim ] }block

( 00265400 )               D# 405 shadow{ 
 ( timing roughly { 6AF } ns 19.2 mhz read clock ) { , }
 ( clk low 16.5 ns 30. mhz so this is good for ) { , }
 ( all sst25wfxxx parts as well. with mk1 sram ) { , }
 ( we get { 456F } us block read time. ) { , , }
 ( registers b-io a-boss t-delay r-cmd. command ) { , }
 ( stream starts with dly and then funcs... ) { , , }
: done ( deselect ) [ and end operation. ]
: null ( does so after sending a dummy byte in. )
: cmd ( selects and pumps a command )
: out ( given nbyt-1 sends nbyt bytes to device. )
: bytin ( given nbyt-1 receives nbyt bytes from ) { , ... }
      ( the device ) [ and ends operation. ]
: wout ( given nwds writes nwds 16-bit words to ) { , ... }
      ( the device in aai mode. used immed after ) { , ... }
      ( address, should be followed by wrdi rdsr. ) { , , }
: slowin ( given nbyt-1 receives nbyt bytes from ) { , ... }
      ( the device. used for slow mmc. ) }block

( 00265800 )               D# 406 code{ 
 ( minimal spi ) [ reclaim d# 705 node d# 0 org ] { , }
 ( working before speed up )
: entry ^ 00 ^ pop a! ( delay ) @
: nxt ^ 01 ^ ( d-d ) @ push ex . nxt ; { , , }
: null ^ 03 ^ ( d ) dup !
: done ^ 04 ^ ( d ) -++ !b await ;
: cmd ^ 07 ^ ( d ) dup select
: out ^ 08 ^ ( d ) @ for @ 2* 2* 8obits zif { , ... }
      drop ; then 8obits drop next ;
: byte ^ 10 ^ ( d-dw ) dup dup or
: +byte ^ 11 ^ ( dw-dw ) d# 7 push ibits ;
: bytin ^ 14 ^ ( d ) @ for byte zif ! done ; { , ... }
      then +byte ! next done ; { , }
 ^ 1B ^ [ d# 1606 bin reclaim ] }block

( 00265C00 )               D# 407 shadow{ 
 ( minimal code but slow; timing roughly { 80F } ns or 15.4 mhz read
 clock, low { 3EF } ns; write { 98F } ns or 13.2 mhz. when delay is
 zero. addl delay about { 8F } ns per count. ) { , }
 ( command stream starts with dly and then funcs ) { , , }
: done ( deselect ) [ and end operation. ]
: null ( does so after sending a dummy byte in. )
: cmd ( selects and pumps a command )
: out ( given nbyt-1 sends nbyt bytes to device. )
: bytin ( given nbyt-1 receives nbyt bytes from ) { , ... }
      ( the device ) [ and ends operation. ] }block

( 00266000 )               D# 408 code{ 
 }block

( 00266400 )               D# 409 shadow{ 
 }block

( 00266800 )               D# 410 code{ 
 }block

( 00266C00 )               D# 411 shadow{ 
 }block

( 00267000 )               D# 412 code{ 
 }block

( 00267400 )               D# 413 shadow{ 
 }block

( 00267800 )               D# 414 code{ 
 }block

( 00267C00 )               D# 415 shadow{ 
 }block

( 00268000 )               D# 416 code{ 
 }block

( 00268400 )               D# 417 shadow{ 
 }block

( 00268800 )               D# 418 code{ 
 }block

( 00268C00 )               D# 419 shadow{ 
 }block

( 00269000 )               D# 420 code{ 
 }block

( 00269400 )               D# 421 shadow{ 
 }block

( 00269800 )               D# 422 code{ 
 }block

( 00269C00 )               D# 423 shadow{ 
 }block

( 0026A000 )               D# 424 code{ 
 }block

( 0026A400 )               D# 425 shadow{ 
 }block

( 0026A800 )               D# 426 code{ 
 }block

( 0026AC00 )               D# 427 shadow{ 
 }block

( 0026B000 )               D# 428 code{ 
 }block

( 0026B400 )               D# 429 shadow{ 
 }block

( 0026B800 )               D# 430 code{ 
 }block

( 0026BC00 )               D# 431 shadow{ 
 }block

( 0026C000 )               D# 432 code{ 
 }block

( 0026C400 )               D# 433 shadow{ 
 }block

( 0026C800 )               D# 434 code{ 
 }block

( 0026CC00 )               D# 435 shadow{ 
 }block

( 0026D000 )               D# 436 code{ 
 }block

( 0026D400 )               D# 437 shadow{ 
 }block

( 0026D800 )               D# 438 code{ 
 }block

( 0026DC00 )               D# 439 shadow{ 
 }block

( 0026E000 )               D# 440 code{ 
 }block

( 0026E400 )               D# 441 shadow{ 
 }block

( 0026E800 )               D# 442 code{ 
 }block

( 0026EC00 )               D# 443 shadow{ 
 }block

( 0026F000 )               D# 444 code{ 
 }block

( 0026F400 )               D# 445 shadow{ 
 }block

( 0026F800 )               D# 446 code{ 
 ( - sram loader nodes ) { , , }
 ( wires ) [ d# 605 node d# 0 org ]
: wire ( b! a! ) @ dup !b for @ !b unext warm ; { , }
 ^ 04 ^ [ d# 1711 bin ] { , , }
 ( sram loader node { D8F } ) { , }
 [ d# 108 node h# 39 org d# 278 load ] { , }
 [ d# 0 org ] { * }
: start ^ 00 ^ up a! left b! { , }
 d# 0 @ dup push over x! { , }
 begin d# 1 . + @ over x! next warm ; { , }
 ^ 0D ^ [ d# 1713 bin ] }block

( 0026FC00 )               D# 447 shadow{ 
 ( minimal version of plumbing for sram boot from flash. wires are
 compiled only once and are ) { , }
 ( initialized with source port in a and dest ) { , }
 ( port in b. ) { , , }
 ( message consists of word count n-1 followed by n words to be passed
 along. ) { , , }
 ( node { D8F } now loads the image received from ) { , }
 ( flash into sram. { 1A0F } is just another wire ) { , , }
 ( however, the generic sram interface code is ) { , }
 ( compiled at the usual place anyway, so this ) { , }
 ( bin can be used by both the streamer and the ) { , }
 ( ide ) }block

( 00270000 )               D# 448 code{ 
 ( - spi flash { 10F } bits ) [ d# 705 node d# 0 org host ]
: resume nnc d# 2 * h# 8000 + block @ h# FFFFF and { indent }
      d# 18 d# 8 */ d# 4 * lit ; [ target ]
: wait ( dw-dw ) ^ 00 ^ select dup begin drop @b -until drop select
 ;
: 2cmd ( dw-d ) ^ 04 ^ select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) ^ 09 ^ io b! ( fast ) d# 5 ;
: fet ( ah al-d ) ^ 0C ^ push push set ( read ) h# C00 cmd pop !8 pop
 8obits !8 ;
: 16ibits ( d-db ) ^ 12 ^ dup d# 15 for { cr }
 rbit ibit - next h# FFFF and ;
: start ^ 19 ^ down a! d# 0 h# 20000 fet { cr }
 16ibits dup ! for 16ibits ! next { indent }
      resume fet 18ibits h# 1E000 . + - -if
: done io b! d# 20 d# 20 -++ half warm ; then { cr }
 d# 5 resume push spicmd spi-boot ; { cr }
 ^ 34 ^ [ d# 1710 bin ] }block

( 00270400 )               D# 449 shadow{ 
: start ( 1st word read is count in words ) }block

( 00270800 )               D# 450 code{ 
 ( polyforth ide boot ) [ host load loader load ] { , }
 ( kill boots ) [ d# 0 d# 708 hook d# 0 -hook ]
: s1+ ( nm-mn' ) swap [ d# 1 ] + ; { , , }
 ( custom routes ) [ d# 2 fh load sram d# 4 + load ] { , }
 ( select ) [ pfp0 'pths ! pfp1 'pths d# 1 + ! ] { , ... }
      [ s708 'pths d# 2 + ! ] { , }
 ( vm build tools ) [ d# 4 fh load d# 12 fh load ] { , , }
 ( sram ) [ d# 6 fh load d# 1 ship ] { , }
: !img ( n ) push [ fbuf ] d# 0 begin over 2@ swab { , }
 over sm swap [ d# 2 ] + s1+ next drop drop ;
: !nuc [ chr ] @ 2/ [ d# 1 ] + !img ; { , ... }
      [ d# 1 d# 108 hook !nuc ] { . }
      [ unfoc d# 1 -hook ] { , , }
 ( rest ) [ d# 470 load ] { . }
      [ d# 2 ship ] { . }
      [ panel upd ?ram ] { , }
 }block

( 00270C00 )               D# 451 shadow{ 
 ( customize ide for polyforth development. ) { br }

: pf ( loads polyforth f18 code, nucleus in sram, and starts it up. )
 { br }

 < ***no canonical opcodes*** > { cr }
 [ use the ] 'remote' [ ones ] }block

( 00271000 )               D# 452 code{ 
 ( - custom ide paths ) { , , }
: pfp0 align create [ d# 708 d# 707 to d# 607 d# 207 to ] { , }
 [ d# 206 d# 205 to d# -1 , ] { , , }
: pfp1 align create ( sram ) [ d# 708 d# 108 to d# 107 d# 7 to ] { , }
 [ d# 8 d# 9 to d# -1 , ] }block

( 00271400 )               D# 453 shadow{ 
 ( paths { F } and { 2F } are customized for interactive devel and
 testing of polyforth. ) { , , }
: pfp0 ( is not used by the loading procedures and is available for
 detailed application testing. if more paths are needed in testing,
 stuff new path vectors after ) pf ( is loaded. ) { , , }
: pfp1 ( is used after reset to load and start the sram cluster, then
 boot sram as needed. ) }block

( 00271800 )               D# 454 code{ 
 ( - sram user code from nodes 106, 108, { 19EF } )
: 2lit' ( nn- ) swap lit' lit' ;
: sm ( wa- ) 2lit' [ h# 39 ] ( x! ) call ;
: sem ( wap- ) push 2lit' pop lit' [ h# 3A ] ( ex! ) call ;
: fm ( a-w ) lit' [ h# 3C ] ( x@ ) call
: get ( -w ) upd [ stak ] @ rdrop ;
: fem ( ap-w ) 2lit' [ h# 3D ] ( ex@ ) call get ;
: 4lit' ( nnnn- ) push push 2lit' pop pop 2lit' ;
: cxm ( wapw-f ) 4lit' [ h# 3E ] ( cx? ) call get ; { cr cr }
 ( sram test code )
: fmem ( ap-... ) d# 8 for push dup i fem { indent }
      s1+ pop next drop drop ;
: smem ( wapn- ) for push over over i sem { indent }
      s1+ s1+ pop next drop drop drop ;
: n2x ( wapn- ) 4lit' [ h# 42 ] ( n2x ) call ;
: nqx ( wapn- ) 4lit' [ h# 4A ] ( nqx ) call ; { br }

 }block

( 00271C00 )               D# 455 shadow{ 
 ( this tester code assumes the ide is hooked to one of the sram user
 nodes. ) }block

( 00272000 )               D# 456 code{ 
 ( - ph0 sram setup ) { br }

 ( kill boot nodes { 4F } { 4F } hook { 4F } -hook { 2F } path ) { br }

 ( sram setup ) [ sram d# 2 + load ] { br }

 ( temporary ) [ d# 108 +node d# 1713 /ram left /b ] }block

( 00272400 )               D# 457 shadow{ 
 ( load sram cluster for booting pf nucleus ) { br }

 ( this is done with ide path { 2F } from { 588F } down to { D8F }
 before any of the rest of the chip is set up. ) { br }

 ( after it's completed, the whole rest of the chip can be booted using
 the serpentine path 2. this relatively byzantine method is used instead
 of simply reloading the sram with a more regular path so that the
 methods will still work with external dram. ) { br }

 ( this block leaves path { 2F } connected to sram for use by !pf )
 }block

( 00272800 )               D# 458 code{ 
 }block

( 00272C00 )               D# 459 shadow{ 
 }block

( 00273000 )               D# 460 code{ 
 ( install pf in flash ) [ empty ] { , , }
 [ compile streamer load ] { , }
 [ d# 0 fh loaded ! nores ] { , , }
 ( read pfdisk.blk ) [ d# 2 fh load ] { , ... }
      [ fbuf source ! d# 4607 len ! ] { , }
 ( display nuc length ) { , ... }
      [ len @ d# 1 + d# 2 * d# 8 d# 18 */ leng ! ] { , , }
 [ h# 8000 stream nip ers ] { , ... }
      ( burn nucleus ) [ stream h# 8000 swap burn ] { , , }
 ( generate boot stream ) [ d# 4 fh load ] }block

( 00273400 )               D# 461 shadow{ 
 ( load this block to install polyforth for flash booting. just follow
 instructions. ) { , , }
 ( burns nucleus to flash starting at 32k then ) { , }
 ( generates and burns full chip boot stream. ) }block

( 00273800 )               D# 462 code{ 
 ( - read pf nucleus ) :# ft 0 :# chr 9216
: a-b ( a-b ) 2* 2* ; { * }
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ; { , }
: fbuf ( -a ) [ nnc d# 2 * h# 8000 + block a-b ] ; { , , }
: +pf [ d# 0 fnam b-a ] r/o fopen if [ ft ] ! ; { , }
 then drop abort ;
: -pf [ ft ] @ [ d# 0 ] + if fclose d# 0 then [ ft ] ! ; { , , }
: @nuc +pf [ fbuf ] d# 9216 [ ft ] @ frd [ chr ] ! -pf ; { , , }
 [ named ] ( pf/pfdisk.blk ) { , , }
 [ @nuc ] }block

( 00273C00 )               D# 463 shadow{ 
 }block

( 00274000 )               D# 464 code{ 
 ( - burn pf boot stream ) { cr }
 [ empty ] ( 1st pass ) [ compile streamer load ] { cr }
 [ framer load ] ( the stream ) [ d# 2 fh load ] { br }

 [ empty ] ( 2nd pass ) [ compile streamer load ] { cr }
 [ framer load ] ( the stream ) [ d# 2 fh load ] { br }

 [ d# 0 fh loaded ! ] { cr }
 ( write stream into flash ) { cr { F } }
 ( stream nip ers ) { cr }
 ( display stream length ) [ strlen leng ! ] { , }
 [ stream d# 0 swap 18burn ] }block

( 00274400 )               D# 465 shadow{ 
 ( pf stream ) { br }

 ( two passes required to calculate address ) { cr }
 ( to resume booting from after loading sram ) { cr }
 ( and compile it into node { 582F } ) }block

( 00274800 )               D# 466 code{ 
 ( -- generate pf stream ) { br }

 ( speedup ) { indent }
      [ d# 0 d# 0 d# 3 d# 1608 /root ] { br }

 ( default ) [ entire course ] { cr }
 ( sram driver ) [ sram d# 2 + load ] { , }
 ( flash to sram ) [ d# 2 fh load ] { , }
 [ frame adjust ] ( resume point ) { , , }
 [ fresh ] ( residual ) [ sram d# 4 + load s705 course ] { , ... }
      ( rest of chip ) [ d# 470 load ] { , ... }
      ( retain asynch boot ) [ d# 708 +node h# AA /p ] { , , }
 [ frame ] }block

( 00274C00 )               D# 467 shadow{ 
 }block

( 00275000 )               D# 468 code{ 
 ( --- load polyforth nucleus ) { , }
: /nwire ( in out ) /b /a d# 0 d# 4 [ d# 1711 ] /part d# 0 /p ; { ,
 , }
 [ d# 705 +node d# 1710 /ram h# 19 /p ] { , }
 [ d# 605 +node down left /nwire ] { , }
 [ d# 606 +node left right /nwire ] { , }
 [ d# 607 +node right left /nwire ] { , }
 [ d# 608 +node left up /nwire ] { , }
 [ d# 508 +node up down /nwire ] { , }
 [ d# 408 +node down up /nwire ] { , }
 [ d# 308 +node up down /nwire ] { , }
 [ d# 208 +node down up /nwire ] { , }
 [ d# 108 +node d# 1713 /ram left /b d# 0 /p ] }block

( 00275400 )               D# 469 shadow{ 
 }block

( 00275800 )               D# 470 code{ 
 ( pf load descriptors ) { , }
: l, ( nn ) dup +node d# 100 /mod d# 1 and 2* swap d# 1 and + d# 1714
 + push d# 32 d# 32 pop /part ( warm ) h# A9 /p ;
: ganglia nns for i d# -1 + n-nn l, next ; { , , }
 ( sea of ) [ ganglia ] { , }
 ( snorkel ) [ d# 108 +node d# 1605 /ram left /b h# 37 /p ] { , , }
 ( sram cluster mk1 ) [ sram d# 2 + load ] { , }
 ( virtual machine ) [ d# 2 fh load ] { , }
 ( serial terminal ) [ d# 4 fh load ] { , }
 ( additional i/o ) [ d# 6 fh load ] }block

( 00275C00 )               D# 471 shadow{ 
 ( this block describes entire chip's loading for polyforth boot environment. )
 { , , }
 ( suitable for use with ide loader, streamer, ) { , }
 ( and softsim. ) { , , }
 ( all nodes not otherwise programmed are loaded with ganglia for ad
 hoc routing. ) { , , }
 ( the sram cluster is invoked here for complete documentation although
 it has been loaded ) { , }
 ( earlier and is excluded from the path used by the main stream. )
 }block

( 00276000 )               D# 472 code{ 
 ( - virtual machine ) { br }

 ( buds ) [ d# 205 +node d# 1705 /ram up /b d# 1 /p ] { indent }
      [ d# 5 +node d# 1704 /ram down /b d# 1 /p ] { indent }
      [ d# 206 +node d# 1702 /ram up /b right { 2F } /p ] { indent }
      [ d# 6 +node d# 1701 /ram down /b d# 1 /p ] { br }

 ( bitsy ) [ d# 105 +node d# 1703 /ram ] { indent }
      [ h# FFE0 h# 15555 ] ( 'cold ) [ d# 1 d# 3 /stack ] { indent }
      [ left /b right /a h# 31 /p ] { br }

 ( stack ) [ d# 106 +node d# 1700 /ram ] { indent }
      [ h# FFFF d# 0 d# 0 d# 3 /stack ] { indent }
      [ right /b left /p ] }block

( 00276400 )               D# 473 shadow{ 
 }block

( 00276800 )               D# 474 code{ 
 ( - serial terminal ) { br }

: /wire ( io ) h# 20 d# 1 [ d# 1709 ] /part /b /a [ h# 20 ] /p ; { br }

 [ d# 104 +node d# 1708 /ram h# 20 /p ] { cr }
 [ d# 103 +node left right /wire ] { cr }
 [ d# 102 +node right left /wire ] { cr }
 [ d# 101 +node left right /wire ] { cr }
 [ d# 100 +node d# 1706 /ram h# 20 /p ] { br }

 [ d# 204 +node left up /wire ] { cr }
 [ d# 203 +node right left /wire ] { cr }
 [ d# 202 +node left right /wire ] { cr }
 [ d# 201 +node right left /wire ] { cr }
 [ d# 200 +node d# 1707 /ram h# 20 /p ] }block

( 00276C00 )               D# 475 shadow{ 
 }block

( 00277000 )               D# 476 code{ 
 ( - additional i/o ) { , }
 ( spi ) [ d# 705 +node d# 1606 /ram io /b h# A9 /p ] }block

( 00277400 )               D# 477 shadow{ 
 }block

( 00277800 )               D# 478 code{ 
 }block

( 00277C00 )               D# 479 shadow{ 
 }block

( 00278000 )               D# 480 code{ 
 ( g144a12 ats test components ) { br }

 ( pkg { FA0F } to { FC2F } ) [ d# 482 d# 18 loads ] { cr }
 ( pkg { 1068F } to { 108AF } ) [ d# 518 d# 18 loads ] { cr }
 ( pkg { 1130F } to { 1140F } ) [ d# 554 d# 9 loads ] { br }

 ( ats/ide parts { 960F } to { 96CF } ) [ d# 630 d# 7 loads ] { br }

 ( steven mem-random xxxx { 480F } { 2F } loads ) { cr { AF0F } }
 ( to { AF0F } { 510F } { 2F } loads ) }block

( 00278400 )               D# 481 shadow{ 
 }block

( 00278800 )               D# 482 code{ 
 { FA0F } ( port tests ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 1B org ]
: release ^ 1B ^ @p ! ; ( / ) ; ( / )
: bit ^ 1D ^ ( n-nn ) @p ! dup dup ( / ) @p !p .. ( / ) { cr }
 ! @ or ;
: walk ^ 20 ^ ( n ) d# 17 for bit if pop !b pop { cr }
 release ; then drop 2* next drop ; { cr }
 ^ 28 ^ [ d# 4 org ] { -cr }
: ftst a h# 1FF and h# 13400 or
: tst ^ 08 ^ ( cport ) dup a! ! { cr }
 h# 15554 dup walk dup - walk release dup or !b ;
: trd ^ 0F ^ leap ( tr ) { -cr }
: td ^ 10 ^ @p tst ; -d--
: tdr ^ 12 ^ td { -cr }
: tr ^ 13 ^ then @p tst ; r---
: tdl ^ 15 ^ td { -cr }
: tl ^ 16 ^ @p tst ; --l-
: tru ^ 18 ^ tr { -cr }
: tu ^ 19 ^ @p tst ; ---u { cr }
 ^ 1B ^ [ d# 2000 bin ] }block

( 00278C00 )               D# 483 shadow{ 
 ( port tests )
: bit ( send and receive 1 bit pattern via port )
: walk ( test with pattern shifted left { 24F } times )
: tst ( focus neighbor with a call then ) { cr }
 ( walk with { 2F } bit set and { 2F } bit clear ) { cr }
 ( shifting left on the test node )
: release ( causes node under test to return . ) { cr }
 ( error code { F } for success , ) { cr }
 ( loop index for failure ) { cr }
 parameter ( is ignored ) { br }

 tests ( on single neighbor and on pairs ) { cr }
 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 [ h# 13 ] ( tests the ) [ right ] ( neighbor ) { cr }
 [ h# 10 ] ( tests the ) [ down ] ( neighbor ) { cr }
 [ h# 16 ] ( tests the ) [ left ] ( neighbor ) { cr }
 [ h# 19 ] ( tests the ) [ up ] ( neighbor ) { cr }
 [ h# 15 ] ( tests the ) [ down ] ( and ) [ left ] ( neighbors ) { cr }
 [ h# 12 ] ( tests the ) [ down ] ( and ) [ right ] ( neighbors ) { cr }
 [ h# 18 ] ( tests the ) [ right ] ( and ) [ up ] ( neighbors ) { cr }
 [ h# F ] ( tests the ) [ right ] ( and ) [ down ] ( neighbors ) }block

( 00279000 )               D# 484 code{ 
 { FA2F } ( port tests with 2* ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 1B org ]
: release ^ 1B ^ @p ! ; ( / ) ; ( / )
: bit ^ 1D ^ ( n-nn ) @p ! dup dup ( / ) @p 2* !p .. ( / ) { cr }
 ! 2* @ or ;
: walk ^ 21 ^ ( n ) d# 17 for bit if pop !b pop { cr }
 release ; then drop 2* next drop ; { cr }
 ^ 2A ^ [ d# 4 org ] { -cr }
: ftst a h# 1FF and h# 13400 or
: tst ^ 08 ^ ( cport ) dup a! ! { cr }
 h# 15554 dup walk dup - walk release dup or !b ;
: trd ^ 0F ^ { -cr }
 leap ( tr )
: td ^ 10 ^ @p tst ; -d--
: tdr ^ 12 ^ td { -cr }
: tr ^ 13 ^ then @p tst ; r---
: tdl ^ 15 ^ td { -cr }
: tl ^ 16 ^ @p tst ; --l-
: tru ^ 18 ^ tr { -cr }
: tu ^ 19 ^ @p tst ; ---u { cr }
 ^ 1B ^ [ d# 2001 bin ] }block

( 00279400 )               D# 485 shadow{ 
 ( port tests )
: bit ( send and receive 1 bit pattern via port )
: walk ( test with pattern shifted left { 24F } times )
: tst ( focus neighbor with a call then ) { cr }
 ( walk with { 2F } bit set and { 2F } bit clear )
: release ( causes node under test to return . ) { cr }
 ( error code { F } for success , ) { cr }
 ( loop index for failure ) { cr }
 parameter ( is ignored ) { br }

 tests ( on single neighbor and on pairs ) { cr }
 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 [ h# 13 ] ( tests the ) [ right ] ( neighbor ) { cr }
 [ h# 10 ] ( tests the ) [ down ] ( neighbor ) { cr }
 [ h# 16 ] ( tests the ) [ left ] ( neighbor ) { cr }
 [ h# 19 ] ( tests the ) [ up ] ( neighbor ) { cr }
 [ h# 15 ] ( tests the ) [ down ] ( and ) [ left ] ( neighbors ) { cr }
 [ h# 12 ] ( tests the ) [ down ] ( and ) [ right ] ( neighbors ) { cr }
 [ h# 18 ] ( tests the ) [ right ] ( and ) [ up ] ( neighbors ) { cr }
 [ h# F ] ( tests the ) [ right ] ( and ) [ down ] ( neighbors ) }block

( 00279800 )               D# 486 code{ 
 { FA4F } ( extensive ram test jeff ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 28 org ]
: err [ d# 4 org ]
: test ( n1 ) @p ! @p dup ( ' ) h# 3F push dup dup { cr }
 ! @p ! ( ' ) or dup a! . { cr }
 @p ! ( ' ) begin dup !+ unext .. ^ 0B ^ ( erased ) { cr }
 for { br }

 h# 19999 @p ! dup ( ' ) @p ! @ . { cr }
 ! @p ! . ( ' ) !b @p ! { cr }
 @ or if ^ 12 ^ pop err ; then ^ 13 ^ ( test1 ) { cr }
 h# CCCC dup ! @p ( ' ) @ !b dup dup { cr }
 ! @ or if ^ 18 ^ pop err ; then ^ 19 ^ ( 0 test2 ) { cr }
 @p ! . ( ' ) or ! . ( erased ) { br }

 drop @p ! @p ( ' ) dup ( 0 0 ) - { 7FFFFF } ! h# 3E { cr }
 ! @p ! ( ' ) @+ !b push { 1F } { cr }
 @ - if ^ 21 ^ pop err ; then ^ 22 ^ ( test3 ) { cr }
 drop @p ! ( ' ) begin @+ !b unext . { 1F } { cr }
 h# 3E for @ if pop pop
: err ^ 28 ^ d# 1 + !b ; then ^ 2A ^ ( test4 ) { cr }
 drop next { cr }
 @p ! . . ( ' ) dup !+ . next ( erased ) { cr }
 dup dup or !b ; ^ 30 ^ [ d# 2002 bin ] }block

( 00279C00 )               D# 487 shadow{ 
 ( test tests neighbor's memory ) { br }

 ( tests the tfocused node node's ram. ) { cr }
 [ apocryphal documentation follows ] { br }

 ( 19999 cccc test shorts to bits two bits away ) { cr }
 ( 3ffff { 1F } test shorts to bits one bit away ) { cr }
 ( tests for shorts between two addresses ) { cr }
 ( by reading { 80F } words after each { 7FFFFF } ! ) { cr }
 }block

( 0027A000 )               D# 488 code{ 
 { FA6F } ( testing t and s ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 20 org ]
: echo ^ 20 ^ ( n-n ) @p ! dup .. ( / ) @p - dup .. ( / ) { cr }
 ! @p ! .. ( / ) drop !p .. ( / ) - @ or ; [ d# 4 org ]
: test ^ 04 ^ ( n ) d# 17 for dup echo { cr }
 if pop d# 1 . + !b ; then drop 2* next { cr }
 dup or !b ; ^ 0E ^ [ d# 2003 bin ] }block

( 0027A400 )               D# 489 shadow{ 
 ( testing t and s ) { br }

 ( intended to isolate testing to t and s ) { cr }
 ( non-zero return value identifies bad bit ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) { cr }
 ( loop index for failure ) }block

( 0027A800 )               D# 490 code{ 
 { FA8F } ( testing t and r ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 20 org ]
: echo ^ 20 ^ ( n-n ) @p ! dup .. ( / ) @p - push .. ( / ) { cr }
 ! @p ! .. ( / ) pop !p .. ( / ) - @ or ; [ d# 4 org ]
: test ^ 04 ^ ( n ) d# 17 for dup echo { cr }
 if pop d# 1 . + !b ; then drop 2* next { cr }
 dup or !b ; ^ 0E ^ [ d# 2004 bin ] }block

( 0027AC00 )               D# 491 shadow{ 
 ( testing t and s ) { br }

 ( intended to isolate testing to t and r ) { cr }
 ( non-zero return value identifies bad bit ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) { cr }
 ( loop index for failure ) }block

( 0027B000 )               D# 492 code{ 
 { FAAF } ( testing stack registers ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load d# 6 org ]
: put ( n ) @p ! ! ; ( / ) @p .. ( / )
: get ( -n ) @p ! @ ; ( / ) !p .. ( / )
: stack ^ 0A ^ d# 1 d# 9 for dup put 2* next { cr }
 d# 9 for 2/ get over or if pop d# 1 . + !b { cr }
 pop ; then drop next ; ^ 18 ^ [ d# 4 org ]
: start ( n ) stack dup or !b ; ^ 06 ^ [ d# 2005 bin ] }block

( 0027B400 )               D# 493 shadow{ 
 ( testing stack registers ) { br }

 ( fill the stack registers with unique ) { cr }
 ( numbers and read them back. error code ) { cr }
 ( identifies the register that failed the test. ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) { cr }
 ( loop index for failure ) }block

( 0027B800 )               D# 494 code{ 
 { FACF } ( testing return stack registers ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ^ 04 ^ ahead
: !error ( n ) d# 1 !b ;
: put ^ 07 ^ ( n ) @p ! ! ; ( / ) @p push .. ( / )
: get ^ 09 ^ ( -n ) @p ! @ ; ( / ) pop !p .. ( / )
: fill ^ 0B ^ ( n-n ) d# 8 for - dup put next ;
: check ^ 11 ^ ( n-f ) leap - then fill - { cr }
 d# 9 for - get over or .. if !error pop ; { cr }
 then drop next ;
: test ( n ) then d# 0 check h# 15555 check { cr }
 ( .. ) h# 19999 check h# 33333 check { cr }
 ( .. ) dup or !b ; { cr }
 ^ 26 ^ [ d# 2006 bin ] }block

( 0027BC00 )               D# 495 shadow{ 
 ( testing return stack registers ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then read back and verify each pattern ; relies
 on ) s ( and ) t ( of uut ) { cr }
 ( and instructions ) @p !p push pop ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , { 2F } for failure ) { br }

 ( comment ) - ( after ) fill ( to force failure ) }block

( 0027C000 )               D# 496 code{ 
 { FAEF } ( mark ram test { 190F } node ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: store @p ! ; .. ( / ) !+ .. ( / )
: fetch ( -n ) @p ! @ ; ( / ) @+ !b drop .. ( / )
: /neighbor d# 4 for @p ! unext ;
: /stack ^ 0C ^ h# 15555 { 55555F } dup - over over over { cr }
 over over over over over over .. ^ 11 ^ ; { br }

: go ( entry ) ^ 12 ^ then /neighbor /stack
: testmem ^ 14 ^ d# 3 { 1FFFEF } for { cr }
 @p ! drop .. ( / ) dup or a! .. ( / ) { cr }
 h# 3F for store next h# 3F for fetch or if { indent }
      pop pop d# 3 { 1FFFEF } or d# 1 . + !b ; { cr }
 then drop next next { cr }
 ( good ) h# 0 { 2468BF } !b ; ^ 29 ^ [ d# 2007 bin ] }block

( 0027C400 )               D# 497 shadow{ 
 ( worst case ram test looking for store failures when driving weak
 inverter high. ) [ this test preserves b, a, and p. ] { br }

: store ( makes target store next value in next wd )
: fetch ( makes target return next word in ram )
: /stack ( executed in either node sets stack to alternating { 2AAABF }
 and { 55555F } with { 2AAABF } on top. )
: /neighbor ( feeds ) /stack ( to target node. doesn't pass the last
 word - return. ) { br }

: go ( sets both nodes' stacks that way then begins the ) testmem
: testmem ( runs test cycles, must do at least 2. each cycle switches
 polarity { 2AAABF } or { 55555F } for first word stored, then stores
 alternating values into all ram in target. reads back and compares.
 if all cycles run ok, returns zero status. otherwise returns the { 2F }
 relative cycle number in which the failure occurred. ) }block

( 0027C800 )               D# 498 code{ 
 { FB0F } ( mark r d stack test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: store dup ! dup ! dup ! ! ;
: fetch ( -n ) @p ! @ ; ( / ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack dup - over .. ( / ) over over ( - ) { cr }
 over .. ( / ) over over over .. ( / ) over .. ( / ) ;
: t-stk ^ 14 ^ { cr }
 dup /neighbor /stack ^ 16 ^ { cr { 1FFFDF } }
 d# 8 for { cr }
 @p .. push push push .. store { cr }
 fetch drop @p .. pop pop pop .. store { cr cr }
 d# 9 for fetch or .. if pop pop h# FFFF and pop drop !b ; then drop
 { cr }
 next next ; { cr }
 then ^ 2B ^ [ h# 2B org ]
: full ^ 2B ^ h# 2AAAA t-stk dup or t-stk h# 33333 t-stk h# 19999 t-stk
 dup or t-stk { 1F } dup or !b ; { cr }
 ^ 36 ^ [ d# 2008 bin ] }block

( 0027CC00 )               D# 499 shadow{ 
 ( testing return and data stacks registers ) { cr }
 ( also mulitple overs pops and pushes in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then push to return stack then pop to data stack
 then read back and verify each pattern ; relies on ) b s t r r-stack
 ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) @p !b over push pop ( in the port ) { br }

 [ address h# 2B ]
: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , next count for failure ) { br }

 ( comment ) - ( in ) [ /stack ] ( after ) over ( to force failure )
 }block

( 0027D000 )               D# 500 code{ 
 { FB2F } ( +* a shift test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: !error ( n ) d# 1 !b ;
: init ( s ) @p ! ! ; ( / ) @p .. ( / )
: check ( an-a ) over or if !error pop pop ; { cr }
 then drop ;
: step ( tan-t'a' ) push .. { cr }
 @p ! ! .. ( / ) @p a! @p .. ( / ) { cr }
 ! @p ! . ( / ) +* !p a !p ( / ) @ @ pop check ;
: start then { cr }
 d# 1 init d# 0 h# 15555 h# 2AAAA step h# 15555 step { cr }
 ( ...... ) d# 0 h# 19999 h# 2CCCC step h# 16666 step { cr }
 d# 2 init d# 0 h# 15555 h# AAAA step h# 25555 step { cr }
 ( ...... ) d# 0 h# 19999 h# CCCC step h# 26666 step { cr }
 dup or !b ; { cr }
 ^ 35 ^ [ d# 2009 bin ] }block

( 0027D400 )               D# 501 shadow{ 
 ( testing a shifts by ) +* { br }

 ( tests the { 8F } combinations of shifting 1/0 ) { cr }
 ( from t for add/notadd behavior of +* . the ) { cr { 33333F } }
 ( group checks the double shift error seen previously ; relies on )
 s ( and ) t ( of uut ) { cr }
 ( and instructions ) @p !p +* a a! ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , { 2F } for failure ) { br }

 ( replace pattern before ) step ( with ) d# 0 { cr }
 ( to force failure ) }block

( 0027D800 )               D# 502 code{ 
 { FB4F } ( t s a and r data path tests ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: check or if pop !b pop ; then drop ;
: -t- ( n ) dup @p ! .. ( / ) @p !p .. ( / ) ! @ ( 2* ) check ;
: -s- ( n ) dup @p ! dup ( / ) @p @p !p !p ( / ) { cr }
 ! ! @ drop @ ( 2* ) check ;
: t-a ( n ) dup @p ! .. ( / ) @p a! a !p ( / ) { cr }
 ! @ ( 2* ) check ;
: t-r ( n ) dup @p ! .. ( / ) @p push pop !p ( / ) { cr }
 ! @ ( 2* ) check ;
: start then ^ 19 ^ h# 3FFFF dup - h# 2AAAA { cr }
 dup - h# 33333 dup - h# 6666 dup - dup dup drop { cr }
 d# 256 for drop -t- ^ 24 ^ -s- ^ 25 ^ { cr }
 ( ............ ) t-a ^ 26 ^ t-r ^ 27 ^ next dup or !b ; ^ 29 ^ [ d# 2010
 bin ] }block

( 0027DC00 )               D# 503 shadow{ 
 ( testing t s a and r data paths ) { br }

 ( does { 40F } reps of { 10F } patterns between t and ) { cr }
 ( the other registers; relies on instructions ) { cr }
 @p !p a! a push pop ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, address after ) { cr }
 ( test for failure ) { br }

 ( uncomment ) 2* ( in each test to force failure ) }block

( 0027E000 )               D# 504 code{ 
 { FB6F } ( gpio pin test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: !it ( n ) ^ 05 ^ @p drop !p ;
: its ( n-n ) ^ 06 ^ d# 0 and ;
: ++ ^ 08 ^ d# -1 { -cr }
: !io its ! ; { -cr }
: -- h# 2AAAA !io ;
: 500ns ( n ) ^ 0E ^ d# 199 for unext ;
: .hi ( -n ) ^ 11 ^ d# 15 for @ its if { cr }
 drop pop ; then drop next dup dup or ;
: .lo ^ 18 ^ for @ h# 2AAAA and its while drop next { cr }
 dup dup or ; then drop pop ;
: start ( n ) ^ 20 ^ then !it io a! { cr }
 ++ 500ns ( wpd ) h# 15555 !io d# 8191 .lo { cr }
 d# -16 -- and 500ns ++ .hi or 500ns { cr }
 2* -- 2* 2* 2* d# 15 .lo or !b ; { cr }
 ^ 34 ^ [ d# 2011 bin ] }block

( 0027E400 )               D# 505 shadow{ 
 ( drive test of a single gpio pin whose control bits are nonzero in
 the argument. ) { br }

 ( while testing a pin any other pins are set at high impedance so
 we can prove all three drive transistors work for this pin and detect
 any opens. other tests look for shorts between pins ) }block

( 0027E800 )               D# 506 code{ 
 { FB8F } ( mark d stack test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: fetch ( -n ) @p ! @ ; ( // ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack ^ 0C ^ dup - over .. ( / ) over over { cr }
 over .. ( / ) over over over .. ( / ) over ( - ) . .. ( / ) ;
: d-stack ^ 11 ^ h# 8 for dup - /neighbor /stack ^ 16 ^ next { cr }
 d# 12 { 1F } for drop fetch or if pop pop h# FFFF and ( !b ) pop ( and )
 drop !b ; then { cr }
 next ; { cr }
 ^ 21 ^ [ h# 2A org ] then
: full ^ 2A ^ h# 2AAAA d-stack dup or d-stack h# 33333 d-stack h# 19999
 d-stack dup or d-stack { cr }
 !b ; ^ 35 ^ [ d# 2012 bin ] }block

( 0027EC00 )               D# 507 shadow{ 
 ( testing data stack registers ) { cr }
 ( also overs in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then read back and verify each pattern ; relies
 on ) b s t ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) @p !b over ( in the port ) { br }

 [ address h# 2A ]
: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , next count for failure ) { br }

 ( comment ) - ( in ) [ /stack ] ( after ) over ( to force failure )
 }block

( 0027F000 )               D# 508 code{ 
 { FBAF } ( io data path tests ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: check ( nn ) or if pop !b pop ; then drop ;
: t-io ( mn-m ) h# 15555 or dup @p ( / ) @p ! @ !p ( / ) { cr }
 ! ! @ or over and over check ;
: start ( m ) then ^ 0E ^ if d# 0 for { cr }
 io @p ! .. ( / ) @p a! .. ( / ) ! { cr }
 dup t-io ^ 16 ^ d# 0 t-io ^ 18 ^ next then dup or !b ; ^ 1A ^ [ d# 2013
 bin ] }block

( 0027F400 )               D# 509 shadow{ 
 ( testing io data path ) { br }

 ( checks that the masked bits return their ) { cr }
 ( inverse ; relies on ) a ( of uut ) { cr }
 ( and instructions ) @p !p ! @ ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is a mask for the io bits ) { cr }
 ( to be tested . error code { F } for success, ) { cr }
 ( test's return address for failure ) { br }

 ( include unwritable bits in the mask ) { cr }
 ( to force failure ) }block

( 0027F800 )               D# 510 code{ 
 { FBCF } ( set/clear carry test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] { br }

 [ h# 2A org ] ( test tools )
: +c ^ 2A ^ ( n-c ) a h# 200 or !
: +@ ^ 2D ^ ( n-c ) @p ! dup . ( / ) . . . @p ( / ) { cr }
 ( .. ) ^ 2F ^ ! @p ! . ( / ) @p . + !p ( / ) ! @ a ! ;
: ?t ^ 33 ^ ( c ) or if pop !b pop then drop ; ^ 36 ^ { br }

 [ h# 4 org ] ( test start ) { cr }
 ^ 04 ^ ( post args ) push h# 20000 h# 0 begin { cr }
 ^ 07 ^ ( clr nxt ) dup +c ( ign was ) drop .. { cr }
 ^ 09 ^ ( set nxt ) over +c ( tst clr ) over ?t { cr }
 ^ 0B ^ ( set nxt ) over +c ( tst set ) h# 1 ?t { cr }
 ^ 0E ^ ( clr nxt ) dup +c ( tst set ) h# 1 ?t { cr }
 ^ 11 ^ ( clr nxt ) dup +c ( tst clr ) over ?t { cr }
 ^ 13 ^ ( nop nxt ) over +@ ( see nop ) over ?t { cr }
 ^ 15 ^ ( set nxt ) over +c ( tst clr ) over ?t { cr }
 ^ 17 ^ ( nop nxt ) dup +@ ( see nop ) over ?t { cr }
 ^ 19 ^ ( clr nxt ) dup +c ( tst set ) h# 1 ?t { cr }
 ^ 1C ^ next ( pass ) !b drop ; { cr }
 ^ 1E ^ [ d# 2014 bin ] }block

( 0027FC00 )               D# 511 shadow{ 
 ( test ) p9 ( control of carry ) { br }

 ( verify that neighbor carry can be set or ) { cr }
 ( cleared under control of p9 and that carry is preserved when p9
 is zero. ) { br }

 ( depends upon uut ) p9 cry s ( and ) t ( as well as ) { cr }
 ( uut ) jump @p !p . + ( in port. ) { cr }
 ( test starts at ) ^ 04 ^ ( with loop count input. ) { cr { 18F } }
 ( words of ram are unused. ) { cr }
 ( error code is ) ?t ( return address. ) { cr }
 ( verify by defeating any ) ?t ( parameter. ) { br }

: +@ ( calculate n+n in test node, returning c ) { cr }
 ( then clear tested's p9. )
: +c ( set p9 in test node prior to add. )
: ?t ( match result to expected and abort with ) { cr }
 ( call address as return code in case of error. ) [ note ] ( that
 loop count will clear high ) r ( bits. ) }block

( 00280000 )               D# 512 code{ 
 { FBEF } ( mark @p test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ^ 04 ^ ahead { cr }
: seq ( -n ) ^ 05 ^ d# 63 .. a push d# 6 a! { cr }
 if dup d# -1 . + ! pop a! ; { cr }
 then drop d# 63 ! pop a! ( @p!bunext; ) h# 5B75 ;
: init ^ 11 ^ @p ! @p .. ( / ) @p a! .. ( / ) [ d# 1 , ] ! { cr }
 d# 63 for seq @p ! ! .. ( / ) @p !+ .. ( / ) next { cr }
 @p ! a .. ( / ) @p push .. ( / ) { cr }
 ! @p ! @p ( / ) @p push .. ( / ) [ d# 63 , ] { cr }
 ! @p ! ; ( / ) dup or push ; ( / )
: /@p ( n ) ^ 21 ^ then init { cr }
 d# 63 for @ seq ( - ) or .. if pop !b ; { cr }
 then drop next dup or !b ; { cr }
 ^ 2A ^ [ d# 2015 bin ] }block

( 00280400 )               D# 513 shadow{ 
 ( testing @p ) { br }

 ( does { 80F } reps of @p on target covering all ram addresses; relies
 on target port instructions; ) @p a! !+ dup or push ; { cr }
 ( relies on target ram instructions; ) { cr }
 @p !b unext ; { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, target address ) { cr }
 ( for failure ) { br }

 ( uncomment ) - ( to force failure ) }block

( 00280800 )               D# 514 code{ 
 { FC0F } ( test i-ad and r-ad data paths ) { cr }
 ( creeper ) [ reclaim d# 2 node d# 1344 load ] { br }

 ( test start ) { cr }
 ^ 04 ^ ( @p; ) h# 5500 d# 63 for .. { cr }
 ^ 07 ^ pop dup push dup @p ! ! .. ( / ) @p dup a! @p ^ 0A ^ over or
 @p .. ( / ) ! b! @b !p ( / ) { cr }
 ^ 0C ^ over ! ! @ ( - ) or .. if pop h# 40 or !b ; { cr }
 ^ 12 ^ then drop next { cr }
 ^ 13 ^ a @p ! .. ( / ) @p b! .. ( / ) ! .. ( dup or !b ; ) { cr }
 ^ 16 ^ ( call ) h# 12000 d# 63 for .. { cr }
 ^ 19 ^ dup ! d# 1 @p ( / ) !p .. ( / ) ! . + dup { cr }
 ^ 1D ^ @ ( - ) or h# 3F and if pop h# 80 or !b ; { cr }
 ^ 23 ^ then drop next ( dup or !b ; ) { cr }
 ^ 24 ^ ( ex { 24081F } ) dup d# 63 for .. { cr }
 ^ 26 ^ @p ! ! @p ( / ) @p push ex ( / ) [ d# 1 , ] { cr }
 ^ 29 ^ @p ! . + ( / ) !p .. ( / ) @ over ( - ) or h# 3F { cr }
 ^ 2D ^ and if pop drop h# C0 or !b ; { cr }
 ^ 31 ^ then drop dup .. next dup or !b ; { br }

 ^ 34 ^ [ d# 2016 bin ] }block

( 00280C00 )               D# 515 shadow{ 
 ( test 8,5-0 of ) i ( and ) r ( to adrs bus ) { br }

 ( verify adrs drivers for above bits in uut. ) { cr }
 ( 1. using ) a ( set ) [ @p ; n ] ( in ram, where ) [ n ] ( is ) { cr }
 ( -- loc of same word. chk ram via ) b ( and ) { cr }
 ( -- return error code ) < 40+n > ( if fail. ) { cr }
 ( 2. for ) [ n ] ( of ) < 0-3f > ( store ) [ call-n ] ( / ) [ !p .. ]
 ( into ) { cr }
 ( -- port and read back and confirm that data ) { cr }
 ( -- have the same low order { CF } bits as the next -- call we are
 to send. return error code ) { cr }
 ( -- ) < 80+n > ( if fail. ) { cr }
 ( 3. same as test { 4F } using ) [ ex ] ( instead of ) [ call ] { cr }
 ( -- return error code ) < c0+n > ( if fail. ) { br }

 ( test starts at ) ^ 04 ^ ( with ignored input. ) { cr }
 ( depends upon uut ) a b r s t ( and ) ram ( as well as uut ) call
 ex ; @p !p . push dup a! b! ! @b ( in ram or port. ) { br }

 ( failure is forced by uncommenting ) [ - ] ( in ) { cr }
 ( each test ) }block

( 00281000 )               D# 516 code{ 
 { FC2F } ( rom checksum ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ]
: start ( n ) ^ 04 ^ d# 0 d# 63 for pop dup push h# 80 . + { cr }
 @p .. ( / ) @p a! @ !p ( / ) ! ! @ or next { cr }
 or if d# 1 then !b ; { cr }
 ^ 11 ^ [ d# 2017 bin ] }block

( 00281400 )               D# 517 shadow{ 
 ( rom check sums ) { br }

 ( does an xor checksum of the { 80F } target node rom locations ;
 relies on instructions ) { cr }
 @p !p a! a ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is expected checksum ) { cr }
 ( error code { F } for success, { 2F } for failure ) { br }

 [ d# 0 test ] ( to force failure ) }block

( 00281800 )               D# 518 code{ 
 { 1068F } ( parallel port pin test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: return ( n ) pop dup b! push !b ;
: chk ( nn ) ^ 07 ^ or { cr }
 if pop pop drop pop drop return ; { cr }
 then drop ;
: write ( n ) ^ 0C ^ ( out ) h# 15555 !b ! ;
: 50ns ( -n ) ^ 0E ^ d# 18 { 42F } for unext ( ; )
: sample ( -n ) ^ 11 ^ ( in ) h# 14555 !b .. @ ( out ) h# 15555 !b
 ;
: 300ns ( -n ) ^ 15 { ECF } ^ d# 87 for unext sample ;
: once ( n-n' ) ^ 18 ^ { cr }
 dup write 50ns d# 0 chk ^ 1C ^ 300ns over chk ^ 1E ^ { cr }
 d# 0 write 50ns over chk ^ 22 ^ 300ns d# 0 chk ^ 25 ^ 2* ;
: start ( n ) ^ 26 ^ then { cr }
 d# 0 data a! io b! write 300ns d# 0 chk ^ 2E ^ { cr }
 d# 1 d# 17 for once next drop !b dup or return ; { cr }
 ^ 35 ^ [ d# 2100 bin ] }block

( 00281C00 )               D# 519 shadow{ 
 ( parallel port pin test ) { br }

 ( walking ones test of parallel port pins in ) { cr }
 ( nodes { EF } and { 12F } , detects opens shorts and weak drive transistors
 . ) { br }

 [ address h# 4 ] ( tests active node given arg which is ending io
 value. ) [ note purpose is to control wr bit setting and if the bit
 does not work in either node the test will fail in one of em. ] { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr }
 ( test's return address for failure ) { br }

 ( force an 'open pad' failure by running ) { cr }
 ( the test on node { 12F } of a chip with sram ) { cr }
 ( connected ) { br }

 ( force a 'short' failure by temporarily ) { cr }
 ( connecting a pin to power ground or a ) { cr }
 ( neighbor pin ) }block

( 00282000 )               D# 520 code{ 
 { 106AF } ( mark @b !b test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ahead
: /t ^ 05 ^ ( n ) dup - .. ( / ) @p ! ! ; ( / ) @p .. ( / )
: /b! ^ 08 ^ ( n ) @p ! ! ; ( / ) @p b! .. ( / )
: /!b ^ 0A ^ ( n ) @p ! ! ; ( / ) @p !b .. ( / )
: /@b ^ 0C ^ ( -n ) @p ! @ ; ( / ) @b !p .. ( / )
: end @p ! a . ( / ) @p b! .. ( / ) ! !b ;
: init ^ 11 ^ then @p ! @p .. ( / ) dup or a! . [ d# 63 , ] { cr }
 ^ 14 ^ @p ! ! .. ( / ) ^ 15 ^ @p push .. ^ 16 ^ ( / ) { cr }
 @p ! .. ( / ) ^ 17 ^ begin a - !+ unext .. ^ 18 ^ ( / ; ) { cr }
 d# 1 dup { 7DF } h# 3F for over . + /t dup /b! dup /!b next ( ; )
: chk-a ^ 21 ^ d# 1 dup h# 3F for over . + /t dup /b! dup /@b or ..
 if pop d# -1064 . + - !b pop drop ; then drop next
: b-adr d# 0 end ; { cr }
 ^ 32 ^ [ d# 2101 bin ] }block

( 00282400 )               D# 521 shadow{ 
 ( b-adr-data test; b-reg adr paths to ram and data path from t to
 ram and ram to t using b-reg ) { br }

 ( uses !+ to fill ram with -1 to -40 ) { cr }
 ( next uses b to change ram to { F } to 3f ) { cr }
 ( next checks to see if ram successfully changed ; relies on instructions )
 { cr }
 @p ( / ) @p b! ( / ) @b !p ( / ) @p push ( / ) dup or a! ( / ) { cr }
 a - !+ unext ( / in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr }
 ( address + { 7D0F } of failure for failure ) { br }

 ( uncomment { 7DF } and comment ) h# 3F ( in )
: init ( to force failure ) }block

( 00282800 )               D# 522 code{ 
 { 106CF } ( mark t to b reg test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] ( ahead { 25F } ) [
 h# 14 org ]
: end ^ 14 ^ @p ! a . ( / ) @p b! .. ( / ) ! !b ;
: /t ^ 17 ^ ( n ) dup - .. ( / ) @p ! ! .. ( / ) @p .. ( / ) ;
: /b! ^ 1B ^ ( n ) @p ! ! .. ( / ) @p b! .. ( / ) ;
: /!b ^ 1E ^ ( n ) @p ! ! .. ( / ) @p !b .. ( / ) ;
: /@b ^ 21 ^ ( -n ) @p ! @ .. ( / ) @b !p .. ( / ) ;
: chk-a ^ 24 ^ h# 3F and dup dup /t /b! /@b or ( - ) .. if drop d# 1000
 . + end pop pop pop ; then ;
: 2chk dup dup chk-a drop drop - chk-a drop drop chk-a ; ^ 36 ^ [ h# 4
 org ]
: init ( then ) @p ! .. ( / ) dup or a! .. ( / ) { cr }
 h# 3F .. ( / ) ^ 08 ^ @p ! ! .. ( / ) ^ 09 ^ @p push .. ^ 0A ^ ( / )
 { , }
 @p ! .. ( / ) ^ 0B ^ begin a !+ unext .. ^ 0C ^ ( / )
: b-reg ^ 0C ^ dup or 2chk h# AA 2chk h# 33 2chk h# 19 2chk { cr }
 ^ 14 ^ ( end ; ) { cr }
 [ d# 2102 bin ] }block

( 00282C00 )               D# 523 shadow{ 
 ( b-reg testing t to b-reg ) { br }

 ( uses !+ to fill ram with { 1F } to { 7FF } ) { cr }
 ( next puts { 1F } on t and -1 on s ) { cr }
 ( next puts the { 1F } into b and does a @b with -1 on t ) { cr }
 ( next checks if t contains { 1F } ) { cr }
 ( then does this for { 7FF } , { 1F } and other numbers ; relies on
 instructions ) { cr }
 @p ( / ) @p b! ( / ) @b !p ( / ) @p push ( / ) dup or a! ( / ) { cr }
 ( / ) a !+ unext ( / in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr }
 ( address + { 7D0F } of failure for failure ) { br }

 ( uncomment - in )
: chk-a ( to force failure ) }block

( 00283000 )               D# 524 code{ 
 { 106EF } ( mark port to i-reg test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 1A org ]
: chk ^ 1A ^ or if pop d# 1000 !b ; then ;
: rets @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! @p ( / ) dup dup or . ( / ) push push . . ( / ) !
: init ^ 24 ^ h# 15555 dup - over over ( - ) over over { cr }
 ( . 2/ . ) over .. @p ! ! . ( / ) @p a! @p @p ( / ) { cr }
 .. ! ! @p . ( / ) @p @p . . ( / ) ! ( . ) ! ! ;
: code ^ 2D ^ @p - dup . ( / ) begin a! !p drop unext ( / ) - over
 ! ! @ push ( / ) ! pop ; ( ; - @p dup ) { cr }
: -code ^ 32 ^ @p dup - dup ( / ) a! - @p dup ( / ) push ! ! ! pop
 ! ; ( / ; !p drop unext ) { br }

 ^ 36 ^ [ h# 4 org ]
: i-reg ^ 04 ^ rets ( ; ) code over chk drop { cr }
 ^ 08 ^ .. ( / ) @p ! @ . ( / ) a !p !p .. ( / ) { cr }
 ^ 0A ^ - chk drop @ - chk ( / end first check ) { cr }
 ^ 0D ^ rets .. ( / ) @p ! @p . ( / ) pop pop drop . ( / ) push ..
 ( / ) ! dup dup -code { cr }
 ^ 13 ^ ( / ) @p ! @ ( . ) .. ( / ) !p !p !p .. ( / ) { cr }
 chk drop @ chk drop @ chk ( end second check ) { cr }
 !b ; ^ 1A ^ [ d# 2103 bin ] }block

( 00283400 )               D# 525 shadow{ 
 ( port testing port to i-reg ) { br }

 ( uses the instruction / ) a! !p drop unext ( / ) { cr }
 ( first the inverse instruction is sent then the instruction then
 the inverse instruction again ) [ note ] ( the inverse of ) a! ( is )
 ; { cr }
 ( next the inverse of instruction / ) a! - @p dup ( is used, except
 for the ) a! ( / ) { cr }
 [ note ] ( the pre and post instructions begin with ) ; ( and don,t
 effect the stack ) { cr }
 ( after each triplet the stack is checked; ) { cr }
 ( relies on instructions ) { cr }
 @p dup push . ( / ) dup dup or . ( / ) push push .. ( / ) @p a! @p
 @p ( / ) @p @p . . ( / ) a !p !p . ( / ) { cr }
 pop pop drop . ( / ) push .. ( / ) { cr }
 ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00283800 )               D# 526 code{ 
 { 1070F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 27F } h# 17 org ]
: chk ^ 17 ^ or if pop pop d# 1000 { 2001F } !b ; then drop ;
: init ^ 1C ^ h# 3807 dup 2* dup 2* dup dup { cr }
 2* dup dup 2* dup dup { cr }
 .. @p ! @p . ( / ) @p @p @p . ( / ) [ h# 12345 , ] ( . 2/ . ) ! !
 ! ;
: read ^ 25 ^ ( / ) @p ! @ . ( / ) !p !p !p . ( / ) @ @ ; { br }

: code ^ 28 ^ ( / ) @p ; ( / ) and @b and @p ( / )
: -code ^ 2A ^ ( / ) @p ; ( / ) @b and @b + ( / ) { br }

: run ^ 2C ^ -code ! ( . ) ! ! ( . ) code ! ( . ) ! ! ( . ) { cr }
 -code ! ( . ) ! ! ( . ) ; { cr br }

 ^ 32 ^ [ h# 4 org ]
: i-reg ^ 04 ^ init run read h# 12345 chk h# 10020 chk h# 1502A chk
 { cr }
 dup or !b ; ^ 0E ^ [ d# 2104 bin { 13027F } ] }block

( 00283C00 )               D# 527 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions / ) and @b and + ( / ) { cr }
 ( and ) @b and @b + ( checked; ) { cr }
 ( relies on instructions ) { cr }
 @p dup push . ( / ) dup dup or . ( / ) push push .. ( / ) @p a! @p
 @p ( / ) @p @p . . ( / ) a !p !p . ( / ) { cr }
 pop pop drop . ( / ) push .. ( / ) { cr }
 ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00284000 )               D# 528 code{ 
 { 1072F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 1A org ]
: chk ^ 1A ^ or if pop pop d# 1000 { 2001F } !b ; then drop ;
: init ^ 1F ^ { cr }
 dup or - dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p push @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! ! ; { cr }
: 3code ^ 29 ^ ( / ) @p dup dup . ( / ) - - - . ( / !p !p !p ; )
: run ^ 2B ^ push ! - ! @ @ @ pop ! { cr }
 .. ( / ) @p ! @ . ( / ) !p !p !p . ( / ) @ @ ; { br }

 ^ 31 ^ [ h# 4 org ]
: i-reg ^ 04 ^ init 3code h# 3FFC0 chk h# 3FFE0 chk h# F chk h# 3FFF8
 chk h# 3FFFC chk h# 1 ( - ) chk { cr cr }
 dup or !b ; ^ 13 ^ [ d# 2105 bin ] }block

( 00284400 )               D# 529 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions / ) - - - . ( / ) !p !p !p ; ( / relies on
 instructions ) { cr }
 ( / ) !p !p !p . ( / ) @p @p @p @p ( / ) @p push @p @p ( / . in the
 port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00284800 )               D# 530 code{ 
 { 1074F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 18 org ]
: chk ^ 18 ^ or if pop pop d# 1000 !b ; then drop ;
: init ^ 1D ^ dup or - dup 2* dup 2* dup 2* { cr }
 dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 .. ( / ) ! @p ! . ( / ) push @p a! @p ( / ) { cr }
 ^ 27 ^ ! ! @p . ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! ! ; { cr }
: 2code ^ 2B ^ ( / ) @p - dup . ( / ) !p - a! . ( / - !p ; ; )
: run ^ 2D ^ - over push push ! @ pop ! @ pop ! @ { cr }
 .. ( / ) @p ! @ . .. ( / ) a !p !p . ( / ) @ .. ; { br }

 ^ 35 ^ [ h# 4 org ]
: i-reg ^ 04 ^ init 2code h# 3FF00 chk h# 3F chk h# 7F chk h# 3FFE0
 chk h# F chk { cr }
 dup or !b ; ^ 11 ^ [ d# 2106 bin ] }block

( 00284C00 )               D# 531 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) !p - a! . ( / ) - !p ; ; ( / ) { cr }
 ( relies on instructions ) { cr }
 ( / / ) @p dup push . ( / ) push @p a! @p ( / ) { cr }
 ( / ) @p @p @p @p ( / ) a !p !p . ( / ) { cr }
 ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00285000 )               D# 532 code{ 
 { 1076F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 31F } h# 17 org ]
: chk ^ 17 ^ or if pop pop d# 1000 { 2001F } !b ; then drop ;
: init ^ 1C ^ { cr }
 dup or - dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! . ( / ) push @p a! . ( / ) { cr }
 ^ 23 ^ ! @p ! . ( / ) @p @p @p @p ( / . 2/ . ) ! ! ! ! ; { cr }
: 1code ^ 27 ^ ( / ) @p - dup . ( / ) - a! - . ( / !p ; !p ; )
: run ^ 29 ^ ! @ ( ; ) push dup - ! ! pop @ { cr }
 .. ( / ) @p ! @ . ( / ) !p a !p . ( / ) @ ;
: 0code ^ 2F ^ ( / ) @p - dup . ( / ) a! - . . ( / ; !p c c )
: 0run ^ 31 ^ - over ! ! ! { cr }
 .. ( / ) @p ! @ . ( / ) a !p !p !p ( / ) @ @ ; { br }

 ^ 36 ^ [ h# 4 org ]
: i-reg ^ 04 ^ init 1code h# 1 chk h# 3FFF8 chk d# 3 chk h# 3FFFF chk
 { cr }
 ^ 0E ^ init 0code h# 3FFFC chk h# 1 chk h# 3FFFF chk { cr }
 dup or !b ; ^ 17 ^ [ d# 2107 bin ] }block

( 00285400 )               D# 533 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) a! - . . ( / ) ; !p c c ( / ) { cr }
 ( / ) - a! - . ( / ) !p ; !p ; ( / ) { cr }
 @p dup push . ( / ) dup dup or . { cr }
 ( relies on instructions ) { cr }
 ( / ) a !p !p !p ( / ) !p a !p . ( / ) @p @p @p @p { cr }
 ( / ) push @p a! . ( / ) @p dup push . ( / ) { cr }
 ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00285800 )               D# 534 code{ 
 { 1078F } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 15 org ]
: chk ^ 15 ^ or if pop pop d# 1000 { 2001F } !b ; then drop ;
: init ^ 1A ^ { cr }
 dup or - dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! . ( / ) push @p a! . ( / ) { cr }
 ^ 21 ^ ! @p ! . ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! ; { cr }
: +code ^ 25 ^ ( / ) @p - dup . ( / ) a! a! a! . ( / ; ; ; ; )
: +run ^ 27 ^ - over ! ! ! { cr }
 .. ( / ) @p ! @ . ( / ) a !p !p . ( / ) @ ; { br }

 ^ 2C ^ [ h# 4 org ]
: i-reg ^ 04 ^ init +code h# 3FFF8 chk h# 3FFFC chk { cr }
 ^ 0A ^ dup or !b ; ^ 0B ^ [ d# 2108 bin ] }block

( 00285C00 )               D# 535 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) a! a! a! . ( / ; ; ; ; / ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p dup push . ( / ) push @p a! . ( / ) { cr }
 ( / ) @p @p @p @p ( / ) a !p !p . ( / ) { cr }
 ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00286000 )               D# 536 code{ 
 { 107AF } ( mark port to i-reg-bit-short test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 15 org ]
: chk ^ 15 ^ or if pop pop d# 1000 !b ; then drop ;
: init ^ 1A ^ dup or - dup 2* dup 2* dup 2* { cr }
 dup 2* dup 2* dup 2* dup 2* dup 2* ( / ) { cr }
 .. ( / ) @p ! a . ( / ) @p dup push . ( / ) { cr }
 ( / ) ! @p ! . ( / ) push @p a! @p ( / ) { cr }
 ^ 23 ^ ! ! @p . ( / ) @p @p @p @p ( / ) ! ( . 2/ . ) ! ! ! ! ; { cr }
: -code ^ 27 ^ ( / ) @p ; ( / ) @p @p @p ; ( / )
: +code ^ 29 ^ ( / ) @p ; ( / ) a! a! a! . ( / ; ; ; ; )
: -run ^ 2B ^ +code ! -code ! ( . ) ! ! ! ( . ) +code ! { cr }
 .. ( / ) @p ! @ . ( / ) a !p !p !p . ( / ) @ @ ; { br }

 ^ 33 ^ [ h# 4 org ]
: i-reg ^ 04 ^ init -run h# 3FF80 chk h# 3FFC0 chk h# 3FFFC chk { cr }
 dup or !b ; ^ 0D ^ [ d# 2109 bin ] }block

( 00286400 )               D# 537 shadow{ 
 ( i-reg-bits testing port to i-reg for ) { cr }
 ( shorted adjacent bits ) { br }

 ( uses the instructions ) { cr }
 ( / ) @p @p @p ; ( / ) a! a! a! . ( / ) ; ; ; ; ( / ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p dup push . ( / ) push @p a! @p ( / ) { cr }
 ( / ) @p @p @p @p ( / ) a !p !p !p . ( / ) { cr }
 ( / ) { cr }
 ( in the port ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: init ( to force failure ) }block

( 00286800 )               D# 538 code{ 
 { 107CF } ( mark prp-call test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 1BF } { 19F } h# 9
 org ]
: p-r-p dup h# 1 . + h# 7E for
: init { 5F } { 7F } dup ( 3 ) push over a { cr { 7F } }
 ( . { 5F } a ) pop ( 3 ) a push dup push h# 1 . + { cr { 7F } }
 ( . { 5F } a { 9F } ) dup a! - { 7FF } h# 7F and { cr { 7F } }
 ( . { 5F } a { 77F } ) dup push h# 13000 or pop { cr { 7F } }
 ( . { 5F } a { 26077F } { 77F } ) pop { 7F } ( . { 5F } a { 77F } { 7F } )
 { cr }
 a { 9F } pop a! { 9F } push { cr }
 ( / ) .. @p ! ! . ( // ) @p @p @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( // ) @p .. ( / ) ! ! { cr }
 d# 8 for @p ! unext { cr }
 ( / { 5F } ) a! @p !+ . ( / ) !b pop !b . ( / ) { cr }
 ( a ) push !+ @p .. ( / ) ; ( / ) { cr }
: forcefail !+ dup .. ( / { 77F } ) a! { 77F } ( . 2/ . ) @p @p ..
 !b pop !b . ( / ) pop dup push ; { cr }
 !+ !+ push .. ( / ) { cr cr }
: calls ^ 2A { 7F } ^ pop { 9F } over { 7F } h# 11000 or ! ( ? @ ;
 ? ) { cr }
 ( / ) .. @p ! @ .. ( // ) !p .. a { cr }
 ( chk ) or if pop pop d# 1000 !b ; then drop { cr cr }
 next ; ^ 35 ^ [ h# 4 org ]
: p-r h# 0 p-r-p h# 200 p-r-p dup or !b ; { cr }
 ^ 09 ^ [ d# 2110 bin ] }block

( 00286C00 )               D# 539 shadow{ 
 ( prp-call testing p to r to p using ) call ( and ) ; ( also test )
 jump ( from port to ram. ) ; ( returns to port and to ram ) { br }

 ( uses the instructions in ram ) { cr }
 ( / ) pop dup push ; ( / ) call ( / ) ; ( / ) { br }

 ( to insure failure on fail, fills ram with ) { cr }
 ( / ) !b pop !b . ( / ) { br }

 ( relies on instructions in the port ) { cr }
 ( / ) a! @p !+ . ( / ) push !+ @p .. ( / ) { cr }
 ( / ) !+ dup .. ( / ) a! @p @p .. ( / ) { cr }
 ( / ) !+ !+ push .. ( / ) { cr br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: forcefail ( to force failure ) { cr }
 ( uncomment ) [ @ ; ] ( in )
: calls ( and removing ) [ for next ] ( structure ) { cr }
 ( might help debuging chip. ) }block

( 00287000 )               D# 540 code{ 
 { 107EF } ( mark prp-ex test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# D org ]
: p-r-p dup h# 1 . + h# 7E for
: init { 5F } { 7F } dup ( 3 ) push over a { cr { 7F } }
 ( . { 5F } a ) pop ( 3 ) a push dup push h# 1 . + { cr { 7F } }
 ( . { 5F } a { 9F } ) dup a! - h# 7F and { cr { 7F } }
 ( . { 5F } a { 77F } ) pop { 7F } ( . { 5F } a { 77F } { 7F } ) { cr }
 a { 9F } pop a! { 9F } push { cr }
 ( / ) .. @p ! ! . ( // ) @p @p @p @p ( / ) ! ! ! { cr cr }
 d# 10 for @p ! unext { cr }
 ( / { 5F } ) a! @p !+ . ( / ) !b pop !b . ( / ) { cr }
 ( a ) push @p @p .. ( / ) ; ( / ) ex .. ( / ) { cr }
 !+ !+ dup dup .. ( / { 77F } ) a! { 77F } push @p @p ( / ) { cr }
 ( / ) !b pop !b . ( / ) pop dup ( . . ) push ( . ) ; ( / ) { cr }
: forcefail !+ !+ .. ( / . 2/ . ) push drop .. ( / ) { cr cr }
: calls ^ 2B { 7F } ^ pop { 9F } over { 7F } h# 11000 or ! ( ? ; ? )
 { cr }
 ( / ) a .. @p ! @ .. ( // ) !p .. { cr }
 ( chk ) or if pop pop d# 1000 !b ; then drop { cr }
 next ; ^ 36 ^ [ h# 4 org ]
: p-r d# 0 p-r-p h# 200 p-r-p dup or !b ; { cr }
 ^ 09 ^ [ d# 2111 bin ] }block

( 00287400 )               D# 541 shadow{ 
 ( prp-ex testing p to r to p using ) ex ( and ) ; { cr }
 ( also test ) jump ( from port to ram. ) ; ( returns to port and to
 ram ) { br }

 ( uses the instructions in ram ) { cr }
 ( / ) pop dup push ; ( / ) ex .. ( / ) ; ( / ) { cr }
 ( to insure failure on fail, fills ram with ) { cr }
 ( / ) !b pop !b . ( / ) { cr }
 ( relies on instructions in the port ) { cr }
 ( / ) a! @p !+ . ( / ) push @p @p .. ( / ) { cr }
 ( / ) !+ !+ dup dup .. ( / ) a! push @p @p ( / ) { cr }
 ( / ) !+ !+ .. ( / ) push drop .. ( / ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) [ 2/ ] ( in )
: forcefail ( to force failure ) { cr }
 ( uncomment ) [ @ ; ] ( in )
: calls ( and removing ) [ for next ] ( structure ) { cr }
 ( might help debuging chip. ) }block

( 00287800 )               D# 542 code{ 
 { 1080F } ( serdes 001 slave test ) { cr }
 ( creeper ) [ reclaim d# 1 node d# 1344 load ] ahead
: s-lis ^ 05 ^ ( rip ) d# -1 !b .. cold ;
: lis ^ 08 ^ io a! h# 15555 ! data a! h# 3FFFE dup ! ;
: m-lis ( arg ) ^ 0F ^ then a push lis pop a! .. d# 0 !b ; ^ 14 ^ { br }

: ran ( n-n ) ^ 14 ^ -if 2* h# 2CD81 or ; then 2* ;
: rcv ( -n ) ^ 18 ^ h# 3FFFE @ ( nip ) over or or ;
: dly ^ 1B ^ d# 50 for unext ;
: one ^ 1E ^ up a! d# 0 rcv dup for { cr }
 ran dup push rcv or over - and or pop next { cr }
 drop dly { cr }
 data a! h# 31416 or dup ! io a! h# 20000 ! { cr }
 up a! ! dly lis warm ; { br }

 ^ 36 ^ [ d# 2112 bin ] }block

( 00287C00 )               D# 543 shadow{ 
 ( basic serdes test. this package is loaded into node 001 and location { AF }
 executed, returning negative status to rip the creeper out and placing
 the node in its cold configuration to execute anything node { 57AF }
 sends it. the location { 8F } entry point is used in node { 57AF }
 on the way to 001 to place { 57AF } in listen mode first. ) { br }

: s-lis ( is used from node { CAF } to start 001 listening for instructions
 from node 701. )
: one ( is called by master thru serdes to run the test. receives count,
 nominally 250,000, and then receives one more than that words of data.
 compares each word with prn sequence generated off the initial count.
 ors all error bits together, then xors that result with { F570F }
 and returns two copies after turning line around. finally goes back
 to receive and warm so it's rdy for the next test. ) }block

( 00288000 )               D# 544 code{ 
 { 1082F } ( serdes { 57AF } master test ) { cr }
 ( creeper ) [ reclaim d# 1 node d# 1344 load ] ahead { br }

: ran ( n-n ) ^ 05 ^ -if 2* h# 2CD81 or ; then 2* ;
: dly ^ 09 { 14F } ^ d# 12 for unext ;
: lis ^ 0C ^ io a! h# 15555 ! data a! h# 3FFFE dup ! ;
: go ( arg ) ^ 13 ^ then data a! io h# 1201E { cr }
 ! a! up h# 20000 ( . ) ! a! dup ! dup for { indent }
      dly ran dup ! next drop { cr }
 ( result ) . .. . .. lis dly dly lis up a! @ @ { cr }
 h# 31416 or over h# 31416 or over - and or { cr }
 dup 2/ over - and or h# 1FFFF and .. !b ; { br }

 ^ 31 ^ [ d# 2113 bin exit ] }block

( 00288400 )               D# 545 shadow{ 
 ( basic serdes test. single package used in two modes on path { 2F }
 for the two nodes. ) { br }

: s-lis ( is used from node { CAF } to start 001 listening for instructions
 from node 701. ) }block

( 00288800 )               D# 546 code{ 
 { 1084F } ( basic analog checks ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load ] { br }

: !dac ^ 04 ^ ( n ) io a! ! dup dup or !b ;
: ladc ^ 07 ^ ( n ) io a! ! ldata
: .adc ^ 0A ^ a! ! @ dup d# 1000 for unext .. { cr }
 ( ---- ) ^ 0E ^ ! @ - d# 1 . + . + h# 1FFFF and !b ;
: uadc ^ 13 ^ ( n ) io a! ! data .adc ; { br }

 ^ 17 ^ [ d# 2114 bin exit ] { br }

: !dac ^ 19 ^ ( n ) dup @p ! dup ( / ) @p a! @p . ( / ) { cr }
 ( ---- ) ^ 1B ^ io ! ! @p ( / ) ! . . . ( / ) ! or !b ; }block

( 00288C00 )               D# 547 shadow{ 
 ( basic analog control ) { br }

 ( this code is intended to run in the active ) { cr }
 ( node, not the target node. ) { br }

: !dac ( sets dac value into io and returns zero. )
: ladc ( sets up dac and io then reads back raw ) { cr }
 ( adc value when used in a left analog node. )
: uadc ( does the same for an up analog node. ) }block

( 00289000 )               D# 548 code{ 
 { 1086F } ( mark 2* test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 13 org ]
: t! ( n ) @p ! ! ; ( // ) @p .. ( / )
: t2* @p ! ; ( // ) 2* .. ( / )
: t@ ( -n ) @p ! @ ; ( // ) !p .. ( / )
: t2*3 @p ! .. ( // ) 2* 2* 2* .. ( / ) { cr }
 @p ! @ ; ( // ) dup !p .. ( / )
: chk over or .. if pop pop pop d# 1000 !b ; then drop ;
: h2* dup t! d# 18 for { cr }
 dup . + t2* t@ dup t! chk { cr }
 next ;
: h2*3 dup t! d# 6 for { cr }
 dup . + dup . + dup . + t2*3 chk next ;
: forcefail ^ 36 ^ [ h# 4 org ]
: tst-2* ^ 04 ^ h# 15555 h2* h# 1 h2* - { 7FFFFF } h2*3 { 1F } h2*3
 h# 15555 h2*3 h# 33333 h2*3 h# 71C7 h2*3 h# 1 h2*3 !b ; { cr }
 ^ 13 ^ [ d# 2115 bin ] }block

( 00289400 )               D# 549 shadow{ 
 ( tst-2* testing 2* ) { cr br }

 ( relies on instructions in the port ) { cr }
 @p . . . ( / ) 2* . . . ( / ) !p . . . ( / ) 2* 2* 2* . ( / ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( first comment ) dup ( in )
: h2*3 ( to force failure ) { cr }
 ( then comment ) dup ( in )
: h2* ( to force failure ) }block

( 00289800 )               D# 550 code{ 
 { 1088F } ( mark 2/ test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load { 27F } h# 19 org ]
: t2/ ( n-n ) dup . + @p ( // ) @p 2/ !p .. ( / ) ! dup ! over @ ;
: t2/3 ( n-n ) dup . + dup . + { cr }
 .. ( / ) dup . + @p ( // ) @p .. ( / ) { cr }
 ( / ) ! dup ! @p ( // ) 2/ 2/ 2/ !p ( / ) { cr }
 ( / ) ! over @ ;
: chk or .. if pop pop pop d# 1000 !b ; then drop ;
: h2/ d# 12 for dup t2/ chk next ;
: h2/3 d# 3 for dup t2/3 chk next ; ^ 36 ^ [ h# 4 org ]
: tst-2/ ^ 04 ^ h# F h2/ h# 5 h2/ h# 3 h2/ h# C h2/ h# F h2/3 h# 5
 h2/3 h# 3 h2/3 h# C h2/3 h# 7 h2/3 h# 9 h2/3 dup or !b ; { cr }
 ^ 19 ^ [ d# 2116 bin ] }block

( 00289C00 )               D# 551 shadow{ 
 ( tst-2/ testing 2/ ) { cr br }

 ( relies on instructions in the port ) { cr }
 @p 2/ !p . ( / ) @p . . . ( / ) 2/ 2/ 2/ !p ( / ) { cr br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( first comment ) dup ( in )
: h2/ ( to force failure ) { cr }
 ( then comment ) dup ( in )
: h2/3 ( to force failure ) }block

( 0028A000 )               D# 552 code{ 
 { 108AF } ( mark 2/ test ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 22 org ]
: t2/ ( n-n ) dup . + @p ( // ) @p 2/ !p .. ( / ) ! ! @ ;
: t2/3 ( n-n ) dup . + dup . + { cr }
 .. ( / ) dup . + @p ( // ) @p .. ( / ) { cr }
 ( / ) ! ! @p .. ( // ) 2/ 2/ 2/ !p ( / ) { cr }
 ( / ) ! @ ;
: chk or .. if pop pop pop d# 1000 !b ; then drop ;
: h2/ dup t2/ chk ;
: h2/3 dup t2/3 chk ; ^ 36 ^ [ h# 4 org ]
: tst-2/b ^ 04 ^ h# 30000 h2/ h# 3AAAA h2/ h# 35555 h2/ h# 3FFFE h2/
 h# 33333 h2/ h# 3CCCC h2/ { cr }
 h# 3C000 h2/3 h# 3EAAA h2/3 h# 3D555 h2/3 h# 3FFF8 h2/3 h# 3F333 h2/3
 h# 3CCCC h2/3 h# 3C0F0 h2/3 h# 3C1C3 h2/3 dup or !b ; { cr }
 ^ 21 ^ [ d# 2117 bin ] }block

( 0028A400 )               D# 553 shadow{ 
 ( tst-2/b testing 2/ ) { cr br }

 ( relies on instructions in the port ) { cr }
 @p 2/ !p . ( / ) @p . . . ( / ) 2/ 2/ 2/ !p ( / ) { cr br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( first comment ) dup ( in )
: h2/ ( to force failure ) { cr }
 ( then comment ) dup ( in )
: h2/3 ( to force failure ) }block

( 0028A800 )               D# 554 code{ 
 { 1130F } ( tst+ mark testing + ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 2A org ] { cr }
: chk or if pop pop d# 1000 !b ; then drop ;
: t+ ( nnn-n ) push .. { cr }
 ( / ) @p ! ! @p ( // ) @p ( . - . ) .. ( // ) @p . + !p ( / ) { cr }
 ( / ) ! ! @ pop chk ; { cr }
 ^ 35 ^ [ h# 4 org ] { cr }
: tst+ h# 15555 dup dup h# 2AAAA t+ { cr }
 dup dup - h# 3FFFF t+ - dup - dup h# 2AAAA h# 3FFFF t+ dup - h# 3FFFF
 t+ { cr }
 dup or - dup dup h# 3FFFE t+ h# 2AAAA h# CCCC h# 37776 t+ h# 19999
 h# 15555 h# 2EEEE t+ h# 33333 h# 8888 h# 3BBBB t+ { cr }
 dup or !b ; { cr }
 ^ 27 ^ [ d# 2200 bin ] }block

( 0028AC00 )               D# 555 shadow{ 
 ( tst+ mark testing + ) { cr br }

 ( relies on ) s ( and ) t ( of uut ) { cr }
 ( relies on instructions in the port ) { cr }
 ( / ) @p .. ( / ) @p . + !p ( / ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( fail mode; ) { cr }
 ( uncomment ) - ( in )
: t+ ( to force failure ) { cr cr }
 }block

( 0028B000 )               D# 556 code{ 
 { 1132F } ( mark r d stack test v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# E org ]
: store dup ! dup ! dup ! ! ;
: fetch ( -n ) @p ! @ ; ( / ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack dup - over .. ( / ) over over ( . - . ) { cr }
 over .. ( / ) over over over .. ( / ) over .. ( / ) ;
: t-stk ^ 1D ^ { cr }
 dup /neighbor /stack ^ 1F ^ { cr { 1FFFDF } }
 d# 8 for { cr }
 @p .. push push push .. store { cr }
 fetch drop @p .. pop pop pop .. store { cr cr }
 d# 11 for fetch or .. if pop pop - d# 10 . + !b pop ; then drop { cr }
 next drop fetch drop next ; { cr }
 ^ 35 ^ [ h# 4 org ]
: full ^ 04 ^ h# 2AAAA t-stk dup or { 1F } t-stk h# 33333 t-stk h# 19999
 t-stk dup or !b ; { cr }
 ^ 0D ^ [ d# 2201 bin ] }block

( 0028B400 )               D# 557 shadow{ 
 ( rdstk mark testing return and data stacks registers ) { cr }
 ( also mulitple overs pops and pushes in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then push to return stack then pop to data stack
 then read back and verify each pattern ; relies on ) b s t r r-stack
 ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) { cr }
 ( / ) !b .. ( / ) @p .. dup - over .. ( / ) { cr }
 ( / ) over over over .. ( / ) over .. ( / ) { cr }
 ( / ) push push push .. ( / ) pop pop pop .. ( / ) { cr }
 ( / ) @p .. ( / ) !b .. ( / ) over push pop .. ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , next count for failure ) { br }

 ( uncomment ) - ( in )
: /stack ( after ) over ( to force failure ) }block

( 0028B800 )               D# 558 code{ 
 { 1134F } ( mark d stack test v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 18 org ]
: fetch ( -n ) @p ! @ ; ( // ) !b .. ( / )
: /neighbor @p ! ! .. @p .. { cr }
 d# 3 for @p ! unext ; ..
: /stack ^ 1F ^ dup - over .. ( / ) over over { cr }
 over .. ( / ) over over over .. ( / ) over .. ( / ) ;
: d-stack ^ 24 ^ h# 8 for dup ( . - . ) /neighbor /stack ( . ) d# 11
 for fetch or if pop pop - d# 10 . + !b pop ; then drop { cr }
 next next ; { cr }
 ^ 33 ^ [ h# 4 org ]
: full ^ 04 ^ h# 2AAAA d-stack dup or { 1F } d-stack h# 15555 d-stack
 dup or - { 7FFFFF } d-stack h# 33333 d-stack h# 19999 d-stack h# CCCC
 d-stack h# 26666 d-stack dup dup or { cr }
 !b ; ^ 16 ^ [ d# 2202 bin ] { cr }
 }block

( 0028BC00 )               D# 559 shadow{ 
 ( stk mark testing data stack registers ) { cr }
 ( also overs in the port ) { br }

 ( fill neighbor return stack with alternating ) { cr }
 ( inverted patterns , then read back and verify each pattern ; relies
 on ) b s t ( and ) d-stack ( of uut ) { cr }
 ( and instructions ) { cr }
 ( / ) dup - over .. ( / ) over over over .. ( / ) { cr }
 ( / ) over .. ( / ) @p .. ( / ) !b .. ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , next count for failure ) { br }

 ( uncomment ) - ( in )
: d-stack ( after ) dup ( to force failure ) }block

( 0028C000 )               D# 560 code{ 
 { 1136F } ( mark test + v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 18 org ] { cr }
: h+ over over ( . - . ) . + push
: t+ ( nn-n ) @p ! ! @p ( // ) @p .. ( // ) @p . + !p ( / ) ! ! @ { cr }
 pop over ( chk ) or if pop pop d# 1000 !b ; then drop ; { cr }
: first ( x ) leap h# 23225 . + dup
: xstr @p drop !p ; { -cr }
: x then h# 0 ; ^ 2A ^
: sec ( y ) leap h# 1F9A9 . + dup
: ystr @p drop !p ; { -cr }
: y then h# 0 ;
: thr ( z ) leap h# 1BE29 . + dup
: zstr @p drop !p ; { -cr }
: z then h# 0 ; { cr cr }
 ^ 36 ^ [ h# 4 org ] { cr }
: tst+ dup or { 7FFFFF } h# 3FF for first h+ sec over h+ thr h+ x -
 h+ over h+ z - h+ - y h+ dup h+ h+ next dup or !b ; { cr }
 ^ 18 ^ [ d# 2203 bin ] }block

( 0028C400 )               D# 561 shadow{ 
 ( tst+b mark testing + ) { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions in the port / ) { cr }
 @p .. ( / ) @p . + !p ( / ) { br }

 [ address h# 4 ] ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success, ) { cr { 7D0F } }
 ( for failure ) { br }

 ( uncomment ) - ( in )
: h+ ( to force failure ) { cr }
 }block

( 0028C800 )               D# 562 code{ 
 { 1138F } ( mark testing and ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 1E org ]
: chk ( nn ) or if pop pop pop h# 1000 !b ; then ( drop ) ;
: tand ( nn-n ) @p ! ! .. ( // ) @p @p and !p ( / ) ! @ ;
: ttand over over ( . - . ) and push tand pop chk ;
: first ( x ) leap h# 23225 . + dup
: xstr @p drop !p ; { -cr }
: x then h# 0 ;
: sec ( y ) leap h# 1F9A9 . + dup
: ystr @p drop !p ; { -cr }
: y then h# 0 ; { cr }
 ^ 35 ^ [ h# 4 org ]
: tstand { 7FFFFF } h# 100 for first sec ttand x - y ttand x y - ttand
 x - y - ttand y - x ttand y x - ttand y - x - ttand next dup or !b
 ; { cr }
 ^ 1D ^ [ d# 2204 bin ] { cr cr }
 }block

( 0028CC00 )               D# 563 shadow{ 
 ( tst-and mark testing and ) { br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) [ d# 1000 ] ( for failure ) { br }

 ( uncomment ) - ( in )
: ttand ( after ) over ( to force failure ) }block

( 0028D000 )               D# 564 code{ 
 { 113AF } ( mark test and ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 25 org ]
: chk ( nn ) or if pop pop h# 1000 !b ; then ;
: tand ( nn-n ) @p ! ! .. ( // ) @p @p and !p .. ( / ) ! @ ; { cr }
: tand3 ( nnnn-n ) @p ! ! .. ( // ) @p @p @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( // ) and and and !p .. ( / ) ! @ ;
: tsa tand chk ;
: tsa3 tand3 chk ; { cr }
 ^ 36 ^ [ h# 4 org ]
: tstand { F } h# 2222 h# 17777 h# 2AAAA h# 3FAFF h# 33333 tsa3 h# 30A5C
 h# 3FFFF over tsa h# 30A5C - h# 3FFFF over tsa h# A00 h# 3FF00 h# FFF
 h# 3FFFF h# 3FA55 tsa3 - tsa h# 15555 tsa dup h# 2AAAA tsa h# 15555
 h# 2AAAA tsa !b ; { cr }
 ^ 25 ^ [ d# 2205 bin ] { cr cr }
 }block

( 0028D400 )               D# 565 shadow{ 
 ( tst-andb mark testing and ) { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p .. ( / ) @p @p @p @p ( / ) { cr }
 ( / ) and and and !p ( / ) { cr }
 ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) [ d# 1000 ] ( for failure ) { br }

 ( first fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand ( to force failure ) { cr cr }
 ( second fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand3 ( to force failure ) { cr }
 }block

( 0028D800 )               D# 566 code{ 
 { 113CF } ( mark testing or ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 1E org ]
: chk ( nn ) or if pop pop pop h# 1000 !b ; then ;
: tor ( nn-n ) @p ! ! .. ( // ) @p @p or !p ( / ) ! @ ;
: ttor over over ( . - . ) or push tor pop chk ;
: first ( x ) leap h# 23225 . + dup
: xstr @p drop !p ; { -cr }
: x then h# 0 ;
: sec ( y ) leap h# 1F9A9 . + dup
: ystr @p drop !p ; { -cr }
: y then h# 0 ; { cr }
 ^ 35 ^ [ h# 4 org ]
: tst-or { 7FFFFF } h# 100 for first sec ttor x - y ttor x y - ttor
 x - y - ttor y - x ttor y x - ttor y - x - ttor next dup or !b ; { cr }
 ^ 1D ^ [ d# 2206 bin ] { cr cr }
 }block

( 0028DC00 )               D# 567 shadow{ 
 ( tst-or mark testing and ) { br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) [ d# 1000 ] ( for failure ) { br }

 ( uncomment ) - ( in )
: ttand ( after ) over ( to force failure ) }block

( 0028E000 )               D# 568 code{ 
 { 113EF } ( mark test or v2 ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 25 org ]
: chk ( nn ) or if pop pop pop h# 1000 !b ; then ;
: tor ( nn-n ) @p ! ! .. ( // ) @p @p or ( . - . ) !p .. ( / ) ! @
 ; { cr }
: tor3 ( nnnn-n ) @p ! ! .. ( // ) @p @p @p @p ( / ) { cr }
 ( / ) ! ! ! @p ( // ) or or or ( . - . ) !p .. ( / ) ! @ ;
: tso tor chk ;
: tso3 tor3 chk ; { cr }
 ^ 36 ^ [ h# 4 org ]
: tstor h# 3E372 h# 35FA9 h# 3F57F h# 25733 h# 11E97 tso3 h# 3F555
 h# 3FF00 h# FFF h# 3FFFF h# 3FA55 tso3 h# 15555 h# 3FFFF over - tso
 h# 2AAAA h# 3FFFF over - tso dup or dup - dup tso dup or - dup dup
 - tso h# 15555 over - over - tso !b ; { cr }
 ^ 25 ^ [ d# 2207 bin ] { cr cr }
 }block

( 0028E400 )               D# 569 shadow{ 
 ( tst-orb mark testing and ) { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p @p and !p .. ( / ) @p @p @p @p ( / ) { cr }
 ( / ) and and and !p ( / ) { cr }
 ( / ) { cr }
 ( in the port ) { br }

: full ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code { F } for success , ) [ d# 1000 ] ( for failure ) { br }

 ( first fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand ( to force failure ) { cr cr }
 ( second fail mode; ) { cr }
 ( uncomment ) and ( in )
: tand3 ( to force failure ) { cr }
 }block

( 0028E800 )               D# 570 code{ 
 { 1140F } ( mark test - ) { cr }
 ( creeper ) [ reclaim d# 0 node d# 1344 load h# 26 org ]
: chk ( nn ) ! @ or if pop pop h# 1000 !b ; then ;
: t- ( n-n ) @p ! .. ( // ) @p - !p .. ( / ) chk ;
: t-2 ( n-n ) dup @p ! .. ( // ) @p - - !p .. ( / ) chk ; { cr }
: t-3 ( n-n ) @p ! ! @p ( // ) @p .. ( / ) { cr }
 ( // ) - - - !p .. ( / ) chk ; { cr }
 ^ 36 ^ [ h# 4 org ]
: tstor h# 1C8D h# 3E372 t- h# 2AAAA h# 15555 t- h# 15555 h# 2AAAA
 t- h# 3FFFF dup dup or t- dup dup or h# 3FFFF t- { cr }
 dup dup or t-2 h# 3FFFF t-2 h# 2AAAA t-2 h# 15555 t-2 h# 3FFFF dup
 dup or t-3 h# 2AAAA h# 15555 t-3 !b ; { cr }
 ^ 26 ^ [ d# 2208 bin ] { cr cr }
 }block

( 0028EC00 )               D# 571 shadow{ 
 ( tst- mark testing ) - { cr br }

 ( relies on ) s t ( and ) d-stack ( of uut ) { cr }
 ( relies on instructions ) { cr }
 ( / ) @p - !p .. ( / ) @p - - !p .. ( / ) { cr }
 ( / ) @p .. ( / ) - - - !p .. ( / ) { br }

 ( in the port ) { br }

 ( tests the ) [ tfocused ] ( neighbor ) { cr }
 parameter ( is ignored ) { cr }
 ( error code ) [ d# 0 ] ( for success , ) [ d# 1000 ] ( for failure )
 { br }

 ( first fail mode; ) { cr }
 ( uncomment ) - ( in )
: t- ( to force failure ) { br }

 ( second fail mode; ) { cr }
 ( uncomment ) - ( in )
: t-2 ( to force failure ) { br }

 ( second fail mode; ) { cr }
 ( uncomment ) - ( in )
: t-3 ( to force failure ) }block

( 0028F000 )               D# 572 code{ 
 }block

( 0028F400 )               D# 573 shadow{ 
 }block

( 0028F800 )               D# 574 code{ 
 }block

( 0028FC00 )               D# 575 shadow{ 
 }block

( 00290000 )               D# 576 code{ 
 }block

( 00290400 )               D# 577 shadow{ 
 }block

( 00290800 )               D# 578 code{ 
 }block

( 00290C00 )               D# 579 shadow{ 
 }block

( 00291000 )               D# 580 code{ 
 }block

( 00291400 )               D# 581 shadow{ 
 }block

( 00291800 )               D# 582 code{ 
 }block

( 00291C00 )               D# 583 shadow{ 
 }block

( 00292000 )               D# 584 code{ 
 }block

( 00292400 )               D# 585 shadow{ 
 }block

( 00292800 )               D# 586 code{ 
 }block

( 00292C00 )               D# 587 shadow{ 
 }block

( 00293000 )               D# 588 code{ 
 }block

( 00293400 )               D# 589 shadow{ 
 }block

( 00293800 )               D# 590 code{ 
 }block

( 00293C00 )               D# 591 shadow{ 
 }block

( 00294000 )               D# 592 code{ 
 }block

( 00294400 )               D# 593 shadow{ 
 }block

( 00294800 )               D# 594 code{ 
 }block

( 00294C00 )               D# 595 shadow{ 
 }block

( 00295000 )               D# 596 code{ 
 }block

( 00295400 )               D# 597 shadow{ 
 }block

( 00295800 )               D# 598 code{ 
 }block

( 00295C00 )               D# 599 shadow{ 
 }block

( 00296000 )               D# 600 code{ 
 ( res for more ats test pkgs --- ) }block

( 00296400 )               D# 601 shadow{ 
 }block

( 00296800 )               D# 602 code{ 
 }block

( 00296C00 )               D# 603 shadow{ 
 }block

( 00297000 )               D# 604 code{ 
 }block

( 00297400 )               D# 605 shadow{ 
 }block

( 00297800 )               D# 606 code{ 
 }block

( 00297C00 )               D# 607 shadow{ 
 }block

( 00298000 )               D# 608 code{ 
 }block

( 00298400 )               D# 609 shadow{ 
 }block

( 00298800 )               D# 610 code{ 
 }block

( 00298C00 )               D# 611 shadow{ 
 }block

( 00299000 )               D# 612 code{ 
 }block

( 00299400 )               D# 613 shadow{ 
 }block

( 00299800 )               D# 614 code{ 
 }block

( 00299C00 )               D# 615 shadow{ 
 }block

( 0029A000 )               D# 616 code{ 
 }block

( 0029A400 )               D# 617 shadow{ 
 }block

( 0029A800 )               D# 618 code{ 
 }block

( 0029AC00 )               D# 619 shadow{ 
 }block

( 0029B000 )               D# 620 code{ 
 }block

( 0029B400 )               D# 621 shadow{ 
 }block

( 0029B800 )               D# 622 code{ 
 }block

( 0029BC00 )               D# 623 shadow{ 
 }block

( 0029C000 )               D# 624 code{ 
 }block

( 0029C400 )               D# 625 shadow{ 
 }block

( 0029C800 )               D# 626 code{ 
 }block

( 0029CC00 )               D# 627 shadow{ 
 }block

( 0029D000 )               D# 628 code{ 
 }block

( 0029D400 )               D# 629 shadow{ 
 }block

( 0029D800 )               D# 630 code{ 
 { ED8F } ( ats analog ) { cr }
 [ reclaim d# 717 node d# 0 org ]
: sam ( n-k ) ^ 00 ^ io b! data a! @b - h# 1FF and or { cr }
 !b dup ! @ d# 1000 for unext dup ! @ - . + ;
: vdd ^ 0C ^ h# 2000 sam ; { -cr }
: vss ^ 0E ^ h# 6000 sam ;
: vpin ^ 10 ^ h# 0 sam ;
: u* ( nn-hl ) ^ 12 ^ dup a! dup or d# 17 for +* unext { cr }
 push drop pop a ;
: m/ ( dn-q ) --u/mod push drop pop ;
: mv ( -n ) ^ 19 ^ vss vdd over - . + push { cr }
 vpin - . + -if dup or then d# 1800 u* pop m/ ;
: !mv ( n ) ^ 23 ^ io b! d# 511 u* d# -1800 m/ h# 155 or !b ; { cr }
 ^ 2B ^ [ d# 1900 bin ] }block

( 0029DC00 )               D# 631 shadow{ 
 ( ide mode code. )
: mv ( returns approx pad voltage in mv using contemporaneous cal values
 from our own rails assuming said rails at { F } and 1800. no linearization.
 dac output remains unchanged. )
: !mv ( sets dac output to a voltage in mv. this is most bogus since
 no linearization is done; the actual voltage will be much higher than
 what we are setting. ) }block

( 0029E000 )               D# 632 code{ 
 { EDAF } ( ats sync boot master ) { cr }
 [ reclaim d# 300 node d# 0 org ]
: dly ^ 00 ^ ( b ) !b d# 40 { 3EF } for unext ;
: 1bt ^ 03 ^ ( wb-w' ) dup dly h# 10000 or dly ;
: 18o ^ 06 ^ ( w ) h# 30000 dly d# 8 for begin { cr }
 ^ 0A ^ -if ( 1- ) h# 30003 1bt [ swap ] { -cr }
: rise { cr }
 ^ 0D ^ 2* -if ( 1+ ) h# 20003 1bt 2* *next drop ; { cr }
 ^ 12 ^ ( . ) then ( 0+ ) h# 20002 1bt 2* *next drop ; { cr }
 ^ 16 ^ ( . ) then ( 0- ) h# 30002 1bt rise ; { cr }
: off ^ 19 ^ io b! h# 20002 dly h# 10001 !b ; { cr }
 ^ 1F ^ [ d# 1901 bin ] }block

( 0029E400 )               D# 633 shadow{ 
 ( this code is loaded into tb001 test chip node { 258F } to boot node { 258F }
 of the uut. the ide uses ) 18o ( to form a boot stream to load the
 link ) { cr }
 ( routine into the remote node. once remote ) { cr }
 ( is started ide sets the local pins to low ) { cr }
 ( tri-state and weak-low before loading the ) { cr }
 ( link code into the local node and starting it. at this time both
 of these nodes remain off of the grid until both the test and uut
 chip have been reset. ) }block

( 0029E800 )               D# 634 code{ 
 { EDCF } ( boot frame for master testing ) { cr }
 [ reclaim d# 300 node d# 0 org ] { cr }
 [ host ] { -cr }
: 3- h# -3 + ; [ target ] { br }

: frame ser-exec -d-- [ d# 0 , ]
: portex @p !b . . ( / ) [ h# 30000 , ] ( / ) { cr }
 ^ 05 ^ [ here here 3- d# 2 org , ] { cr }
 [ org ] ^ 05 ^ [ d# 1902 bin ] }block

( 0029EC00 )               D# 635 shadow{ 
 ( boot frame which commands uut node { 401F } to set its pin 200.17
 high. ) }block

( 0029F000 )               D# 636 code{ 
 { EDEF } ( boot frame for master testing ) { cr }
 [ reclaim d# 300 node d# 0 org ] { cr }
 [ host ] { -cr }
: 3- h# -3 + ; [ target ] { br }

: frame ser-exec -d-- [ d# 0 , ]
: portex @p !b . . ( / ) [ h# 20000 , ] ( / ) { cr }
 ^ 05 ^ [ here here 3- d# 2 org , ] { cr }
 [ org ] ^ 05 ^ { cr }
 [ h# 20 org ]
: misc ---u @p - !p ; [ d# 1903 bin ] }block

( 0029F400 )               D# 637 shadow{ 
 ( boot frame which commands uut node { 401F } to set its pin 200.17
 low. ) }block

( 0029F800 )               D# 638 code{ 
 { EE0F } ( ats sync bridge ) { cr }
 [ reclaim d# 300 node { 6F } d# 8 org ] { cr }
 [ host ] { -cr }
: hd- { -51 } d# -8 + ; [ target ] { br }

: dly ^ 08 ^ ( b ) !b d# 40 for unext ; ( 88ns )
: 1bt ^ 0B ^ ( wb-w' ) dup dly h# 10000 or dly ;
: zro ^ 0E ^ h# 10001 dly ; { -cr }
: wpd ^ 10 ^ h# 10001 !b ;
: 18o ^ 12 ^ ( w ) zro d# 17 for begin { cr }
 ^ 15 ^ -if h# 30003 1bt 2* *next drop wpd ; { cr }
 ^ 1A ^ then h# 30002 1bt 2* next drop wpd ; { br }

: 18i ^ 1E ^ ( x ) drop dup or !b d# 17 for { cr }
 ^ 21 ^ ( .. ) begin @b -until { cr }
 ^ 22 ^ ( .. ) begin @b - -until { cr }
 ^ 23 ^ ( .. ) - d# 2 and 2/ a 2* or a! next { cr }
 ^ 27 ^ a up a! ! { br }

: idl ^ 2A ^ h# 165 ( --lu ) a! . @ @b -if drop 18i ; { cr }
 ^ 2E ^ then zro drop 18o idl ; { cr }
: ent ^ 31 ^ io b! wpd begin @b - -until idl ; { cr }
 ^ 36 ^ [ here here hd- { F } d# 5 org ]
: frame ent dly [ , ] { cr }
 [ org ] ^ 36 ^ [ d# 1904 bin ] }block

( 0029FC00 )               D# 639 shadow{ 
 shadow out of date. { cr }
 ( this code is loaded into nodes { 258F } of both ) { cr }
 ( the test and uut chips of the tb001 board. ) { cr }
 ( the transmitter controls the clock and data is sampled on the falling
 edge. the clock is set to low tri-state and data to weak-low one half
 bit time from the end of word. the code idles reading from a neighbor
 and the clock pin. ) { cr }
 ( data from the neighbor are transmitted and ) { cr }
 ( receive data are writen to the neighbor. no ) { cr }
 ( attempt is made to be able to terminate either of these serial linked
 nodes except reset. ) { cr }
 ( terminating the remote node would require ) { cr }
 ( an enhanced protocol. also we see no need ) { cr }
 ( to impliment flow control at this time. on ) { cr }
 ( entry the code waits for the clock to drop ) { cr }
 ( to facilitate transition from the old boot ) { cr }
 ( protocol. ) { cr }
 [ origin moved to d# 5 so boot frame header can be laid down without
 affecting slot d# 2 jumps. ] }block

( 002A0000 )               D# 640 code{ 
 { EE2F } ( uut bridge debug ) { cr }
 [ reclaim d# 300 node { 6F } d# 8 org ] { cr }
 [ host ] { -cr }
: hd- { -51 } d# -8 + ; [ target ] { br }

: dly ^ 08 ^ ( b ) !b { 50F } d# 400 for unext ; ( 88ns )
: 1bt ^ 0B ^ ( wb-w' ) dup dly h# 10000 or dly ;
: zro ^ 0E ^ h# 10001 dly ;
: wpd ^ 10 ^ h# 10001 !b ;
: 18o ^ 12 ^ ( w ) zro d# 17 for begin { cr }
 ^ 15 ^ -if h# 30003 1bt 2* *next drop wpd ; { cr }
 ^ 1A ^ then h# 30002 1bt 2* next drop wpd ;
: 18i ^ 1E ^ ( x ) drop dup or !b d# 17 for { cr }
 ^ 21 ^ ( .. ) begin @b -until { cr }
 ^ 22 ^ ( .. ) begin @b - -until { cr }
 ^ 23 ^ ( .. ) - d# 2 and 2/ a 2* or a! next { cr }
 ^ 27 ^ a ( up a! ! { 2F } and { 4F } or !b ) zro d# 12345 . + 18o
 { br }

: idl ^ 2B ^ h# 165 ( --lu ) a! .. { cr }
 ^ 2D ^ @ @b -if drop 18i ; then { cr }
 ^ 2F ^ zro drop 18o ( idl ; ) { cr }
: ent ^ 31 ^ io b! wpd { cr }
 begin @b - -until idl ; { cr }
 ^ 36 ^ [ here here hd- { F } d# 5 org ]
: frame ent dly [ , ] { cr }
 [ org ] ^ 36 ^ [ d# 1905 bin ] }block

( 002A0400 )               D# 641 shadow{ 
 shadow out of date. { cr }
 ( this code is loaded into nodes { 258F } of both ) { cr }
 ( the test and uut chips of the tb001 board. ) { cr }
 ( the transmitter controls the clock and data is sampled on the falling
 edge. the clock is set to low tri-state and data to weak-low one half
 bit time from the end of word. the code idles reading from a neighbor
 and the clock pin. ) { cr }
 ( data from the neighbor are transmitted and ) { cr }
 ( receive data are writen to the neighbor. no ) { cr }
 ( attempt is made to be able to terminate either of these serial linked
 nodes except reset. ) { cr }
 ( terminating the remote node would require ) { cr }
 ( an enhanced protocol. also we see no need ) { cr }
 ( to impliment flow control at this time. on ) { cr }
 ( entry the code waits for the clock to drop ) { cr }
 ( to facilitate transition from the old boot ) { cr }
 ( protocol. ) { cr }
 [ origin moved to d# 5 so boot frame header can be laid down without
 affecting slot d# 2 jumps. ] }block

( 002A0800 )               D# 642 code{ 
 { EE4F } ( tester bridge debug ) { cr }
 [ reclaim d# 300 node { 6F } d# 8 org ] { cr }
 [ host ] { -cr }
: hd- { -51 } d# -8 + ; [ target ]
: dly ^ 08 ^ ( b ) !b { 50F } d# 400 for unext ; ( 88ns )
: 1bt ^ 0B ^ ( wb-w' ) dup dly h# 10000 or dly ;
: zro ^ 0E ^ h# 10001 dly ;
: wpd ^ 10 ^ h# 10001 !b ;
: 18o ^ 12 ^ ( w ) io b! zro d# 17 for begin { cr }
 ^ 17 ^ -if h# 30003 1bt 2* *next drop wpd ; { cr }
 ^ 1C ^ then h# 30002 1bt 2* next drop wpd ;
: 18i ^ 20 ^ ( x ) drop dup or !b d# 17 for { cr }
 ^ 23 ^ ( .. ) begin @b -until { cr }
 ^ 24 ^ ( .. ) begin @b - -until { cr }
 ^ 25 ^ ( .. ) - d# 2 and 2/ a 2* or a! next { cr }
 ^ 2A ^ a ( up a! ! ) ;
: joe ^ 2B ^ ( w ) 18o 18i ;
: idl ^ 2D ^ h# 165 ( --lu ) a! .. { cr }
 ^ 2F ^ @ @b -if drop 18i ; then { cr }
 ^ 31 ^ zro drop 18o ( idl ; ) { cr }
: ent ^ 33 ^ io b! h# 10001 !b { cr }
 begin @b - -until ( idl ) ; { cr }
 ^ 3A ^ [ here here hd- { F } d# 5 org ]
: frame ent dly [ , ] { cr }
 [ org ] ^ 3A ^ [ d# 1906 bin ] }block

( 002A0C00 )               D# 643 shadow{ 
 shadow out of date. { cr }
 ( this code is loaded into nodes { 258F } of both ) { cr }
 ( the test and uut chips of the tb001 board. ) { cr }
 ( the transmitter controls the clock and data is sampled on the falling
 edge. the clock is set to low tri-state and data to weak-low one half
 bit time from the end of word. the code idles reading from a neighbor
 and the clock pin. ) { cr }
 ( data from the neighbor are transmitted and ) { cr }
 ( receive data are writen to the neighbor. no ) { cr }
 ( attempt is made to be able to terminate either of these serial linked
 nodes except reset. ) { cr }
 ( terminating the remote node would require ) { cr }
 ( an enhanced protocol. also we see no need ) { cr }
 ( to impliment flow control at this time. on ) { cr }
 ( entry the code waits for the clock to drop ) { cr }
 ( to facilitate transition from the old boot ) { cr }
 ( protocol. ) { cr }
 [ origin moved to d# 5 so boot frame header can be laid down without
 affecting slot d# 2 jumps. ] }block

( 002A1000 )               D# 644 code{ 
 }block

( 002A1400 )               D# 645 shadow{ 
 }block

( 002A1800 )               D# 646 code{ 
 }block

( 002A1C00 )               D# 647 shadow{ 
 }block

( 002A2000 )               D# 648 code{ 
 { AF0F } ( ats cs master0 n108 ) { cr }
 [ reclaim d# 108 node { 5CCF } ] ( load ) ^ AA ^ [ d# 0 org ]
: sam ( n-k ) ^ 00 ^ { cr }
 ^ 01 ^ [ d# 1400 bin ] }block

( 002A2400 )               D# 649 shadow{ 
 ( code for node { D8F } in ats. ) { cr }
 }block

( 002A2800 )               D# 650 code{ 
 { AF2F } ( ats cs wire ) { cr }
 [ reclaim d# 109 node d# 0 org ]
: sam ( n-k ) ^ 00 ^ { cr }
 ^ 2B ^ [ d# 1401 bin ] }block

( 002A2C00 )               D# 651 shadow{ 
 }block

( 002A3000 )               D# 652 code{ 
 { AF4F } ( ats cs digital ) { cr }
 [ reclaim d# 717 node d# 0 org ]
: sam ( n-k ) ^ 00 ^ { cr }
 ^ 2B ^ [ d# 1402 bin ] }block

( 002A3400 )               D# 653 shadow{ 
 ( pf mode code for digital nodes. ) }block

( 002A3800 )               D# 654 code{ 
 { AF6F } ( ats cs analog ) { cr }
 [ reclaim d# 717 node d# 0 org ]
: sam ( n-k ) ^ 00 ^ io b! data a! @b - h# 1FF and or { cr }
 !b dup ! @ d# 1000 for unext dup ! @ - . + ;
: vdd ^ 0C ^ h# 2000 sam ; { -cr }
: vss ^ 0E ^ h# 6000 sam ;
: vpin ^ 10 ^ h# 0 sam ;
: u* ( nn-hl ) ^ 12 ^ dup a! dup or d# 17 for +* unext { cr }
 push drop pop a ;
: m/ ( dn-q ) --u/mod push drop pop ;
: mv ( -n ) ^ 19 ^ vss vdd over - . + push { cr }
 vpin - . + -if dup or then d# 1800 u* pop m/ ;
: !mv ( n ) ^ 23 ^ io b! d# 511 u* d# -1800 m/ h# 155 or !b ; { cr }
 ^ 2B ^ [ d# 1403 bin ] }block

( 002A3C00 )               D# 655 shadow{ 
 ( pf mode code. )
: mv ( returns approx pad voltage in mv using contemporaneous cal values
 from our own rails assuming said rails at { F } and 1800. no linearization.
 dac output remains unchanged. )
: !mv ( sets dac output to a voltage in mv. this is most bogus since
 no linearization is done; the actual voltage will be much higher than
 what we are setting. ) }block

( 002A4000 )               D# 656 code{ 
 }block

( 002A4400 )               D# 657 shadow{ 
 }block

( 002A4800 )               D# 658 code{ 
 ( xxxx smtm mem-random converted ) { cr }
 [ reclaim d# 0 node d# 0 ] d# 3 [ org ]
: rnd ( n-n' ) ^ 00 ^ -if 2* h# 2CD81 or ; then 2* ;
: run ^ 04 ^ @p @p a! dup ( / ) [ h# 12155 , h# A9 , ] ( / ) { cr }
 @ h# B a! .. or h# 3 h# 3FFF8 .. rnd dup ! and .. { cr }
 push h# 8 begin 2* . . unext and if or ahead { cr }
 [ swap ] then run ; ^ 14 ^ . .. . ..
: go ^ 16 ^ then @ over a! @p ( / ) @p dup push dup { cr }
 a ! ! h# E push dup ! begin @p ! . unext ( /- ) { cr }
 ^ 1C ^ push dup push dup push dup push dup { cr }
 ^ 1E ^ push dup push dup push push pop dup { cr }
 ^ 20 ^ pop pop pop pop pop pop pop pop h# 3F dup { cr }
 ^ 24 ^ push push or dup a! or or or or or or or . ^ 28 ^ begin dup
 !+ . unext begin @+ or . unext { cr }
 ^ 2A ^ @p a! ! . ( -/ ) a ! @ or if warm ; then
: migrate h# 1557F !b h# 1556A . h# 1F for . . . unext { cr }
 ^ 34 ^ !b h# 4 @p . ( / ) @p dup 2/ . ( / ) { cr }
 ^ 37 ^ a ! ! h# 43 push begin @p !+ . unext ( /- ) { cr }
 ^ 3B ^ [ h# 3F , ] 2* a! push begin @p !+ . unext { cr }
 ^ 3E ^ @p push ; ( -/ ) ! warm ; { cr }
 ^ 40 ^ ( xxxx bin ) }block

( 002A4C00 )               D# 659 shadow{ 
 ( this is steven's ) { cr }
 ( g144-smtm-self-tet-mem-random ) }block

( 002A5000 )               D# 660 code{ 
 ( tb001 ide pretest ) [ empty serial load ] { br }

 ( customize ) [ -canon d# 660 orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { br }

: mv ( -n ) [ h# 19 ] call h# 3F lit' ra! !a h# 3F r@ ;
: !mv ( n ) lit' [ h# 23 ] call ;
: +a ( nn ) d# 2 swap hook d# 0 d# 64 d# 1900 boot ; { br }

: !vdc ( mv ) [ d# 709 ] +a !mv ; { -cr }
: vdc ( -mv ) [ d# 709 ] +a mv ;
: !vdi ( mv ) [ d# 713 ] +a !mv ; { -cr }
: vdi ( -mv ) [ d# 713 ] +a mv ;
: !vda ( mv ) [ d# 717 ] +a !mv ; { -cr }
: vda ( -mv ) [ d# 717 ] +a mv ;
: !bus ( mv ) [ d# 117 ] +a !mv ; { -cr }
: bus ( -mv ) [ d# 117 ] +a mv ;
: drain d# 2 [ d# 617 ] hook h# AA io r! h# 155 io r! ;
: set ( n nn ) d# 2 swap hook [ d# 2 ] + [ h# 10000 ] * io r! ;
: rst ( n ) [ d# 417 ] set ;
: 1.8 ( n ) [ d# 715 ] set ; { -cr }
: 1.475 ( n ) [ d# 517 ] set ;
: hivd [ d# 1 ] 1.8 [ d# 0 ] 1.475 ; { -cr }
: lovd [ d# 1 ] 1.475 [ d# 0 ] 1.8 ;
: novd [ d# 0 ] 1.8 [ d# 0 ] 1.475 drain ; { br }

 ( functions ) [ d# 662 d# 4 loads ] { cr }
 ( automate ) [ talk pre ] }block

( 002A5400 )               D# 661 shadow{ 
 ( these defns are used in ide on ats master to simulate actions later
 run by polyforth. ) { br }

: !vdx ( and ) vdx ( drive and read uut power bus ) [ x ] ( in nonlinear
 millivolts. )
: !bus ( and ) bus ( do the same with analog bus. )
: rst ( sets uut reset line low if ) [ n d# 0 ] ( or high ) [ d# 1 ]
: drain ( used only when no power enabled to short out the supply rails
 briefly. )
: rst ( controls uut reset line ) [ d# 0 ] ( is low. )
: 1.8 ( and ) 1.475 ( control power supplies ) [ d# 1 ] ( enables )
 [ d# 0 ] ( disables. )
: hivd lovd ( and ) novd ( select high, low, and zero voltage power
 supply to uut. ) }block

( 002A5800 )               D# 662 code{ 
 ( - pre powerup tests ) [ d# 662 list ] { br }

 ( preliminary tests ) { .pok }
      :# vval 1 { cr }
 :# vcop 1 :# vcsh 1 :# viop 1 :# vish 1 :# vaop 1 :# vash 1 { br }

: init d# 0 [ vcop ] ! d# 0 [ vcsh ] ! d# 0 [ viop ] ! d# 0 [ vish ]
 ! { cr }
 d# 0 [ vaop ] ! d# 0 [ vash ] ! d# 0 [ vval ] ! pause
: -pwr d# 0 rst d# 0 !vdc d# 0 !vdi d# 0 !vda novd ; { br }

 [ exit ] ( test procedure... )
: - no chip in socket
: - 'compile'
: - '280 load talk'
: - insert chip
: - 'pre'
: - will stop here if pretests fail
: - else runs creeper tests in d# 250
: - [ always say ] -pwr [ before removing chip!!! ] }block

( 002A5C00 )               D# 663 shadow{ 
: -pwr ( removes all power from uut socket and leaves it ) safe ( for
 inserting or removing chip. puts chip in reset, disables both power
 supplies, removes drive from power rail test dacs, and drains the
 rails. )
: ?open ( checks each supply rail for enough loading to believe there's
 a chip in the socket. ) }block

( 002A6000 )               D# 664 code{ 
 ( - power opens and shorts )
: sam ( -n ) mv mv + mv + mv + 2/ 2/ ;
: -sam ( x-mv ) drop sam ;
: lt ( nn-t ) less if drop drop d# 1 ; { cr }
 then drop drop d# 0 ;
: -sht ( n.mv.mv-t ) max 2* swap lt ; { br }

: ?cop [ d# 75 ] !vdc sam ( dup ) [ d# 500 ] lt [ vcop ] ! d# 0 !mv
 ;
: ?iop [ d# 75 ] !vdi sam ( dup ) [ d# 500 ] lt [ viop ] ! d# 0 !mv
 ;
: ?aop [ d# 75 ] !vda sam ( dup ) [ d# 850 ] lt [ vaop ] ! d# 0 !mv
 ;
: ?open ?cop pause ?iop pause ?aop pause ; { br }

: ?csht [ d# 75 ] !vdc sam vdi -sam vda -sam { cr }
 -sht [ vcsh ] ! d# 0 !vdc ;
: ?isht [ d# 75 ] !vdi sam vdc -sam vda -sam { cr }
 -sht [ vish ] ! d# 0 !vdi ;
: ?asht [ d# 75 ] !vda sam vdi -sam vdc -sam { cr }
 -sht [ vash ] ! d# 0 !vda ;
: ?short ?csht pause ?isht pause ?asht pause ; }block

( 002A6400 )               D# 665 shadow{ 
 }block

( 002A6800 )               D# 666 code{ 
 ( - results )
: chs ( ...n ) for emit next ;
: ?good ( -t ) [ vcop ] @ [ vcsh ] @ and [ viop ] @ and [ vish ] @
 and [ vaop ] @ and [ vash ] @ and ;
: .pf ?good drop if { cr }
 green d# 42 d# 36 d# 3 d# 3 chs space ; { cr }
 then red d# 42 d# 12 d# 7 d# 5 d# 14 d# 5 chs space ;
: .pok blu [ vval ] @ d# 0 + drop if .pf ; { cr }
 then silver d# 11 d# 8 d# 22 d# 19 d# 4 chs space ; }block

( 002A6C00 )               D# 667 shadow{ 
: .pok ( shows how to make a blue word display variable text strings. )
 }block

( 002A7000 )               D# 668 code{ 
 ( - port bridge ) { br }

: !sync d# 0 [ d# 300 ] hook d# 0 d# 64 [ d# 1901 ] boot [ h# 19 ]
 call ; { br }

: pt@ ( a-n ) @ h# 15555 or ;
: frame ( a nd ) nn-n 2* d# 32768 + block + dup d# 2 + pt@ d# 3 + for
 dup pt@ lit' d# 6 call [ d# 1 ] + next drop ;
: !hitst d# 0 [ d# 1902 ] frame ;
: !lotst d# 0 [ d# 1903 ] frame ;
: !his d# 5 [ d# 1904 { EE2F } ] frame ; { br }

: !ours ( off ) [ h# 19 ] call d# 0 d# 64 [ d# 1904 ] boot { cr }
 ( ent ) [ h# 30 ] call ( testing ) h# 0 [ d# 400 ] hook focus ; { br }

: setup ?good drop if -pwr !sync hivd d# 1 rst { cr }
 [ d# 300 ] node ( !hitst ) !his !ours then ; { br }

: pre [ d# 662 ] list pause init { cr }
 ?open ?short d# 1 [ vval ] ! d# 123 pause { cr }
 ?good drop if setup { cr }
 d# 2 -hook d# 1 -hook d# 0 -hook drop pause { cr }
 [ d# 670 ] load ; then ; }block

( 002A7400 )               D# 669 shadow{ 
 ( set up port bridge. ) { br }

: first ( we load sync boot master in our { 258F } done by ) !sync
: second ( we load bridge in uut node { 258F } using ) frame ( which
 sends a boot frame starting at location ) [ a ] ( compiled for bin )
 [ nd's ] ( ram )
: third ( we load bridge into our node { 258F } ) { br }

: setup ( does all this and loads new ide for the bridged 2-chip system. )
: pre ( runs full set of pre-tests ) }block

( 002A7800 )               D# 670 code{ 
 ( tb001 ide creepers ) [ empty serial load ] { br }

 ( customize ) [ -canon d# 670 orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { cr }
 ( functions ) [ d# 674 d# 5 loads ] { br }

 ( test status is ) { .pok br }

 ( details ) :# ph 3 :# id 2002 :# tgt 1000 :# pos 154 { cr }
 ( ------- ) :# ans 0 :# rval 39050 { cr }
 ( ------- ) :# nrun 13125 :# vval 1 { br }

: init d# 0 [ tgt ] ! d# 0 [ pos ] ! d# 0 [ nrun ] ! d# 0 [ id ] !
 d# 0 [ rval ] ! d# 0 [ ans ] ! d# 0 [ vval ] ! d# -1 [ ph ] ! ; { cr }
 ( runner ) [ d# 684 d# 9 loads d# 672 load { 53CF } ] ( list ) { br }

: run d# 670 list !p0 !p1 init pause { indent }
      -buses d# 0 d# 1000 hook d# 0 -hook ana0 ( ; ) { cr }
 d# 0 [ ph ] ! d# 0 path z t911 t917 ta00 t913 { cr }
 d# 1 [ ph ] ! d# 1 path z !p1a { cr }
 d# 2 [ ph ] ! d# 1 path z !p1 ser70 !p1b ser07 !p1 { cr }
 d# 3 [ ph ] ! lovd d# 0 path d# 2007 runall d# 2002 runall { cr }
 d# 1 [ vval ] ! -pwr ; [ run ] }block

( 002A7C00 )               D# 671 shadow{ 
 ( ide environment to run ide and creepers in the uut. path { 4F }
 reaches right side controls. paths { F } and { 2F } are mutually exclusive
 reaching into the uut. ) { br }

: !vdx ( and ) vdx ( drive and read uut power bus ) [ x ] ( in nonlinear
 millivolts. )
: !bus ( and ) bus ( do the same with analog bus. )
: rst ( sets uut reset line low if ) [ n d# 0 ] ( or high ) [ d# 1 ]
: drain ( used only when no power enabled to short out the supply rails
 briefly. )
: rst ( controls uut reset line ) [ d# 0 ] ( is low. )
: 1.8 ( and ) 1.475 ( control power supplies ) [ d# 1 ] ( enables )
 [ d# 0 ] ( disables. )
: hivd lovd ( and ) novd ( select high, low, and zero voltage power
 supply to uut. ) { br }

 [ needing special runners - d# 913 d# 911 ] }block

( 002A8000 )               D# 672 code{ 
 ( - all tests ) { br }

: z ( lov-ram ) [ d# 2007 ] runall { cr }
 ( port ) [ d# 2000 ] runall ( port2* ) [ d# 2001 ] runall { cr }
 ( ram ) [ d# 2002 ] runall ( t,s ) [ d# 2003 ] runall { cr }
 ( t,r ) [ d# 2004 ] runall ( stack ) [ d# 2005 ] runall { cr }
 ( return ) [ d# 2006 ] runall ( ms-rdst ) [ d# 2008 ] runall { cr }
 ( shifta ) [ d# 2009 ] runall ( tsar-data ) [ d# 2010 ] runall { cr }
 ( ms-stk ) [ d# 2012 ] runall ( carry ) [ d# 2014 ] runall { cr }
 ( ms-@p ) [ d# 2015 ] runall ( i,r-ad ) [ d# 2016 ] runall { cr }
 ( @b!b ) [ d# 2101 ] runall ( b-reg ) [ d# 2102 ] runall { cr }
 ( i-reg ) [ d# 2103 ] runall ( i-reg ) [ d# 2104 ] runall { cr }
 ( i-reg ) [ d# 2105 ] runall ( i-reg ) [ d# 2106 ] runall { cr }
 ( i-reg ) [ d# 2107 ] runall ( i-reg ) [ d# 2108 ] runall { cr }
 ( i-reg ) [ d# 2109 ] runall ( prp-call ) [ d# 2110 ] runall { cr }
 ( prp-ex ) [ d# 2111 ] runall ( tst-2* ) [ d# 2115 ] runall { cr }
 ( tst-2/ ) [ d# 2116 ] runall ( tst-2/b ) [ d# 2117 ] runall { cr }
 ( tst+ ) [ d# 2200 ] runall ( rdstkv2 ) [ d# 2201 ] runall { cr }
 ( dstkv2 ) [ d# 2202 ] runall ( +v2 ) [ d# 2203 ] runall { cr }
 ( and ) [ d# 2204 ] runall ( andv2 ) [ d# 2205 ] runall { cr }
 ( or ) [ d# 2206 ] runall ( orv2 ) [ d# 2207 ] runall { cr }
 ( - ) [ d# 2208 ] runall { cr }
 ; }block

( 002A8400 )               D# 673 shadow{ 
 }block

( 002A8800 )               D# 674 code{ 
 ( - multichip ide )
: mwall ( nn-i ) [ d# 1000 ] mod swap [ d# 1000 ] mod { cr }
 over over or drop if swall ; { cr }
 then drop drop ( up ) d# 3 ; [ ' mwall 'wall ! ] { br }

: uup0 align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1500 , d# 1600 , ] { cr }
 [ d# 1700 , d# 1701 , d# 1702 , d# 1703 , d# 1704 , d# 1705 , ] { cr }
 [ d# 1706 , d# 1707 , d# 1708 , d# 1709 , d# 1710 , d# 1711 , ] { cr }
 [ d# 1712 , d# 1713 , d# 1714 , d# 1715 , d# 1716 , d# 1717 , ] { cr }
 [ d# 1617 , d# 1616 , d# 1615 , d# 1614 , d# 1613 , d# 1612 , ] { cr }
 [ d# 1611 , d# 1610 , d# 1609 , d# 1608 , d# 1607 , d# 1606 , ] { cr }
 [ d# 1605 , d# 1604 , d# 1603 , d# 1602 , d# 1601 , ] { cr }
 [ d# 1501 , d# 1502 , d# 1503 , d# 1504 , d# 1505 , d# 1506 , ] { cr }
 [ d# 1507 , d# 1508 , d# 1509 , d# 1510 , d# 1511 , d# 1512 , ] { cr }
 [ d# 1513 , d# 1514 , d# 1515 , d# 1516 , d# 1517 , ] { cr }
 [ d# 1417 , d# 1416 , d# 1415 , d# 1414 , d# 1413 , d# 1412 , ] { cr }
 [ d# 1411 , d# 1410 , d# 1409 , d# 1408 , d# 1407 , d# 1406 , ] { cr }
 [ d# 1405 , d# 1404 , d# 1403 , d# 1402 , d# 1401 , ] { cr }
 [ d# 1301 , d# 1302 , d# 1303 , d# 1304 , d# 1305 , d# 1306 , ] { cr }
 [ d# 1307 , d# 1308 , d# 1309 , d# 1310 , d# 1311 , d# 1312 , ] { cr }
 [ d# 1313 , d# 1314 , d# 1315 , d# 1316 , d# 1317 , ] { cr }
 }block

( 002A8C00 )               D# 675 shadow{ 
: mwall ( discards chip id portion of node number and in the special
 case of two consecutive nodes of same number forces up port to be
 the wall between them. thus a path going from { 320F } to { AF0F }
 uses up to make the connection via the { 258F } to { 258F } sync bridge. )
 { br }

: uup0 ( is the primary path for pass/fail testing in the uut. it reaches
 all nodes but the bridge in { 258F } )
: uup1 ( is secondary path which passes thru most of the ports skipped
 by uup1. it does not include nodes 000 { C8F } { 190F } and leaves { 8F }
 ports that have not been exercised. )
: up1a ( is a quick path that is substituted for path { 2F } to catch
 the four remaining ports. ) { br }

 when all three have been done, only node d# 300 and its right and
 down ports have not been exercised. }block

( 002A9000 )               D# 676 code{ 
 ( -- paths 0,1 ) { cr }
 [ d# 1217 , d# 1216 , d# 1215 , d# 1214 , d# 1213 , d# 1212 , ] { cr }
 [ d# 1211 , d# 1210 , d# 1209 , d# 1208 , d# 1207 , d# 1206 , ] { cr }
 [ d# 1205 , d# 1204 , d# 1203 , d# 1202 , d# 1201 , d# 1200 , ] { cr }
 [ d# 1100 , d# 1101 , d# 1102 , d# 1103 , d# 1104 , d# 1105 , ] { cr }
 [ d# 1106 , d# 1107 , d# 1108 , d# 1109 , d# 1110 , d# 1111 , ] { cr }
 [ d# 1112 , d# 1113 , d# 1114 , d# 1115 , d# 1116 , d# 1117 , ] { cr }
 [ d# 1017 , d# 1016 , d# 1015 , d# 1014 , d# 1013 , d# 1012 , ] { cr }
 [ d# 1011 , d# 1010 , d# 1009 , d# 1008 , d# 1007 , d# 1006 , ] { cr }
 [ d# 1005 , d# 1004 , d# 1003 , d# 1002 , d# 1001 , d# 1000 , d# -1
 , ] { br }

: uup1 align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1500 , d# 1600 , d# 1700 , ] { cr }
 [ d# 1701 , d# 1601 , d# 1501 , d# 1401 , d# 1301 , d# 1201 , ] { cr }
 [ d# 1101 , d# 1001 , d# 1002 , d# 1102 , d# 1202 , d# 1302 , ] { cr }
 [ d# 1402 , d# 1502 , d# 1602 , d# 1702 , ] { cr }
 [ d# 1703 , d# 1603 , d# 1503 , d# 1403 , d# 1303 , d# 1203 , ] { cr }
 [ d# 1103 , d# 1003 , d# 1004 , d# 1104 , d# 1204 , d# 1304 , ] { cr }
 [ d# 1404 , d# 1504 , d# 1604 , d# 1704 , ] { cr }
 }block

( 002A9400 )               D# 677 shadow{ 
 }block

( 002A9800 )               D# 678 code{ 
 ( -- paths 1 ) { cr }
 [ d# 1705 , d# 1605 , d# 1505 , d# 1405 , d# 1305 , d# 1205 , ] { cr }
 [ d# 1105 , d# 1005 , d# 1006 , d# 1106 , d# 1206 , d# 1306 , ] { cr }
 [ d# 1406 , d# 1506 , d# 1606 , d# 1706 , ] { cr }
 [ d# 1707 , d# 1607 , d# 1507 , d# 1407 , d# 1307 , d# 1207 , ] { cr }
 [ d# 1107 , d# 1007 , d# 1008 , d# 1108 , d# 1208 , d# 1308 , ] { cr }
 [ d# 1408 , d# 1508 , d# 1608 , d# 1708 , ] { cr }
 [ d# 1709 , d# 1609 , d# 1509 , d# 1409 , d# 1309 , d# 1209 , ] { cr }
 [ d# 1109 , d# 1009 , d# 1010 , d# 1110 , d# 1210 , d# 1310 , ] { cr }
 [ d# 1410 , d# 1510 , d# 1610 , d# 1710 , ] { cr }
 [ d# 1711 , d# 1611 , d# 1511 , d# 1411 , d# 1311 , d# 1211 , ] { cr }
 [ d# 1111 , d# 1011 , d# 1012 , d# 1112 , d# 1212 , d# 1312 , ] { cr }
 [ d# 1412 , d# 1512 , d# 1612 , d# 1712 , ] { cr }
 [ d# 1713 , d# 1613 , d# 1513 , d# 1413 , d# 1313 , d# 1213 , ] { cr }
 [ d# 1113 , d# 1013 , d# 1014 , d# 1114 , d# 1214 , d# 1314 , ] { cr }
 [ d# 1414 , d# 1514 , d# 1614 , d# 1714 , ] { cr }
 [ d# 1715 , d# 1615 , d# 1515 , d# 1415 , d# 1315 , d# 1215 , ] { cr }
 [ d# 1115 , d# 1015 , d# 1016 , d# 1116 , d# 1216 , d# 1316 , ] { cr }
 [ d# 1416 , d# 1516 , d# 1616 , d# 1716 , ] { cr }
 [ d# 1717 , d# 1617 , d# 1517 , d# 1417 , d# 1317 , d# 1217 , ] { cr }
 [ d# 1117 , d# 1017 , d# -1 , ] }block

( 002A9C00 )               D# 679 shadow{ 
 }block

( 002AA000 )               D# 680 code{ 
 ( -- paths 1a ) { cr }
: up1a align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1401 , d# 1501 , d# 1500 , d# 1600 , d# 1601 , ] { cr }
 [ d# 1602 , d# 1502 , d# 1402 , d# 1302 , d# 1202 , ] { cr }
 [ d# 1201 , d# 1200 , d# 1100 , d# 1000 , d# -1 , ] { br }

: up1b align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 ,
 d# 703 , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , ] { cr }
 [ d# 1400 , d# 1401 , d# 1301 , d# 1201 , d# 1101 , d# 1001 , ] { cr }
 [ d# 1002 , d# 1102 , d# 1202 , d# 1302 , d# 1402 , d# 1502 , ] { cr }
 [ d# 1602 , d# 1702 , d# 1701 , d# 1700 , d# -1 , ] { br }

: !p0 uup0 [ 'pths ] ! ;
: !p1 uup1 [ 'pths ] d# 1 + ! ;
: !p1a up1a [ 'pths ] d# 1 + ! ;
: !p1b up1b [ 'pths ] d# 1 + ! ; }block

( 002AA400 )               D# 681 shadow{ 
: path1a ( catches the port walls that are left ) { cr }
 ( after using paths { F } and 1. )
: path1b ( reverses path { 2F } swapping serdes roles. ) }block

( 002AA800 )               D# 682 code{ 
 ( - control lines ) { br }

: mv ( -n ) [ h# 19 ] call h# 3F lit' ra! !a h# 3F r@ ;
: !mv ( n ) lit' [ h# 23 ] call ;
: +a ( nn ) d# 2 swap hook d# 0 d# 64 d# 1900 boot ; { br }

: !vdc ( mv ) [ d# 709 ] +a !mv ; { -cr }
: vdc ( -mv ) [ d# 709 ] +a mv ;
: !vdi ( mv ) [ d# 713 ] +a !mv ; { -cr }
: vdi ( -mv ) [ d# 713 ] +a mv ;
: !vda ( mv ) [ d# 717 ] +a !mv ; { -cr }
: vda ( -mv ) [ d# 717 ] +a mv ;
: !bus ( mv ) [ d# 117 ] +a !mv ; { -cr }
: bus ( -mv ) [ d# 117 ] +a mv ;
: drain d# 2 [ d# 617 ] hook h# AA io r! h# 155 io r! ;
: set ( n nn ) d# 2 swap hook [ d# 2 ] + [ h# 10000 ] * io r! ;
: rst ( n ) [ d# 417 ] set ;
: 1.8 ( n ) [ d# 715 ] set ; { -cr }
: 1.475 ( n ) [ d# 517 ] set ;
: hivd [ d# 1 ] 1.8 [ d# 0 ] 1.475 ; { -cr }
: lovd [ d# 1 ] 1.475 [ d# 0 ] 1.8 ;
: novd [ d# 0 ] 1.8 [ d# 0 ] 1.475 drain ; { br }

: -pwr d# 0 rst d# 0 !vdc d# 0 !vdi d# 0 !vda novd drain ; }block

( 002AAC00 )               D# 683 shadow{ 
 ( these defns control and interrogate the uut. )
: !vdx ( and ) vdx ( drive and read uut power bus ) [ x ] ( in nonlinear
 millivolts. )
: !bus ( and ) bus ( do the same with analog bus. )
: rst ( sets uut reset line low if ) [ n d# 0 ] ( or high ) [ d# 1 ]
: drain ( used only when no power enabled to short out the supply rails
 briefly. )
: rst ( controls uut reset line ) [ d# 0 ] ( is low. )
: 1.8 ( and ) 1.475 ( control power supplies ) [ d# 1 ] ( enables )
 [ d# 0 ] ( disables. )
: hivd lovd ( and ) novd ( select high, low, and zero voltage power
 supply to uut. ) }block

( 002AB000 )               D# 684 code{ 
 ( - all-nodes runner ) { br }

: pt@ ( -a ) paths [ pos ] @ + ;
: active ( -nn ) pt@ @ ;
: nxt ( -nn ) pt@ d# 1 + @ ;
: -us ( nn-nn ) dup paths @ or drop ;
: -end ( nn-nn ) dup d# -1 or drop ; { br }

 :# 'arg 270112297
: -try ( n-t ) d# 1 [ nrun ] +! test dup [ ans ] ! d# 0 or drop ;
: ecch ( fail ) h# BAD h# BAD rip d# 1 [ vval ] ! abort ;
: pass [ 'arg ] xqt -try if ecch then ; { br }

: /all ( n ) [ id ] ! targets @ [ pos ] ! pause { cr }
 d# 0 d# 64 [ id ] @ boot ( ?ram ) pfocus ( punchout ; )
: hike key? active nxt -us if -end if { cr }
 dup [ tgt ] ! ( pause ) wall port tfocus pass { cr }
 creep d# 1 [ pos ] +! hike ; { cr }
 then then drop drop rip ;
: /zero [ 'arg ] assign d# 0 ;
: runall ( n ) /zero /all rip ; }block

( 002AB400 )               D# 685 shadow{ 
: tgt ( current target node )
: pos ( posn of current active node in path )
: nrun ( number of tests run on current chip )
: id ( puka number for test being run )
: ans ( most recent answer from a test ) { br }

: pt@ ( addresses path table for active node. )
: active ( returns active node no. yxx format )
: nxt ( returns next target node in path. )
: -us ( true if node given is not current boot )
: -end ( true if node given is not end path marker )
: -pass ( runs current test, true if failed ) { br }

: runall ( runs the test whose puka number is given on all nodes using
 the selected path. this path must be empty, selecting a node adjacent
 to the boot in use. )
: hike ( starts with active node selected. runs test against next node
 then creeps into it and repeats. aborts on test fail. returns with
 path ripped and ready to load new test after all remaining nodes in
 path have been tested ok. ) }block

( 002AB800 )               D# 686 code{ 
 ( - incremental runner ) { br }

: some ( n ) [ id ] ! targets @ [ pos ] ! pause { cr }
 d# 0 d# 64 [ id ] @ boot ( ?ram ) pfocus ;
: adv active nxt -us if -end if dup [ tgt ] ! { cr }
 ( pause ) wall port tfocus creep d# 1 [ pos ] +! ; { cr }
 then then ecch ;
: kreep ( nn ) begin key? active dup [ tgt ] ! { cr }
 over or drop while adv end then drop ;
: uno ( nn ) kreep d# 0 pass ; }block

( 002ABC00 )               D# 687 shadow{ 
 ( runner components for tests that do not apply to all nodes and for
 tests that work on the active rather than the target node. ) { br }

: some ( starts work on current path given test in given bin. )
: adv ( steps to the next node in path. )
: kreep ( advances to make the given node active. )
: uno ( kreeps if necessary to the given node and runs the test there. )
 { br }

 ( usage... ) [ d# 906 some ] { cr }
 [ d# 1500 kreep d# 1 pass d# 1600 uno rip ] }block

( 002AC000 )               D# 688 code{ 
 ( - build table of valid io w/r bits )
: iom [ nns aray h# 201FF d# 0 iom nns fill ]
: iom! ( nm ) push nn-n iom dup @ pop or swap ! ;
: c0, ( n ) h# 1E00 iom! ; { -cr }
: l0, ( n ) h# 1800 iom! ;
: u0, ( n ) h# 600 iom! ; { -cr }
: !l ( nn ) over l0, iom! ;
: !u ( nn ) over u0, iom! ; { -cr }
: l1, ( n ) h# 20000 !l ;
: u1, { -cr }
: us, { -cr }
: u18, ( n ) h# 20000 !u ;
: l2, ( n ) h# 20003 !l ; { -cr }
: u2, ( n ) h# 20003 !u ;
: u4, ( n ) h# 2003F !u ; { -cr }
: la, ( nn ) l1, l1, ;
: ua, ( nn ) u1, u1, ; { br }

 ( single ) [ d# 100 l1, d# 317 l1, d# 417 l1, d# 500 l1, d# 600 l1, ]
 ( serdes ) [ d# 1 us, d# 701 us, ] ( spi ) [ d# 705 u4, ] { cr }
 ( async ) [ d# 708 u2, ] ( 1wire ) [ d# 200 l1, ] ( sync ) [ d# 300
 l2, ] { cr }
 ( parallel ) [ d# 7 u18, d# 8 u4, d# 9 u18, ] { cr }
 ( analog ) [ d# 709 d# 715 ua, d# 713 d# 715 ua, d# 717 d# 715 ua, ]
 { cr }
 [ d# 117 d# 217 la, d# 617 d# 517 la, ] { cr }
 ( no pins ) [ d# 0 c0, d# 2 u0, d# 3 u0, d# 4 u0, d# 5 u0, d# 6 u0, ]
 { cr }
 [ d# 10 u0, d# 11 u0, d# 12 u0, d# 13 u0, d# 14 u0, d# 15 u0, ] { cr }
 [ d# 16 u0, d# 17 c0, d# 400 l0, d# 700 c0, d# 702 u0, d# 703 u0,
 d# 704 u0, d# 706 u0, d# 707 u0, d# 710 u0, ] { cr }
 [ d# 711 u0, d# 712 u0, d# 714 u0, d# 716 u0, ] }block

( 002AC400 )               D# 689 shadow{ 
 ( notes- ) { br }

 ( this took the bulk of the code from softsim ) }block

( 002AC800 )               D# 690 code{ 
 ( - build table of rom checksums )
: sums [ nns aray d# 0 d# 0 sums nns fill ]
: !sum ( n ) dup push 2* h# 8000 + block h# 80 + h# 0 { indent }
      d# 63 for over i + @ or -next { indent }
      pop sums ! drop ;
: !sums [ nns d# -1 + ] for i !sum -next ; [ !sums ] { cr }
 }block

( 002ACC00 )               D# 691 shadow{ 
 }block

( 002AD000 )               D# 692 code{ 
 ( - results )
: chs ( ...n ) for emit next ;
: .pf [ ans ] @ d# 0 + drop if { cr }
 red d# 42 d# 12 d# 7 d# 5 d# 14 d# 5 chs space ; { cr }
 then green d# 42 d# 36 d# 3 d# 3 chs space ;
: .pok blu [ vval ] @ d# 0 + drop if .pf ; { cr }
 then silver d# 11 d# 8 d# 22 d# 19 d# 4 chs space ; { br }

: -buses d# 0 d# 1009 hook ( ou ) h# 15555 io r! h# 0 data r! { cr }
 d# 0 d# 1007 hook ( in ) h# 14555 io r! h# 0 data r! ; }block

( 002AD400 )               D# 693 shadow{ 
: .pok ( shows how to make a blue word display variable text strings. )
 { br }

: -buses ( quiets test chip parallel buses by setting { EF } to read
 and { 12F } to write. this facilitates later creeper test using path
 0. easily burns hundreds of ma if not done due to cross coupling of
 output mode buses on powerup. ) }block

( 002AD800 )               D# 694 code{ 
 ( - runner for { 71EF } pin test ) { br }

: atest ( arg-ans ) d# 1 [ nrun ] +! test dup [ rval ] ! ;
: within ( nlh-t ) push less drop pop if drop d# 0 and ; then less
 if drop d# -1 +or ; then drop d# 0 and ;
: pinok ( ans ) d# 16 /mod d# 16 /mod d# 24 d# 180 within { cr }
 push d# 4 d# 12 within push d# 4 d# 12 within pop and { cr }
 pop and ( ; ) drop if ; then d# 2011 [ ans ] ! ecch ; { br }

: p17 h# 30000 ;
: p5 h# 30 ; { -cr }
: p3 h# C ; { -cr }
: p1 h# 3 ;
: a911 ( p ) atest pinok ;
: n911 ( np ) swap kreep a911 ;
: t911 d# 0 path d# 2011 some { cr }
 [ d# 1500 ] p17 n911 [ d# 1600 ] p17 n911 { cr }
 [ d# 1705 ] p1 n911 [ p3 ] a911 [ p5 ] a911 { cr }
 ( 1k pullup ) [ p17 ] atest [ h# 7000 ] +or pinok { cr }
 ( no-caps { D58F } p17 n911 p1 a911 ) { cr }
 [ d# 1715 ] p17 n911 [ d# 1517 ] p17 n911 [ d# 1417 ] p17 n911 { cr }
 [ d# 1317 ] p17 n911 [ d# 1217 ] p17 n911 rip ; }block

( 002ADC00 )               D# 695 shadow{ 
 }block

( 002AE000 )               D# 696 code{ 
 ( - runner for { 72AF } rom checksum ) { br }

: /917 [ 'arg ] assign [ tgt ] @ d# 1000 mod nn-n sums @ ;
: t917 /917 d# 2017 /all rip ;
: /913 [ 'arg ] assign [ tgt ] @ d# 1000 mod nn-n iom @ ;
: t913 /913 d# 2013 /all rip ; { br }

: na00 ( np ) swap kreep -try if ecch then ;
: ta00 d# 0 path d# 2100 some { cr }
 [ d# 1009 ] h# 14555 na00 [ d# 1007 ] h# 14555 na00 rip { cr }
 d# 1 path d# 2100 some { cr }
 [ d# 1007 ] h# 14555 na00 [ d# 1009 ] h# 15555 na00 rip d# 0 path
 ; }block

( 002AE400 )               D# 697 shadow{ 
: t917 ( needs arg of expected xor checksum value. )
: t913 ( needs arg of io latch bit mask. )
: ta00 ( needs arg of state to leave in io at end. ) }block

( 002AE800 )               D# 698 code{ 
 ( - runner for { 1082F } serdes test ) { br }

: /many [ 'arg ] assign d# 250000 ;
: stest ( arg-ans ) /many pass ; { br }

: ser70 d# 1 path [ d# 2112 ] some /zero { cr }
 [ d# 1701 ] kreep pass { cr }
 [ d# 1001 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 1 path [ d# 2113 ] some [ d# 1701 ] kreep stest rip ; { br }

: ser07 d# 1 path [ d# 2112 ] some /zero { cr }
 [ d# 1001 ] kreep pass { cr }
 [ d# 1701 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 1 path [ d# 2113 ] some [ d# 1001 ] kreep stest rip ; }block

( 002AEC00 )               D# 699 shadow{ 
 }block

( 002AF000 )               D# 700 code{ 
 ( - runner for { 1084F } analog test ) { br }

 :# 'side 270113283
: tops [ 'side ] assign [ h# 13 ] ;
: rights [ 'side ] assign [ h# 7 ] ;
: stest ( arg-ans ) /many pass ;
: atest ( arg.ent-ans ) d# 1 [ nrun ] +! vtest dup [ rval ] ! ;
: !da ( n ) [ h# 4 ] atest drop ;
: @ad ( n-n ) h# 155 or [ 'side ] xqt atest ;
: @vdd ( -n ) [ h# 2000 ] @ad ; { -cr }
: @vss ( -n ) [ h# 6000 ] @ad ;
: @off ( -n ) [ h# 4000 ] @ad ; { -cr }
: @pad ( -n ) [ h# 0 ] @ad ; { br }

: a? ( nlhk ) push within if drop pop drop ; then { cr }
 pop [ ans ] ! ecch ;
: /vlo d# 13000 d# 14700 ; { -cr }
: /vhi d# 8250 d# 9350 ;
: aok ( nn ) kreep pause @off d# 0 d# 1 [ d# 1 ] a? { cr }
 @vdd /vhi [ d# 2 ] a? { cr }
 @vss /vlo [ d# 3 ] a? [ h# AA ] @ad /vhi [ d# 4 ] a? { cr }
 @pad /vlo [ d# 5 ] a? d# 1800 !bus d# 0 path { cr }
 @pad /vhi [ d# 6 ] a? d# 0 !bus d# 0 path ;
: ana0 d# 0 path [ d# 2114 ] some { cr }
 tops [ d# 1709 ] aok [ d# 1713 ] aok [ d# 1717 ] aok { cr }
 rights [ d# 1617 ] aok [ d# 1117 ] aok rip ; }block

( 002AF400 )               D# 701 shadow{ 
 }block

( 002AF800 )               D# 702 code{ 
 }block

( 002AFC00 )               D# 703 shadow{ 
 }block

( 002B0000 )               D# 704 code{ 
 }block

( 002B0400 )               D# 705 shadow{ 
 }block

( 002B0800 )               D# 706 code{ 
 }block

( 002B0C00 )               D# 707 shadow{ 
 }block

( 002B1000 )               D# 708 code{ 
 ( selftest a chip, port on stack ) [ empty stp ! ] { br }

 [ compile serial load -canon ] :# usb 3 { cr }
 [ stp @ dup sport ! usb ! a-bps bps ! !nam ] { cr }
 ( functions ) [ d# 674 d# 4 loads ] ( exit ) { br }

 ( test status is ) { .pok br }

 ( details ) :# ph 3 :# id 913 :# tgt 701 :# pos 7 { cr }
 ( ------- ) :# ans 0 :# rval 0 { cr }
 ( ------- ) :# nrun 11520 :# vval 1 { br }

: init d# 0 [ tgt ] ! d# 0 [ pos ] ! d# 0 [ nrun ] ! d# 0 [ id ] !
 d# 0 [ rval ] ! d# 0 [ ans ] ! d# 0 [ vval ] ! d# -1 [ ph ] ! ; [ init ]
 { cr }
 ( runner ) [ d# 684 d# 7 loads d# 672 load d# 710 load ] { br }

: run [ d# 708 ] list init pause talk { indent }
      2pa [ 'pths ] d# 2 + ! { indent }
      d# 2 d# 708 hook d# 2 -hook !p0 !p1 !p2 ( ; ) { cr }
 d# 0 [ ph ] ! d# 0 path z t917 t913 { cr }
 d# 1 [ ph ] ! d# 1 path z t917 t913 { cr }
 d# 2 [ ph ] ! d# 2 path z t917 t913 !p1a { cr }
 d# 3 [ ph ] ! d# 1 path z t917 t913 { cr }
 d# 1 [ vval ] ! ; [ run ] }block

( 002B1400 )               D# 709 shadow{ 
 ( this code runs selected creeper tests directly on a chip using the
 ide. use with a-com/c-com or a literal port number. ) { br }

: tgt ( current target node )
: pos ( posn of current active node in path )
: nrun ( number of tests run on current chip )
: id ( puka number for test being run )
: ans ( most recent answer from a test ) }block

( 002B1800 )               D# 710 code{ 
 ( - paths )
: line ( ncd ) swap push swap { indent }
      begin dup , over + -next drop drop ;
: count ( nc-ncd ) dup [ d# 100 ] mod [ d# 0 ] + if { cr }
 ( horz ) swap drop [ d# 1 ] ; ( vert ) then drop [ d# 100 ] / [ d# 100 ]
 ;
: to ( nn ) over negate + -if { cr }
 ( back ) negate count negate line ; { cr }
 ( forw ) then count line ; { br }

: stp2 align create [ d# 708 d# 717 to d# 617 d# 600 to ] { cr }
 [ d# 500 d# 517 to d# 417 d# 400 to d# 300 d# 317 to d# 217 d# 200
 to ] { cr }
 [ d# 100 d# 117 to d# 17 d# 0 to d# -1 , ]
: stp1 align create [ d# 708 d# 8 to d# 7 d# 707 to ] { cr }
 [ d# 706 d# 6 to d# 5 d# 705 to d# 704 d# 4 to d# 3 d# 703 to ] { cr }
 [ d# 702 d# 2 to d# 1 d# 701 to d# 700 d# 0 to d# -1 , ]
: stp1a align create [ d# 708 d# 701 to d# -1 , ]
: stp0 align create [ d# 708 d# 8 to d# 9 d# 709 to d# 710 d# 10 to
 d# 11 d# 711 to d# 712 d# 12 to d# 13 d# 713 to d# 714 d# 14 to ]
 { cr }
 [ d# 15 d# 715 to d# 716 d# 16 to d# 17 d# 717 to d# -1 , ] { br }

: !p0 stp0 [ 'pths ] ! ; { -cr }
: !p1 stp1 [ 'pths ] d# 1 + ! ;
: !p1a stp1a [ 'pths ] d# 1 + ! ;
: !p2 stp2 [ 'pths ] d# 2 + ! ; }block

( 002B1C00 )               D# 711 shadow{ 
: line ncd ( comma nodes into a table starting at node ) n ( for )
 c ( nodes incrementing by ) d { cr }
: /left ( extend line toward the left )
: /right ( extend line toward the right )
: /up ( extend line upward )
: /down ( extend line downward )
: path ( make a default path table that ) { cr }
 ( covers the whole chip ) }block

( 002B2000 )               D# 712 code{ 
 ( ats target test given host port ) [ empty stp ! ] { br }

 [ compile serial load -canon ] :# usb 3 { cr }
 [ stp @ dup sport ! usb ! a-bps bps ! !nam ] { cr }
 ( functions ) [ d# 674 d# 4 loads ] ( exit ) { br }

 ( test status is ) { .pok br }

 ( details ) :# ph -1 :# id 0 :# tgt 0 :# pos 0 { cr }
 ( ------- ) :# ans 0 :# rval 0 { cr }
 ( ------- ) :# nrun 0 :# vval 0 { br }

: init d# 0 [ tgt ] ! d# 0 [ pos ] ! d# 0 [ nrun ] ! d# 0 [ id ] !
 d# 0 [ rval ] ! d# 0 [ ans ] ! d# 0 [ vval ] ! d# -1 [ ph ] ! ; [ init ]
 { cr }
 ( runner ) [ d# 684 d# 7 loads d# 672 load d# 710 load ] { cr }
 [ d# 714 d# 3 loads ] { br }

: run [ d# 712 ] list init pause talk { cr }
 ( .. ) 2pa [ 'pths ] d# 2 + ! d# 2 d# 708 hook d# 2 -hook { cr }
 ( .. ) !p0 !p1 !p2 setup ( ; ) { cr }
 d# 0 [ ph ] ! d# 0 path z t917 t913 { cr }
 d# 1 [ ph ] ! d# 1 path z t917 t913 !p1a { cr }
 d# 2 [ ph ] ! d# 1 path z t917 t913 !p1 { cr }
 d# 3 [ ph ] ! serht serth talk d# 1 [ vval ] ! ; [ run ] }block

( 002B2400 )               D# 713 shadow{ 
 ( this code runs selected creeper tests directly on a chip using the
 ide. use with a-com/c-com or a literal port number. ) { br }

: tgt ( current target node )
: pos ( posn of current active node in path )
: nrun ( number of tests run on current chip )
: id ( puka number for test being run )
: ans ( most recent answer from a test ) }block

( 002B2800 )               D# 714 code{ 
 ( - paths )
: atp2 align create { cr }
 [ d# 708 d# 700 to d# 600 d# 300 to d# -1 , ] { cr }
: atp0 align create [ d# 708 d# 408 to d# 407 d# 400 to ] { cr }
 [ d# 1400 d# 1700 to d# 1701 d# 1717 to d# 1617 d# 1601 to ] { cr }
 [ d# 1501 d# 1517 to d# 1417 d# 1401 to d# 1301 d# 1317 to ] { cr }
 [ d# 1217 d# 1200 to d# 1100 d# 1117 to d# 1017 d# 1000 to d# -1 , ]
: atp1 align create [ d# 708 d# 408 to d# 407 d# 400 to ] { cr }
 [ d# 1400 d# 1700 to d# 1701 d# 1001 to d# 1002 d# 1702 to ] { cr }
 [ d# 1703 d# 1003 to d# 1004 d# 1704 to d# 1705 d# 1005 to ] { cr }
 [ d# 1006 d# 1706 to d# 1707 d# 1007 to d# 1008 d# 1708 to ] { cr }
 [ d# 1709 d# 1009 to d# 1010 d# 1710 to d# 1711 d# 1011 to ] { cr }
 [ d# 1012 d# 1712 to d# 1713 d# 1013 to d# 1014 d# 1714 to ] { cr }
 [ d# 1715 d# 1015 to d# 1016 d# 1716 to d# 1717 d# 1017 to d# -1 , ]
: atp1a align create [ d# 708 d# 408 to d# 407 d# 400 to ] { cr }
 [ d# 1400 d# 1401 to d# 1501 d# 1500 to d# 1600 d# 1602 to ] { cr }
 [ d# 1502 d# 1202 to d# 1201 d# 1200 to d# 1100 d# 1000 to d# -1 , ]
 { br }

: !p0 atp0 [ 'pths ] ! ; { -cr }
: !p1 atp1 [ 'pths ] d# 1 + ! ;
: !p1a atp1a [ 'pths ] d# 1 + ! ;
: !p2 atp2 [ 'pths ] d# 2 + ! ; }block

( 002B2C00 )               D# 715 shadow{ 
 ( these paths are used by host chip to test the target chip via sync
 node 300. ) { br }

: atp2 ( runs from { 588F } to the { 578F } corner and down to { 3E8F }
 which controls target reset, accessing { 57AF } for ) [ serdes ] ( testing
 along the way. includes { 258F } so it may be used to boot both chips'
 300. )
: atp0 atp1 ( and ) atp1a ( steer clear of path two on their way to
 node 300's up port where they duplicate the paths used on tb001 for
 ats testing ) }block

( 002B3000 )               D# 716 code{ 
 ( - build port bridge )
: set ( n nn ) d# 2 swap hook [ d# 2 ] + [ h# 10000 ] * io r! ;
: rst ( n ) [ d# 500 ] set ; { br }

: !sync d# 2 [ d# 300 ] hook d# 0 d# 64 [ d# 1901 ] boot [ h# 19 ]
 call ; { br }

: pt@ ( a-n ) @ h# 15555 or ;
: frame ( a nd ) nn-n 2* d# 32768 + block + dup d# 2 + pt@ d# 3 + for
 dup pt@ lit' d# 6 call [ d# 1 ] + next drop ;
: !hitst d# 0 [ d# 1902 ] frame ;
: !lotst d# 0 [ d# 1903 ] frame ;
: !his d# 5 [ d# 1904 { EE2F } ] frame ; { br }

: !ours ( off ) [ h# 19 ] call d# 0 d# 64 [ d# 1904 ] boot ( ent )
 [ h# 30 ] call ; { cr }
: setup d# 0 rst !sync d# 1 rst { cr }
 d# 2 [ d# 300 ] hook ( !hitst ) !his !ours d# 2 -hook { cr }
 ( testing ) h# 0 [ d# 400 ] hook focus ( ; ) { cr }
 d# 2 -hook d# 1 -hook d# 0 -hook ; }block

( 002B3400 )               D# 717 shadow{ 
: setup ( resets target chip and sets up the port bridge for ide and
 creeper use. ) { br }

: first ( we load sync boot master in our { 258F } done by ) !sync
: second !his ( loads bridge in uut node { 258F } using ) frame ( which
 sends a boot frame starting at location ) [ a ] ( compiled for bin )
 [ nd's ] ( ram )
: third !ours ( loads bridge into our node { 258F } ) { br }

: setup ( does all this and leaves ide set to node { 320F } which may
 talk to { AF0F } through its up port for testing of the bridged 2-chip
 system. ) }block

( 002B3800 )               D# 718 code{ 
 ( - runner for { 1082F } serdes test ) { br }

: /many [ 'arg ] assign d# 250000 ;
: stest ( arg-ans ) /many pass ; { br }

: serht d# 2 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 701 ] kreep pass rip { cr }
 d# 1 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 1001 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 2 path [ d# 2113 ] some [ d# 701 ] kreep stest rip ; { br }

: serth d# 1 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 1001 ] kreep pass rip { cr }
 d# 2 path [ d# 2112 ] some /zero { cr }
 ( .. ) [ d# 701 ] kreep d# 0 [ d# 5 ] vtest drop { cr }
 d# 1 path [ d# 2113 ] some [ d# 1001 ] kreep stest rip ; }block

( 002B3C00 )               D# 719 shadow{ 
: serht ( transmits 250k words from host { 57AF } into tgt 001 with
 success feedback. ) }block

( 002B4000 )               D# 720 code{ 
 ( g144a12 automated testing system ) { cr }
 [ copyright c 2010-2011 ] greenarrays, inc. { cr }
 [ see db007 for ats documentation ] { br }

 d# 480 ( load block for f18 test code ) { indent }
      ( compiled for bins { 708F } and up ) { cr }
 d# 482 ( f18 test code and documentation ) { cr }
 d# 560 ( f18 ats master code ide mode ) { cr }
 d# 576 ( test compilation of steven's mem-random ) { cr }
 d# 580 ( pf ats f18 code ) { cr }
 d# 660 ( load block for tb001 ats ide pretest ) { cr }
 d# 670 ( load block for tb001 ats ide creepers ) { cr }
 d# 706 ( load block for creeper control scripts ) }block

( 002B4400 )               D# 721 shadow{ 
 }block

( 002B4800 )               D# 722 code{ 
 }block

( 002B4C00 )               D# 723 shadow{ 
 }block

( 002B5000 )               D# 724 code{ 
 }block

( 002B5400 )               D# 725 shadow{ 
 }block

( 002B5800 )               D# 726 code{ 
 }block

( 002B5C00 )               D# 727 shadow{ 
 }block

( 002B6000 )               D# 728 code{ 
 }block

( 002B6400 )               D# 729 shadow{ 
 }block

( 002B6800 )               D# 730 code{ 
 }block

( 002B6C00 )               D# 731 shadow{ 
 }block

( 002B7000 )               D# 732 code{ 
 }block

( 002B7400 )               D# 733 shadow{ 
 }block

( 002B7800 )               D# 734 code{ 
 }block

( 002B7C00 )               D# 735 shadow{ 
 }block

( 002B8000 )               D# 736 code{ 
 }block

( 002B8400 )               D# 737 shadow{ 
 }block

( 002B8800 )               D# 738 code{ 
 }block

( 002B8C00 )               D# 739 shadow{ 
 }block

( 002B9000 )               D# 740 code{ 
 }block

( 002B9400 )               D# 741 shadow{ 
 }block

( 002B9800 )               D# 742 code{ 
 }block

( 002B9C00 )               D# 743 shadow{ 
 }block

( 002BA000 )               D# 744 code{ 
 }block

( 002BA400 )               D# 745 shadow{ 
 }block

( 002BA800 )               D# 746 code{ 
 }block

( 002BAC00 )               D# 747 shadow{ 
 }block

( 002BB000 )               D# 748 code{ 
 }block

( 002BB400 )               D# 749 shadow{ 
 }block

( 002BB800 )               D# 750 code{ 
 }block

( 002BBC00 )               D# 751 shadow{ 
 }block

( 002BC000 )               D# 752 code{ 
 }block

( 002BC400 )               D# 753 shadow{ 
 }block

( 002BC800 )               D# 754 code{ 
 }block

( 002BCC00 )               D# 755 shadow{ 
 }block

( 002BD000 )               D# 756 code{ 
 }block

( 002BD400 )               D# 757 shadow{ 
 }block

( 002BD800 )               D# 758 code{ 
 }block

( 002BDC00 )               D# 759 shadow{ 
 }block

( 002BE000 )               D# 760 code{ 
 }block

( 002BE400 )               D# 761 shadow{ 
 }block

( 002BE800 )               D# 762 code{ 
 }block

( 002BEC00 )               D# 763 shadow{ 
 }block

( 002BF000 )               D# 764 code{ 
 }block

( 002BF400 )               D# 765 shadow{ 
 }block

( 002BF800 )               D# 766 code{ 
 }block

( 002BFC00 )               D# 767 shadow{ 
 }block

( 002C0000 )               D# 768 code{ 
 }block

( 002C0400 )               D# 769 shadow{ 
 }block

( 002C0800 )               D# 770 code{ 
 }block

( 002C0C00 )               D# 771 shadow{ 
 }block

( 002C1000 )               D# 772 code{ 
 }block

( 002C1400 )               D# 773 shadow{ 
 }block

( 002C1800 )               D# 774 code{ 
 }block

( 002C1C00 )               D# 775 shadow{ 
 }block

( 002C2000 )               D# 776 code{ 
 }block

( 002C2400 )               D# 777 shadow{ 
 }block

( 002C2800 )               D# 778 code{ 
 }block

( 002C2C00 )               D# 779 shadow{ 
 }block

( 002C3000 )               D# 780 code{ 
 }block

( 002C3400 )               D# 781 shadow{ 
 }block

( 002C3800 )               D# 782 code{ 
 }block

( 002C3C00 )               D# 783 shadow{ 
 }block

( 002C4000 )               D# 784 code{ 
 }block

( 002C4400 )               D# 785 shadow{ 
 }block

( 002C4800 )               D# 786 code{ 
 }block

( 002C4C00 )               D# 787 shadow{ 
 }block

( 002C5000 )               D# 788 code{ 
 }block

( 002C5400 )               D# 789 shadow{ 
 }block

( 002C5800 )               D# 790 code{ 
 }block

( 002C5C00 )               D# 791 shadow{ 
 }block

( 002C6000 )               D# 792 code{ 
 }block

( 002C6400 )               D# 793 shadow{ 
 }block

( 002C6800 )               D# 794 code{ 
 }block

( 002C6C00 )               D# 795 shadow{ 
 }block

( 002C7000 )               D# 796 code{ 
 }block

( 002C7400 )               D# 797 shadow{ 
 }block

( 002C7800 )               D# 798 code{ 
 }block

( 002C7C00 )               D# 799 shadow{ 
 }block

( 002C8000 )               D# 800 code{ 
 }block

( 002C8400 )               D# 801 shadow{ 
 }block

( 002C8800 )               D# 802 code{ 
 }block

( 002C8C00 )               D# 803 shadow{ 
 }block

( 002C9000 )               D# 804 code{ 
 }block

( 002C9400 )               D# 805 shadow{ 
 }block

( 002C9800 )               D# 806 code{ 
 }block

( 002C9C00 )               D# 807 shadow{ 
 }block

( 002CA000 )               D# 808 code{ 
 }block

( 002CA400 )               D# 809 shadow{ 
 }block

( 002CA800 )               D# 810 code{ 
 }block

( 002CAC00 )               D# 811 shadow{ 
 }block

( 002CB000 )               D# 812 code{ 
 }block

( 002CB400 )               D# 813 shadow{ 
 }block

( 002CB800 )               D# 814 code{ 
 }block

( 002CBC00 )               D# 815 shadow{ 
 }block

( 002CC000 )               D# 816 code{ 
 }block

( 002CC400 )               D# 817 shadow{ 
 }block

( 002CC800 )               D# 818 code{ 
 }block

( 002CCC00 )               D# 819 shadow{ 
 }block

( 002CD000 )               D# 820 code{ 
 }block

( 002CD400 )               D# 821 shadow{ 
 }block

( 002CD800 )               D# 822 code{ 
 }block

( 002CDC00 )               D# 823 shadow{ 
 }block

( 002CE000 )               D# 824 code{ 
 }block

( 002CE400 )               D# 825 shadow{ 
 }block

( 002CE800 )               D# 826 code{ 
 }block

( 002CEC00 )               D# 827 shadow{ 
 }block

( 002CF000 )               D# 828 code{ 
 }block

( 002CF400 )               D# 829 shadow{ 
 }block

( 002CF800 )               D# 830 code{ 
 }block

( 002CFC00 )               D# 831 shadow{ 
 }block

( 002D0000 )               D# 832 code{ 
 }block

( 002D0400 )               D# 833 shadow{ 
 }block

( 002D0800 )               D# 834 code{ 
 }block

( 002D0C00 )               D# 835 shadow{ 
 }block

( 002D1000 )               D# 836 code{ 
 }block

( 002D1400 )               D# 837 shadow{ 
 }block

( 002D1800 )               D# 838 code{ 
 }block

( 002D1C00 )               D# 839 shadow{ 
 }block

( 002D2000 )               D# 840 code{ 
 ( uncommitted/user code ) }block

( 002D2400 )               D# 841 shadow{ 
 ( this index page of { F0F } blocks is available for user code. )
 { br }

 ( any code delivered in this area is provided to facilitate working
 with examples presented in the user's guide. it may be deleted if
 you no longer have use for it. ) { br }

 ( when deleting examples here, be sure to remove references in load
 blocks such as 200. ) }block

( 002D2800 )               D# 842 code{ 
 ( pwm demo ) [ d# 600 node d# 0 org ] { br }

: pol ^ 00 ^ @b h# 2000 ( dw ) and if { cr }
 ( ... ) ^ 03 ^ ( ... ) down b! @b push ex { cr }
: rtn ^ 06 ^ ( ... ) io b! then ^ 08 ^ drop { br }

 ( cyc ie- ) h# 1FFFF and over . + -if { cr }
 ( ... ) ^ 0C ^ ( ... ) h# 20000 !b pol ; { cr }
 ( ... ) ^ 0F ^ then h# 10000 { 1F } !b pol ; { br }

: upd ^ 12 ^ ( xex- ) drop push drop h# 100 { cr }
 ( ... ) ^ 14 ^ pop pop ( iex- ) rtn ; ^ 16 ^ }block

( 002D2C00 )               D# 843 shadow{ 
 ( pwm demo for host node { 4B0F } ) { br }

: pol ( checks for ide inputs and calls ) down { cr }
 ( when noticed. )
: rtn ( is the return point from a ) down ( call ) { cr }
 ( and is used by ) [ upd ] ( as an re-entry point. )
: cyc ( begins the actual pwm code. )
: upd ( is the ide entry point for initial ) { cr }
 ( start or output update. ) }block

( 002D3000 )               D# 844 code{ 
 ( demo ide boot ) [ empty compile serial load ] { br }

 ( customize ) [ -canon d# 0 fh orgn ! ] { cr }
 [ a-com sport ! a-bps bps ! !nam ] { br }

: seed ( n ) h# 13 r! h# 12 call upd ; { br }

: run talk d# 0 d# 600 hook d# 0 d# 64 d# 600 boot { indent }
      upd ?ram panel d# 0 lit h# 18000 seed ; }block

( 002D3400 )               D# 845 shadow{ 
 ( configure ide for demo testing. ) { br }

 < ***no canonical opcodes*** > { cr }
 [ use the ] 'remote' [ ones ] { br }

: seed ( loads pwm 'rate' and re-/runs cycle. )
: run ( selects node { 4B0F } target, loads the pwm ) { cr }
 ( into it and starts it with a default value. ) }block

( 002D3800 )               D# 846 code{ 
 ( loader template ) [ target load ] { , , }
: seed ( n ) h# 13 r! h# 12 call upd ; { , , }
 [ loader load d# 0 d# 708 hook d# 0 -hook ] { , , }
 ( setup application ) { , ... }
      [ d# 600 +node d# 600 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 500 +node d# 500 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 200 +node d# 200 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 100 +node d# 100 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 709 +node d# 709 /ram h# 19 /p ] { , ... }
      [ d# 609 +node d# 609 /ram d# 0 /p ] { , ... }
      [ d# 509 +node d# 509 /ram d# 0 /p ] { , ... }
      [ d# 508 +node d# 508 /ram d# 0 /p ] { , ... }
      [ d# 507 +node d# 507 /ram d# 0 /p ] { , ... }
      [ d# 506 +node d# 506 /ram d# 0 /p ] { , ... }
      [ d# 505 +node d# 505 /ram d# 0 /p ] { , ... }
      [ d# 504 +node d# 504 /ram d# 0 /p ] { , ... }
      [ d# 503 +node d# 503 /ram d# 0 /p ] { , ... }
      [ d# 502 +node d# 502 /ram d# 0 /p ] { , ... }
      [ d# 501 +node d# 501 /ram d# 0 /p ] { , , }
 [ d# 2 ship panel upd ?ram ] }block

( 002D3C00 )               D# 847 shadow{ 
 }block

( 002D4000 )               D# 848 code{ 
 ( framer template ) [ empty ] { , }
 [ compile streamer load framer load ] { , }
 ( default ) [ entire course ] { , , }
 ( setup application ) { , ... }
      [ d# 600 +node d# 600 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 500 +node d# 500 /ram d# 0 d# 1 /stack h# 12 /p ] { , ... }
      [ d# 501 +node d# 501 /ram d# 0 /p ] { , ... }
      [ d# 502 +node d# 502 /ram d# 0 /p ] { , ... }
      [ d# 503 +node d# 503 /ram d# 0 /p ] { , ... }
      [ d# 504 +node d# 504 /ram d# 0 /p ] { , ... }
      [ d# 505 +node d# 505 /ram d# 0 /p ] { , ... }
      [ d# 506 +node d# 506 /ram d# 0 /p ] { , ... }
      [ d# 507 +node d# 507 /ram d# 0 /p ] { , ... }
      [ d# 508 +node d# 508 /ram d# 0 /p ] { , ... }
      [ d# 509 +node d# 509 /ram d# 0 /p ] { , ... }
      [ d# 609 +node d# 609 /ram d# 0 /p ] { , ... }
      [ d# 709 +node d# 709 /ram d# 0 /p ] { , , }
 ( make boot ) [ frame ] { , , }
 ( fb ) [ d# 0 fh loaded ! nores strlen leng ! ] { , }
 ( erase flash ) [ stream ers ] { , }
 ( flash ) [ stream d# 0 swap 18burn ] }block

( 002D4400 )               D# 849 shadow{ 
 }block

( 002D4800 )               D# 850 code{ 
 }block

( 002D4C00 )               D# 851 shadow{ 
 }block

( 002D5000 )               D# 852 code{ 
 ( pwm demo ) [ d# 500 node d# 0 org ] { br }

: pol ^ 00 ^ @b h# 2000 ( dw ) and if { cr }
 ( ... ) ^ 03 ^ ( ... ) down b! @b push ex { cr }
: rtn ^ 06 ^ ( ... ) io b! then ^ 08 ^ [ h# 16 ] end { br }

: cyc ^ 09 ^ ( ie- ) h# 1FFFF and over . + -if { cr }
 ( ... ) ^ 0C ^ ( ... ) h# 20000 !b pol ; { cr }
 ( ... ) ^ 0F ^ then h# 10000 { 1F } !b pol ; { br }

: upd ^ 12 ^ ( xex- ) drop push drop h# 1100 { cr }
 ( ... ) ^ 14 ^ pop pop ( iex- ) rtn ; ^ 16 ^ { br }

: chk ^ 16 ^ ( xex- ) drop push @b h# 8000 ( rw ) { cr }
 ( ... ) ^ 18 ^ and if drop drop right . { cr }
 ( ... ) ^ 1B ^ ( ... ) b! @b dup io b! then { cr }
 ( ... ) ^ 1E ^ drop pop ( ie- ) cyc ; ^ 20 ^ }block

( 002D5400 )               D# 853 shadow{ 
 ( pwm demo for host node { 3E8F } ) { br }

: pol ( checks for ide inputs and calls ) up { cr }
 ( when noticed. )
: rtn ( is the return point from a ) up ( call ) { cr }
 ( and is used by ) [ upd ] ( as an re-entry point. )
: cyc ( begins the actual pwm code. )
: upd ( is the ide entry point for initial ) { cr }
 ( start or output update. ) }block

( 002D5800 )               D# 854 code{ 
 ( pwm demo ) [ d# 200 node d# 0 org ] { br }

: pol ^ 00 ^ @b h# 8000 ( rw ) and if { cr }
 ( ... ) ^ 03 ^ ( ... ) right b! @b push ex { cr }
: rtn ^ 06 ^ ( ... ) io b! then ^ 08 ^ drop { br }

 ( cyc ie- ) h# 1FFFF and over . + -if { cr }
 ( ... ) ^ 0C ^ ( ... ) h# 20000 !b pol ; { cr }
 ( ... ) ^ 0F ^ then h# 10000 { 1F } !b pol ; { br }

: upd ^ 12 ^ ( xex- ) drop push drop h# 8100 { cr }
 ( ... ) ^ 14 ^ pop pop ( iex- ) rtn ; ^ 16 ^ }block

( 002D5C00 )               D# 855 shadow{ 
 ( pwm demo for host node { 190F } ) { br }

: pol ( checks for ide inputs and calls ) down { cr }
 ( when noticed. )
: rtn ( is the return point from a ) down ( call ) { cr }
 ( and is used by ) [ upd ] ( as an re-entry point. )
: cyc ( begins the actual pwm code. )
: upd ( is the ide entry point for initial ) { cr }
 ( start or output update. ) }block

( 002D6000 )               D# 856 code{ 
 ( pwm demo ) [ d# 100 node d# 0 org ] { br }

: pol ^ 00 ^ @b h# 2000 ( dw ) and if { cr }
 ( ... ) ^ 03 ^ ( ... ) down b! @b push ex { cr }
: rtn ^ 06 ^ ( ... ) io b! then ^ 08 ^ drop { br }

 ( cyc ie- ) h# 1FFFF and over . + -if { cr }
 ( ... ) ^ 0C ^ ( ... ) h# 20000 !b pol ; { cr }
 ( ... ) ^ 0F ^ then h# 10000 { 1F } !b pol ; { br }

: upd ^ 12 ^ ( xex- ) drop push drop h# 10100 { cr }
 ( ... ) ^ 14 ^ pop pop ( iex- ) rtn ; ^ 16 ^ }block

( 002D6400 )               D# 857 shadow{ 
 ( pwm demo for host node { C8F } ) { br }

: pol ( checks for ide inputs and calls ) up { cr }
 ( when noticed. )
: rtn ( is the return point from a ) up ( call ) { cr }
 ( and is used by ) [ upd ] ( as an re-entry point. )
: cyc ( begins the actual pwm code. )
: upd ( is the ide entry point for initial ) { cr }
 ( start or output update. ) }block

( 002D6800 )               D# 858 code{ 
 ( potentiometer code ) [ d# 709 node d# 0 org ] { br }

: pol @b h# 8000 ( rw ) and if { cr }
 ( ... ... ) right b! @b push ex io b! drop ; { cr }
 ( ... ) then d# 0 + d# 0 + d# 0 + @b + . drop ; { br }

: check ( v-v ) io b! @b - h# 4000 ( dr ) and if { cr }
 ( ... ... ) down a! over ! drop ; { cr }
 ( ... ) then d# 0 + drop . @b drop ; { br }

: adc ^ 19 ^ ( mode ) h# 0 !b { cr }
 ( ... initial ) data a! dup ! @ push { br }

: read ( -v ) pol data a! dup ! @ dup a! { cr }
 ( ... ) - d# 1 . + pop . + h# 1FFFF and { cr }
 ( ... ) a push check read ; ^ 29 ^ }block

( 002D6C00 )               D# 859 shadow{ 
 }block

( 002D7000 )               D# 860 code{ 
 ( wire code ) { , }
 [ d# 609 node d# 0 org reclaim ]
: pass down b! up a! begin @b ! end ; { , }
 [ d# 509 node d# 0 org reclaim ]
: pass up b! right a! begin @b ! end ; { , }
 [ d# 508 node d# 0 org reclaim ]
: pass right b! left a! begin @b ! end ; { , }
 [ d# 507 node d# 0 org reclaim ]
: pass left b! right a! begin @b ! end ; { , }
 [ d# 506 node d# 0 org reclaim ]
: pass right b! left a! begin @b ! end ; { , }
 [ d# 505 node d# 0 org reclaim ]
: pass left b! right a! begin @b ! end ; { , }
 [ d# 504 node d# 0 org reclaim ]
: pass right b! left a! begin @b ! end ; { , }
 [ d# 503 node d# 0 org reclaim ]
: pass left b! right a! begin @b ! end ; { , }
 [ d# 502 node d# 0 org reclaim ]
: pass ( right b! left a! begin @b ! end ; ) { , }
 [ d# 501 node d# 0 org reclaim ]
: pass ( left b! right a! begin @b ! end ; ) }block

( 002D7400 )               D# 861 shadow{ 
 }block

( 002D7800 )               D# 862 code{ 
 ( scaling code ) [ d# 501 node d# 0 org ] { br }

 ( reduction ) d# 0 { br }

: pol @b h# 8000 ( rw ) and if { cr }
 ( ... ) right b! @b push ex { cr }
 ( ... ) io b! then drop { br }

: check ( -n ) @b h# 800 ( lw ) and if { cr }
 ( ... ... ) left a! push @ { br }

: read ( rn-vr ) over over - push . + ( -rf ) -if { cr }
 ( adjust lo ) drop drop pop dup push d# 3 . + d# 2 { cr }
 ( ... ) then dup - d# 18 . + ( -rfo ) -if { cr }
 ( adjust hi ) drop drop drop pop dup push { cr }
 ( ... ... ) d# 16 . + d# 15 d# 0 { cr }
 ( ... ) then drop pop drop if { cr }
 ( ... ... ) h# 3FFFF . + push d# 1 begin 2* unext { cr }
 ( swap ) then a! push a pop ( -vr ) { br }

 ( ... ... ) right a! over ! pop { cr }
 ( ... ) then drop pol ; ^ 2E ^ }block

( 002D7C00 )               D# 863 shadow{ 
 }block

( 002D8000 )               D# 864 code{ 
 ( averaging buffer code ) [ d# 502 node d# 0 org ]
: pass h# 20 a! d# 31 for { , }
 ( ... ... ) right b! @b !+ { , }
 ( ... ... ) a push h# 20 a! @+ { , }
 ( ... ... ) d# 30 for @+ + 2/ unext { , }
 ( ... ... ) pop a! left b! !b { , }
 ( ... ) next pass ; ^ 11 ^ }block

( 002D8400 )               D# 865 shadow{ 
 }block

( 002D8800 )               D# 866 code{ 
 }block

( 002D8C00 )               D# 867 shadow{ 
 }block

( 002D9000 )               D# 868 code{ 
 }block

( 002D9400 )               D# 869 shadow{ 
 }block

( 002D9800 )               D# 870 code{ 
 }block

( 002D9C00 )               D# 871 shadow{ 
 }block

( 002DA000 )               D# 872 code{ 
 }block

( 002DA400 )               D# 873 shadow{ 
 }block

( 002DA800 )               D# 874 code{ 
 }block

( 002DAC00 )               D# 875 shadow{ 
 }block

( 002DB000 )               D# 876 code{ 
 }block

( 002DB400 )               D# 877 shadow{ 
 }block

( 002DB800 )               D# 878 code{ 
 }block

( 002DBC00 )               D# 879 shadow{ 
 }block

( 002DC000 )               D# 880 code{ 
 }block

( 002DC400 )               D# 881 shadow{ 
 }block

( 002DC800 )               D# 882 code{ 
 }block

( 002DCC00 )               D# 883 shadow{ 
 }block

( 002DD000 )               D# 884 code{ 
 }block

( 002DD400 )               D# 885 shadow{ 
 }block

( 002DD800 )               D# 886 code{ 
 }block

( 002DDC00 )               D# 887 shadow{ 
 }block

( 002DE000 )               D# 888 code{ 
 }block

( 002DE400 )               D# 889 shadow{ 
 }block

( 002DE800 )               D# 890 code{ 
 }block

( 002DEC00 )               D# 891 shadow{ 
 }block

( 002DF000 )               D# 892 code{ 
 }block

( 002DF400 )               D# 893 shadow{ 
 }block

( 002DF800 )               D# 894 code{ 
 }block

( 002DFC00 )               D# 895 shadow{ 
 }block

( 002E0000 )               D# 896 code{ 
 }block

( 002E0400 )               D# 897 shadow{ 
 }block

( 002E0800 )               D# 898 code{ 
 }block

( 002E0C00 )               D# 899 shadow{ 
 }block

( 002E1000 )               D# 900 code{ 
 }block

( 002E1400 )               D# 901 shadow{ 
 }block

( 002E1800 )               D# 902 code{ 
 }block

( 002E1C00 )               D# 903 shadow{ 
 }block

( 002E2000 )               D# 904 code{ 
 }block

( 002E2400 )               D# 905 shadow{ 
 }block

( 002E2800 )               D# 906 code{ 
 }block

( 002E2C00 )               D# 907 shadow{ 
 }block

( 002E3000 )               D# 908 code{ 
 }block

( 002E3400 )               D# 909 shadow{ 
 }block

( 002E3800 )               D# 910 code{ 
 }block

( 002E3C00 )               D# 911 shadow{ 
 }block

( 002E4000 )               D# 912 code{ 
 }block

( 002E4400 )               D# 913 shadow{ 
 }block

( 002E4800 )               D# 914 code{ 
 }block

( 002E4C00 )               D# 915 shadow{ 
 }block

( 002E5000 )               D# 916 code{ 
 }block

( 002E5400 )               D# 917 shadow{ 
 }block

( 002E5800 )               D# 918 code{ 
 }block

( 002E5C00 )               D# 919 shadow{ 
 }block

( 002E6000 )               D# 920 code{ 
 }block

( 002E6400 )               D# 921 shadow{ 
 }block

( 002E6800 )               D# 922 code{ 
 }block

( 002E6C00 )               D# 923 shadow{ 
 }block

( 002E7000 )               D# 924 code{ 
 }block

( 002E7400 )               D# 925 shadow{ 
 }block

( 002E7800 )               D# 926 code{ 
 }block

( 002E7C00 )               D# 927 shadow{ 
 }block

( 002E8000 )               D# 928 code{ 
 }block

( 002E8400 )               D# 929 shadow{ 
 }block

( 002E8800 )               D# 930 code{ 
 }block

( 002E8C00 )               D# 931 shadow{ 
 }block

( 002E9000 )               D# 932 code{ 
 }block

( 002E9400 )               D# 933 shadow{ 
 }block

( 002E9800 )               D# 934 code{ 
 }block

( 002E9C00 )               D# 935 shadow{ 
 }block

( 002EA000 )               D# 936 code{ 
 }block

( 002EA400 )               D# 937 shadow{ 
 }block

( 002EA800 )               D# 938 code{ 
 }block

( 002EAC00 )               D# 939 shadow{ 
 }block

( 002EB000 )               D# 940 code{ 
 }block

( 002EB400 )               D# 941 shadow{ 
 }block

( 002EB800 )               D# 942 code{ 
 }block

( 002EBC00 )               D# 943 shadow{ 
 }block

( 002EC000 )               D# 944 code{ 
 }block

( 002EC400 )               D# 945 shadow{ 
 }block

( 002EC800 )               D# 946 code{ 
 }block

( 002ECC00 )               D# 947 shadow{ 
 }block

( 002ED000 )               D# 948 code{ 
 }block

( 002ED400 )               D# 949 shadow{ 
 }block

( 002ED800 )               D# 950 code{ 
 }block

( 002EDC00 )               D# 951 shadow{ 
 }block

( 002EE000 )               D# 952 code{ 
 }block

( 002EE400 )               D# 953 shadow{ 
 }block

( 002EE800 )               D# 954 code{ 
 }block

( 002EEC00 )               D# 955 shadow{ 
 }block

( 002EF000 )               D# 956 code{ 
 }block

( 002EF400 )               D# 957 shadow{ 
 }block

( 002EF800 )               D# 958 code{ 
 }block

( 002EFC00 )               D# 959 shadow{ 
 }block

( 002F0000 )               D# 960 code{ 
 ( uncommitted/user code ) }block

( 002F0400 )               D# 961 shadow{ 
 ( this index page of { F0F } blocks is available for user code. )
 { br }

 ( any code delivered in this area is provided to facilitate working
 with examples presented in the user's guide. it may be deleted if
 you no longer have use for it. ) { br }

 ( when deleting examples here, be sure to remove references in load
 blocks such as 200. ) }block

( 002F0800 )               D# 962 code{ 
 }block

( 002F0C00 )               D# 963 shadow{ 
 }block

( 002F1000 )               D# 964 code{ 
 }block

( 002F1400 )               D# 965 shadow{ 
 }block

( 002F1800 )               D# 966 code{ 
 }block

( 002F1C00 )               D# 967 shadow{ 
 }block

( 002F2000 )               D# 968 code{ 
 }block

( 002F2400 )               D# 969 shadow{ 
 }block

( 002F2800 )               D# 970 code{ 
 }block

( 002F2C00 )               D# 971 shadow{ 
 }block

( 002F3000 )               D# 972 code{ 
 }block

( 002F3400 )               D# 973 shadow{ 
 }block

( 002F3800 )               D# 974 code{ 
 }block

( 002F3C00 )               D# 975 shadow{ 
 }block

( 002F4000 )               D# 976 code{ 
 }block

( 002F4400 )               D# 977 shadow{ 
 }block

( 002F4800 )               D# 978 code{ 
 }block

( 002F4C00 )               D# 979 shadow{ 
 }block

( 002F5000 )               D# 980 code{ 
 }block

( 002F5400 )               D# 981 shadow{ 
 }block

( 002F5800 )               D# 982 code{ 
 }block

( 002F5C00 )               D# 983 shadow{ 
 }block

( 002F6000 )               D# 984 code{ 
 }block

( 002F6400 )               D# 985 shadow{ 
 }block

( 002F6800 )               D# 986 code{ 
 }block

( 002F6C00 )               D# 987 shadow{ 
 }block

( 002F7000 )               D# 988 code{ 
 }block

( 002F7400 )               D# 989 shadow{ 
 }block

( 002F7800 )               D# 990 code{ 
 }block

( 002F7C00 )               D# 991 shadow{ 
 }block

( 002F8000 )               D# 992 code{ 
 }block

( 002F8400 )               D# 993 shadow{ 
 }block

( 002F8800 )               D# 994 code{ 
 }block

( 002F8C00 )               D# 995 shadow{ 
 }block

( 002F9000 )               D# 996 code{ 
 }block

( 002F9400 )               D# 997 shadow{ 
 }block

( 002F9800 )               D# 998 code{ 
 }block

( 002F9C00 )               D# 999 shadow{ 
 }block

( 002FA000 )               D# 1000 code{ 
 }block

( 002FA400 )               D# 1001 shadow{ 
 }block

( 002FA800 )               D# 1002 code{ 
 }block

( 002FAC00 )               D# 1003 shadow{ 
 }block

( 002FB000 )               D# 1004 code{ 
 }block

( 002FB400 )               D# 1005 shadow{ 
 }block

( 002FB800 )               D# 1006 code{ 
 }block

( 002FBC00 )               D# 1007 shadow{ 
 }block

( 002FC000 )               D# 1008 code{ 
 }block

( 002FC400 )               D# 1009 shadow{ 
 }block

( 002FC800 )               D# 1010 code{ 
 }block

( 002FCC00 )               D# 1011 shadow{ 
 }block

( 002FD000 )               D# 1012 code{ 
 }block

( 002FD400 )               D# 1013 shadow{ 
 }block

( 002FD800 )               D# 1014 code{ 
 }block

( 002FDC00 )               D# 1015 shadow{ 
 }block

( 002FE000 )               D# 1016 code{ 
 }block

( 002FE400 )               D# 1017 shadow{ 
 }block

( 002FE800 )               D# 1018 code{ 
 }block

( 002FEC00 )               D# 1019 shadow{ 
 }block

( 002FF000 )               D# 1020 code{ 
 }block

( 002FF400 )               D# 1021 shadow{ 
 }block

( 002FF800 )               D# 1022 code{ 
 }block

( 002FFC00 )               D# 1023 shadow{ 
 }block

( 00300000 )               D# 1024 code{ 
 }block

( 00300400 )               D# 1025 shadow{ 
 }block

( 00300800 )               D# 1026 code{ 
 }block

( 00300C00 )               D# 1027 shadow{ 
 }block

( 00301000 )               D# 1028 code{ 
 }block

( 00301400 )               D# 1029 shadow{ 
 }block

( 00301800 )               D# 1030 code{ 
 }block

( 00301C00 )               D# 1031 shadow{ 
 }block

( 00302000 )               D# 1032 code{ 
 }block

( 00302400 )               D# 1033 shadow{ 
 }block

( 00302800 )               D# 1034 code{ 
 }block

( 00302C00 )               D# 1035 shadow{ 
 }block

( 00303000 )               D# 1036 code{ 
 }block

( 00303400 )               D# 1037 shadow{ 
 }block

( 00303800 )               D# 1038 code{ 
 }block

( 00303C00 )               D# 1039 shadow{ 
 }block

( 00304000 )               D# 1040 code{ 
 }block

( 00304400 )               D# 1041 shadow{ 
 }block

( 00304800 )               D# 1042 code{ 
 }block

( 00304C00 )               D# 1043 shadow{ 
 }block

( 00305000 )               D# 1044 code{ 
 }block

( 00305400 )               D# 1045 shadow{ 
 }block

( 00305800 )               D# 1046 code{ 
 }block

( 00305C00 )               D# 1047 shadow{ 
 }block

( 00306000 )               D# 1048 code{ 
 }block

( 00306400 )               D# 1049 shadow{ 
 }block

( 00306800 )               D# 1050 code{ 
 }block

( 00306C00 )               D# 1051 shadow{ 
 }block

( 00307000 )               D# 1052 code{ 
 }block

( 00307400 )               D# 1053 shadow{ 
 }block

( 00307800 )               D# 1054 code{ 
 }block

( 00307C00 )               D# 1055 shadow{ 
 }block

( 00308000 )               D# 1056 code{ 
 }block

( 00308400 )               D# 1057 shadow{ 
 }block

( 00308800 )               D# 1058 code{ 
 }block

( 00308C00 )               D# 1059 shadow{ 
 }block

( 00309000 )               D# 1060 code{ 
 }block

( 00309400 )               D# 1061 shadow{ 
 }block

( 00309800 )               D# 1062 code{ 
 }block

( 00309C00 )               D# 1063 shadow{ 
 }block

( 0030A000 )               D# 1064 code{ 
 }block

( 0030A400 )               D# 1065 shadow{ 
 }block

( 0030A800 )               D# 1066 code{ 
 }block

( 0030AC00 )               D# 1067 shadow{ 
 }block

( 0030B000 )               D# 1068 code{ 
 }block

( 0030B400 )               D# 1069 shadow{ 
 }block

( 0030B800 )               D# 1070 code{ 
 }block

( 0030BC00 )               D# 1071 shadow{ 
 }block

( 0030C000 )               D# 1072 code{ 
 }block

( 0030C400 )               D# 1073 shadow{ 
 }block

( 0030C800 )               D# 1074 code{ 
 }block

( 0030CC00 )               D# 1075 shadow{ 
 }block

( 0030D000 )               D# 1076 code{ 
 }block

( 0030D400 )               D# 1077 shadow{ 
 }block

( 0030D800 )               D# 1078 code{ 
 }block

( 0030DC00 )               D# 1079 shadow{ 
 }block

( 0030E000 )               D# 1080 code{ 
 ( compile 16-bit eforth virtual machine ) { cr }
 [ reclaim ] { , , }
 ( sram cluster mk1 ) [ sram load ] { , ... }
      ( user ) [ d# 108 node h# 39 org d# 278 load d# 1817 bin ] { cr }
 ( boot flash-sram pipe ) [ d# 1170 d# 2 loads ] { , , }
 ( e4vm16 siobus wires ) [ d# 1120 load ] { indent }
      ( tx plug ) [ d# 100 node d# 1124 load ] { indent }
      ( rx plug ) [ d# 200 node d# 1126 d# 2 loads ] { indent }
      ( 1-pin plug ) [ d# 500 node d# 1130 load ] { indent }
      ( 1-pin plug ) [ d# 600 node d# 1130 load d# 1813 bin ] { , ... }
      ( flash plug ) [ d# 704 node d# 1132 load ] { cr }
 ( e4vm16 stack ) [ d# 106 node ] { indent }
      ( sram+ ) [ h# 39 org d# 278 load ] { indent }
      [ d# 1082 d# 2 loads ] ( +buds ) [ d# 1086 d# 4 loads ] { cr }
 ( e4vm16 bitsy +buds ) [ d# 1094 d# 8 loads ] { cr }
 ( e4vm16 starter ) [ d# 207 node ] ( sram+ ) [ h# 39 org d# 278 load
 ' -d-- ' ---u h# 8A00 d# 1114 load ] { cr }
 ( e4vm16 flash-sram pipe { 8ACF } load ) { cr }
 ( erase and burn flash ) [ d# 288 load ] { cr }
 ( spi speedup ) [ d# 290 load ] }block

( 0030E400 )               D# 1081 shadow{ 
 }block

( 0030E800 )               D# 1082 code{ 
 ( - e4vm16 stack 8xxx-9xxx ) { cr -cr }
 ( 'x@ ) [ h# 3C org ]
: 'au@ ( a-w ) ^ 3C ^ [ h# 0 org ]
: '1+ ( w-w ) ^ 00 ^ d# 1 . + { -cr }
: mask ( w-w ) ^ 02 ^ h# FFFF and ;
: '2/ ( w-w ) ^ 04 ^ 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt ) ^ 06 ^ dup '1+ over x@ ;
: 'au! ( pst-p43 ) ^ 08 ^ x!
: popst ( p-pst ) ^ 09 ^ popt
: pops ( pt-pst ) ^ 0A ^ push popt pop ;
: pop43 ( pst-p43st ) ^ 0C ^ push push popst pop pop ;
: '1- ( w-w ) ^ 0E ^ d# -1 . + mask ; [ here ] ( 'x!-2 ) [ h# 37 org ]
: psht ( pt-p ) ^ 37 ^ push '1- pop over ( x! ; ) ^ 39 ^ ( * ) [ org ]
: pshs ( pst-pt ) ^ 11 ^ push psht pop ;
: pshw ( pstw-ptw ) ^ 13 ^ push pshs pop ;
: 'sp@ ( pst-ptp ) ^ 15 ^ pshs psht dup pops ;
: 'sp! ( ptp-pst ) ^ 18 ^ pshs popst ; { br }

: 'drop ( pst-p3s ) ^ 1A ^ drop pops ;
: 'dup ( pst-ptt ) ^ 1B ^ dup pshw ;
: 'over ( pst-pts ) ^ 1C ^ over pshw ;
: 'swap ( st-ts ) ^ 1D ^ over push push drop pop pop ;
: 'or ( pst-p3w ) ^ 1F ^ over - and
: 'xor ( pst-p3w ) ^ 20 ^ or pops ;
: 'and ( pst-p3w ) ^ 21 ^ and pops ; }block

( 0030EC00 )               D# 1083 shadow{ 
 ( notes- ) { indent }
      ( the e4th stack node must abut the memory driver to have fast
 bidirectional access to ) { cr }
 ( external memory. ) { indent }
      ( the code must not overwrite the sram user code compiled at )
 [ h# 39 ] { indent }
      psht ( is placed so it falls into ) x! { indent }
      ( names beginning with ' are e4vm code words. others are internal
 words ) { indent }
      ( e4th's external data stack grows down ) { cr }
 ( with pre-dec writes and post-inc reads. ) { indent }
      ( the stack-node's stack keeps the e4th ) { cr }
 [ stack pointer ] ( and cached ) [ s ] ( and ) [ t ] { indent }
      ( 16-bit words are ) [ 00.nnnn.nnnn.nnnn.nnnn ] }block

( 0030F000 )               D# 1084 code{ 
 ( --- more stack )
: 'um+ ( uu-uc ) ^ 22 ^ + h# 10000 over and if or d# 1 ;
: 'nop ^ 27 ^ then ;
: 'zlt ( n-f ) ^ 28 ^ 2* 2* -if dup or ..
: 'inv ( w-w ) ^ 2A ^ - mask ; ^ 2B ^ then dup or ; { br }

 ^ 2C ^ ( must be at or before ) [ h# 32 org ] { cr }
 ( bitsy left slot2 call reaches { 61F } - { 6FF } )
: c.s* ( code0* prix3 ) ^ 32 ^ 2* -if { cr }
 ( code01* prix4 ) ^ 33 ^ 2* -if -d-- ; then ---u ; { cr }
 ( code00* prix4 ) ^ 36 ^ then drop push ; { br }

 ^ 37 ^ [ exit ] ( started by ide )
: start h# FFE0 h# 0 dup ( sp.s.t ) { indent }
      ( memory ) right b! ( bitsy ) --l- ; ^ 3D ^ }block

( 0030F400 )               D# 1085 shadow{ 
 ( notes- ) { indent }
      ( the initial sp is reset by ) [ cold ] { indent }
      ( code must fit before ) psht }block

( 0030F800 )               D# 1086 code{ 
 ( -- stack up bud axxx ) [ d# 206 node h# 20 org ]
: start @p b! ahead [ ' ---u , ]
: xqt ^ 22 ^ @b push ex
: cmd ^ 23 ^ then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / ) { br }

 ^ 25 ^ }block

( 0030FC00 )               D# 1087 shadow{ 
 }block

( 00310000 )               D# 1088 code{ 
 }block

( 00310400 )               D# 1089 shadow{ 
 }block

( 00310800 )               D# 1090 code{ 
 ( -- stack down bud bxxx ) [ d# 6 node h# 20 org ]
: start @p b! ahead [ ' -d-- , ]
: xqt ^ 22 ^ @b push ex
: cmd ^ 23 ^ then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / ) { br }

: .ex! ( pst-p54 ) ^ 25 ^ @p @p @p ( reversed! ) { indent }
      ( / ) pops ; ( ' ) ex! ( ' ) pop43 ( / ) !b !b !b ;
: .ex@ ( pst-p3w ) ^ 2A ^ @p @p .. ( reversed! ) { indent }
      ( / ) pops ; ( ' ) ex@ ( / ) !b !b ;
: .cx? ( pst-p5f ) ^ 2E ^ @p @p @p ( reversed! ) { indent }
      ( / ) pops ; ( ' ) cx? ( ' ) pop43 ( / ) !b !b !b ; { br }

: '+ ( pst-p3n ) ^ 33 ^ @p @p .. ( reversed! ) { indent }
      ( / ) pops ; ( ' ) + mask ( / ) !b !b ;
: '2* ( w-w ) ^ 37 ^ @p !b ; ( / ) 2* mask ; ( / ) ^ 39 ^ }block

( 00310C00 )               D# 1091 shadow{ 
 }block

( 00311000 )               D# 1092 code{ 
 }block

( 00311400 )               D# 1093 shadow{ 
 }block

( 00311800 )               D# 1094 code{ 
 ( - e4vm16 bitsy cxxx ) [ d# 105 node h# 0 org ]
: inc ( a-a ) ^ 00 ^ d# 1 . + ;
: bpshw ( w- ) ^ 02 ^ @p !b !b ; ( / ) @p pshw ( / )
: 'rp@ ( pri-pri ) ^ 04 ^ push over bpshw pop ;
: 'else { -cr }
: bx@ ( a-w ) ^ 06 ^ @p !b !b . ( / ) @p x@ ( / )
: gett ( -w ) @p !b @b ; ( / ) !p .. ( / )
: 'rfrom ( pri-pri ) ^ 0A ^ push bpshw
: popr ( p.i-pri ) ^ 0B ^ inc
: getr ( p.i-pri ) ^ 0C ^ dup bx@ pop ;
: 'exit ( pri-pri ) ^ 0E ^ drop push popr ;
: bpops ( -w ) ^ 0F ^ @p !b @b ; ( / ) !p pops ( / )
: bx! ( wa- ) ^ 11 ^ @p !b !b . ( / ) @p push @p . ( / ) { indent }
      !b @p !b ; ( / ) pop x! ( / )
: pshr ( aw-a ) ^ 15 ^ over bx!
: dec ( a-a ) ^ 16 ^ d# -1 . + ;
: 'tor ( pri-pri ) ^ 18 ^ push pshr bpops pop ;
: 'rp! ( pri-pri ) ^ 1B ^ push pshr bpops getr ;
: 'if ( pri-pri ) ^ 1E ^ bpops if drop inc ; { indent }
      then drop bx@ ;
: 'con ( pri-pri ) ^ 22 ^ bx@
: 'var ( pri-pri ) ^ 23 ^ dup bpshw 'exit ; ^ 25 ^ }block

( 00311C00 )               D# 1095 shadow{ 
 ( notes- ) { indent }
      ( the bitsy node keeps the return-stack ) { cr }
 ( pointer, top-of-return-stack ) r ( and the interpreter pointer on
 its stack. ) { indent }
      ( memory access gets done only through the stack node. ) }block

( 00312000 )               D# 1096 code{ 
 ( --- more bitsy ) { cr }
 ^ 25 ^ ( must be at or before ) [ h# 28 org ] { indent }
      begin drop ;
: 'exe ( pri-pri ) ^ 29 ^ bpops
: ?exe ( pri?-pri ) ^ 2A ^ until
: xxt ( prix-pri ) ^ 2B ^ dup 2* 2* -if { cr }
 ( code prix2 ) ^ 2D ^ 2* -if { cr }
 ( code1* prix3 ) ^ 2E ^ 2* -if { cr }
 ( code11* prix4 ) ^ 2F ^ 2* -if -d-- ; then ---u ; { cr }
 ( code101 prix4 ) ^ 32 ^ then 2* -if r--- ; { cr }
 ( code100 prix5 ) ^ 34 ^ then drop push ; { cr }
 ( code0* prix3 ) ^ 35 ^ then ( slot2 port call! ) { indent }
      @p !b push . ( / ) @p @p c.s* ( / ) !b pop !b ; { cr }
 ( list prix2 ) ^ 38 ^ then drop push push pshr { indent }
      pop pop 2* ;
: step ( pri-pri ) ^ 3B ^ dup bx@ push inc pop xxt ;
: bitsy ( pri ) ^ 3E ^ step bitsy ; { 7DF } ( in block { 898F } ) { br }

 ^ 40 ^ [ exit ] ( started by ide )
: start h# FFF0 h# 5 dup ( rp.r.ip ) left ( stack ) b! { indent }
      right ( terminal ) a! bitsy ; ^ 47 ^ }block

( 00312400 )               D# 1097 shadow{ 
 ( notes- ) { indent }
      ( the bit-threaded code technique confines execution to the )
 bitsy ( loop and a small number of code subroutines. it uses one or
 more bits of the execution token to select the class- ) { indent }
      [ 00.10**.xxaa.aaaa.aaaa ] ( code.s-xt's ) { indent }
      [ 00.11**.xxaa.aaaa.aaaa ] ( code.b-xt's ) { indent }
      [ 00.0aaa.aaaa.aaaa.aaaa ] ( list-xt ) { cr }
 ( -and process the token. code tokens are called while list tokens
 are interpreted by pushing the current ) [ ip ] ( address onto the
 return stack and continuing at 2*xt. ) { indent }
      ( the ) [ ide ] ( can single-step the bitsy node by calling )
 step ( instead of executing ) bitsy. }block

( 00312800 )               D# 1098 code{ 
 ( -- bitsy right bud dxxx ) [ d# 104 node host ]
: 'lu h# 165 lit ; [ target h# 20 org ]
: start @p b! .. [ ' r--- , ] 'lu a! ahead
: xqt ^ 24 ^ @b push ex
: cmd ^ 25 ^ then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / ) { br }

: message ( nw-w ) ^ 27 ^ @p ! - . ( / ) @p over @p ; ( / ) { cr }
 over ! ! @ ( ... ) drop @ or drop @ ;
: n@ ( n-w ) ^ 2C ^ h# 3FFFF message h# FFFF and ;
: n! ( nw- ) ^ 30 ^ message drop ; { br }

: br!p ( i- ) ^ 32 ^ @p !b !b ; ( / ) bpops .. ( / )
: brpops ^ 34 ^ @p br!p ; ( / ) !p .. ( / )
: pn!; ( n- ) @p br!p ( / ) !p ; ( / ) @b n! ;
: n@p; ( n- ) ^ 39 ^ n@ @p !b !b ; ( / ) @p bpshw ; ( / )
: .n@ ^ 3C ^ brpops @b n@p; ;
: .n! ^ 3E ^ brpops @b pn!; ; { br }

: .rx ^ 40 ^ d# 200 n@p; ; { -cr }
: .io@ ^ 42 ^ d# 100 n@p; ;
: .tx ^ 44 ^ d# 100 pn!; ; { -cr }
: .io! ^ 46 ^ d# 200 pn!; ; { cr }
 ^ 48 ^ ( must be at or before { C1F } ) }block

( 00312C00 )               D# 1099 shadow{ 
 }block

( 00313000 )               D# 1100 code{ 
 }block

( 00313400 )               D# 1101 shadow{ 
 }block

( 00313800 )               D# 1102 code{ 
 ( -- bitsy up bud exxx ) [ d# 205 node h# 20 org ]
: start @p b! ahead [ ' ---u , ]
: xqt ^ 22 ^ @b push ex
: cmd ^ 23 ^ then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / ) { br }

 ^ 25 ^ }block

( 00313C00 )               D# 1103 shadow{ 
 }block

( 00314000 )               D# 1104 code{ 
 }block

( 00314400 )               D# 1105 shadow{ 
 }block

( 00314800 )               D# 1106 code{ 
 ( -- bitsy down bud fxxx ) [ d# 5 node h# 20 org ]
: start @p b! ahead [ ' -d-- , ]
: xqt ^ 22 ^ @b push ex
: cmd ^ 23 ^ then @p !b ( ... ) xqt ; ( / ) drop !p .. ( / ) { br }

: 'next ( pri-pri ) ^ 25 ^ @p !b @b ( / ) push !p .. ( / ) { cr }
 if @p !b !b @p ( / ) @p dec ( ' ) pop bx@ ; ( / ) !b ; { cr }
 then drop @p @p @p ( reversed! ) { indent }
      ( / ) pop inc ; ( ' ) dup bx@ ( ' ) inc ( / ) !b !b !b ;
: '@exe ( pri-pri ) ^ 31 ^ @p @p @p . ( reversed! ) { indent }
      ( / ) ?exe ; ( ' ) bx@ ( ' ) bpops ( / ) !b !b !b ;
: 'r@ ( pri-pri ) ^ 36 ^ @p !b ; ( / ) over bpshw ; ( / )
: 'lit ( pri-pri ) ^ 38 ^ @p @p @p ( reversed! ) { indent }
      ( / ) inc ; ( ' ) bpshw ( ' ) dup bx@ ( / ) !b !b !b ; ^ 3D ^
 }block

( 00314C00 )               D# 1107 shadow{ 
 }block

( 00315000 )               D# 1108 code{ 
 }block

( 00315400 )               D# 1109 shadow{ 
 }block

( 00315800 )               D# 1110 code{ 
 ( - flash to sram pipe ) [ host ]
: head { -cr }
: pipe [ d# 1112 ] load ; [ target ] { cr }
 ( -------- --in-- --out- ---- ) { cr }
 [ d# 307 node ' ---u ' -d-- pipe ] { cr }
 [ d# 407 node ' -d-- ' ---u pipe ] { cr }
 [ d# 507 node ' ---u ' -d-- pipe ] { cr }
 [ d# 607 node ' r--- ' ---u pipe ] { cr }
 [ d# 606 node ' --l- ' r--- pipe ] { cr }
 [ d# 605 node ' -d-- ' --l- head ] { br }

 [ d# 705 node ] ( interface ) [ d# 1116 load ] }block

( 00315C00 )               D# 1111 shadow{ 
 }block

( 00316000 )               D# 1112 code{ 
 ( -- head/pipe nodes take two parameters! ) { cr }
 [ h# 20 org ] ( programmed with abandon )
: start ( init ) leap warm ;
: init ^ 22 ^ then @p b! .. ( out ) [ , ] @p a! ; ( in ) [ , ]
: prime ( i-i ) ^ 26 ^ dup !p ; ( install /* */ )
: pump ^ 27 ^ ( /* ) begin @ !b unext ; ( */ )
: run ( in ) ^ 28 ^ init { indent }
      @p !b over . ( / ) @p prime ( / ) { indent }
      !b @p !b dup ( / ) @p run ( / ) { indent }
      !b push pump ; { br }

 ( used in the 'head' node )
: hf2s ( n ) ^ 2F ^ @p prime ( / ) begin @ !b unext ; ( / ) { cr }
 over run ;
: hs2f ( n ) ^ 32 ^ @p prime ( / ) begin @b ! unext ; ( / ) { cr }
 over run ; ^ 35 ^ }block

( 00316400 )               D# 1113 shadow{ 
 ( notes- ) { cr }
 ( this is a bi-directional port pump! it assumes control comes from
 the 'head' and passes the it to the b-reg 'tail' of the pipe. a-reg
 the registers are set each time it is used, so the pipe may be crossed
 by other 'courteous' users. at this point only the count is passed--the
 tail has a fixed address to read to or write from. ) }block

( 00316800 )               D# 1114 code{ 
 ( -- tail / starter node takes three parameters! ) [ h# 0 org ] ( programmed
 with abandon )
: tf2s ^ 00 ^ ( e4base ) d# 0 { indent }
      begin @ over x! d# 1 . + next warm ;
: ts2f ^ 08 ^ ( e4base ) d# 0 { indent }
      begin dup x@ ! d# 1 . + next warm ;
: xm! ( m- ) ^ 0F ^ dup dup or dup - mk! ; ^ 11 ^ { br }

 [ h# 20 org ]
: start ^ 20 ^ @p @p b! @p ( mask ) [ , ] ( out ) [ , ] ( in ) [ , ]
 { indent }
      a! xm! warm ;
: prime ( i-i ) ^ 26 ^ ; ( dummy ) ;
: run ( in ) ^ 28 ^ push @p or ( /* ) begin @b ! unext ; ( */ ) if
 tf2s ; then ts2f ; ^ 2D ^ }block

( 00316C00 )               D# 1115 shadow{ 
 ( notes- ) { indent }
      xm! [ mask ] ( sets which neighbor nodes get access to memory. { 10001F }
 is 106, { 1001F } is 108, { 401F } is 207, { 11401F } is all three. )
 [ use carefully! ] }block

( 00317000 )               D# 1116 code{ 
 ( -- eforth flash interface ) [ h# 0 org ]
: 2cmd ( dw-d ) select ( +2r ) { -cr }
: +cmd ( dw-d ) 8obits ( +4r )
: cmd ( db-d ) select { -cr }
: !8 ( db-d ) 8obits drop ;
: reading ( dh-d ) ^ 05 ^ io b! over . ( read ) h# C00 cmd ( +5r )
: !24h ( dhd-d ) ^ 09 ^ drop 8obits
: !16 ( dw-d ) ^ 0A ^ 8obits !8 ;
: @16 ( d-dw ) ^ 0C ^ d# 15 dup push dup or ( 'ibits ) [ h# DB ] end
: set ( ndo-n ) ^ 0F ^ down a! ! drop dup ! ;
: f2s ( dndh-d ) ^ 12 ^ reading ( +6r ) @p set ( / ) @p hf2s ( / )
: readn ( dn-d ) ^ 15 ^ for @16 ( +4r ) ! next ;
: start ( dx-dx ) ^ 19 ^ drop ( n-1 ) over d# 512 f2s ( +7r )
: restart ( d-dx ) ^ 1D ^ ( resume ) reading dup spi-exec ;
: deselect ( dx-dx ) ^ 20 ^ io b! -++ half warm ; { cr }
 ^ 25 ^ [ exit ]
: +wr ( d-d wren+wrsr ) h# 1804 2cmd ( 0+ebsy ) h# 1C0 +cmd ;
: er32k ( dh-dd ) ^ 29 ^ over +wr ( +6r ) { indent }
      ( wren+ers32 ) h# 1948 2cmd !24h dup select ;
: writing ( dh-d ) ^ 2E ^ over +wr ( +6r ) { indent }
      ( wren+aaip ) h# 1AB4 2cmd !24h ;
: s2f ( dndh-d ) ^ 32 ^ writing ( +7r ) @p set ( / ) @p hs2f ( / )
: writn ( dn-d ) ^ 35 ^ push ahead begin [ swap ] { indent }
      ( aaip ) h# 2B400 cmd then @ !16 ( +5r ) { indent }
      ( wait ) dup select ^ 3A ^ begin drop @b -until { cr }
 ^ 3B ^ drop next ( wrdi+dbsy ) h# 1200 2cmd ; ^ 3E ^ }block

( 00317400 )               D# 1117 shadow{ 
 ( notes- ) { indent }
      ( assumes that during booting the delay value is on the top of
 the data stack and is preserved during all flash accesses. ) { indent }
      ( also assumes b contains io. ) }block

( 00317800 )               D# 1118 code{ 
 }block

( 00317C00 )               D# 1119 shadow{ 
 }block

( 00318000 )               D# 1120 code{ 
 ( - siobus16 wire nodes ) [ host ]
: wire [ d# 1122 ] load ; [ target ] { cr }
 ( ------- plug -dest- --in-- --out- ---- ) { cr }
 [ d# 204 node d# 999 ' r--- ' -d-- ' ---u wire ] { cr }
 [ d# 304 node d# 999 ' r--- ' ---u ' -d-- wire ] { cr }
 [ d# 404 node d# 999 ' r--- ' -d-- ' ---u wire ] { cr }
 [ d# 504 node d# 999 ' r--- ' ---u ' -d-- wire ] { cr }
 [ d# 604 node d# 704 ' -d-- ' --l- ' ---u wire ] ( * ) { cr }
 [ d# 603 node d# 999 ' -d-- ' r--- ' --l- wire ] { cr }
 [ d# 602 node d# 999 ' -d-- ' --l- ' r--- wire ] { cr }
 [ d# 601 node d# 600 ' r--- ' ---u ' --l- wire ] ( * ) { cr }
 [ d# 501 node d# 500 ' r--- ' -d-- ' ---u wire ] ( * ) { cr }
 [ d# 401 node d# 999 ' r--- ' ---u ' -d-- wire ] { cr }
 [ d# 301 node d# 999 ' r--- ' -d-- ' ---u wire ] { cr }
 [ d# 201 node d# 200 ' r--- ' ---u ' -d-- wire ] ( * ) { cr }
 [ d# 101 node d# 100 ' r--- ' --l- ' ---u wire ] ( * ) { cr }
 [ d# 102 node d# 999 ' r--- ' r--- ' --l- wire ] { cr }
 [ d# 103 node d# 999 ' r--- ' --l- ' r--- wire ] }block

( 00318400 )               D# 1121 shadow{ 
 ( notes- ) { cr }
 [ iobus ] ( nodes have { 8F } values defined when booted- ) in-port
 ( and ) destination ( are kept on the stack, ) dest-port ( is put
 in a, and ) out-port ( into b. an ) [ iobus ] ( node with a ) destination
 ( of ) [ d# 999 ] ( only ) { cr }
 ( passes messages from its ) in-port ( to ) out-port. ( its ) dest-port
 ( is unused. otherwise they are ) { cr }
 ( the node-number and port of a node with pins. ) { cr }
 [ iobus ] ( messages consist of three words; ) { indent }
      ( / ) @p over @p ; ( / ) < destination > ( / ) < data > ( / )
 { br }

 < destination > ( is the node-number of a node with code to handle )
 < data > { br }

 < data > ( is ) [ d# 0 ] ( for reads and the 18-bit inverse of a )
 [ 16-bit value ] ( for writes. ) { br }

 ( eforth originates all messages. they travel around the loop until
 their ) < destination > ( matches an ) [ iobus ] ( node's or they
 return to eforth. at a matching node ) < data > ( is written and the )
 { cr }
 ( reply read and returned to eforth. ) }block

( 00318800 )               D# 1122 code{ 
 ( -- generic siobus wire ) [ h# 30 org ] { br }

: start ( takes four parameters! ) { indent }
      @p b! @p .. ( out-port ) [ , ] ( in-port ) [ , ] { indent }
      @p a! @p .. ( dest-port ) [ , ] ( dest-node ) [ , ]
: wait ( id ) ^ 36 ^ over push ex ( ... @p over @p ; )
: test ( idndw ) ^ 37 ^ push over or if
: pass ( idnx.w ) ^ 39 ^ { indent }
      @p !b drop .. ( / ) @p over @p ; ( / ) { indent }
      !b pop !b wait ;
: mine ( idn0.w ) ^ 3D ^ then pop ! @ push pass ; ^ 3F ^ }block

( 00318C00 )               D# 1123 shadow{ 
 }block

( 00319000 )               D# 1124 code{ 
 ( -- tx plug node ) [ host ]
: tx0 ( dumb ) h# 25555 ( maxim { 6AAABF } ) lit ;
: tx1 ( dumb ) h# 35555 ( maxim { 4AAABF } ) lit ;
: 'ru [ h# 1C5 ] lit ; { -cr }
: 115k [ d# 2350 ] lit ; { cr }
 [ target h# 30 org ]
: !bit ( im-i ) ^ 30 ^ over and { indent }
      if tx0 !b drop ; then tx1 !b drop ;
: putchar ( di-dx ) ^ 35 ^ h# FF or 2* .. { cr }
 ( 1-start, 8-data, 1-stop bit ) d# 9 for ^ 39 ^ { indent }
      d# 1 !bit 2/ over for . unext next ; ^ 3E ^ { br }

 ^ 3E ^ [ h# 20 org ] ( programmed with abandon )
: start io b! ( space ) tx0 !b 'ru a! ( bit delay ) 115k
: wait ( *d ) ^ 26 ^ @ ( ... ) if { cr }
 ( dly *d ) [ ' wait ] -until { cr }
 ( n! ) ^ 28 ^ ( *di ) - putchar ! wait ; { cr }
 ( n@ ) ^ 2A ^ ( *d0 ) then drop dup ! wait ; ^ 2C ^ }block

( 00319400 )               D# 1125 shadow{ 
 ( notes- ) { indent }
      [ tx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. ) { br }

: putchar ( takes a clean inverted octet and ) { cr }
 ( transmits it low bit first via p17. ) { br }

: wait ( suspends while waiting for an inverted ) { cr }
 ( character or a new delay value. the message ) { cr }
 ( protocol guarentees that there won't be a port conflict. ) }block

( 00319800 )               D# 1126 code{ 
 ( -- rx plug node ) [ h# 0 org ]
: @bit ( cm-c ) @b - over - and push and pop or ;
: getchar ( dx-di ) ^ 03 ^ over 2/ for . unext ( 1/2 bit ) d# 8 for
 ( 1-start, 8-data, 1-stop bits ) { indent }
      h# 1FFFF @bit 2/ over for . unext { cr }
 next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ h# FF and - ; { br }

: baud ( n-ddd ) ^ 11 ^ if dup dup ; then - push { cr }
 ^ 14 ^ begin @b . -until ( at start-bit of space ) { , }
 ^ 15 ^ begin @b - -until ( at 1-bit ) { cr }
 ^ 16 ^ begin @b . zif then . -until ( at 0-bits ) { cr }
 ^ 18 ^ begin @b - zif then . -until ( stop-bit ) { cr }
 ^ 1A ^ pop - ( n ) dup 2/ . + ( 1.5n ) dup dup ; ^ 1D ^ }block

( 00319C00 )               D# 1127 shadow{ 
 ( notes- ) { indent }
      [ rx ] ( is inverted for compatibility with the boot node conventions,
 i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received
 characters may have one stop bit. ) { br }

: getchar ( called after seeing leading edge of start bit. returns
 clean inverted character. must be called before start bit begins! )
 { br }

: baud ( space is 1...1'0010.0000'0 ) { indent }
      ( stop bits ------' .hex..20. '--- start ) { br }

: idle }block

( 0031A000 )               D# 1128 code{ 
 ( --- more rx ) { br }

 ^ 1D ^ [ h# 20 org ] ( programmed with 2-stack abandon )
: start ( est 115k delay ) d# 2350 { indent }
      ( tri-state pin17 ) io b! h# 5555 !b { indent }
      ( 2-char empty buffer ) d# 0 dup push
: pwait ( *dl.p* ) ^ 27 ^ push
: wait ( *d.lp* ) ^ 28 ^ ( io-mask ) h# 28000 dup { indent }
      begin drop @b over and until -if { cr }
 ( pin *dm-.lp* ) drop getchar pwait ; { cr }
 ( msg *dm+.lp* ) then drop drop right a! @ -if { cr }
 ( n! *d-.lp* ) ^ 32 ^ - baud ! up a! ! wait ; { cr }
 ( n@ *d0.lp* ) ^ 36 ^ then pop if { cr }
 ( *d0l.p* ) pop if { 4F } ( chars in buffer ) { indent }
      ( *d0lp.* ) ! over push push drop wait ; { indent }
      ( *d0l0.* ) then push ( 0/1 char in buffer ) { cr }
 ( *d0l.p* ) then ! pwait ; ^ 3D ^ }block

( 0031A400 )               D# 1129 shadow{ 
 }block

( 0031A800 )               D# 1130 code{ 
 ( -- 1-pin plug node ) [ h# 20 org ]
: start right a! io b! ( p17 hi-imp ) h# 5555 dup !b
: cmd ( m ) ^ 26 ^ @ ( ... ) -if { cr }
 ( n! ) ^ 27 ^ ( mw ) d# 1 or d# 7 for 2* 2* unext { indent }
      over over or !b ! cmd ; { cr }
 ( n@ ) ^ 2F ^ ( m0 ) then @b -if drop - ! cmd ; { indent }
      then drop ! cmd ; ^ 34 ^ }block

( 0031AC00 )               D# 1131 shadow{ 
 ( notes- ) { cr }
 ( currently plugged into nodes { 3E8F } and { 4B0F } . ) { cr }
 [ d# 0 ] n! ( drives the pin lo. ) { cr }
 [ d# 1 ] n! ( drives the pin hi. ) { cr }
 [ d# 2 ] n! ( tri-states the pin. ) { cr }
 [ d# 3 ] n! ( attaches a weak pull-down to the pin. ) { cr }
 n@ ( samples the pin, returning ) { indent }
      [ d# -1 ] ( when hi, ) [ d# 0 ] ( when lo. ) { br }

 ( high level eforth code toggles at { 1F4F } khz! ) }block

( 0031B000 )               D# 1132 code{ 
 ( -- dummy flash controller plug ) [ h# 0 org ]
: !x @p drop !p ; { -cr }
: x d# 0 ;
: xfers dup !x ; [ h# 20 org ]
: start down a!
: cmd ^ 22 ^ @ ( ... ) -if { cr }
 ( n! ) ^ 23 ^ ( w ) - xfers ! cmd ; { cr }
 ( n@ ) ^ 25 { F } ^ then drop x ! cmd ; }block

( 0031B400 )               D# 1133 shadow{ 
 }block

( 0031B800 )               D# 1134 code{ 
 }block

( 0031BC00 )               D# 1135 shadow{ 
 }block

( 0031C000 )               D# 1136 code{ 
 }block

( 0031C400 )               D# 1137 shadow{ 
 }block

( 0031C800 )               D# 1138 code{ 
 }block

( 0031CC00 )               D# 1139 shadow{ 
 }block

( 0031D000 )               D# 1140 code{ 
 ( eforth ide ) [ host load ] { , , }
: hoot ( pn ) dup
: book ( pnb ) push hook d# 0 d# 64 pop boot pause ;
: 'lu [ h# 165 ] ; { * }
: 'cold [ h# 5 ] ; ( eforth cold-start )
: e4base ( -a ) [ h# 0 { 10001F } ] ; ( eforth location in sram )
: 'bitsy [ h# 3E ] ; { * }
: 'rp [ h# FFF0 ] ; { * }
: 'sp [ h# FFE0 ] ; { , , }
 ( tools ) [ d# 1142 d# 4 loads ] { , , }
 ( build chip ) [ d# 1160 load talk e4 ] }block

( 0031D400 )               D# 1141 shadow{ 
 ( customize ide for eforth development. ) { br }

: hoot ( combines ) [ hook ] ( and ) [ boot ]
: e4 ( loads f18 virtual machine code, puts ) { cr }
 ( threaded-code image in sram, and starts it. ) { cr }
 [ note--initial 'space' character needed from ] { cr }
 [ the terminal to determine the baud rate. ] { br }

 < ***no canonical opcodes*** > { cr }
 [ use the ] 'remote' [ ones for both ] { cr }
 [ compiled and interpreted scripts. ] }block

( 0031D800 )               D# 1142 code{ 
 ( - ide build paths ) { br }

: route ( p ) pop b-a swap
: !path ( ap ) dup -hook 'pths + ! panel pause ; { br }

: srampath [ d# 1 ] align route [ d# 708 , d# 608 , ] { indent }
      [ d# 508 , d# 408 , d# 308 , d# 208 , d# 108 , d# 107 , ] { indent }
      [ d# 7 , d# 8 , d# 9 , d# -1 , ] ( srampath ) { br }

: e4path [ d# 0 ] align route [ d# 708 , d# 707 , { 584F } ] ( , )
 { indent { 582F } }
      ( , { 4BAF } , { 4BCF } , ) [ d# 607 , d# 507 , d# 407 , ] { indent }
      [ d# 307 , d# 207 , d# 206 , d# 205 , d# 105 , d# 106 , ] { indent }
      [ d# 6 , d# 5 , d# 4 , d# 104 , d# 103 , d# 102 , d# 101 , ]
 { indent }
      [ d# 100 , d# 200 , d# 201 , d# 301 , d# 401 , d# 501 , ] { indent }
      [ d# 500 , d# 600 , d# 601 , d# 602 , d# 603 , d# 703 , ] { indent }
      [ d# 704 , d# 604 , d# 504 , d# 404 , d# 304 , d# 204 , ] { indent }
      [ d# -1 , ] ( e4path ) { br }

: flpath [ d# 0 ] align route [ d# 708 , d# 707 , d# 706 , ] { indent }
      [ d# 705 , d# -1 , ] }block

( 0031DC00 )               D# 1143 shadow{ 
 }block

( 0031E000 )               D# 1144 code{ 
 ( - read 16-bit eforth.bin file ) { cr }
 :# ft 0 { -cr }
: e4max ( -h ) [ d# 16384 ] ; :# e4siz 4926
: a-b ( a-b ) 2* 2* ; { -cr }
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ;
: string pop ; { -cr }
: h-b 2* ; { -cr }
: b-h [ d# 1 ] + 2/ ;
: fbuf ( -b ) [ nnc d# 2 * h# 8000 + block a-b ] ; { br }

: +e4 [ d# 0 fnam b-a ] r/w fopen if [ ft ] ! ; { cr }
 then drop abort ;
: -e4 [ ft ] @ [ d# 0 ] + if fclose d# 0 then [ ft ] ! ;
: !e4 +e4 if fbuf [ e4max ] h-b [ ft ] @ frd { indent }
      b-h [ e4siz ] ! -e4 then ; { br }

 [ named ] ( ef/eforth.bin ) [ !e4 ]
: n-1 [ e4siz @ d# -1 + ] ; { br }

 }block

( 0031E400 )               D# 1145 shadow{ 
 }block

( 0031E800 )               D# 1146 code{ 
 ( - ide access sram16 from nodes { D8F } and { 19EF } )
: n108 srampath d# 1 d# 108 hook panel ?ram ;
: n207 e4path d# 0 d# 207 hook panel ?ram ;
: get ( -w ) upd [ stak ] @ rdrop ;
: put2 ( nn- ) swap lit' lit' ;
: put4 ( nnnn- ) push push put2 pop pop put2 ; { br }

: xm! ( m- ) lit' ( xm! ) [ h# 37 ] call ;
: x! ( wa- ) put2 ( x! ) [ h# 39 ] call ;
: x@ ( a-w ) lit' ( x@ ) [ h# 3C ] call get ;
: ex! ( wap- ) push put2 pop lit' ( ex! ) [ h# 3A ] call ;
: ex@ ( ap-w ) put2 ( ex@ ) [ h# 3D ] call get ;
: cx? ( wapw-f ) put4 ( cx? ) [ h# 3E ] call get ; { br }

: dmp ( ap-... ) d# 7 for push dup i ex@ { indent }
      swap [ d# 1 ] + pop -next drop drop ;
: fil ( wapn- ) for push over over i ex! { indent }
      [ d# 1 ] u+ [ d# 1 ] + pop -next drop drop drop ; { br }

: !e4th [ fbuf ] e4base [ n-1 ] for { indent }
      over 2@ swab over x! [ d# 2 ] u+ [ d# 1 ] + { cr }
 -next drop drop ; }block

( 0031EC00 )               D# 1147 shadow{ 
 ( notes ) { indent }
      ( assumes the ide is hooked to one of the sram user nodes. )
 { indent }
      }block

( 0031F000 )               D# 1148 code{ 
 ( - ide access term16 from { D0F } , flash from { 584F } )
: n104 e4path d# 0 d# 104 hook panel ?ram ;
: io! ( w ) d# 200
: n! ( wn ) lit' lit' ( n! ) h# 30 call upd ;
: tx ( w ) d# 100 n! ;
: io@ ( -w ) d# 100
: n@ ( n-w ) lit' ( n@ ) h# 2C call get ;
: rx ( -w ) d# 200 n@ ;
: key ( -w ) begin rx if h# FFFF or ; then drop end
: emit ( w- ) h# FFFF or tx ; [ exit ] { br }

: n706 flpath d# 0 d# 706 hoot panel ?ram ;
: ffo ( foc ) [ h# 20 ] call ; { -cr }
: blk ( n- ) [ h# 200 ] * lit ;
: len ( len ) [ h# 23 ] call ; { -cr }
: f2s ( dnl ) [ h# 32 ] call ;
: des ( des ) [ h# 34 ] call ; { -cr }
: don ( don ) [ h# 3C ] call ;
: e32 ( e32 ) [ h# 36 ] call ; { -cr }
: s2f ( upl ) [ h# 38 ] call ;
: burn ( k ) foc blk n108 x@ d# -1 + { indent }
      h# 0 path lit s2f don ;
: try ( k ) foc blk len f2s don ; }block

( 0031F400 )               D# 1149 shadow{ 
 }block

( 0031F800 )               D# 1150 code{ 
 }block

( 0031FC00 )               D# 1151 shadow{ 
 }block

( 00320000 )               D# 1152 code{ 
 }block

( 00320400 )               D# 1153 shadow{ 
 }block

( 00320800 )               D# 1154 code{ 
 }block

( 00320C00 )               D# 1155 shadow{ 
 }block

( 00321000 )               D# 1156 code{ 
 }block

( 00321400 )               D# 1157 shadow{ 
 }block

( 00321800 )               D# 1158 code{ 
 }block

( 00321C00 )               D# 1159 shadow{ 
 }block

( 00322000 )               D# 1160 code{ 
 ( eforth chip builder ) { br }

: hooked panel pause d# 2 d# 708 hook pause d# 2 -hook ;
: clean unfoc d# 2 -hook d# 1 -hook d# 0 -hook ;
: e4sram [ d# 1162 ] load ;
: e4sio [ d# 1164 ] load ;
: e4vm [ d# 1166 ] load ;
: e4boot e4sram e4sio e4vm clean ;
: e4bin e4sram !e4th ;
: e4 e4bin e4sio e4vm clean ; }block

( 00322400 )               D# 1161 shadow{ 
 }block

( 00322800 )               D# 1162 code{ 
 ( - build sram16 using ) [ srampath ] { br }

 ( address-bus ) [ d# 1 d# 9 hook d# 0 d# 64 d# 1617 boot h# 20 call ]
 { , }
 ( control-pins ) [ d# 1 d# 8 hook d# 0 d# 64 d# 1616 boot h# 20 call ]
 { , }
 ( data-bus ) [ d# 1 d# 7 hook d# 0 d# 64 d# 1615 boot h# 20 call ]
 { , }
 ( interface ) [ d# 1 d# 107 hook d# 0 d# 64 d# 1614 boot ] { , ... }
      [ down lit rb! ] { , ... }
      ( 108+207 mask ) [ h# 8A00 lit ] ( re ) [ h# 17 call ] { cr }
 ( user ) [ d# 1 d# 108 hook d# 0 d# 64 d# 1817 boot ] }block

( 00322C00 )               D# 1163 shadow{ 
 }block

( 00323000 )               D# 1164 code{ 
 ( - build siobus wires and plugs using ) [ e4path ]
: wire ( n ) dup { * }
: wbin ( bn ) d# 0 swap hook push { , ... }
      h# 30 d# 16 pop boot pause h# 30 call ;
: plug ( n ) dup { * }
: pbin ( bn ) d# 0 swap hook push { , ... }
      h# 0 d# 64 pop boot pause h# 20 call ; { , , }
 [ d# 204 wire d# 304 wire d# 404 wire d# 504 wire d# 604 wire ] { , }
 ( flash ) [ d# 704 plug d# 603 wire d# 602 wire d# 601 wire ] { , }
 ( 1-pin ) [ d# 1813 d# 600 pbin ] ( plug 1-pin ) [ d# 500 plug ] { , }
 [ d# 501 wire d# 401 wire d# 301 wire d# 201 wire ] { , }
 ( rx ) [ d# 200 plug ] ( tx ) [ d# 100 plug d# 101 wire d# 102 wire ]
 { , }
 [ d# 103 wire exit ] ( for eforth ) { , , }
 ( testing serial bus from bitsy right bud ) { , ... }
      [ d# 104 plug 'lu lit ra! ] }block

( 00323400 )               D# 1165 shadow{ 
 }block

( 00323800 )               D# 1166 code{ 
 ( - build e4vm16 nodes using ) [ e4path ]
: pipe ( n ) dup node push h# 20 d# 32 pop boot { indent }
      h# 20 call ; { br }

 ( bitsy right bud ) [ foc d# 104 plug ] { cr }
 ( bitsy down bud ) [ d# 5 plug ] { cr }
 ( stack down bud ) [ d# 6 plug ] { br }

 ( stack ) [ d# 0 d# 106 hoot right lit rb! ] { indent }
      [ 'sp lit ] ( s ) [ d# 0 lit ] ( t ) [ d# 0 lit ] { indent }
      [ left call ] { br }

 ( bitsy ) [ d# 0 d# 105 hoot left lit rb! ] { indent }
      [ 'rp lit ] ( r ) [ d# 0 lit ] ( ip ) [ 'cold lit ] { indent }
      [ 'bitsy call unfoc ] { br }

 ( bitsy up bud ) [ d# 205 plug ] { cr }
 ( stack up bud ) [ d# 206 plug ] { br }

 ( starter/tail node ) [ d# 207 plug exit ] { br }

 ( pipeline ) [ d# 307 pipe d# 407 pipe d# 507 pipe ] { indent }
      [ d# 607 pipe d# 606 pipe ] ( head ) [ d# 605 pipe ] }block

( 00323C00 )               D# 1167 shadow{ 
 }block

( 00324000 )               D# 1168 code{ 
 }block

( 00324400 )               D# 1169 shadow{ 
 }block

( 00324800 )               D# 1170 code{ 
 ( - sram loader nodes ) { , , }
 ( wires ) [ d# 605 node d# 0 org ]
: wire ( b! a! ) @ dup !b for @ !b unext warm ; { , }
 ^ 04 ^ [ d# 1815 bin ] { , , }
 ( sram loader node { 1A0F } ) { , }
 [ d# 208 node d# 0 org ] ahead
: !sram ^ 01 ^ ( an ) @p !b !b .. ( / ) @p @p .. ( / ) { , }
 !b @p !b ; ( / ) x! ( / )
: start ^ 05 ^ then down a! up b! { , }
 d# 0 dup @ dup push !sram begin { , }
 d# 1 . + dup @ !sram next warm ; { , }
 ^ 11 ^ [ d# 1816 bin ] }block

( 00324C00 )               D# 1171 shadow{ 
 ( minimal version of plumbing for sram boot from flash. wires are
 compiled only once and are ) { , }
 ( initialized with source port in a and dest ) { , }
 ( port in b. ) { , , }
 ( message consists of word count n-1 followed by n words to be passed
 along. ) }block

( 00325000 )               D# 1172 code{ 
 ( - spi flash { 10F } bits ) [ d# 705 node d# 0 org host ]
: resume nnc d# 2 * h# 8000 + block @ h# FFFFF and { indent }
      d# 18 d# 8 */ d# 4 * lit ; [ target ]
: wait ( dw-dw ) ^ 00 ^ select dup begin drop @b -until drop select
 ;
: 2cmd ( dw-d ) ^ 04 ^ select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) ^ 09 ^ io b! ( fast ) d# 5 ;
: fet ( ah al-d ) ^ 0C ^ push push set ( read ) h# C00 cmd pop !8 pop
 8obits !8 ;
: 16ibits ( d-db ) ^ 12 ^ dup d# 15 for { cr }
 rbit ibit - next h# FFFF and ;
: start ^ 19 ^ down a! d# 0 h# 20000 fet { cr }
 16ibits dup ! for 16ibits ! next { indent }
      resume fet 18ibits h# 1E000 . + - -if
: done io b! d# 20 d# 20 -++ half warm ; then { cr }
 d# 5 resume push spicmd spi-boot ; { cr }
 ^ 34 ^ [ d# 1814 bin ] }block

( 00325400 )               D# 1173 shadow{ 
: start ( 1st word read is count in words ) }block

( 00325800 )               D# 1174 code{ 
 ( load eforth kernel ) { , }
: /nwire ( in out ) /b /a d# 0 d# 4 [ d# 1815 ] /part d# 0 /p ; { ,
 , }
 [ d# 705 +node d# 1814 /ram h# 19 /p ] { , }
 [ d# 605 +node down left /nwire ] { , }
 [ d# 606 +node left right /nwire ] { , }
 [ d# 607 +node right left /nwire ] { , }
 [ d# 608 +node left up /nwire ] { , }
 [ d# 508 +node up down /nwire ] { , }
 [ d# 408 +node down up /nwire ] { , }
 [ d# 308 +node up down /nwire ] { , }
 [ d# 208 +node d# 1816 /ram d# 0 /p ] { , }
 [ d# 108 +node d# 1817 /ram left /b ] }block

( 00325C00 )               D# 1175 shadow{ 
 }block

( 00326000 )               D# 1176 code{ 
 }block

( 00326400 )               D# 1177 shadow{ 
 }block

( 00326800 )               D# 1178 code{ 
 }block

( 00326C00 )               D# 1179 shadow{ 
 }block

( 00327000 )               D# 1180 code{ 
 ( build eforth bootstream ) { , , }
 ( speedup ) { , ... }
      [ h# 0 d# 0 d# 3 d# 1608 /root ] { , , }
 ( default ) [ entire course ] { cr }
 ( sram driver ) [ sram d# 2 + load ] { , }
 ( flash to sram ) [ d# 1174 load ] { , }
 [ frame adjust ] ( resume point ) { , , }
 [ fresh ] ( residual ) [ sram d# 4 + load s705 course ] { , ... }
      ( siobus and virtual machine ) [ d# 1182 load ] { , ... }
      ( flash-sram pipe { 940F } load ) { , ... }
      ( retain asynch boot ) [ d# 708 +node h# AA /p ] { , }
 [ frame ] }block

( 00327400 )               D# 1181 shadow{ 
 }block

( 00327800 )               D# 1182 code{ 
 ( - build siobus and virtual machine bootstream )
: wire ( n ) dup +node push h# 30 d# 16 pop /part h# 30 /p ;
: plug ( n ) dup { * }
: pbin ( bn ) +node /ram h# 20 /p ; { br }

 [ d# 103 wire d# 102 wire d# 101 wire ] { indent }
      ( tx ) [ d# 100 plug ] ( rx ) [ d# 200 plug ] { cr }
 [ d# 201 wire d# 301 wire d# 401 wire d# 501 wire ] { indent }
      ( 1-pin ) [ d# 500 plug ] ( 1-pin ) [ d# 1813 d# 600 pbin ] ( plug )
 { cr }
 [ d# 601 wire d# 602 wire d# 603 wire ] { indent }
      ( flash ) [ d# 704 plug ] { cr }
 [ d# 604 wire d# 504 wire d# 404 wire d# 304 wire ] { cr }
 [ d# 204 wire ] { br }

 ( bitsy ) [ d# 105 +node d# 105 /ram ] { indent }
      ( rp ) [ h# FFF0 ] ( r ) [ d# 0 ] ( ip 'cold ) [ h# 5 d# 3 /stack ]
 { indent }
      [ left /b right /a ] ( 'bitsy ) [ h# 3E /p ] { indent }
      ( buds ) [ d# 205 plug d# 104 plug d# 5 plug ] { br }

 ( stack ) [ d# 106 +node d# 106 /ram ] { indent }
      ( sp ) [ h# FFE0 ] ( s ) [ d# 0 ] ( t ) [ d# 0 d# 3 /stack ]
 { indent }
      [ right /b left /p ] { indent }
      ( buds ) [ d# 206 plug d# 6 plug ] { br }

 ( starter/tail ) [ d# 207 plug ] }block

( 00327C00 )               D# 1183 shadow{ 
 }block

( 00328000 )               D# 1184 code{ 
 ( - build flash-sram pipe bootstream )
: pipe ( n ) dup node push h# 20 d# 32 pop boot h# 20 /p ; { br }

 ( head ) [ d# 605 pipe ] { cr }
 ( pipeline ) [ d# 606 pipe d# 607 pipe ] { indent }
      [ d# 507 pipe d# 407 pipe d# 307 pipe ] { cr }
 }block

( 00328400 )               D# 1185 shadow{ 
 }block

( 00328800 )               D# 1186 code{ 
 }block

( 00328C00 )               D# 1187 shadow{ 
 }block

( 00329000 )               D# 1188 code{ 
 }block

( 00329400 )               D# 1189 shadow{ 
 }block

( 00329800 )               D# 1190 code{ 
 ( burn 16-bit eforth.bin file into flash ) { cr }
 [ empty compile streamer load ] { cr }
 [ d# 1190 loaded ! nores ] { cr }
 ( read eforth.bin ) [ d# 1144 load ] { cr }
 [ fbuf source ! n-1 len ! ] { , }
 ( display image length ) [ len @ d# 8 d# 18 */ leng ! ] { br }

 [ h# 8000 stream nip ers ] { cr }
 [ stream h# 8000 swap burn d# 1194 load ] { br }

 [ exit ] ( source cf-byte-addr ) [ fbuf ] { cr }
 ( dest flash-byte-addr ) [ h# 8000 ] { cr }
 ( count 16-bit-words ) [ n-1 burn ] }block

( 00329C00 )               D# 1191 shadow{ 
 }block

( 0032A000 )               D# 1192 code{ 
 }block

( 0032A400 )               D# 1193 shadow{ 
 }block

( 0032A800 )               D# 1194 code{ 
 ( burn 18-bit eforth bootstream into flash ) { cr }
 ( 1st pass ) [ empty compile streamer load ] { cr }
 ( framer ) [ framer load ] ( the stream ) [ d# 1180 load ] { br }

 ( 2nd pass ) [ empty compile streamer load ] { cr }
 ( framer ) [ framer load ] ( the stream ) [ d# 1180 load ] { br }

 [ d# 1194 loaded ! ] { , }
 ( display stream length ) [ strlen leng ! ] { , }
 ( write stream into flash ) { indent }
      ( source cf-word-addr ) [ stream ] { indent }
      ( dest flash-byte-addr ) [ d# 0 ] { indent }
      ( count 18-bit-words ) [ swap ] ( flasher ) [ 18burn ] }block

( 0032AC00 )               D# 1195 shadow{ 
 }block

( 0032B000 )               D# 1196 code{ 
 }block

( 0032B400 )               D# 1197 shadow{ 
 }block

( 0032B800 )               D# 1198 code{ 
 ( eforth index and listing ) { br }

 [ index load named ] ( eforth.txt ) [ d# 1080 d# 1200 run ] { br }

 [ html load named ] ( eforth.html ) [ d# 1080 d# 1200 run ] { br }

 [ exit ] }block

( 0032BC00 )               D# 1199 shadow{ 
 }block

( 0032C000 )               D# 1200 code{ 
 }block

( 0032C400 )               D# 1201 shadow{ 
 }block

( 0032C800 )               D# 1202 code{ 
 }block

( 0032CC00 )               D# 1203 shadow{ 
 }block

( 0032D000 )               D# 1204 code{ 
 }block

( 0032D400 )               D# 1205 shadow{ 
 }block

( 0032D800 )               D# 1206 code{ 
 }block

( 0032DC00 )               D# 1207 shadow{ 
 }block

( 0032E000 )               D# 1208 code{ 
 }block

( 0032E400 )               D# 1209 shadow{ 
 }block

( 0032E800 )               D# 1210 code{ 
 }block

( 0032EC00 )               D# 1211 shadow{ 
 }block

( 0032F000 )               D# 1212 code{ 
 }block

( 0032F400 )               D# 1213 shadow{ 
 }block

( 0032F800 )               D# 1214 code{ 
 }block

( 0032FC00 )               D# 1215 shadow{ 
 }block

( 00330000 )               D# 1216 code{ 
 }block

( 00330400 )               D# 1217 shadow{ 
 }block

( 00330800 )               D# 1218 code{ 
 }block

( 00330C00 )               D# 1219 shadow{ 
 }block

( 00331000 )               D# 1220 code{ 
 }block

( 00331400 )               D# 1221 shadow{ 
 }block

( 00331800 )               D# 1222 code{ 
 }block

( 00331C00 )               D# 1223 shadow{ 
 }block

( 00332000 )               D# 1224 code{ 
 }block

( 00332400 )               D# 1225 shadow{ 
 }block

( 00332800 )               D# 1226 code{ 
 }block

( 00332C00 )               D# 1227 shadow{ 
 }block

( 00333000 )               D# 1228 code{ 
 }block

( 00333400 )               D# 1229 shadow{ 
 }block

( 00333800 )               D# 1230 code{ 
 ( sync boot testbed ) { , }
 :# addr 75751425 :# len 67 { , }
 :# word -559677440 :# bit 1 :# dly 50
: clock [ bit ] @ ( - ) [ d# 1 ] and ?v p17v ! ;
: data [ word ] @ [ h# 40000 ] and ?v p1v ! ; { , , }
: 'stream ( -a ) [ nnc d# 2 * h# 8000 + block d# 2 + ] ;
: stream ( -an ) [ 'stream ] dup [ d# -2 ] + @ ;
: /sync softbed assign ( len ) [ d# 0 + ] nop [ len ] ! { , ... }
      ( addr ) [ d# 0 + ] nop [ addr ] ! d# 50 [ dly ] ! 'bed assign
 { , ... }
      [ vdd @ ] p17v ! [ d# 0 ] p1v ! [ dly ] @ [ d# -1 ] + if [ dly ]
 ! ; { , ... }
      then drop
: /word [ addr ] @ dup [ d# 1 ] + [ addr ] ! @ p-n [ word ] ! { , ... }
      d# 18 [ bit ] !
: /bit [ word ] @ 2* [ word ] ! d# 40 [ dly ] ! 'bed assign { , ... }
      clock data [ dly ] @ [ d# -1 ] + if [ dly ] ! ; { , ... }
      then drop [ bit ] @ [ d# -1 ] + if [ bit ] ! /bit ; { , ... }
      then drop [ len ] @ [ d# -1 ] + if [ len ] ! /word ; { , ... }
      then drop 'bed assign [ d# 0 ] p17v ! [ d# 0 ] p1v ! ; { , , }
 [ d# 300 !node stream /sync ] }block

( 00333C00 )               D# 1231 shadow{ 
 ( sync boot )
: sync ac ( installs testbed ) { , . }
      a ( is buffer base address of boot stream ) { , . }
      c ( is word count of boot stream ) { , , }
 ( testbed holds clock high for { 32F } ticks before ) { , }
 ( clocking out stream data ) }block

( 00334000 )               D# 1232 code{ 
 }block

( 00334400 )               D# 1233 shadow{ 
 }block

( 00334800 )               D# 1234 code{ 
 }block

( 00334C00 )               D# 1235 shadow{ 
 }block

( 00335000 )               D# 1236 code{ 
 ( configuration tables ) :# com 0
: tabl pop 2/ 2/ [ com ] @ + ;
: jsr h# E8 dst ; ( call has been clobbered already )
: table ( nn ) < align > jsr tabl for dup , next drop ;
: a-boot [ d# -1 d# 144 table ] { * }
: c-boot [ d# -1 d# 144 table ]
: b-boot [ d# -1 d# 144 table ]
: a-reg [ d# -1 d# 144 table ] { * }
: b-reg [ io d# 144 table ] { , , }
: /a ( a ) a-reg ! ; { * }
: /b ( a ) b-reg ! ;
: /p ( a ) [ com ] @ !inode entry ! ;
: +node ( n ) nn-n [ com ] ! ;
: /part ( acb ) b-boot ! c-boot ! a-boot ! ;
: /ram ( b ) b-boot ! d# 64 c-boot ! d# 0 a-boot ! ;
: rammer ( -acb ) a-boot @ c-boot @ b-boot @ ; { , , }
: aaray pop 2/ 2/ [ com ] @ [ d# 11 ] * + ;
: array ( n ) < align > jsr aaray [ d# 11 ] * for d# 0 , next ;
: 'stack [ d# 144 array ] :# stkp 10
: @s+ 'stack [ stkp ] @ + @ d# 1 [ stkp ] +! ;
: !s- ( n ) 'stack [ stkp ] @ + ! d# -1 [ stkp ] +! ;
: /stack ( stuff count ) { , }
 d# 10 [ stkp ] ! dup !s- for !s- next ; }block

( 00335400 )               D# 1237 shadow{ 
 ( - configuration tables )
: tabl
: jsr ( call from block { B0F } has been clobbered ) { , }
 ( so replace it with jsr instead )
: table ( build and initialize a table ) { , }
 ( tables hold configuration information )
: /a a ( specifies ) [ a ] ( value for current node )
: /b a ( specifies ) [ b ] ( value for current node )
: /p a ( specifies entry point for current node ) { , }
 ( using preexisting ) entry ( mechanism )
: +node n ( makes n the current node )
: /part acb ( specifies ) [ address count ] ( and ) [ bin ] { , }
 ( for code to be loaded into current node later )
: /ram b ( specifies just the bin, load all { 80F } )
: rammer -acb ( returns ) [ address count ] ( and ) [ bin ] { , }
 ( from table )
: /stack stuff count ( specifies ) [ count ] ( items to be placed on
 the stack at load time ) }block

( 00335800 )               D# 1238 code{ 
 ( - initial values )
: ?load c-boot @ [ d# 0 ] + drop -if ; then rammer { , }
 swap push nn-n inode over + swap { , }
 [ comb ] @ + pop move ; { , , }
: -com [ comb ] @ [ h# 8000 block negate ] + h# 200 / [ com ] ! ;
: deliver [ 'boot ] assign -com ?load { , }
 a-reg @ - [ d# 0 ] + drop -if a-reg @ lit ra! then { , }
 b-reg @ - [ d# 0 ] + drop -if b-reg @ lit rb! then { , }
 'stack [ d# 10 ] + @ dup and if dup { , ... }
      dup negate [ d# 10 ] + [ stkp ] ! for @s+ lit next { , }
 then drop ; [ deliver ] }block

( 00335C00 )               D# 1239 shadow{ 
 }block

( 00336000 )               D# 1240 code{ 
 ( interactive )
: node ( n ) nn-n dup !inode [ nod ] ! ;
: other ( n ) nn-n [ nod2 ] ! ;
: exec ( n ) pc @ +r ir ! d# 1 slot ! d# 0 cnt ! ;
: fin step listen -track ;
: !b ( .!b;; ) [ h# 2DB55 ] exec !b, fin ;
: !a ( .!a;; ) [ h# 2DA55 ] exec !a, fin ;
: !+ ( .!+;; ) [ h# 2D855 ] exec !+, fin ;
: @b ( .@b;; ) [ h# 2DF55 ] exec @b, fin ;
: @a ( .@a;; ) [ h# 2DE55 ] exec @a, fin ;
: @+ ( .@+;; ) [ h# 2DC55 ] exec @+, fin ;
: r@ ( a-n ) lit ra! @a -t ;
: r! ( na ) lit ra! lit !a ;
: call pc @ lit rpush lit rpush ret fin h ;
: boot ( acn ) swap push nn-n inode over + swap { , ... }
      [ nod ] @ inode + pop move ;
: break ( san ) [ comb ] @ push !node 2* 2* or bp ! { , }
 pop [ comb ] ! ;
: -break ( n ) [ comb ] @ swap !node [ d# -1 ] bp ! [ comb ] ! ; }block

( 00336400 )               D# 1241 shadow{ 
 ( memory operators and constants ) }block

( 00336800 )               D# 1242 code{ 
 ( build boot stream for softsim testbeds ) { , }
 ( exit ) [ streamer load framer load ] { , , }
 ( smtm frame for spi { 4F } { F } { 80F } { F } /root ) { , }
 ( smtm frame for sync ) [ d# 1 d# 0 d# 64 d# 0 /root ] { , ... }
      [ stream drop drop ] }block

( 00336C00 )               D# 1243 shadow{ 
 ( makes a boot stream from the smtm example ) { , }
 ( starting at address { 4F } in order to avoid ) { , }
 ( running into the edge ) { , , }
 [ stream ] ( leaves its address and length on stack ) }block

( 00337000 )               D# 1244 code{ 
 ( spi testbed ) :# clk 1 :# btcnt 33 { cr }
 :# cmd -1 [ d# 0 cmd ! ] :# spbit 1363526856
: 'stream ( -a ) [ nnc d# 2 * h# 8000 + block d# 2 + ] ;
: setmem ( b ) h# FFFFFF and d# 8 * ( byte offset in bits ) { cr }
 [ 'stream ] d# 18 * + [ spbit ] ! ; [ d# 0 setmem ]
: 'cmd ( -a ) [ cmd ] dup @ p5v @ low? -if { indent }
      2* over ! ; then - 2* - over ! ;
: ?bit [ btcnt ] @ d# -1 + d# 0 max dup [ btcnt ] ! { indent }
      dup and drop if 'cmd @ setmem { indent }
      pop drop ; then ;
: bitn ( n-nn ) dup @ swap over d# 1 + swap ! { indent }
      d# 18 /mod @ p-n swap d# 1 + ;
: bit17 d# 0 [ spbit ] bitn for 2* next { indent }
      h# 40000 and drop if drop [ vdd @ ] then { indent }
      p17v ! ; }block

( 00337400 )               D# 1245 shadow{ 
 ( spi testbed ) { cr }
 [ boot stream is assembled starting at nnc ]
: setmem ( adds an offset and converts to bits )
: ?bit ( reads command or allows data write ) { br }

: spi ( assigns initial behavior to softbed ) { cr }
 [ first waits for select high , ] { cr }
 [ then waits for select low , then watches ] { cr }
 [ spi clock and accumulates data until select ] { cr }
 [ goes high , at which point it starts over ] }block

( 00337800 )               D# 1246 code{ 
 ( spi testbed )
: threshold ( -v ) [ vdd @ d# 2 / negate ] ;
: clk? ( -n ) p1v @ threshold + - d# 0 max d# 1 min ;
: hi? ( a ) @ threshold + d# 0 max dup and drop ;
: lo? ( a ) @ threshold + - d# 0 max dup and drop ; { , , }
: /spi softbed assign
: desel d# -1 [ cmd ] ! d# 33 [ btcnt ] ! { cr }
 'bed assign p3v lo? if ; then { cr }
 'bed assign clk? [ clk ] ! p3v lo? if { cr }
 'bed assign p3v hi? if desel ; then { indent }
      [ clk ] @ clk? dup [ clk ] ! or { indent }
      drop if [ clk ] @ dup and drop { indent }
      if ; then ?bit bit17 then then ; { , , }
 [ d# 705 !node /spi ] }block

( 00337C00 )               D# 1247 shadow{ 
 ( spi testbed ) { cr }
 [ boot stream is assembled starting at nnc ]
: setmem ( adds an offset and converts to bits )
: ?bit ( reads command or allows data write ) { br }

: /spi ( assigns initial behavior to softbed ) { cr }
 [ first waits for select high , ] { cr }
 [ then waits for select low , then watches spi ] { , }
 [ clock and accumulates data until select ] { cr }
 [ goes high , at which point it starts over ] }block

( 00338000 )               D# 1248 code{ 
 ( show directions ) :# arrow 92 [ d# 92 arrow ! ]
: magenta h# FF00FF color ;
: .dir ( o ) [ xy ] @ dup push + [ xy ] ! { indent }
      [ arrow ] @ emit pop [ xy ] ! ;
: ?dir ( n-n ) dup d# 1 and drop if pop drop then ;
: .ndir 2/ ?dir h# 160000 .dir ;
: .sdir 2/ ?dir h# 1600A5 .dir ;
: .wdir 2/ ?dir h# -AFFB5 .dir ;
: .edir 2/ ?dir h# 37004B .dir ;
: .eswn ( a ) magenta .ndir .wdir { indent }
      red .sdir .edir drop ;
: .wsen ( a ) magenta .ndir .edir { indent }
      red .sdir .wdir drop ;
: .enws ( a ) magenta .sdir .wdir { indent }
      red .ndir .edir drop ;
: .wnes ( a ) magenta .sdir .edir { indent }
      red .ndir .wdir drop ;
: which d# 92 dbus @ [ wrq ] and drop { indent }
      if d# -2 + then [ arrow ] ! ;
: .drs abus @ dup - h# 100 and drop { indent }
      if drop ; then which h# A0 or d# 8 / { indent }
      [ comb ] @ [ h# 8000 block negate ] + [ h# 200 ] / { indent }
      dup d# 9 / d# 2 and swap d# 1 and or { indent }
      jump .enws .wnes .eswn .wsen }block

( 00338400 )               D# 1249 shadow{ 
: which dbus @ dup wrq and drop { indent }
      if drop d# 90 [ arrow ] ! ; then { indent }
      rrq and drop if d# 92 [ arrow ] ! then ; }block

( 00338800 )               D# 1250 code{ 
 ( prelude ) :# comb 75530240
: xqt? ( a ) @ ( b ) dup and if push ; then drop ;
: nodes ( i-n ) 2* blks ;
: inode ( i-a ) nodes [ h# 8000 block ] + ;
: !node ( n ) nn-n { * }
: !inode ( i ) inode [ comb ] ! ;
: my ( o-a ) [ comb ] @ + ; ( node variables )
: memory ( o-a ) h# BF and my ; { * }
: rombit ( -m ) h# 80 ; { , }
 ( 40-7c defined later )
: brk [ h# 7C ] my ; { * }
: bp [ h# 7D ] my ;
: entry [ h# 7E ] my ; { * }
: pins [ h# 7F ] my ;
: nnxmod ( -n ) [ d# 100 ] ; { , , }
: io [ h# 15D ] ; { * }
: data [ h# 141 ] ; { * }
: ldata [ h# 171 ] ;
: right [ h# 1D5 ] ; { * }
: down [ h# 115 ] ; { * }
: left [ h# 175 ] ; { * }
: up [ h# 145 ] ;
: enter ( a nn ) !node entry ! ;
: /enter [ nns d# -1 + ] for i dup !inode resets @ { , ... }
      rstadr entry ! -next ; [ /enter ] }block

( 00338C00 )               D# 1251 shadow{ 
 ( prelude )
: comb ( base address of node vars for this node )
: xqt? ( execute code starting at adr in preceding variable ) }block

( 00339000 )               D# 1252 code{ 
 ( softsim node variables ) { cr }
 ( cpu -pattern- buses and registers )
: dbus h# 40 my ;
: uport h# 41 my ; { -cr }
: udest h# 4E my ;
: lport h# 42 my ; { -cr }
: ldest h# 4D my ;
: dport h# 44 my ; { -cr }
: ddest h# 4B my ;
: rport h# 48 my ; { -cr }
: rdest h# 47 my ; { cr }
 ( pins and testbed )
: p17v h# 50 my ; { -cr }
: p5v h# 51 my ;
: p3v h# 52 my ; { -cr }
: p1v h# 53 my ;
: edge h# 54 my ; { -cr }
: ios h# 55 my ;
: softbed h# 56 my ; { cr }
 ( cpu -number- buses and registers )
: abus h# 57 my ; { -cr }
: ioc h# 58 my ;
: ar h# 59 my ; { -cr }
: b h# 5A my ;
: t h# 5B my ; { -cr }
: pc h# 5C my ; { -cr }
: ir h# 5D my ;
: s h# 5E my ; { -cr }
: ss ( i ) d# 7 and h# 60 my + ;
: r h# 5F my ; { -cr }
: rs ( i ) d# 7 and h# 68 my + ; }block

( 00339400 )               D# 1253 shadow{ 
 ( softsim node variables ) { br }

 ( some node variables make more sense as hardware patterns, others
 as numbers ) }block

( 00339800 )               D# 1254 code{ 
 ( softsim node variables and shared code ) { , }
: 'tik h# 43 my ; { * }
: 'tok h# 45 my ; { * }
: sp h# 46 my ;
: slot h# 49 my ; { * }
: cnt h# 4A my ; { * }
: pre h# 4C my ;
: cy h# 4F my ; { * }
: 'opcode h# 70 my ; { * }
: rp h# 71 my ;
: mem h# 72 my ; { * }
: pwv h# 73 my ; { * }
: vis h# 74 my ;
: ip h# 75 my ; { * }
: 'group h# 76 my ; { * }
: rqs h# 77 my ;
: iom h# 78 my ; { * }
: 'bed h# 79 my ; ( 7a-7b available )
: rrq h# 80000 ; { * }
: wrq h# 40000 ; { * }
: brq h# C0000 ; { , , }
 :# 'trk 271562920 { * }
: -track [ 'trk ] assign nop ;
: track [ 'trk ] assign ip @ 2/ 2/ h# B8 and mem ! ; { , }
 [ macro ] { * }
: 2/s ?lit h# F8C1 2, 1, ;
: 2*s ?lit h# E0C1 2, 1, ; [ forth ]
: @10 @ { * }
: 10bit h# 3FF and ; { * }
: p-n { * }
: n-p h# 15555 or ;
: 18bit h# 3FFFF and ;
: 8bit h# FF and pc @ h# 200 and or ;
: !18 ( na ) push 18bit i @ h# -40000 and or pop ! ;
: !10 ( na ) push 10bit i @ h# 3FC00 and or pop ! ; { , , }
 :# vdd 1800 [ d# 1800 vdd ! ]
: ?v ( w-v ) if drop [ vdd @ ] then ; }block

( 00339C00 )               D# 1255 shadow{ 
 ( softsim node variables and shared code ) { cr }
 ( variables )
: 'tik 'tok ( defered execution )
: sp slot ( stack and slot pointers )
: cnt pre ( timers )
: cy 'op ( carry )
: rp mem ( return stack pointer , mem dump pointer )
: pwv vis
: ip bp' ( instruction pointer , ) { indent }
      ( alternate breakpoint )
: rqs ( requests from all ports accumulated here )
: rrq wrq brq ( read , write , both requests ) { br }

: 2/s ( right shift macro )
: 2*s ( left shift macro )
: @10 10bit ( mask and store 10 bit address )
: p-n n-p ( convert pattern to/from numbers )
: 18bit 8bit ( mask address bits )
: !18 ( store masked off 18 bit address )
: !10 ( store masked off 10 bit address ) { , , }
 vdd ( is 1.8v )
: ?v [ must follow an operation that sets ] w { , }
 [ to zero/non-zero ] }block

( 0033A000 )               D# 1256 code{ 
 ( softsim all tiks )
: out ( apm ) and if drop [ vdd @ ] then swap ! ;
: low? ( v- ) [ vdd @ d# 2 / negate ] + drop ; { , , }
: ?1p wrq
: pw! ( m ) ioc @ p17v @ low? -if - then h# 800 and { , .. }
      drop if dup or then edge @ 18bit or edge ! ; { , }
: ?18p p17v [ d# 8 !node ioc ] @ pwv @ ( phantom ) out
: npw! [ brq ] dbus @ over and or pw! ;
: ?sp ( to.do ) ;
: ?ap p17v pwv @ @ h# 20000 ( shared ) out npw! ;
: ?wake pins @ jump nul ?1p ?1p ?1p ?18p ?sp ?ap { , }
: @dest ( a-p ) h# F or @ @ ;
: +ours ( pa-p ) dup @ swap @dest +or [ brq ] and { , ... }
      or 2/ 2/ ;
: @ours ( -p ) [ d# 0 ] uport +ours lport +ours { , ... }
      dport +ours rport +ours ; { , , }
: status ?wake @ours 2/ rqs ! ; }block

( 0033A400 )               D# 1257 shadow{ 
 ( softsim all tiks )
: out ( output is zero or 1.8v )
: low? ( output negative if voltage is low ) { , , }
: pw! ( pin-wakeup sets request flag in ) edge
: npw! ( neighbor-pin-wakeup sets opposite request flag based on local
 copy of phantom/shared pin in otherwise unused p17v. ) { , , }
: @ours ( accumulate r/w requests into ) rqs }block

( 0033A800 )               D# 1258 code{ 
 ( softsim all toks )
: v-b ( mn-mb ) low? -if d# 0 ; then dup ;
: @pin ( mpma-mp ) @ v-b v+ ;
: @4p ( mp-mp ) h# 20 p5v @pin h# 8 p3v @pin
: @2p ( mp-mp ) h# 2 p1v @pin
: @1p ( mp-mp ) h# 20000 p17v @pin ;
: @sp ( mp-mp to.do ) ;
: @pins pins @ jump nul @1p @2p @4p @1p @sp @1p
: !ios ios h# 1FE00 d# 0 @pins push - over @ and { , ... }
      pop or rqs @ or swap ! ; { , , }
: !pin ( vm ) ioc @ over over and drop if 2* out ; { , .. }
      then ( in ) 2* - and drop if ( tri ) drop ; { , .. }
      then ( weak0 ) dup @ dup 2/ 2/ negate + swap ! ;
: !4p p5v h# 20 !pin p3v h# 8 !pin
: !2p p1v h# 2 !pin { * }
: !1p p17v h# 20000 !pin ;
: !18p abus @ h# 100 or h# 110 and drop if ; { , ... }
      ( up/data ) then dbus @ cnt @ - 2* drop { , ... }
      -if 18bit then p-n edge ! ;
: !sp ( to.do ) ;
: !ap ( to.do ) ;
: !pins pins @ jump nul !1p !2p !4p !18p !sp !ap }block

( 0033AC00 )               D# 1259 shadow{ 
 ( softsim all toks ) }block

( 0033B000 )               D# 1260 code{ 
 ( softsim suspended tiks and toks )
: cnt? cnt @ dup and drop ; { br }

: -hand ( mp-mp ) 2* 2* over over over and or drop ;
: -shake [ brq ] rqs @ 2* -hand if -hand if { indent }
      -hand if -hand then then then drop drop ;
: wait? cnt? if -shake ; then ; { br }

: +mine ( pa-p ) @ [ brq ] and or 2/ 2/ ;
: @mine [ d# 0 ] uport +mine lport +mine { indent }
      dport +mine rport +mine 2/ rqs ! ;
: !port ( mo-mo ) over over and { indent }
      if drop dbus @ then over dbus + ! 2/ ;
: !ports abus @ h# 155 or dup d# 4 2/s h# 8 { indent }
      d# 4 for !port next drop drop { indent }
      h# 14 or drop if d# -1 cnt ! then @mine ; }block

( 0033B400 )               D# 1261 shadow{ 
 ( softsim suspended tiks and toks ) { br }

: @mine ( accumulate r/w requests into ) rqs }block

( 0033B800 )               D# 1262 code{ 
 ( softsim tik/tok and power ) :# op 271568576 { , }
 :# 'boot 271568938 :# bail 0 [ d# 0 bail ! ] ( breakpoint )
: update !pins 'bed xqt !ios ;
: ipower !inode 'tok assign { , ... }
      [ d# 0 ] p17v [ p17v negate softbed + ] fill { , ... }
      [ d# 0 p-n ] abus [ softbed negate d# 7 rs + ] fill { , ... }
      d# 0 mem ! entry @ pc ! softbed @ 'bed ! { , ... }
      [ 'boot ] xqt d# 4 slot ! [ h# A9 ] ip ! -track update
: newop [ d# 0 ] cnt ! [ d# 0 ] dbus ! pc @ abus ! [ d# 0 ] rqs ! { ,
 ... }
      [ d# 0 ] rport ! [ d# 0 ] dport ! [ d# 0 ] lport ! [ d# 0 ] uport
 ! { , ... }
      [ op ] @ 'tik ! [ d# 3 ] pre ! ; { , , }
: ?bp ip @ slot @ or bp @ or if drop ; { , ... }
      then - [ bail ] ! [ comb ] @ brk ! ; { , , }
: itik ( i ) !inode { * }
: tik 'tik xqt ;
: itok ( i ) !inode { * }
: tok [ d# 0 ] brk ! 'tok xqt ;
: tiks [ nns d# -1 + ] for i itik -next ;
: toks [ nns d# -1 + ] for i itok -next ;
: power [ nns d# -1 + ] for i ipower -next toks tiks ; }block

( 0033BC00 )               D# 1263 shadow{ 
 ( opcode ---tick--- ---tock--- ) { cr }
 ( -alu-- ..update.. .!results. ) { cr }
 ( ...... .......... ) { cr }
 ( -addr- .upd,bus,? / ) { br }

 ( alu ops don't have to change tick; ) { cr }
 ( addr ops set abus,dbus in tick, then check for completion; if not
 done, tock writes dbus to ports and tick checks again, repeated til
 done. when done, tock clears ports and resumes opcode. ) }block

( 0033C000 )               D# 1264 code{ 
 ( softsim read/write access )
: @port ( mop-mop ) push over over and { , ... }
      if dbus + @dest then pop +or over u+ ;
: @ports dbus @ [ wrq ] ? drop if ; then { , ... }
      abus @ d# 4 2/s h# 15 or h# 1 d# 0 { , ... }
      d# 4 for @port next nip nip 18bit dbus ! ; { , , }
: ir/w abus @ h# 15D or drop if ; then { , ... }
      dbus @ [ wrq ] ? if 18bit p-n ioc ! ; { , ... }
      then drop ios @ dbus ! ; { , , }
: romw? dbus @ [ wrq ] ? drop if { , ... }
      abus @ [ rombit ] ? drop then ;
: mr/w dbus @ [ wrq ] ? if 18bit abus @ memory ! ; { , ... }
      then drop abus @ memory @ dbus ! ; }block

( 0033C400 )               D# 1265 shadow{ 
 ( softsim read/write access ) }block

( 0033C800 )               D# 1266 code{ 
 ( softsim port, register, and memory access ) { , }
 ( tik0 ) { * }
: por@! status 'tok assign { , }
 ( tok0 ) !ports update d# -1 cnt +! 'tik assign { , }
 ( tiki ) status wait? if 'tok assign { , }
 ( toki ) update d# -1 cnt +! ; { , }
 ( tike ) then @ports 'tok assign
: toke 'opcode xqt 'group xqt newop ; { , ... }
      begin 'tik assign { , }
 ( tiki ) { * }
: reg@! status cnt? while 'tok assign { , }
 ( toki ) update d# -1 cnt +! end { , }
 ( tike ) then 'tok assign ( toke ) ir/w toke ; { , ... }
      begin 'tik assign { , }
 ( tiki ) { * }
: mem@! status cnt? while 'tok assign { , }
 ( toki ) update d# -1 cnt +! end { , }
 ( tike ) then romw? if 'tok assign [ op ] @ 'tik ! ; { , ... }
      then 'tok assign ( toke ) mr/w toke ; { , , }
: access ( apc ) pop 'group ! pop 'opcode ! { , ... }
      cnt ! dbus ! h# 3FF and dup abus ! { , ... }
      h# 100 ? if h# 155 or h# F0 and drop if { , }
 ( ports ) d# 1 cnt ! por@! ; { , }
 ( regs ) then d# 2 cnt ! reg@! ; { , }
 ( mem ) then ( x ) drop mem@! ; }block

( 0033CC00 )               D# 1267 shadow{ 
 ( notes ) { , , }
 ( opcode ---tick--- ---tock--- ) { , }
 ( -alu-- ..update.. .!results. ) { , }
 ( ...... .......... ) { , }
 ( -addr- .upd,bus,? / ) { , , }
 ( alu ops don't have to change tick; ) { , }
 ( addr ops set abus,dbus in tick, then check ) { , }
 ( for completion; if not done, tock writes dbus to ports and tick
 checks again, repeated til ) { , }
 ( done. when done, tock clears ports and resumes opcode. ) }block

( 0033D000 )               D# 1268 code{ 
 ( softsim ops common code )
: ++@ ( a-n ) dup push @ d# 1 + dup pop ! ;
: @-- ( a-n ) dup push @ dup d# -1 + pop ! ;
: +t ( n ) t @ s @ sp ++@ ss ! s ! t ! ;
: -t ( -n ) t @ s @ t ! sp @-- ss @ s ! ;
: +r ( n ) r @ rp ++@ rs ! r ! ;
: -r ( -n ) r @ rp @-- rs @ r ! ;
: bin ( -nn ) -t t @ ;
: @19 ( -n ) @ dup h# 20000 and 2* or ;
: 3bit ( a-a ) h# 7 and pc @ h# 2F8 and or ;
: addr ( a-a ) slot @ jump { , ... }
      10bit 8bit 3bit nul nul { , , }
: ++abus ( -n ) abus @ h# 100 ? if ; then h# 27F
: /++/ ( nm-n ) over dup d# 1 + or and or ;
: pc++ ++abus pc ! ;
: ar++ ++abus ar !10 ; { , , }
: ?+c ( n-n ) pc @ - h# 200 and drop if ; then { , }
 cy @ d# 1 and + dup d# 18 2/s d# 1 and cy ! ;
: ?+*c ( n-n ) pc @ - h# 200 and drop if ; then { , }
 cy @ d# 1 and + dup - d# 18 2/s d# 1 and cy ! ;
: ?s+ ( n-n ) ar @ d# 1 ? if push s @19 + ?+*c pop then 2/ over d# 1
 and drop if h# 20000 or then ar ! ; }block

( 0033D400 )               D# 1269 shadow{ 
 ( softsim ops common code ) { br }

: @19 ( fetch then extend sign into bit 18 )
: ?+c ( add carry for + when p9 set )
: ?+*c ( add carry for +* when p9 set ) { indent }
      ( includes sign extend in s ) }block

( 0033D800 )               D# 1270 code{ 
 ( softsim ops control )
: /fet/ ( a ) [ rrq ] d# 3 { * }
: /pre/ ( adc ) access ( control group ) { , ... }
      abus @ 2* 2* ip ! { , ... }
      dbus @ p-n ir ! pc++ { * }
: slot0 d# 0 slot ! ; { , , }
 ( tike ) { * }
: /unext/ status pop 'opcode ! 'tok assign { , }
 ( toke ) update 'opcode xqt [ d# 3 ] pre ! ; { , , }
: ret r @ /fet/ -r drop ;
: ex r @ /fet/ pc @ r !10 ;
: jmp ir @ addr /fet/ nop ;
: call ir @ addr /fet/ r @ +r pc @ r !10 ; { , , }
: ur r @ dup and drop if { , ... }
      ( jump ) /unext/ d# -1 r +! slot0 ; { , ... }
      ( fall ) then /unext/ -r drop { * }
: slot+ d# 1 slot +! ;
: jr r @ dup and drop if { , ... }
      ( jump ) ir @ addr /fet/ d# -1 r +! ; { , ... }
      ( fall ) then pc @ /fet/ -r drop ;
: jz h# 3FFFF { * }
: jc t @ and drop if { , ... }
      ( fall ) { * }
: fetch pc @ /fet/ nop ; { , ... }
      ( jump ) then jmp ;
: jp h# 20000 jc ; }block

( 0033DC00 )               D# 1271 shadow{ 
 ( notes ) { , , }
: /fet/ ( begins a forced instruction fetch )
: /pre/ ( uses ) access ( to set control-group ) { , }
 ( behavior ) { , , }
 ( unconditional jumps specify source of next ) { , }
 ( instruction followed by ) /fet/ ( group behavior ) { , }
 ( followed by instruction completion behavior ) { , , }
 ( conditional jumps make their test which ) { , }
 ( determines which of two actions to follow ) }block

( 0033E000 )               D# 1272 code{ 
 ( softsim ops read/write and alu.1 )
: /w/ ( r ) @ t @ n-p [ wrq ] or [ d# 3 ] access ( write group ) { ,
 ... }
      -t drop slot+ ;
: /r/ ( r ) @ [ rrq ] d# 3 access ( read group ) { , ... }
      dbus @ p-n +t slot+ ; { , , }
: @a { * }
: @a, ar /r/ nop ; { * . }
     
: !a { * }
: !a, ar /w/ nop ;
: @b { * }
: @b, b /r/ nop ; { * .. }
     
: !b { * }
: !b, b /w/ nop ;
: @+ { * }
: @+, ar /r/ ar++ ; { * }
: !+ { * }
: !+, ar /w/ ar++ ;
: @p pc /r/ pc++ ; { * .. .. }
     
: !p pc /w/ pc++ ; { , , }
: /alu/ slot @ d# 3 or drop if ( slot0-2 ) { , }
 ( tike ) status pop 'opcode ! 'tok assign { , }
 ( toke ) update 'opcode xqt d# -1 pre +! slot+ ; { , }
 then ( slot3 ) pc @ [ rrq ] pre @ d# 0 max /pre/ ; { , , }
: +* /alu/ { * }
: r+* t @19 ?s+ 2/ 18bit t ! ;
: 2*x /alu/ { * }
: r2* t @ 2* 18bit t ! ;
: 2/x /alu/ { * }
: r2/ t @19 2/ t ! ;
: -x /alu/ { * }
: r- t @ h# 3FFFF or t ! ;
: +x /alu/ { * }
: r+ bin + ?+c 18bit t ! ;
: andx /alu/ { * }
: rand bin and t ! ;
: orx /alu/ { * }
: ror bin or t ! ;
: t! /alu/ { * }
: rdrop -t drop ; }block

( 0033E400 )               D# 1273 shadow{ 
 ( notes ) { , , }
: /alu/ ( alu opcodes in slots 0-2 don't end any ) { , }
 ( over-lapping prefetch behavior, while in slot { 6F } both actions
 finish together. ) pre ( fakes the simultaneity by keeping track of
 how many ) { , }
 ( contiguous alu opcodes were at the end of the instruction word. )
 }block

( 0033E800 )               D# 1274 code{ 
 ( softsim ops alu.2 and jump table )
: t@ /alu/ { * }
: rdup t @ { * }
: lit ( n ) +t ;
: .x /alu/ nop ;
: r@ /alu/ { * }
: rpop -r +t ;
: r! /alu/ { * }
: rpush -t +r ;
: s@ /alu/ { * }
: rover s @ +t ;
: b! /alu/ { * }
: rb! -t 10bit b ! ;
: a@ /alu/ { * }
: ra@ ar @ +t ;
: a!x /alu/ { * }
: ra! -t ar ! ; { , , }
: s0 ( p-o ) d# 13 2/s h# 1F and ;
: s1 ( p-o ) d# 8 2/s h# 1F and ;
: s2 ( p-o ) d# 3 2/s h# 1F and ;
: s3 ( p-o ) 2* 2* h# 1F and ;
: s4 ( p-o ) drop h# 20 ;
: @op ( ps-o ) jump s0 s1 s2 s3 s4 { , , }
: !op [ op ] assign ?bp ir @ n-p slot @ @op jump { , ... }
      ret ex jmp call ur jr jz jp { , ... }
      @p @+ @b @a !p !+ !b !a { , ... }
      +* 2*x 2/x -x +x andx orx t! { , ... }
      t@ r@ s@ a@ .x r! b! a!x { , ... }
      fetch [ !op ] }block

( 0033EC00 )               D# 1275 shadow{ 
 }block

( 0033F000 )               D# 1276 code{ 
 ( softsim display ops ) :# ?op 271571604
: tab/2 ( xy ) push [ d# 11 ] * [ d# 3 ] + pop [ d# 15 ] * [ d# 3 ]
 + { indent }
      over lm at ;
: cr/2 cr d# -15 [ xy ] +! ;
: emit/2 ( c ) [ d# 48 ] + emit
: -sp/2 [ d# -11 h# 10000 * ] nop [ xy ] +! ; { br }

: v- ( xyxy-xy ) push negate pop negate v+ ; { br }

: 'ops align strings ( ; ex jump call unext next if -if @p @+ @b @
 !p !+ !b ! +* 2* 2/ - + and or drop dup pop over a . push b! a! fetch )
 { br }

: .op ( i ) 'ops @ [ h# -10 ] and { indent }
      begin dup and while unpack emit/2 { indent }
      end then drop sp/2 ;
: ?more ( o ) [ h# 18 ] ? if drop ( t ) ; { indent }
      then [ h# 3 ] ? if dup or drop ( f ) ; { indent }
      then [ h# 4 ] and drop ( t/f ) ;
: .ops ( p ) d# 0 d# 4 for [ ?op ] xqt { indent }
      over over @op dup .op { indent }
      ?more while [ d# 1 ] + next ; then { indent }
      pop drop ; }block

( 0033F400 )               D# 1277 shadow{ 
 ( softsim display ops ) }block

( 0033F800 )               D# 1278 code{ 
 ( softsim display numbers ) :# base 16
: hex d# 16 [ base ] ! ;
: dec d# 10 [ base ] ! ;
: digits ( i-n ) d# 1 + d# 0 max d# 17 min align tbl { , ... }
      [ d# 47 , d# 24 , d# 25 , d# 26 , d# 27 , ] { , ... }
      [ d# 28 , d# 29 , d# 30 , d# 31 , ] { , ... }
      [ d# 32 , d# 33 , d# 5 , d# 19 , ] { , ... }
      [ d# 10 , d# 16 , d# 4 , d# 14 , d# 48 , ]
: digit ( i ) digits emit/2 ;
: .n ( nc ) dup push d# -1 + { , ... }
      for [ base ] @ /mod next { , ... }
      begin digit next ;
: awake cnt? -if -shake { , ... }
      if silver pop drop ; then then ;
: ?blue awake { * }
: blue h# 4040FF color ;
: ?cyan awake { * }
: cyan h# FFFF color ; { * }
: ?red awake red ;
: yellow h# E0E000 color ; { * }
: ?white awake white ;
: ?green awake { * }
: green h# D000 color ;
: broke [ comb ] @ brk @ or drop if pop drop then ;
: ?brk broke [ xy ] @ h# 10000 /mod d# 56 + swap d# 136 + { , ... }
      h# 3F3F color box ; }block

( 0033FC00 )               D# 1279 shadow{ 
 ( softsim display )
: base ( radix for small character number display )
: hex ( change ) [ base ] ( to hex )
: dec ( change ) [ base ] ( to decimal )
: digits ( table of character values )
: digit ( display digit as small character ) { cr }
 ( ? if too low, pacman if too high, for debug )
: .n ( display ) c ( digits of ) n ( in the current ) [ base ]
: awake ( exits caller if not awake )
: ?white
: ?green
: ?blue
: ?red ( change to named color if only awake )
: broke ( exit caller if breakpoint not reached )
: ?brk ( draw a box around the node which has ) { , }
 ( reached a breakpoint ) }block

( 00340000 )               D# 1280 code{ 
 ( softsim display directions ) { cr }
: .some ( p- -sp/2 ) h# 80 ? if ( r ) d# 1 emit/2 then { indent }
      h# 40 ? if ( d ) d# 16 emit/2 then { indent }
      h# 20 ? if ( l ) d# 12 emit/2 then { indent }
      h# 10 ? if ( u ) d# 22 emit/2 then { indent }
      drop pop drop ;
: .rdlu ( p- ) h# F0 over over or and drop { indent }
      if .some ; then ( a ) d# 5 emit/2 { indent }
      ( l ) d# 12 emit/2 ( l ) d# 12 emit/2 drop pop drop ;
: .iocs ( p- i ) d# 7 emit/2 ( o ) d# 3 emit/2 { indent }
      drop pop drop ;
: .adirs ( a-? ) h# 100 over over or and drop if ( -n ) ;
: .dirs ( a-? ) dup n-p if h# 15400 or h# 3FD00 and { indent }
      while then drop ( -n ) ; { indent }
      then drop sp/2 sp/2 { indent }
      then 8bit h# 55 or h# F0 ? if .rdlu ; { indent }
      then h# 8 ? if .iocs ; { indent }
      then sp/2 ( ? ) d# 47 emit/2 drop pop drop ;
: noadr ( w ) drop ; { -cr }
: .10b ( w ) p-n h# 3FF and d# 3 .n ;
: .8b ( w ) p-n h# FF and d# 2 .n ;
: .3b ( w ) d# 43 emit/2 p-n d# 7 and digit ;
: .adr ( wi ) over over @op d# -2 + drop { indent }
      -if drop drop ; then { indent }
      jump .10b .8b .3b noadr noadr }block

( 00340400 )               D# 1281 shadow{ 
 ( softsim display directions ) { cr }
 }block

( 00340800 )               D# 1282 code{ 
 ( softsim display registers )
: adr. abus @10 .adirs d# 3 .n ;
: db. dbus @ p-n d# 5 .n ;
: tr. cy @ d# 1 and drop if -sp/2 h# 25 emit/2 then { cr }
 t @ d# 5 .n ;
: sr. s @ d# 5 .n ;
: ar. ar @ .dirs d# 5 .n ;
: br. b @10 .adirs d# 3 .n ;
: ioc. ioc @ d# 5 .n ;
: ios. ios @ p-n d# 5 .n ;
: rqs. rqs @ d# 9 2/s h# FF and h# 2 .n ;
: ir. ir @ d# 5 .n ;
: op. ir @ n-p slot @ @op .op ;
: pc. pc @10 .adirs d# 3 .n ;
: rr. r @ d# 5 .n ;
: sl. slot @ digit ;
: rp. rport @ d# 5 .n ;
: dp. dport @ d# 5 .n ;
: lp. lport @ d# 5 .n ;
: up. uport @ d# 5 .n ; { br }

: ?+- ( -c ) -shake if ( - ) d# 35 ; then white ( + ) d# 43 ;
: cnt. cnt @ dup and { indent }
      -if drop ?+- emit/2 ; then digit ; }block

( 00340C00 )               D# 1283 shadow{ 
 ( softsim display registers ) { br }

 ( building blocks for the 2d display, com. ) }block

( 00341000 )               D# 1284 code{ 
 ( softsim display pins )
: i/o ( m ) cyan ioc @ and drop if yellow then ;
: .io ( m ) dup i/o ios @ and if drop h# 1 then digit ;
: .1p h# 20000 .io ; { * }
: .2p .1p h# 2 .io ;
: .4p .1p h# 20 .io h# 8 .io h# 2 .io ;
: .18p h# 1000 i/o edge @ d# 5 .n ;
: .sp ( to-do ) red [ d# 0 ] d# 2 .n ;
: .ap ( to-do ) red [ d# 0 ] d# 2 .n ;
: .pin pins @ jump nul .1p .2p .4p .18p .sp .ap
: .pins [ comb ] @ [ h# 8000 block negate ] + [ h# 200 ] / { , ... }
      dup d# -17 + drop -if drop d# 165 [ xy ] +! .pin ; { , ... }
      then d# 18 mod d# -17 + drop -if .pin ; { , ... }
      then h# 2C0000 [ xy ] +! .pin ;
: mv. ( ab ) i/o @ sp/2 d# 4 .n ;
: .mvs p17v h# 20000 mv. p5v h# 20 mv. { , ... }
      p3v h# 8 mv. p1v h# 2 mv. ;
: ?pex [ ?op ] assign dup slot @ or drop if white ; { , }
 then red { * }
: /?op [ ?op ] assign white ; [ /?op ]
: ?ip ( nf-n ) dup and drop if ?green /?op ; then ;
: ?pc ( n-nf ) dup pc @ or [ h# 240 - ] and drop { , }
 if dup 2* 2* ip @ or [ h# 900 - ] and drop { , }
 if [ d# 1 ] ; then red ?pex [ d# 0 ] ; then yellow [ d# 0 ] ; }block

( 00341400 )               D# 1285 shadow{ 
 ( softsim display pins ) }block

( 00341800 )               D# 1286 code{ 
 ( softsim display big nodes ) :# nod 0 :# nod2 18 { cr }
 begin drop red ;
: me? ( i ) dup [ nod ] @ or drop until [ nod2 ] @ or drop { , ... }
      if broke cyan ; then yellow ;
: .focus ( i ) dup me? n-nn dec d# 3 .n hex ;
: stack sp @ d# 8 for dup ss @ d# 5 .n { , ... }
      cr/2 d# -1 + next drop ;
: return rp @ d# 8 for d# 1 + dup rs @ d# 5 .n { , ... }
      cr/2 next drop ;
: stacks white return ?red rr. cr/2 { , ... }
      ?green tr. cr/2 sr. cr/2 white stack ;
: /mem. ( i ) [ 'trk ] xqt mem @ + dup white ?pc swap { , ... }
      d# 2 .n sp/2 ?ip memory @ dup p-n { , ... }
      d# 5 .n sp/2 .ops .adr cr/2 ;
: mem. mem @ h# B8 and mem ! d# 15 for i /mem. -next ;
: .pex ip @ dup h# 400 and drop if { , ... }
      red -sp/2 2/ 2/ h# 3FF and d# 3 .n sp/2 { , ... }
      ir. sp/2 ir @ p-n ?pex .ops .adr ; { , ... }
      then drop ;
: .big ( hvn ) dup push !inode hex { , ... }
      over d# 30 + over tab/2 stacks { , ... }
      tab/2 pop .focus sp/2 white ar. { , ... }
      cr/2 space space space br. { , ... }
      cr/2 .pex cr/2 mem. cr/2 { , ... }
      white ( ios. sp/2 rqs. cr edge @ h. cr ) ; }block

( 00341C00 )               D# 1287 shadow{ 
 ( softsim display big nodes ) }block

( 00342000 )               D# 1288 code{ 
 ( softsim display small nodes ) { cr }
 :# xo 0 :# yo 0 :# xs 8 [ d# 8 xs ! ] :# ys 4 [ d# 4 ys ! ]
: com. ( i ) hex [ xy ] @ push .drs .pins pop [ xy ] ! cr/2 -sp/2 silver
 ( i ) .focus white adr. cr/2 ?brk { cr }
 -sp/2 ?white sl. ?green op. cr/2 { indent }
      ?white ir. cr/2 { indent }
      ?green cnt. sp/2 ?white pc. cr/2 { indent }
      ?white ar. cr/2 space ?white br. { cr }
 cr/2 ?cyan ioc. cr/2 ?red rr. cr/2 { cr }
 ?green tr. cr/2 sr. ;
: ?com ( i ) dup !inode vis @ dup and { indent }
      if [ h# 10000 ] /mod tab/2 com. ; { indent }
      then drop drop ;
: coms. nnx [ xs ] @ negate + [ xo ] @ [ yo ] @ [ nnx ] * + { cr }
 [ ys ] @ for [ xs ] @ for dup ?com d# 1 + next { cr }
 over + next drop drop ;
: out? ( i-xy ) [ nnx ] /mod [ xo ] @ [ yo ] @ v- { indent }
      over over +or push over over { indent }
      [ xs ] @ [ ys ] @ v- and - pop +or drop ;
: loc ( i-l ) dup !inode out? -if drop drop d# 0 ; { cr }
 then push ( x ) [ d# 7 ] * [ d# 1 ] + { indent }
      pop ( y ) - [ ys ] @ + { 16F } [ d# 12 ] * ( hv ) [ d# 16 ] 2*s
 + ;
: !vis [ comb ] @ [ nns d# -1 + ] { indent }
      for i loc vis ! -next [ comb ] ! ; }block

( 00342400 )               D# 1289 shadow{ 
 ( softsim display small nodes ) }block

( 00342800 )               D# 1290 code{ 
 ( softsim display map and screen ) { cr }
 :# gap 1 :# wind? -1 :# time 13919
: xm ( -n ) nnx [ xs ] @ negate + ;
: ym ( -n ) nny [ ys ] @ negate + ;
: .vis ( hv ) 2/ [ yo ] @ - ym + [ d# 2 ] + + [ d# 30 ] * push { indent }
      2/ [ xo ] @ + [ d# 22 ] * pop over over at { indent }
      [ xs ] @ [ d# 22 ] * [ ys ] @ [ d# 30 ] * v+ blue box ;
: .node ( n ) nn-n dup !inode ?green d# 48 emit { indent }
      me? h# -160000 [ xy ] +! d# 21 emit ;
: .line ( n ) cr d# 17 for dup .node d# 1 + -next drop ;
: .map ( hv ) over over .vis tab/2 { indent }
      d# 7 for i [ nnxmod ] * .line -next ;
: .wind ( hv ) [ wind? ] @ dup and drop if .map ; { indent }
      then d# 1 d# 1 v+ [ nod2 ] @ .big ;
: bg h# 1F1F1F color { indent }
      d# 25 for d# 46 for d# 48 emit next cr next ;
: .so ( bg ) [ comb ] @ coms. { indent }
      d# 56 d# 0 .wind d# 57 d# 22 [ nod ] @ .big cr/2 { indent }
      white [ time ] @ . cr [ gap ] @ . [ comb ] ! ;
: ok !vis show black screen text .so keyboard ; }block

( 00342C00 )               D# 1291 shadow{ 
 ( softsim display map and screen ) }block

( 00343000 )               D# 1292 code{ 
 ( softsim keyboard handler )
: wtog [ wind? ] @ d# -1 or [ wind? ] ! ;
: we d# 1 { -cr }
: dx ( n ) [ xo ] swap over @ + xm
: dw ( ann ) min d# 0 max swap ! !vis ;
: ww d# -1 dx ;
: wn d# 1 { -cr }
: dy ( n ) [ yo ] swap over @ + ym dw ;
: ws d# -1 dy ;
: wy+ [ ys ] @ d# 1 + d# 4 min [ ys ] ! d# 0 dy ;
: wy- [ ys ] @ d# -1 + d# 1 max [ ys ] ! d# 0 dy ;
: wx+ [ xs ] @ d# 1 + d# 8 min [ xs ] ! d# 0 dx ;
: wx- [ xs ] @ d# -1 + d# 1 max [ xs ] ! d# 0 dx ;
: ftog [ nod2 ] @ [ nod ] @ [ nod2 ] ! { indent }
      [ nmem ] @ [ n2mem ] @ [ nmem ] ! [ n2mem ] !
: nod! ( n ) dup !inode [ nod ] ! mem @ [ nmem ] ! ;
: fw d# -1 { * }
: +nod [ nod ] @ + [ d# 0 ] max [ nns d# -1 + ] min nod! ;
: fn [ nnx ] nop { * }
: ++nod [ nod ] @ over +nod swap over + { , ... }
      [ nod ] @ or drop if nod! ; then drop ;
: fs [ nnx negate ] ++nod ; { * }
: fe d# 1 +nod ;
: mh [ d# 8 d# 64 + ] nop { * }
: mhl -track [ comb ] @ swap { , ... }
      [ nod ] @ !inode mem @ + [ h# BF ] and { , ... }
      dup [ nmem ] ! mem ! [ comb ] ! ;
: ml [ d# -8 ] mhl ; }block

( 00343400 )               D# 1293 shadow{ 
 ( softsim keyboard handler ) }block

( 00343800 )               D# 1294 code{ 
 ( softsim keyboard handler )
: gtog [ big ] @ d# 1 or [ gap ] @ or [ gap ] ! ;
: +gap d# 1 { * }
: +g [ big ] @ + d# 2 max dup [ big ] ! [ gap ] ! ;
: ++gap d# 100 +g ; { * }
: --gap d# -100 +g ; { * }
: -gap d# -1 +g ;
: brk? [ bail ] @ dup and drop ;
: restart d# 0 [ time ] ! [ comb ] @ power nm2m [ comb ] ! ;
: step d# 1 [ time ] +! [ comb ] @ toks tiks [ comb ] ! ;
: quick [ gap ] @ { * }
: steps ( n ) d# 0 [ bail ] ! for { , ... }
      step brk? if pop drop ; then next ;
: upto ( n ) [ time ] @ negate + d# 0 max steps ;
: go quick pause brk? if ; then key? go ;
: -stp -track quick ;
: +stp step { * }
: listen awake begin [ op ] @ 'tik @ or { , ... }
      drop while pause key? step end then track ; { , }
: h pad ( -n.alt ) nul +stp accept nul { , }
 ( ur ) ww wn ws we ( mr ) fw fn fs fe { , }
 ( lr ) ftog mh ml wtog ( ul ) nul nul --gap ++gap { , }
 ( ml ) restart gtog go -stp ( ll ) nul nul -gap +gap { , }
 ( n.alt ) [ h# 2507 , ] { , }
 ( ur ) [ h# 110160C , ] ( mr ) [ h# 110160C , ] ( lr ) [ H# F0C1403
 , ] { , }
 ( ul ) [ H# 2B230000 , ] ( ml ) [ H# 80D0E12 , ] ( ll ) [ H# 2B230000
 , ] }block

( 00343C00 )               D# 1295 shadow{ 
 ( softsim keyboard handler ) { br }

: h ( keyboard handler ) { indent .. }
      [ -+ ] ( by { C8F } ) { indent }
      [ pfgs ] ( power fast go step ) { indent .. }
      [ -+ ] ( by { 2F } ) { cr indent }
      [ ludr ] ( left up down right ) [ window ] { indent }
      [ ludr ] ( left up down right ) [ focus ] { indent }
      [ oudw ] ( other up down window ) [ memory dump ] { cr indent }
      [ i. ] ( instruction ) [ step complete opcode ] ( quit ) { br }

 [ note/ ] pad ( other-keys del-key space-bar alt-key ) [ also, 1st
 chars are ] ( del-key space-bar alt-key ) [ right-to-left ] }block

( 00344000 )               D# 1296 code{ 
 ( softsim connect node ports )
: !dests ( onn-on ) !inode over dbus + push { , ... }
      dup !inode over dbus + pop { , ... }
      ( onaa ) over over h# F or ! swap h# F or ! ;
: row ( on-o ) [ nnx ] for dup [ nnx ] + !dests d# 1 + { , ... }
      next drop ;
: rows ( non ) for over row [ nnx d# 2 * ] u+ { , ... }
      next drop drop ;
: col ( on-o ) [ nny ] for dup d# 1 + !dests [ nnx ] + { , ... }
      next drop ;
: cols ( non ) for over col d# 2 u+ next drop drop ; { , , }
 [ dbus negate ]
: rights d# 0 [ dup rport + ] nop [ nnx 2/ ] cols ;
: lefts d# 1 [ dup lport + ] nop [ nnx 2/ d# -1 + ] cols ;
: downs d# 0 [ dup dport + ] nop [ nny 2/ ] rows ;
: ups nnx [ uport + ] nop [ nny 2/ d# -1 + ] rows ;
: edges [ nns d# -1 + ] for i !inode { , ... }
      [ d# 0 ] pins ! [ h# 201FF ] iom ! [ ' nul ] softbed ! { , ... }
      edge dup ldest ! udest ! -next ;
: connect edges rights lefts ups downs ; { , }
 [ connect ] }block

( 00344400 )               D# 1297 shadow{ 
 ( softsim connect node ports ) { br }

 [ edge ] ( is the dummy destination for unassigned ) { cr }
 ( left and up ports )
: !dests ( using a port index /1,2,4,8/ and two ) { cr }
 ( nodes, node numbers, stores both port ) { cr }
 ( addresses in the other's *dest variable )
: row { -cr }
: rows { -cr }
: col { -cr }
: cols ( calc neighbors and assign *dest )
: rights { -cr }
: downs { -cr }
: lefts { -cr }
: ups
: edges
: connect }block

( 00344800 )               D# 1298 code{ 
 ( softsim assign node pins and wake-up )
: c0, ( n ) h# 1E00 { * }
: iom! ( nm ) swap !node iom @ or iom ! ;
: l0, ( n ) h# 1800 iom! ; { * }
: u0, ( n ) h# 600 iom! ;
: l1, ( n ) h# 21800 d# 1 { * }
: !p ( nmi ) push iom! pop pins ! ;
: l2, ( n ) h# 21803 d# 2 !p ; { * }
: u1, ( n ) h# 20600 d# 1 !p ;
: u2, ( n ) h# 20603 d# 2 !p ; { * }
: u4, ( n ) h# 2063F d# 3 !p ;
: u18, ( nw ) swap h# 20600 d# 4 !p pwv ! ;
: us, ( n ) h# 20600 d# 5 !p ( dummy ) ;
: !ap ( nwm ) swap !node ios push d# 6 !p pop pwv ! ;
: la, ( nw ) h# 21800 !ap ; { * }
: ua, ( nw ) h# 20600 !ap ; { , , }
 ( single ) [ d# 100 l1, d# 217 l1, d# 317 l1, d# 417 l1, d# 500 l1,
 d# 517 l1, d# 600 l1, d# 715 u1, ] ( serdes ) [ d# 1 us, d# 701 us, ]
 { , }
 ( spi ) [ d# 705 u4, ] ( async ) [ d# 708 u2, ] ( 1wire ) [ d# 200
 l1, ] ( sync ) { , }
 [ d# 300 l2, ] ( parallel ) [ d# 7 h# 200 u18, d# 8 u4, d# 9 h# 80
 u18, ] { , }
 ( analog ) [ d# 117 d# 217 la, d# 617 d# 517 la, d# 709 d# 715 ua, ]
 { , }
 [ d# 713 d# 715 ua, d# 717 d# 715 ua, ] ( no pins ) [ d# 0 c0, d# 2
 u0, ] { , }
 [ d# 3 u0, d# 4 u0, d# 5 u0, d# 6 u0, d# 10 u0, d# 11 u0, d# 12 u0, ]
 { , }
 [ d# 13 u0, d# 14 u0, d# 15 u0, d# 16 u0, d# 17 c0, ] { , }
 [ d# 400 l0, d# 700 c0, d# 702 u0, d# 703 u0, ] { , }
 [ d# 704 u0, d# 706 u0, d# 707 u0, d# 710 u0, ] { , }
 [ d# 711 u0, d# 712 u0, d# 714 u0, d# 716 u0, ] }block

( 00344C00 )               D# 1299 shadow{ 
 ( softsim assign node pins and wake-up ) }block

( 00345000 )               D# 1300 code{ 
 unused [ see d# 150 ] ( test code for chip ) [ reclaim ] { br }

 ( ide parts ) [ d# 1372 d# 5 loads reclaim ] { br }

 ( custom code ) [ d# 1302 load ] ( exit ) { br }

 ( polyforth ) [ d# 730 load ] { cr }
 ( smtm test ) [ d# 0 node d# 1342 load exit ] { br }

 ( */ exerciser ) [ d# 402 node d# 1354 load ] { indent }
      [ d# 401 node d# 1356 load d# 400 node d# 1358 load ] { cr }
 ( serdes ) [ d# 1 node d# 1360 load d# 701 node d# 1362 load ] { cr }
 ( spi flash write ) [ d# 702 node d# 1364 load ] { cr }
 ( ana ) [ d# 715 node d# 1366 load d# 717 node d# 1368 load ] { cr }
 }block

( 00345400 )               D# 1301 shadow{ 
 ( this block is loaded to compile test code for any desired nodes.
 write *nnn node* either here before loading a node's source, or in
 the source itself. the *node* phrase compiles the appropriate rom
 for the given node so that test code may reference the rom. ) { br }

 ( things like ide and common tests are loaded here, and this base
 code is presently assigned up at the top of this area just below 1380.
 to simplify base maintenance, please use { A2CF } for your own testing
 and load it from here. when we begin using personal space above { B40F }
 your own tests can go there. ) }block

( 00345800 )               D# 1302 code{ 
 unused ( custom test code exit ) { br }

 ( read/write { 24F } bit flash ) { indent }
      [ d# 705 node d# 1364 load d# 1609 bin ] { indent }
      [ d# 706 node d# 1216 load d# 1610 bin ] { cr }
 ( read/write { 10F } bit flash ) { indent }
      [ d# 705 node d# 1370 load d# 1611 bin ] { cr }
 ( read image from flash to sram ) { cr }
 [ host ]
: sram ( -n ) d# 4095 lit ;
: resume ( -n adjusted ) [ d# 656 d# 18 d# 8 */ d# 4 * ] lit ; { cr }
 [ target ] { indent }
      [ d# 705 node d# 292 load d# 1612 bin ] { cr }
 ( spi speedup ) { indent }
      [ d# 705 node d# 284 load d# 1608 bin ] }block

( 00345C00 )               D# 1303 shadow{ 
 ( this load block, and the following { 32F } source/shadow pairs,
 are yours to do with as you please! ) }block

( 00346000 )               D# 1304 code{ 
 ( eforth rom code ) { br }

 ( sdram addr ) [ d# 9 node d# 1320 load ] { indent }
      ( ctrl ) [ d# 8 node d# 1322 load ] ( ram ) { indent }
      ( data ) [ d# 7 node d# 1324 load ] { indent }
      ( idle ) [ d# 108 node d# 1326 load ] { indent }
      ( user ) [ d# 107 node d# 1328 load ] { br }

 ( eforth stack ) [ d# 106 node d# 1310 d# 2 loads ] { indent }
      ( bitsy ) [ d# 105 node d# 1306 d# 2 loads ] { br }

 }block

( 00346400 )               D# 1305 shadow{ 
 ( load block for rom resident sdram and eforth in the ga144. loaded
 by { 758F } even for tapeout. ) }block

( 00346800 )               D# 1306 code{ 
 ( e4 bitsy 1of2 ) { cr }
 [ h# AA org ]
: rp-- ( a-a' ) ^ AA ^ d# -1 . + ;
: bs@ { -cr }
: 'else ( a-w ) ^ AC ^ { indent }
      @p+ !b !b . ( ' ) @p+ x@ ( ' ) { indent }
      @p+ !b @b ; ( ' ) . . . !p+ ( ' )
: rp@ ( ri-ri ) ^ B0 ^ over rp--
: pshbs ( w- ) ^ B1 ^ @p+ !b !b ; ( ' ) @p+ pshw ( ' )
: 'r@ ( ri-ri ) ^ B3 ^ over rp--
: @w ( a- ) ^ B4 ^ bs@ pshbs ;
: rfrom ( ri-r'i ) ^ B6 ^ over rp-- over over @w ;
: popbs ( -w ) ^ B9 ^ @p+ !b @b ; ( ' ) !p+ pops ( ' )
: pshr ( aw-a ) ^ BB ^ { indent }
      @p+ !b !b dup ( ' ) @p+ . . @p+ ( ' ) { indent }
      !b @p+ !b . ( ' ) x! ( ' )
: rp++ { -cr }
: ip++ ( a-a' ) ^ BF ^ d# 1 . + ;
: tor ( ri-r'i ) ^ C1 ^ push popbs pshr pop ;
: rp! ( i-ri ) ^ C4 ^ push popbs rp++ pop ; { br }

: 'con ( ra-r'i ) ^ C7 ^ bs@
: 'var ( ra-r'i ) ^ C8 ^ dup pshbs
: 'exit ( rx-r'i ) ^ C9 ^ drop rp-- dup bs@ ; }block

( 00346C00 )               D# 1307 shadow{ 
 ( e4 bitsy shadow 1of2 )
: rp-- ( internal )
: x@ ( internal ) { -cr }
: 'else ( eforth microcode )
: rp@ ( eforth microcode )
: pshw ( internal )
: 'r@ ( eforth microcode )
: @w ( internal )
: rfrom ( eforth microcode )
: popw ( internal )
: pshr ( internal )
: rp++ ( internal ) { -cr }
: ip++ ( internal )
: tor ( eforth microcode )
: rp! ( internal )
: 'con ( eforth microcode )
: 'var ( eforth microcode )
: 'exit ( eforth microcode ) }block

( 00347000 )               D# 1308 code{ 
 ( e4 bitsy 2of2 ) { br }

 ^ CB ^ begin dup 2* -if { indent }
      ( code.s-xt ) drop !b ahead [ swap ] then { indent }
      ( code.r-xt ) drop push ;' { cr }
: bitsy ^ CE ^ then dup bs@ push ip++
: xxt ^ D0 ^ pop -until { indent }
      ( list-xt ) push pshr pop bitsy ; { br }

 ( execute )
: 'ex ^ D3 ^ ( xt-- ) popbs push xxt ;
: 'lit ^ D5 ^ ( --w ) dup bs@ push ip++ pop pshbs ;
: 'if ^ D8 ^ ( f-- ) popbs if { indent }
      drop ip++ ; then drop 'else ; { br }

 ^ DC ^ [ exit ] ( start is run in ide )
: start right a! ( terminal ) left b! ( stack ) { indent }
      d# -32 d# 0 ( rp.ip ) bitsy ; }block

( 00347400 )               D# 1309 shadow{ 
 ( e4 bitsy 2of2 shadow )
: 'con ( runtime constant )
: 'var ( runtime variable )
: 'exit ( runtime end call ) { br }

: btc ( label e4 interpreter ) { cr }
 ( bitsy main interpreter entry )
: xxt ( internal ) { br }

: 'ex ( runtime execute )
: 'lit ( runtime literal )
: 'if ( runtime conditional branch ) { cr }
: @io ( return the serial bit delay )
: !io ( init serial 0-autobps n-fixedbps )
: t!io ( internal )
: tx! ( transmit one character )
: ttx! ( internal )
: trx? ( internal )
: rx? ( test recieved char - 0 if no char else 18bit inverted char )
 }block

( 00347800 )               D# 1310 code{ 
 ( e4 stack 1of2 ) { cr }
 [ h# 3C org ]
: xa@ ( a- ) ^ 3C ^ @p+ !b !b ; ( ' ) @p+ sd@ ( ' )
: xa! ( a- ) ^ 3E ^ @p+ !b !b ; ( ' ) @p+ sd! ( ' ) { cr }
 ^ 40 ^ [ h# AA org ]
: 'c@ { -cr }
: '@ { -cr }
: x@ ( a-w ) ^ AA ^ xa@ @b ;
: sp++ { -cr }
: char+ { -cr }
: cell+
: 1+ ( w-w' ) ^ AC ^ d# 1 . + ;
: popt ( p-xp't ) ^ AE ^ dup sp++ over x@ ;
: sp-- { -cr }
: char- { -cr }
: cell-
: 1- ( w-w' ) ^ B0 ^ d# -1 . + ;
: psht ( pt-p' ) ^ B2 ^ push sp-- pop over
: x! ( wa- ) ^ B4 ^ xa! !b ;
: 'c! { -cr }
: '! ( pwa-p'st ) ^ B6 ^ x!
: popts ( p-p'st ) ^ B7 ^ popt
: pops ( pt-p'st ) ^ B8 ^ push popt pop ;
: pshs ( pst-p't ) ^ BA ^ push psht pop ;
: page@ ( pst-p'tw ) ^ BC ^ @p+ !b @b . ( ' ) dup !p+ ; ( ' )
: pshw ( pstw-p'tw ) ^ BE ^ push pshs pop ;
: page! ( ptw-p'st ) ^ C0 ^ @p+ !b !b . ( ' ) drop @p+ ; ( ' ) pops
 ;
: sp@ ^ C3 ^ ( -a ) pshs psht dup pops ;
: sp! ^ C6 ^ ( a- ) pshs popts ; }block

( 00347C00 )               D# 1311 shadow{ 
 ( e4 stack 1of2 shadow )
: 'c@ ( runtime c@ )
: '@ ( runtime @ )
: x@ ( inline external ram )
: sp++ ( increment data stack pointer )
: char+ ( increment address by char size )
: cell+ ( increment address by cell size )
: 1+ ( increment by one )
: popt ( internal )
: sp-- ( decrement data stack pointer )
: char- ( decrement address by char size )
: cell- ( decrement address by cell size )
: 1- ( decrement by one )
: psht ( internal )
: x!
: 'c! ( runtime c! )
: '! ( runtime ! )
: popts ( internal )
: pops ( internal )
: pshs ( internal )
: page@ ( inline external ram )
: pshw ( inline external ram )
: page! ( inline external ram ) }block

( 00348000 )               D# 1312 code{ 
 ( e4 stack 2of2 )
: 'drop ^ C8 ^ ( w- ) drop pops ;
: 'over ^ C9 ^ ( ww-www ) over pshw ;
: 'dup ^ CA ^ ( w-ww ) dup pshw ;
: 'swap ^ CB ^ ( ab-ba ) over push push drop pop pop ;
: '2/ ^ CD ^ ( w-w ) 2/ ; { -cr }
: '2* ^ CE ^ ( w-w ) 2* ;
: um+ ^ CF ^ ( uu-uc ) over or -if { indent }
      ^ D0 ^ over or . + -if
: 'nc ^ D2 ^ ( -0 ) dup dup or ;
: 'cy ^ D3 ^ ( -1 ) then d# 1 ; { indent }
      ^ D5 ^ then over or -if + 'cy ; then + 'nc ;
: zless ^ D8 ^ ( n-f ) -if dup or - ; then dup or ;
: 'or ^ DB ^ ( ww-w ) over - and
: 'xor ^ DC ^ ( ww-w ) or pops ;
: 'and ^ DD ^ ( ww-w ) and pops ;
: negate ^ DE ^ ( w-w ) 1-
: invert ( w-w' ) ^ DF ^ begin ( . ) - ;
: zeq ( w-f ) ^ E0 ^ until dup or ;
: '+ ( pww-p'sw' ) ^ E2 ^ + pops ; ^ E3 ^ ( exit )
: swap- ^ E3 ^ ( ww-w ) - . + - pops ; ^ E5 ^ { br }

 ^ E5 ^ [ exit ] ( start is run in ide )
: start right b! ( sdram ) { cr }
 d# 0 dup dup ( sp.s.t ) --l- ; ( bitsy ) }block

( 00348400 )               D# 1313 shadow{ 
 ( e4 stack 2of2 shadow )
: pshw ( internal )
: sp@ ( get data stack pointer )
: sp! ( set data stack pointer )
: 'drop ( runtime drop )
: 'over ( runtime over )
: 'dup ( runtime dup )
: 'swap ( runtime swap )
: zless ( runtime zero less )
: um+ ( add with carry )
: 'nc ( no carry is 0 )
: 'cy ( carry set is 1 )
: 'xor ( runtime exclusive or )
: 'and ( runtime and )
: 'or ( runtime inclusive or )
: negate ( runtime negate )
: invert ( runtime invert )
: zeq ( runtime zero equals )
: '+ ( runtime + )
: '2/ ( runtime 2/ )
: '2* ( runtime 2* ) }block

( 00348800 )               D# 1314 code{ 
 ( e4th bitsy ) { br }

: @io ^ 31 ^ ( --u ) @p+ ! @ . ( ' ) push t'@io ( ' ) pshw ; { cr }
 ( init io device 0-autobps n-fixedbps )
: !io ^ 34 ^ ( u-- ) popw
: t!io ^ 35 ^ ( u- ) @p+ ! ! ; ( ' ) @p+ t'!io ; ( ' )
: tx! ^ 37 ^ ( c-- ) popw
: ttx! ^ 38 ^ ( c- ) @p+ ! ! ; ( ' ) @p+ - ; ( ' )
: trx? ^ 3A ^ ( -c'0 ) @p+ ! @ ; ( ' ) !p+ t'rx? ; ( ' )
: rx? ^ 3C ^ ( --c'0 ) trx? pshw ; }block

( 00348C00 )               D# 1315 shadow{ 
 }block

( 00349000 )               D# 1316 code{ 
 ( e4 terminal 1of2 - serial i/o ) { br }

: getchar ^ 00 ^ ( delay in'0 f - delay -char f ) push over 2/ for
 . unext .. ( middle of start-bit ) { cr }
 d# 7 for ( 8-data bits ) { indent }
      over for . unext .. { indent }
      h# 1FFFF @b ( middle +/- ) { indent }
      over - and push and pop or { cr }
 2/ next { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .. h# FF and - dup { cr }
 begin drop @b -until drop pop ; { br }

: putchar ^ 13 ^ ( delay in'0 c - delay in'0 ) { cr }
 push over pop { cr }
 2* h# 3FE00 dup push - and pop or { cr }
 d# 10 for ( 1-start, 8-data, 2-stop bits ) { indent }
      d# 2 over over 2/ and or !b { indent }
      over for . unext .. { cr }
 2/ next drop drop ; ^ 21 ^ }block

( 00349400 )               D# 1317 shadow{ 
 ( note. both tx and rx are completely in stock rs232 polarity, i.e.
 mark lo space hi, data low start low. ultimately we need to invert
 the whole thing for compatibility with s40 boot node conventions but
 for testing purposes we will leave it as is and invert the rs232 board. )
 { br }

: getchar ( called after seeing leading edge of start bit. returns
 clean inverted character. ) { br }

: putchar ( takes a dirty octet of data and transmits it as startbit,
 eight data bits no parity one stop bit. ) }block

( 00349800 )               D# 1318 code{ 
 ( e4 terminal 2of2 - bitsy commands ) { br }

: baud ^ 21 ^ ( 0-d ) - push ( space is 0'0000.0100'1 ) { cr }
 ^ 22 ^ begin @b - -until ( at start-bit ) { cr }
 ^ 23 ^ begin @b -until ( at 1-bit ) { cr }
 ^ 24 ^ begin @b zif then - . -until ( at 0-bits ) { cr }
 ^ 26 ^ begin @b zif then . -until ( at stop-bit ) { cr }
 pop - ( n ) dup 2/ . + ( 1.5n ) ; { br }

: @io ^ 2A ^ ( delay - delay in'0 0 ) { indent }
      pop a! push dup or baud ! { indent }
      pop pop dup dup or ; { indent }
      begin baud
: !io ^ 2F ^ ( delay in'0 u - delay 0 0 ) { indent }
      until ( abandon old values )
: rx? ^ 30 ^ ( delay - delay 0 0 ) d# 0 dup ; { br }

: terminal ^ 32 ^ ( delay in'0 x ) { cr }
 begin drop @b - -if getchar then { indent }
      - 2* 2* -if drop .. r--- ( bitsy ) then { cr }
 -until ( delay in'0 -c ) - putchar dup terminal ; ^ 3C ^ }block

( 00349C00 )               D# 1319 shadow{ 
: @io ( return the serial bit delay ) { br }

: !io ( sets nonzero baud rate delay over garbage. if zero, waits for
 a space character to autobaud with. ) { br }

: rx? ( test for received char ) { br }

: tx! ( send one character ) { br }

: terminal ( polling loop for character receive or send ) }block

( 0034A000 )               D# 1320 code{ 
 ( sdram address-bus ) { cr }
 ( copy command to address bus ) { br }

 [ h# AA org ]
: cmd ( c- ) ^ AA ^ h# 3D555 ( nop.xxx ) !b .. { indent }
      @ ( sleeps ) !b cmd ; { br }

 ^ AD ^ [ exit ] ( start is run in ide )
: start right a! data b! cmd ; }block

( 0034A400 )               D# 1321 shadow{ 
 }block

( 0034A800 )               D# 1322 code{ 
 ( sdram control-pins ) { cr }
 ( each word runs the requested rise..fall cycle 12+11 ticks per cycle
 is a 42ns period ) { cr }
 [ h# 0 org ]
: nooop ( rfr-rfr ) ^ 00 ^ ( 'nooop' ) . .. !b { indent }
      .. over over .. . . !b ;
: rcol1 ( rf-rfrf ) ^ 04 ^ . . !b { indent }
      .. h# 2B .. !b ( transfer ) { indent }
      . h# 22E .. . . !b ; { cr }
 ^ 0A ^ [ h# 10 org ] ( 8-word page accessible to down port )
: cmmd ( rfr-rfr ) ^ 10 ^ ( '@p+ ! cmmd' ) !b { indent }
      .. over over .. . . !b ;
: rcol ( rfr-rfr ) ^ 13 ^ ( '@p+ ! rcol' ) !b { indent }
      over over .. rcol1 ;
: wcol ( rfr-rfr ) ^ 15 ^ ( '@p+ ! wcol' ) !b { indent }
      h# 2003E h# 2002E .. !b { indent }
      .. h# 3022B .. !b ( transfer ) { indent }
      h# 3023B !b .. . . !b { indent }
      h# 2002E .. !b h# 2B !b ( recover ) { indent }
      .. over over .. . . !b ; { br }

 ^ 23 ^ [ exit ] ( start is run in ide )
: start right a! io b! h# 2E ( cmd-fall ) -d-- ; }block

( 0034AC00 )               D# 1323 shadow{ 
 }block

( 0034B000 )               D# 1324 code{ 
 ( sdram data-bus ) { br }

 ( db@ isn't used with 7j chip! ) { cr }
 [ h# AA org ] ( called with 'db@' '...!p+' )
: db@ ( -w ) ^ AA ^ @ ; ( wakeup when data ready ) { br }

 ( db! called with '@p+ db!' )
: db! ( w- ) ^ AB ^ h# 15555 !b ( .. set output state ) { indent }
      ! ( wakeup when data taken )
: inpt ^ AD ^ h# 14555 !b ; ( restore input state ) { br }

 ^ AF ^ [ exit ] ( start is run in ide )
: start up a! io b! down push inpt ; }block

( 0034B400 )               D# 1325 shadow{ 
 }block

( 0034B800 )               D# 1326 code{ 
 ( sdram idle-loop ) { cr }
 [ h# AA org ]
: noop ( - ) ^ AA ^ @p+ ! ; ( ' ) nooop ( ' )
: cmd ( c- ) ^ AC ^ h# 5A48 ! ! ; ( '@p+ ! cmmd' ) { cr }
: idle ( m-m ) ^ AE ^ @p+ ! .. ( ' ) nooop ( ' ) h# 8003 cmd noop d# 120
 for ( 7.8us 42ns/ 5- is 181 ) { indent }
      @p+ ! .. ( ' ) nooop ( ' ) { indent }
      begin ^ B7 ^ @b and if { indent }
      ( ... ) @ .. @ ! ! ( user to ctrl ) { indent }
      ( ... ) *next idle ; ^ BC ^ { indent }
      then drop { cr }
 next @p+ ! .. ( ' ) nooop ( ' ) idle ; { cr }
: init ( m-m ) ^ C0 ^ ( run only at power-up/reset ) { indent }
      d# 4761 for ( 200us 42ns/ 1- ) noop next { indent }
      noop h# 10400 ( pre.all ) cmd noop { indent }
      h# 8001 ( rfr.123 ) cmd noop noop { indent }
      h# 8002 ( rfr.123 ) cmd noop noop { indent }
      h# 21 ( std.mode ) cmd noop noop { indent }
      h# 4000 ( ext.mode ) cmd noop idle ; { br }

 ^ D8 ^ [ exit ] ( start is run in ide )
: start h# 135 ( '-dl- ) a! io b! { cr }
 h# 800 ( n13w? ) dup dup dup dup dup dup { cr }
 dup dup dup init ; }block

( 0034BC00 )               D# 1327 shadow{ 
 }block

( 0034C000 )               D# 1328 code{ 
 ( sdram user interface ) { cr }
 [ h# AA org ] ( user cmds+data from/to up or right )
: a2rc ( pa-pbc ) ^ AA ^ dup ( 2* 16mw ) push 2/ ( 32mw ) { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ -if
: row! ( pr-pbc ) ^ AF ^ h# 7FFF ( row.mask ) and dup .. { cr }
 h# 18000 ( activate ) or .. ! h# 5A48 ! .. ( '@p+ ! cmmd' ) h# 6000
 ( bank.mask ) and pop .. h# 3FF ( col.mask ) and ; then over + row!
 ;
: sd@ ( pa-p ) ^ BB ^ a2rc h# 28400 ( read+pre ) or or { cr }
 ! h# 5A4B ! .. ( '@p+ ! rcol' ) down b! .. { cr }
 @p+ !b @b ( ' ) @ !p+ .. ( ' ) pop b! !b ;
: sd! ( pa-p ) ^ C5 ^ a2rc h# 20400 ( write+pre ) or or { cr }
 ! h# 5A4D ! .. ( '@p+ ! wcol' ) pop b! @b .. { cr }
 down b! .. @p+ !b !b ; ( ' ) @p+ db! ( ' )
: poll ( ru-ru ) ^ CF ^ io b! @b { cr }
 2* 2* -if push over .. r--- over pop then { cr }
 h# 800 and . if push .. ---u pop then { cr }
 drop poll ; { br }

 ^ DC ^ [ exit ] ( start is run in ide )
: start left ! d# 0 d# 0 ( r.u ) poll ; }block

( 0034C400 )               D# 1329 shadow{ 
 ( configure for sdram wiring as follows ) { cr }
 2* ( 16mw ) push ( 2/ 32mw ) [ for d# 16 mw wiring ] { cr }
 ( 2* 16mw push ) 2/ ( 32mw ) [ for 32. ] }block

( 0034C800 )               D# 1330 code{ 
 ( async ats interface ) [ d# 0 org ]
: obit ( dwn-dw ) ^ 00 ^ !b over push delay ;
: word ( dw-d ) ^ 02 ^ leap drop leap drop leap drop drop ;
: obyt ( dw-dwx ) ^ 06 ^ then then then d# 3 obit drop d# 7 for dup
 d# 1 and d# 3 or obit drop 2/ next d# 2 obit ;
: -out ^ 11 ^ ser-exec ( rdl- ) ; ^ 12 ^ { br }

: ok ^ 12 ^ h# 31416 word -out ;
: fet ^ 15 ^ d# 0
: pump ( n ) for @+ word next -out ;
: stat ^ 1B ^ d# 9 pump ;
: bstk ^ 1D ^ @ push .. @ word pop dup push word .. ( @p+.push ) h# 49BA
 ! d# 7 .. dup push ! .. @p+ ! .. ( /+ ) begin !p+ . . unext .. begin
 @ word .. next .. @p+ ! pop .. ( /+ ) pop @p+ ; .. ! -out ; ^ 2C ^
 }block

( 0034CC00 )               D# 1331 shadow{ 
 ( this code is loaded on top of ide boot node. )
: obit ( sends one bit 0-3/hi 1-2/low )
: word ( sends a word as { 6F } octets. )
: obyt ( sends and discards { 10F } lsb of w, lsb first, with one start
 bit hi and one stop bit low. ) }block

( 0034D000 )               D# 1332 code{ 
 }block

( 0034D400 )               D# 1333 shadow{ 
 }block

( 0034D800 )               D# 1334 code{ 
 }block

( 0034DC00 )               D# 1335 shadow{ 
 }block

( 0034E000 )               D# 1336 code{ 
 }block

( 0034E400 )               D# 1337 shadow{ 
 }block

( 0034E800 )               D# 1338 code{ 
 }block

( 0034EC00 )               D# 1339 shadow{ 
 }block

( 0034F000 )               D# 1340 code{ 
 }block

( 0034F400 )               D# 1341 shadow{ 
 }block

( 0034F800 )               D# 1342 code{ 
 ( smtm test ) [ h# 32 org ]
: go a! h# 1557F !b h# 1556A !b . pop @p+ { indent }
      ( ' ) @p+ dup 2/ . ( ' ) a ! ! h# 43 for { indent }
      h# 3F !+ . unext { indent }
      ( ' ) 2* a! push . ( ' ' ) begin @p+ !+ . unext ( ' ) { indent }
      ( ' ) @p+ push ; ( ' ) ! warm ; { cr { 25F } }
 [ h# 2A org ]
: r @p+ go ; r---
: d @p+ go ; -d--
: l @p+ go ; --l-
: u @p+ go ; ---u { cr }
 [ d# 0 org ] ( avoid node1 ) d r l
: path r l r l d l r l r d path ; }block

( 0034FC00 )               D# 1343 shadow{ 
 ( smtm test ) { br }

 ( steven's crawling memory tester ) }block

( 00350000 )               D# 1344 code{ 
 { 1CF } ( word ga144 creeper test frame 3/25/11 ) { cr }
 ( see db007 for detailed discussion. ) { br }

 [ h# 36 org ]
: focus ^ 36 ^ ( jport ) dup dup a! dup ! @p ! dup { cr }
 ( ' ) @p b! . ! or !b ;
: creep ^ 3A { 86F } ^ dup !b push { cr }
 begin @p ! unext . ^ 3C ^ { cr }
 ( ' ) h# 3F push dup ( ' ) or a! { cr }
 ( ' ) begin @b !+ unext ^ 40 ^ { cr }
: wire begin @b ! @b ! @
: rip ^ 42 ^ dup !b -until ^ 43 ^ warm ; { cr }
 ^ 44 ^ [ d# 4 org ]
: test ^ 04 ^ ( n1 ) }block

( 00350400 )               D# 1345 shadow{ 
 ( creeper input side data flow iio ) { cr }
 ( @p call to focus, creep, wire, rip, or ) { cr }
 ( anywhere in the test package from { 9F } to { 6BF } ) { cr }
 ( with any n1 on the stack ) { br }

: focus ( prepares to use neighbor thru ) [ jport ] ( sets a forward
 and neighbor pc and b back. result is zero. )
: creep [ d# 67 ] ( returned as early sync. crawl to focused node,
 make it active, we become wire. copies { 88F } words to neighbor )
 { cr }
 ( fallthrough after copy to wire must be at ) ^ 40 ^
: wire ( passes iio messages until result negative at which time this
 node and all before it return to warm. )
: rip ( argument and result must be negative to restore all nodes to
 warm state. )
: test ( can call any address from { 9F } to { 6BF } and can do what
 it wants with ) [ n1. ] ( result must be positive, { F } normally
 means ok. ) }block

( 00350800 )               D# 1346 code{ 
 ( fill neighbor's memory fake test ) { cr }
 ( creeper ) [ d# 1344 load ]
: ping ^ 45 ^ @p ! ! . ( ' @p ) @b 2/ ( !p ) !b . { cr }
 @ !b ; ^ 48 ^ [ exit ]
: why d# -1 . + down a! ! ; [ exit ]
: nulltest ^ 45 ^ d# 1 . + !b ; ^ 48 ^ [ exit ]
: test ^ c01/1 ^ ( n1 ) d# 63 @p ! . ( ' ) dup or a! @p { cr }
 ! @p ! @p ( ' ) push ( ' ) begin a !+ unext . { cr }
 ! dup dup or !b drop ; ^ c01/1 ^ }block

( 00350C00 )               D# 1347 shadow{ 
 }block

( 00351000 )               D# 1348 code{ 
 ( extensive neighbor's memory test 005-035 ) { cr }
 [ h# 29 org ] { -cr }
: err [ h# 5 org ]
: test ( n1 ) @p ! @p dup ( ' ) h# 3F push dup dup { cr }
 ! @p ! ( ' ) or dup a! . { cr }
 @p ! ( ' ) begin dup !+ unext . ( erased ) { cr }
 for { cr cr }
 h# 19999 @p ! dup ( ' ) @p ! @ . { cr }
 ! @p ! . ( ' ) !b @p ! { cr }
 @ or if ^ 13 ^ pop err ; then ^ 14 ^ ( test1 ) { cr }
 h# CCCC dup ! @p ( ' ) @ !b dup dup { cr }
 ! @ or if ^ 19 ^ pop err ; then ^ 1A ^ ( 0 test2 ) { cr }
 @p ! . ( ' ) or ! . ( erased ) { cr cr }
 drop @p ! @p ( ' ) dup ( 0 0 ) - { 7FFFFF } ! h# 3E { cr }
 ! @p ! ( ' ) @+ !b push { 1F } { cr }
 @ - if ^ 22 ^ pop err ; then ^ 23 ^ ( test3 ) { cr }
 drop @p ! ( ' ) begin @+ !b unext . { 1F } { cr }
 h# 3E for @ if pop pop
: err ^ 29 ^ d# 1 + !b ; then ( test4 ) { cr }
 drop next { cr }
 @p ! . . ( ' ) dup !+ . next ( erased ) { cr }
 dup dup or !b ; ^ 31 ^ ( 3/5/11 ) { cr }
 }block

( 00351400 )               D# 1349 shadow{ 
 ( test tests neighbor's memory ) { cr }
 ( 19999 cccc test shorts to bits two bits away ) { cr }
 ( 3ffff { 1F } test shorts to bits one bit away ) { cr }
 ( tests for shorts between two addresses ) { cr }
 ( by reading { 80F } words after each { 7FFFFF } ! ) { cr }
 }block

( 00351800 )               D# 1350 code{ 
 { C88F } ( all nodes template ) [ d# 15 node d# 0 org ]
: poll io b! @b ( mask ) h# AA00 ^ 03 ^ and if ( drop ) warm ; then
 drop ; ^ 06 ^
: incr poll if d# 1 . + ; then drop d# 1 . + d# 1 ;
: run ^ 0E ^ d# -1 d# 0 { 4E1EF } d# 99999 for { 4E1EF } d# 44999 for
 incr next next h# 3E a! !+ !+ h# 600D warm ;
: run ^ 1D ^ d# 0 d# 1 begin begin while poll d# 1 . + end then drop
 d# 1 . + d# 1 end ; { cr }
 ^ 2A ^ [ d# 1604 bin ] }block

( 00351C00 )               D# 1351 shadow{ 
 }block

( 00352000 )               D# 1352 code{ 
 ( erase flash ) [ d# 0 org ]
: wait ( dw-dw ) ^ 00 ^ select dup begin drop @b -until drop select
 ;
: 2cmd ( dw-d ) ^ 04 ^ select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) ^ 09 ^ io b! ( fast ) d# 5 ;
: fet ( ah al-d ) ^ 0C ^ push push set ( read ) h# C00 cmd pop !8 pop
 8obits !8 ;
: +wr ( -d ) ^ 12 ^ set ( wren+wrsr ) h# 1804 2cmd { indent }
      ( hi8 zero ) dup !8 ( ebsy ) h# 1C000 cmd ;
: ers32k ^ 18 ^ +wr ( wren+ers32 ) h# 1948 2cmd { cr }
 d# 0 !8 d# 0 8obits !8 dup select ;
: ersall ^ 21 ^ +wr ( wren+eras ) h# 1980 2cmd { cr }
 dup select ;
: 16ibits ( d-db ) ^ 25 ^ dup d# 15 for { cr }
 rbit ibit - next h# FFFF and ;
: stash ( d-d ) ^ 2C ^ a push h# 3F a! 16ibits ! pop a! ; ^ 30 ^ }block

( 00352400 )               D# 1353 shadow{ 
 }block

( 00352800 )               D# 1354 code{ 
 ( hardware multiply test ) [ d# 0 org +cy ]
: clc ^ 00 ^ dup dup or dup . + drop ;
: d2* ( hl-hl ) ^ 02 ^ dup . + push dup . + pop ;
: um+ ( hln-hl ) ^ 05 ^ . + push dup dup or . + pop ; ^ 08 ^ [ -cy ]
: h* ( nu-hl ) ^ 08 ^ dup a! dup or d# 17 for +* unext a ;
: abs ( n-n ) ^ 0C ^ -if
: neg ( n-n ) ^ 0D ^ - d# 1 . + then ; ^ 10 ^ [ +cy ]
: u/mod ( hld-rq ) ^ 10 ^ clc neg
: -u/mod ^ 12 ^ a! d# 17 push begin begin dup . + push dup . + dup
 a . + -if drop pop *next dup . + ; then over or or pop next dup .
 + ; ^ 1E ^ [ -cy ]
: try ^ 1E ^ right b! ( ba ) @b @b h* ( r ) @b um+ ( a ) @b u/mod ( b )
 !b ( r ) !b try ; ^ 26 ^ }block

( 00352C00 )               D# 1355 shadow{ 
: h* ( is simplest multiply; first arg is a signed number and second,
 the multiplier, is a full { 24F } bit unsigned number. )
: try ( slaves this node to another by the port given. it expects to
 receive numbers b a r and calculates b*a+r then receives a and returns
 b and r. the multiply is done using the h* here which is why b is
 signed and a is unsigned. ) }block

( 00353000 )               D# 1356 code{ 
 ( soft multiply test ) [ d# 0 org +cy ]
: clc ^ 00 ^ dup dup or dup . + drop ;
: d2* ( hl-hl ) ^ 02 ^ dup . + push dup . + pop ;
: um+ ( hln-hl ) ^ 05 ^ . + push dup dup or . + pop ;
: u* ( nn-hl ) ^ 08 ^ a! clc dup push dup or dup pop d# 17 for begin
 push d2* a -if 2* a! pop dup push . + push d# 0 . + pop pop *next
 drop ; then 2* a! pop next drop ; ^ 19 ^ [ -cy ]
: abs ( n-n ) ^ 19 ^ -if
: neg ( n-n ) ^ 1A ^ - d# 1 . + then ;
: *. ( ff-f ) ^ 1D ^ over over or push abs swap abs u* d2* d2* drop
 pop -if drop neg ; then drop ; ^ 26 ^ [ +cy ]
: u/mod ( hld-rq ) ^ 26 ^ clc neg
: -u/mod ^ 28 ^ a! d# 17 push begin begin dup . + push dup . + dup
 a . + -if drop pop *next dup . + ; then over or or pop next dup .
 + ; ^ 33 ^ ( -cy )
: try ^ 33 ^ right b! @b @b u* @b um+ @b u/mod !b !b try ; ^ 3A ^ }block

( 00353400 )               D# 1357 shadow{ 
 }block

( 00353800 )               D# 1358 code{ 
 ( multiply exerciser ) [ h# 0 org ]
: dec ( n-n ) d# -1 . + ;
: +or ( nn-n ) over - and or ;
: try ( abr-ab bad ) ^ 04 ^ right a! ( 12033 ! ) push dup ! over !
 pop dup ! push over ! dup @ or @ pop or +or ;
: test ( abr-abr ) dup push try if pop ; then drop pop
: poll @b h# 200 and if up b! @b push ;' io b! then drop
: run ( abr-abr ) ^ 1A ^ if dec test ; then drop if dec over dec test
 ; then drop dec if ( -1 ) h# 1FFFF over dec test ; then drop h# 600D
 ; ^ 29 ^
: go ^ 29 ^ io b! ( 20000 ) h# 1FFFF ( -1 ) h# 1FFFF over dec run ;
 { br }

: -u/mod ( old ) ^ 2F ^ a! d# 17 push dup . begin begin { cr }
 + push dup . + dup a . + -if drop pop dup *next + ; then over or or
 pop dup next + ; ^ 3C ^ }block

( 00353C00 )               D# 1359 shadow{ 
: try ( exercises slave node given a test vector. for the hardware
 version a is unsigned and b is signed. but the divide is unsigned
 so b is limited to the largest positive number. ) }block

( 00354000 )               D# 1360 code{ 
 ( serdes test ) [ h# AA org ] data a! h# 3FFFE dup ! up a! begin @
 drop unext ( rdlu ) [ d# 0 org ]
: try io b! h# 20000 !b h# 147 a! d# 0 d# 10000 for d# 1 + dup a! next
 ;
: start @ io b!
: test h# 2AAAA @b or ! test . . . . down a! . . start }block

( 00354400 )               D# 1361 shadow{ 
 }block

( 00354800 )               D# 1362 code{ 
 ( serdes test { 4F } ) [ h# AA org ] data a! h# 33333 dup ! up a!
 h# 20000 !b begin dup . . . . . . . . . . . . . . . . . . . . . !
 unext . . . . . . . }block

( 00354C00 )               D# 1363 shadow{ 
 }block

( 00355000 )               D# 1364 code{ 
 ( spi flash writer michael + greg 2.1 ) [ d# 0 org ]
: 2o ( dw-dw' ) ^ 00 ^ obit 2* obit ;
: wait ( dw-dw ) ^ 02 ^ select dup begin drop @b -until drop select
 ;
: 2cmd ( dw-d ) ^ 06 ^ select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) ^ 0B ^ io b! ( fast ) d# 5 { 28F } ;
: fet ( ah al-d ) ^ 0E ^ push push set ( read ) h# C00 cmd pop !8 pop
 8obits !8 ;
: +wr ( -d ) ^ 14 ^ set ( wren+wrsr ) h# 1804 2cmd { indent }
      ( hi8 zero ) dup !8 ( ebsy ) h# 1C000 cmd ;
: aaip ( d-d ) ^ 1A ^ h# 2B400 wait !8 ;
: x8p ( hln-d asrc ) ^ 1D ^ +wr ( wren+aaip ) h# 1AB4 2cmd { cr }
 drop push push push set pop !8 pop 8obits { cr }
 !8 ahead begin aaip [ swap ] then d# 7 for { indent }
      pop dup push push @+ { indent }
      begin 2o 2* next push aaip pop { indent }
      d# 7 pop dup push or push { indent }
      begin 2o 2* next drop next next { cr }
 ( wrdi+dbsy ) h# 1200 wait 2cmd -++ !b rdl- ; ^ 3B ^
: ers32 ^ 3B ^ ( h-dd +wr wren+ers32 { 3291F } 2cmd ) { cr }
 ( over 8obits 8obits !8 dup select ; ) ^ 3B ^ }block

( 00355400 )               D# 1365 shadow{ 
 ( run by an adjacent node through a port. ) { cr }
 24 bit addresses ( are represented in two { 24F } bit words. for continuous
 bit sync, all operations must start on { F } mod { 24F } byte boundaries. )
 { cr }
 [ high ] ( word contains the most significant { 10F } bits of the
 address shifted left { 14F } bits. ) { cr }
 [ low ] ( word contains the least significant { 20F } bits shifted
 left two bits. ) { br }

: x8p ( writes ) [ n ] ( words into flash starting at address whose )
 [ high ] ( and ) [ low ] ( parts are given. the data are read from
 wherever ) [ a ] ( points; to feed a stream through a port, ) [ a ]
 ( must be focused to the port before starting. ) { br }

: fet ( starts a read operation )
: 18ibits ( reads one word; take care with ) [ 'd' ] }block

( 00355800 )               D# 1366 code{ 
 ( take adc data ) [ d# 0 org ]
: sam+ ( -n ) ^ 00 { 2ABF } ^ h# 2155 { C2ABF }
: s+- ( k-n ) io b! !b up b! !b @b ;
: sam- ( -n ) ^ 06 { 12ABF } ^ h# 2955 { D2ABF } s+- ; { br }

: sam ^ 08 ^ h# 20 a! sam+ sam- d# 11 2* for { cr }
 push sam+ dup - pop . + ( !+ ) push { cr }
 push sam- dup - pop . + pop + !+ next ; ^ 16 ^ { br }

 [ exit ] sam+ drop }block

( 00355C00 )               D# 1367 shadow{ 
 ( this block supports taking of data manually for a/d transfer function.
 to use it, put a/d in the desired mode by editing the constants in
 sam+ and - then set desired voltage and execute sam. you will find
 a sequence of samples stored in ram at { 40F } ) { br }

 ( original version sampled each half cycle of the incoming clock. )
 }block

( 00356000 )               D# 1368 code{ 
 ( generate dac waves ) [ d# 0 org ]
: dly ^ 00 ^ d# 100 for unext ;
: sano ( n-n ) h# 3FFDF and ; h# 10 or ;
: tri ( n ) ^ 07 ^ push h# 155 d# 0 begin { cr }
 d# 510 for over or dup sano !b { indent }
      dly over or d# 1 . + next { cr }
 d# 510 for over or dup sano !b { indent }
      dly over or d# -1 . + next next drop drop ;
: try ^ 1C ^ io b!
: sing ^ 1E ^ d# 1000 tri
: poll ^ 20 ^ @b h# 2000 and if down b! @b push ;' io b! then drop
 sing ;
: haul ^ 29 ^ io b! d# -1 dup push dup push dup push dup push dup push
 dup push dup push dup push push h# 155 h# AA over over over over over
 over ( / ) dup dup
: spin ^ 36 ^ begin !b ( . . ) unext ( !b !b !b !b !b !b !b !b ) spin
 ; ^ 37 ^ [ exit ] { cr }
 h# 155 h# 1D5 h# 55 h# D5 h# AA h# D5 h# 55 h# 1D5 ( / ) }block

( 00356400 )               D# 1369 shadow{ 
 }block

( 00356800 )               D# 1370 code{ 
 ( spi flash { 10F } bits ) [ d# 0 org ]
: 2o ( dw-dw' ) ^ 00 ^ obit 2* obit ;
: wait ( dw-dw ) ^ 02 ^ select dup begin drop @b -until drop select
 ;
: 2cmd ( dw-d ) ^ 06 ^ select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) ^ 0B ^ io b! ( fast ) d# 5 ;
: fet ( ah al-d ) ^ 0E ^ push push set ( read ) h# C00 cmd pop !8 pop
 8obits !8 ;
: 16ibits ( d-db ) ^ 14 ^ dup d# 15 for { cr }
 rbit ibit - next h# FFFF and ;
: +wr ( -d ) ^ 1B ^ set ( wren+wrsr ) h# 1804 2cmd { cr }
 ( hi8 zero ) dup !8 ( ebsy ) h# 1C000 cmd ;
: aaip ( d-d ) ^ 21 ^ h# 2B400 wait !8 ;
: ers ^ 24 ^ +wr ( wren+eras ) h# 1980 2cmd dup select ;
: wp ( hln-d asrc ) ^ 28 ^ +wr ( wren+aaip ) h# 1AB4 2cmd { cr }
 drop push push push set pop !8 pop 8obits { cr }
 !8 ahead begin aaip [ swap ] then @+ 8obits !8 { cr }
 next ( wrdi+dbsy ) h# 1200 wait 2cmd -++ !b rdl- ;
: stash ( d-d ) ^ 3B ^ a push h# 3F a! 16ibits ! pop a! ; ^ 3F ^ }block

( 00356C00 )               D# 1371 shadow{ 
 ( run by an adjacent node through a port. ) { cr }
 24 bit addresses ( are represented in two { 24F } bit words. for continuous
 bit sync, all operations must start on { F } mod { 24F } byte boundaries. )
 { cr }
 [ high ] ( word contains the most significant { 10F } bits of the
 address shifted left { 14F } bits. ) { cr }
 [ low ] ( word contains the least significant { 20F } bits shifted
 left two bits. ) { br }

: wp ( writes ) [ n ] ( words into flash starting at address whose )
 [ high ] ( and ) [ low ] ( parts are given. the data are read from
 wherever ) [ a ] ( points; to feed a stream through a port, ) [ a ]
 ( must be focused to the port before starting. ) { br }

: fet ( starts a read operation )
: 16ibits ( reads one word; take care with ) [ 'd' ] }block

( 00357000 )               D# 1372 code{ 
 { C80F } ( ide via async boot ) [ d# 708 node d# 0 org ]
: obit ( dwn-dw ) ^ 00 ^ !b over push delay ;
: word ( dw-d ) ^ 02 ^ leap drop leap drop leap drop drop ;
: obyt ( dw-dwx ) ^ 06 ^ then then then d# 3 obit drop d# 7 for dup
 d# 1 and d# 3 or obit drop 2/ next d# 2 obit ;
: -out ^ 11 ^ ser-exec ( rdl- ) ; ^ 12 ^ { br }

: ok ^ 12 ^ h# 31416 word -out ;
: fet ^ 15 ^ d# 0
: pump ( n ) for @+ word next -out ;
: stat ^ 1B ^ d# 9 pump ;
: bstk ^ 1D ^ @ push .. @ word pop dup push word .. ( @p+.push ) h# 49BA
 ! d# 7 .. dup push ! .. @p+ ! .. ( /+ ) begin !p+ . . unext .. begin
 @ word .. next .. @p+ ! pop .. ( /+ ) pop @p+ ; .. ! -out ; { cr }
 ^ 2C ^ [ d# 1600 bin ] }block

( 00357400 )               D# 1373 shadow{ 
 }block

( 00357800 )               D# 1374 code{ 
 { C82F } ( ide via sync boot ) [ d# 300 node d# 0 org ]
: 1bit ( wx-w'x ) drop -if d# 3 ahead [ swap ] then d# 2 { cr }
 then !b 2* dup ;
: word ( w ) ^ 06 ^ d# 8 dup for begin drop @b -until 1bit begin drop
 @b - -until 1bit next drop drop ;
: +out ( x ) ^ 0F ^ begin drop @b - -until drop d# 3 !b ;
: -out ( x ) ^ 13 ^ begin drop @b -until { cr }
 drop d# 2 !b d# 1 !b ser-exec ; { br }

: ok ^ 18 ^ dup +out h# 31416 word dup -out ;
: fet ^ 1C ^ d# 0
: pump ( n ) dup +out for @+ word next dup -out ;
: stat ^ 23 ^ d# 9 pump ;
: bstk ^ 25 ^ +out @ dup push . @ word word ( / @p+.push ) h# 49BA
 ! d# 7 . ( / ) dup push ! . ( / ) @p+ ! . . ( /+ ) begin !p+ . . unext
 ( / ) begin @ word ( / ) next ( / ) @p+ ! pop . ( /+ ) pop @p+ ; ( / )
 ! -out ; { cr }
 ^ 34 ^ [ d# 1601 bin ] }block

( 00357C00 )               D# 1375 shadow{ 
 }block

( 00358000 )               D# 1376 code{ 
 { C84F } ( ide wire node ) [ d# 17 node d# 0 org ]
: fet ^ 00 ^ @p+ !b @ . fet !b @b ! ; ^ 03 ^ [ d# 5 org ]
: sto ^ 05 ^ @p+ !b @ . sto !b @ !b ; ^ 08 ^ [ h# A org ]
: ins ^ 0A ^ @p+ !b @ . ins !b ; ^ 0D ^ [ h# D org ]
: psh ^ 0D ^ @p+ !b @ . psh !b ; ^ 10 ^ [ h# 10 org ]
: stk ^ 10 ^ @p+ !b . . stk d# 9 for @b ! unext ; { cr }
 ^ 15 ^ [ d# 1602 bin ] }block

( 00358400 )               D# 1377 shadow{ 
 }block

( 00358800 )               D# 1378 code{ 
 { C86F } ( ide last guy ) [ d# 16 node h# 1E org ]
: focus ( i0 ) ^ 1E ^ @p+ !b !b ; ( / ) focus ; [ d# 0 org ]
: fet ^ 00 ^ @p+ focus ( /+ ) @p+ a! @ !p+ ( / ) @ !b @b @p+ ( /+ )
 ; ( / ) !b ! ;
: sto ^ 05 ^ @p+ focus ( /+ ) @p+ a! . @p+ ( / ) @ !b @ . ( / ) !b
 @p+ !b ; ( /+ ) ! ;
: ins ^ 0A ^ @ focus ; ( / ) ins ins
: psh ^ 0D ^ @p+ focus ( /+ ) @p+ ; ( / ) @ !b ;
: stk ^ 10 ^ @p+ focus ( /+ ) !p+ dup push !p+ ( / ) @b @b ! dup ( / )
 ! ( @p+.push ) h# 49BA !b d# 7 ( / ) dup push !b . ( / ) @p+ !b ( /+ )
 begin !p+ . . unext ( / ) begin @b ! unext . ( / ) @p+ !b !b ; ( /+ )
 pop @p+ ; { cr }
 ( if past size-2 not ok- ) ^ 1C ^ [ d# 1603 bin ] }block

( 00358C00 )               D# 1379 shadow{ 
 }block

( 00359000 )               D# 1380 code{ 
 ( common ) { , }
 [ h# 155 org ] { * }
 ( bomb ) { ... }
      [ h# 145 org ] { * }
: ---u { , }
 [ h# 175 org ] { * }
: --l- { ... }
      [ h# 165 org ] { * }
: --lu { , }
 [ h# 115 org ] { * }
: -d-- { ... }
      [ h# 105 org ] { * }
: -d-u { , }
 [ h# 135 org ] { * }
: -dl- { ... }
      [ h# 125 org ] { * }
: -dlu { , }
 [ h# 1D5 org ] { * }
: r--- { ... }
      [ h# 1C5 org ] { * }
: r--u { , }
 [ h# 1F5 org ] { * }
: r-l- { ... }
      [ h# 1E5 org ] { * }
: r-lu { , }
 [ h# 195 org ] { * }
: rd-- { ... }
      [ h# 185 org ] { * }
: rd-u { , }
 [ h# 1B5 org ] { * }
: rdl- { ... }
      [ h# 1A5 org ] { * }
: rdlu { , }
 }block

( 00359400 )               D# 1381 shadow{ 
 }block

( 00359800 )               D# 1382 code{ 
 ( polynomial approximation )
: poly ( xn-xy ) pop a! push @+ a begin { indent }
      push *. pop a! @+ + a next push ; }block

( 00359C00 )               D# 1383 shadow{ 
: poly ( xn-xy ) { cr }
 ( evaluation of chebyshev polynomials using ) { cr }
 ( the horner scheme. ) { br }

 ( x is the input value. n is the length of ) { cr }
 ( the coefficient table minus 2. coefficient ) { cr }
 ( table follows inline, and execution ) { cr }
 ( continues after the final table entry. x is ) { cr }
 ( left on the stack under the result, y. ) { br }

 ( for example... )
: cos ( f-f' ) { cr }
 ( hart 3300 ) { cr }
 ( -0.0043 0.0794 -0.6459 0.5708 ) { indent }
      2* 2* . triangle dup *. d# 2 poly { indent }
      [ d# -281 , d# 5203 , d# -42329 , d# 37407 , ] { indent }
      push drop pop *. + ; }block

( 0035A000 )               D# 1384 code{ 
 ( interpolate )
: interp ( ims-v ) dup push push over { indent }
      begin 2/ unext a! { indent }
      and push @+ dup @+ - . + - { indent }
      pop a! dup dup or { indent }
      begin +* unext push drop pop . + ; }block

( 0035A400 )               D# 1385 shadow{ 
: interp ( ims-v ) { cr }
 ( to determine values for m and s ... ) { cr }
 ( let l be number of meaningful input bits. ) { cr }
 ( let n be power of 2 where 2**n + 1 is the ) { cr }
 ( number of table entries. ) { br }

 ( s equals l-n-1 ) { cr }
 ( m equals 2** l-n - 1 ) { br }

 ( so for example if you have an 8 bit adc, ) { cr }
 ( l equals 8. let n equal 2 for a 5 entry table. the table is expected
 to be at address 0, ) { cr }
 ( so to represent 0 to 1800 millivolts... ) { br }

 [ 0 org 0 , 450 , 900 , 1350 , 1800 , ] { cr }
: mv ( i-n ) h# 3F 5 interp ; { br }

 [ d# 0 mv ] ( gives ) [ d# 0 ] { cr }
 [ d# 128 mv ] ( gives ) [ d# 900 ] { cr }
 [ d# 256 mv ] ( gives ) [ d# 1800 ] { cr }
 ( and intermediate values are interpolated. ) }block

( 0035A800 )               D# 1386 code{ 
 ( fir or iir filter )
: taps ( yxc-y'x' ) pop a! push begin { indent }
      @+ @ push a push *.17 pop a! { indent }
      push !+ pop . + pop next @ a! ; }block

( 0035AC00 )               D# 1387 shadow{ 
: taps ( yxc-y'x' ) { cr }
 ( for example... ) { br }

: fir ( yx-y'x' ) d# 15 taps [ d# -53 , d# 0 , d# 2276 , d# 0 , d# 382
 , d# 0 , d# -1706 , d# 0 , d# -1158 , d# 0 , d# 2014 , d# 0 , d# 2406
 , d# 0 , d# -1977 , d# 0 , d# -4206 , d# 0 , d# 1289 , d# 0 , d# 6801
 , d# 0 , d# 678 , d# 0 , d# -11109 , d# 0 , d# -6250 , d# 0 , d# 23531
 , d# 0 , d# 54145 , d# 0 , ] { br }

 ( 16 taps, 16 coefficients with intermediate ) { cr }
 ( storage interleaved. ) }block

( 0035B000 )               D# 1388 code{ 
 ( routing; called with 'a relay' )
: relay ( a ) pop a! @+ push @+ zif { indent }
      drop ahead ( done ) [ swap ] then { indent }
      pop over push @p+ ( ' ) a relay ( ' ) { indent }
      !b !b !b begin @+ !b unext
: done then a push a! ; }block

( 0035B400 )               D# 1389 shadow{ 
 ( relay moves a port executable packet down ) { cr }
 ( a sequence of nodes linked by their b ) { cr }
 ( registers. the packet consists of a 1-cell ) { cr }
 ( index, a 1-cell count ) [ less one ] ( of body ) { cr }
 ( size, and the body cells. ) { br }

 ( a packet ) [ may ] ( be started from memory within ) { cr }
 ( a node, or it may simply be fed to a port. ) { br }

 ( relay assumes that b points to the next ) { cr }
 ( node in the chain. uses one return stack ) { cr }
 ( location and four data stack locations. ) { cr }
 ( it must be at the same location in every ) { cr }
 ( node. ) }block

( 0035B800 )               D# 1390 code{ 
 ( multiply )
: *.17 ( a b - a a*b ) a! d# 16 push dup dup or { indent }
      begin +* unext - +* a -if { indent }
      drop - 2* ; then drop 2* - ; }block

( 0035BC00 )               D# 1391 shadow{ 
: *.17 ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. note that the definition of ) *. { cr }
 ( contains a call to this word. ) { br }

 ( 17 bit fractions --- s.i ffff ffff ffff ffff ) }block

( 0035C000 )               D# 1392 code{ 
 ( lshift rshift )
: lsh push begin 2* unext ;
: rsh push begin 2/ unext ; }block

( 0035C400 )               D# 1393 shadow{ 
 }block

( 0035C800 )               D# 1394 code{ 
 ( triangle )
: triangle ( x-y call with; 2* 2* triangle ) { indent }
      h# 10000 over -if drop . + ; then { indent }
      drop - . + - ; }block

( 0035CC00 )               D# 1395 shadow{ 
: triangle ( assuming an angle expressed as a ) { cr }
 ( 16 bit fraction of a revolution, ) { cr }
 [ 2* 2* triangle ] ( produces a triangle wave ) { cr }
 ( approximation to the cosine of that angle. ) }block

( 0035D000 )               D# 1396 code{ 
 ( fractional multiply )
: *. ^ B7 ^ ( f1 f2 - f1 f1*f2 ) *.17 { indent }
      a 2* -if drop - 2* - ; then { indent }
      drop 2* ; }block

( 0035D400 )               D# 1397 shadow{ 
: *. ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. ) { br }

 ( 16 bit fractions --- si. ffff ffff ffff ffff ) }block

( 0035D800 )               D# 1398 code{ 
 ( divide ) { cr }
 [ +cy ] ^ D3 ^ ( enter ea mode )
: clc dup dup or dup . + drop ;
: --u/mod ^ D5 ^ clc
: -u/mod ( hld-rq ) ^ D6 ^ a! d# 17 push begin begin { indent }
      dup . + . push dup . + { indent }
      dup a . + -if { indent }
      drop pop *next dup . + ; then { indent }
      over or or . pop next dup . + ; { cr }
 [ -cy ] ^ E1 ^ ( exit ea mode ) }block

( 0035DC00 )               D# 1399 shadow{ 
: clc ( clears the carry bit for addition in ) { cr }
 ( ea mode. ) { br }

 ( the following defines u/mod in ram ... ) { cr }
: u/mod ( hld-rq ) - d# 1 . + --u/mod ; { br }

 ( if the divisor is a constant, just negate ) { cr }
 ( it at edit or compile time. ) }block

( 0035E000 )               D# 1400 code{ 
 ( f18 compiler ) :# h 17 :# ip 16 :# slot 4 :# call? 24576 :# cal 271554087
 :# com 92 [ macro ]
: !7 h# BD0489 3, h# -4 , < drop > ;
: 2*s ?lit h# E0C1 2, 1, ;
: call ( nn ) < ?dup > h# B8 1, , h# E9 1, [ cal ] @ here d# 3 + -
 + , ; [ forth ]
: swap swap ;
: eras ( nn ) push h# 61FC ( call a9 ) swap block pop ( blks ) fill
 ;
: node's ( -n ) [ com ] @ 2* h# 8000 + ;
: memory ( n-a ) [ h# 240 - ] and node's block + ; { cr }
 [ h# 8000 nnc d# 2 * blks eras ]
: -org ( n ) dup [ h ] ! [ ip ] ! d# 0 [ call? ] ! { * }
: break d# 4 [ slot ] ! ;
: p, ( n ) [ h ] @ memory ! [ h ] @ d# 1 over + over or h# 7F and or
 [ h ] ! ;
: s4 [ h ] @ [ ip ] ! d# 13 2*s dup [ call? ] ! p, d# 1 [ slot ] !
 ;
: s0 d# 13 2*s
: sn dup [ call? ] ! [ ip ] @ memory +! d# 1 [ slot ] +! ;
: s1 d# 8 2*s sn ;
: s2 d# 3 2*s sn ;
: s3 dup d# 3 and drop if d# 7 sn s4 ; then d# 4 / sn ;
: i, [ slot ] @ jump s0 s1 s2 s3 s4 }block

( 0035E400 )               D# 1401 shadow{ 
 ( f18 target compiler ) [ includes support for f18a addressing see
 d# 1404 ]
: h ( address of next available word in target memory here )
: ip ( address of current instruction word )
: slot ( next available instruction slot )
: call? ( was last instruction a call ? )
: call a ( compile a call )
: eras ( fills f18 memory with call 155 number )
: 2*s n ( shift left n bits )
: node's ( target node's starting memory block no. )
: memory n-a ( host address for target memory )
: -org n ( set current target memory location, see ) { ... }
      ( next block for true directive. )
: break ( break in emulator only )
: p, n ( compile pattern into target memory )
: s0-s4 ( assemble opcode into slot 0-3 )
: i, ( assemble opcode into next slot *note** simple code jump table
 using ) [ jump ] }block

( 0035E800 )               D# 1402 code{ 
 ( target )
: cnt 2/ d# -1 + ;
: defer ( -b ) pop ;
: execute ( b ) push ;
: f! ( bn ) [ sp ] + ! ;
: f@ ( n-b ) [ sp ] + @ ;
: class ( b ) [ last d# 1 + ] ! ;
: empty empt
: host d# 0 class [ d# 6 f@ ] nop [ d# 4 f@ ] nop [ d# 13 f@ ] nop
: functions ( bbb ) d# 13 f! d# 4 f! d# 6 f! ;
: . h# 1C i, ; ( nop )
: hhere here ;
: .. [ slot ] @ d# 4 or drop if . .. ; then d# 0 [ call? ] ! ;
: here .. [ h ] @ h# 3FF and ; [ hhere ]
: report ( here ) [ h ] @ [ slot ] @ d# 3 and d# 1024 * or { , }
 d# 32 * [ d# 13 d# 16 + ] + !7 ;
: org ( n ) .. -org ;
: f18 ( b ) d# 1 f@ [ d# 0 + ] functions ;
: +cy here h# 200 over - and or org ;
: -cy here [ h# 200 - ] and org ;
: await [ com ] @ idle [ cal ] @ execute ; }block

( 0035EC00 )               D# 1403 shadow{ 
: defer -a ( byte address of the compiled code that follows -- used
 for forward referencing )
: execute a ( code at this address )
: f! an ( store address of code executed when a word with this function
 is interpreted )
: f@ n-a ( fetch address of function code )
: class a ( store address of code to be executed for each word subsequently
 defined )
: empty ( redefine empty to restore altered functions )
: host ( change context back to colorforth )
: functions aa ( store functions in kernel specific way )
: c18 ( save green word and number functions. set green short-number
 to n, compile to call. target words are executed to assemble instructions )
: . ( nop used to fill instruction words )
: .. ( fills rest of word with nops )
: here -a ( starts new instruction word. leaves target address as number )
: org ( sets compilation address safely. )
: await ( generates call to node's idle ports. ) }block

( 0035F000 )               D# 1404 code{ 
 ( f18 jump instructions )
: 9same ( axa-ax ) push over pop - or [ h# 200 ] and drop ;
: j3 .
: j0 i, [ ip ] @ memory +! break ;
: j1 [ h ] @ 9same if over h# 100 and drop if swap h# FF and swap j0
 ; then then . . j3 ;
: j2 over h# 155 or [ h ] @ or h# 3F8 and drop if . j3 ; then swap
 d# 7 and swap j0 ;
: -adr ( an ) swap h# 155 or swap [ slot ] @ jump j0 j1 j2 j3 j0
: adr ( n-n ) [ slot ] @ d# 3 or drop if i, [ ip ] @ d# 8 * [ h ] @
 [ ip ] @ negate + + d# 8 * [ slot ] @ + break ; then . adr ;
: @h ( n-a ) d# 8 /mod + ;
: -rng -range abort ;
: f3 ( an ) over h# 155 or over @h or h# 2F8 and drop if { , }
 -rng ; then swap d# 7 and swap d# 8 / memory +! ;
: f2 dup @h 9same if over h# 100 and drop if swap h# FF and swap
: f1 d# 8 / memory +! ; then then -rng ;
: then ( n ) here h# 155 or swap d# 8 /mod swap jump f1 f1 f2 f3 }block

( 0035F400 )               D# 1405 shadow{ 
 [ the f18a uses adr bit d# 9 for mode; d# 8 for i/o; d# 7 for rom.
 incrementer maintains bits 0-6, rest are left alone except for return
 and slot d# 0 jumps. ] { br }

: 9same ( is true if the two addresses match in bit 9 - the extended
 arithmetic mode bit. )
: -adr an ( assembles jump to known address )
: adr n-a ( assembles forward jump in slot 0,1,2. value left on stack
 is instr addr * 64 + here-ip + slot. )
: @h ( given that vlue value / 8 returns p at time the jump executes. )
: then a ( insert address for forward jump ) }block

( 0035F800 )               D# 1406 code{ 
 ( complex instructions )
: def defer here < call > ;
: call defer ( a ) d# 3 -adr ; [ call cal ! ]
: ; [ call? ] @ dup h# 6000 or drop if dup h# 300 or drop if dup h# 18
 or drop if d# 0 and i, break ; then then then dup 2/ and negate [ ip ]
 @ memory +! ;
: -if ( -a ) d# 7 adr ;
: if ( -a ) d# 6 adr ;
: -until ( a ) d# 7 -adr ;
: until ( a ) d# 6 -adr ;
: -while ( a-aa ) d# 7 adr swap ;
: while ( a-aa ) d# 6 adr swap ;
: zif ( -a ) d# 5 adr ;
: *next ( aa-a ) swap
: next ( a ) d# 5 -adr ;
: unext ( a ) d# 4 i, drop ;
: n defer d# 8 f@ execute
: lit d# 8 i, h# 3FFFF and ( ok in slot 3 )
: , ( n ) h# 15555 or p, ;
: for h# 1D i,
: begin here ;
: ahead ( -a ) d# 2 adr ;
: end ( a ) d# 2 -adr ;
: leap ( -a ) d# 3 adr ; }block

( 0035FC00 )               D# 1407 shadow{ 
: def -a ( deferred to class. executed for every target definition
 to compile host code that compiles target call )
: call a ( compile target call )
: ; ( will be executed as a target word. the pentium macro has precedence
 while compiling )
: if/-if ( leaves address of jump on stack )
: -until a ( jump if positive to ) begin
: zif ( forward ) next ( decrements r and jumps if r! else pops and
 falls thru )
: next/for
: n ( executed for green short-numbers. all 18-bit target numbers are
 short. executes white short-number to put interpreted number on stack.
 then assembles literal instruction with number in next location. inverted
 for rom )
: , n ( compile number into target memory )
: ?lit -n ( retrieve previously compiled number )
: begin -a ( starts new instruction word. leaves properly formatted
 target address )
: ahead ( compiles fwd ref jump resolve w/then )
: leap ( like ahead but compiles a call ) }block

( 00360000 )               D# 1408 code{ 
 ( instructions )
: target n f18 def class ;
: ex { -cr }
: ;' d# 1 i, break ;
: rx
: @p { -cr }
: @p+ d# 8 i, ;
: @+ d# 9 i, ;
: @b h# A i, ;
: @ h# B i, ;
: !p { -cr }
: !p+ h# C i, ;
: !+ h# D i, ;
: !b h# E i, ;
: ! h# F i, ; }block

( 00360400 )               D# 1409 shadow{ 
 ( words being redefined for the target computer. these host words
 can no longer be executed. although pentium macros take precedence
 during compilation, they will no longer be used. )
: f18 ( instructions )
: 0 ( ; ) ....8 ( @p ) .10 ( +* ) ..18 ( dup )
: 1 ( ex ) ...9 ( @+ ) .11 ( 2* ) ..19 ( pop )
: 2 ( j ) ....a ( @b ) .12 ( 2/ ) ..1a ( over )
: 3 ( call ) .b ( @ ) ..13 ( - ) ...1b ( a )
: 4 ( unext ) c ( !p ) .14 ( + ) ...1c ( . )
: 5 ( next ) .d ( !+ ) .15 ( and ) .1d ( push )
: 6 ( if ) ...e ( !b ) .16 ( or ) ..1e ( b! )
: 7 ( -if ) ..f ( ! ) ..17 ( drop ) 1f ( a! ) }block

( 00360800 )               D# 1410 code{ 
 ( port literals and constants )
: right ( . ) [ h# 1D5 ] lit ; ( 0101111111 register bits )
: down ( .. ) [ h# 115 ] lit ; ( 0110111111 )
: left ( .. ) [ h# 175 ] lit ; ( 0111011111 )
: up ( .... ) [ h# 145 ] lit ; ( 0111101111 )
: io ( .... ) h# 15D lit ; ( 0111110111 )
: ldata ( . ) h# 171 lit ; ( 0111011011 )
: data ( .. ) h# 141 lit ; ( 0111101011 port calls )
: warp ( .. ) [ h# 157 ] lit ; ( 0111111101 )
: center h# 1A5 lit ;
: top h# 1B5 lit ;
: side h# 185 lit ;
: corner h# 195 lit ;
: /mod /mod ;
: spispeed d# 497 ( 0 ) lit ; [ h# 0 ] ( 24-bit adrs ) [ d# 4 * d# 262144
 /mod ] ( al ah ) [ h# 3 ] ( read cmd ) [ d# 256 * + d# 4 * ]
: spicmd ( c.ah ) [ d# 0 + ] lit ;
: spiadr ( al ) [ d# 0 + ] lit ; }block

( 00360C00 )               D# 1411 shadow{ 
 }block

( 00361000 )               D# 1412 code{ 
 ( more instructions )
: +* h# 10 i, ; ( slot 3 ok )
: 2* h# 11 i, ;
: 2/ h# 12 i, ;
: - h# 13 i, ;
: + h# 14 i, ; ( slot 3 ok )
: and h# 15 i, ;
: or h# 16 i, ; ( exclusive-or )
: drop h# 17 i, ;
: dup h# 18 i, ; ( slot 3 ok )
: pop h# 19 i, ;
: over h# 1A i, ;
: a h# 1B i, ;
: push h# 1D i, ;
: b! h# 1E i, ;
: a! h# 1F i, ; }block

( 00361400 )               D# 1413 shadow{ 
: o ( replaces top-of-stack with 0. f18 instructions can't be used
 in macros - forth macros take precedence ) }block

( 00361800 )               D# 1414 code{ 
 }block

( 00361C00 )               D# 1415 shadow{ 
 }block

( 00362000 )               D# 1416 code{ 
 }block

( 00362400 )               D# 1417 shadow{ 
 }block

( 00362800 )               D# 1418 code{ 
 ( math rom anywhere ) [ d# 0 kind ] { br }

 [ h# A1 org ] { cr }
 ^ A1 ^ [ d# 1388 load ] ( relay ) { cr }
 ^ A9 ^ { -cr }
: warm await ; { br }

 [ h# B0 org ] { cr }
 ^ B0 ^ [ d# 1390 load ] ( multiply ) { cr }
 ^ B7 ^ [ d# 1396 load ] ( fractional multiply ) { cr }
 ^ BC ^ [ d# 1386 load ] ( taps ) { cr }
 ^ C4 ^ [ d# 1384 load ] ( interpolate ) { cr }
 ^ CE ^ [ d# 1394 load ] ( triangle ) { cr }
 ^ D3 ^ [ d# 1398 load ] ( -u/mod ) { br }

 [ h# AA org ] { cr }
 ^ AA ^ [ d# 1382 load ] ( polynomial approximation ) { cr }
 ^ B0 ^ }block

( 00362C00 )               D# 1419 shadow{ 
 }block

( 00363000 )               D# 1420 code{ 
 ( serdes boot top/bot ) [ d# 6 kind h# AA reset ] { br }

 [ h# A1 org ] { cr }
 ^ A1 ^ [ d# 1388 load ] ( relay ) { cr }
 ^ A9 ^ { -cr }
: warm await ; { cr }
: cold ^ AA ^ h# 3141 a! h# 3FFFE dup ! rdlu cold ; { br }

 ^ B0 ^ [ d# 1390 load ] ( multiply ) { cr }
 ^ B7 ^ [ d# 1396 load ] ( fractional multiply ) { cr }
 ^ BC ^ [ d# 1386 load ] ( taps ) { cr }
 ^ C4 ^ [ d# 1384 load ] ( interpolate ) { cr }
 ^ CE ^ [ d# 1394 load ] ( triangle ) { cr }
 ^ D3 ^ [ d# 1398 load ] ( -u/mod ) { cr }
 ^ E1 ^ }block

( 00363400 )               D# 1421 shadow{ 
 }block

( 00363800 )               D# 1422 code{ 
 ( sync serial boot side ) [ d# 2 kind h# AA reset ] { cr { 17FF } }
 [ h# BE org ] { -cr }
: sget { cr }
 [ h# A1 org ] { cr }
 ^ A1 ^ [ d# 1388 load ] ( relay ) { cr }
 ^ A9 ^ { -cr }
: warm await ; { cr }
: cold ^ AA ^ h# 31A5 a! @ @b . . -if ( 0pin ) { cr }
 h# 3FD85 ( 'rd-u 3fc00 + ) dup push dup begin { cr }
 drop @b . -if ( /pin ) *next [ swap ] then { cr }
 h# 185 ( 'rd-u ) push drop push ; then
: ser-exec ^ B6 ^ ( x-x ) sget push sget a! sget
: ser-copy ^ B9 ^ push zif ; then { cr }
 begin sget ( push sget pop !+ ) !+ next ;
: sget ^ BE ^ ( -4/3-w ) dup leap leap
: 6in ^ C0 ^ then then leap leap
: 2in ^ C2 ^ then then 2* 2* dup begin { cr }
 . drop @b . - -until - d# 2 and dup begin { cr }
 . drop @b . . -until d# 2 and 2/ or or ; { br }

 ^ CC ^ [ d# 1390 load ] ( multiply ) { cr }
 ^ D3 ^ [ d# 1386 load ] ( taps ) { cr }
 ^ DB ^ [ d# 1394 load ] ( triangle ) { cr }
 ^ E0 ^ }block

( 00363C00 )               D# 1423 shadow{ 
 ( sync serial boot side ) { br }

: ser-exec ( reads and processes a boot frame. )
: ser-copy ( receives ) [ n ] ( words at a, nop if n zero. ) { cr }
: sget ( receives { 24F } bits, first bit on falling clock edge, second
 bit on rising, and so on. ends with clock line high. data line must
 be stable by the time clock edge is seen. spins the whole time, no
 suspension. ) }block

( 00364000 )               D# 1424 code{ 
 ( async serial boot top/bot ) [ d# 1 kind h# AA reset ] { cr { 19FF } }
 [ h# CB org ] { -cr }
: 18ibits { cr }
 [ h# A1 org ] { cr }
 ^ A1 ^ [ d# 1388 load ] ( relay ) { cr }
 ^ A9 ^ { -cr }
: warm await ;
: cold ^ AA ^ h# 31A5 ( 'rdlu ) a! @ @b .. -if
: ser-exec ^ AE ^ ( x-d ) 18ibits drop push . { cr }
 18ibits drop a! . 18ibits
: ser-copy ^ B3 ^ ( xnx-d ) drop push zif ; { cr }
 then begin 18ibits drop !+ next ; { cr }
 then drop h# 1B5 ( 'rdl- ) push push ;
: wait ^ BB ^ ( x-1/1 ) begin . drop @b -until . drop ;
: sync ^ BE ^ ( x-3/2-d ) dup dup wait or - push { cr }
 begin @b . -if . drop *next await ; { cr }
 then . drop pop - 2/ ;
: start ^ C5 ^ ( dw-4/2-dw,io ) { cr }
 dup wait over dup 2/ . + push
: delay ^ C8 ^ ( -1/1-io ) { cr }
 begin @b . -if then . drop next @b ; { br }

 ^ CB ^ [ d# 1426 load ] ( 18ibits ) { cr }
 ^ D9 ^ [ d# 1392 load ] ( lsh rsh ) { cr }
 ^ DD ^ }block

( 00364400 )               D# 1425 shadow{ 
 ( async serial boot. ) { cr }
: cold ( reads { 8F } ports, falls thru if pin high. else assumes a
 focusing call received, simulates its execution as though from warm. )
 { br }

: ser-exec ( reads and processes a boot frame. )
: ser-copy ( receives ) [ n ] ( words at a, nop if n zero. ) { cr }
: delay ( waits one bit time and samples io. enter via jump with )
 [ d ] ( in r. )
: wait ( waits for input pin to be high. )
: start ( waits for rising edge of a normally start bit, delays 1.5
 bit times and samples io. ) { br }

: sync ( waits for rising edge then measures high time, designed to
 be { 4F } bit-time start, followed by falling edge. returns ) [ d ]
 ( for { 2F } bit time. times out after approx { 6F } ms, going warm. )
 }block

( 00364800 )               D# 1426 code{ 
 ( more async serial )
: 18ibits ^ CB ^ ( x-4/6-dwx ) { indent }
      sync sync dup start leap ( 2bits ) leap
: byte ^ D0 ^ then drop start leap
: 4bits ^ D2 ^ then leap
: 2bits ^ D3 ^ then then leap
: 1bit ^ D4 ^ ( nw,io-nw,io ) then { indent }
      push 2/ pop over or { indent }
      h# 20000 and or over push delay ; { cr }
 ^ D9 ^ }block

( 00364C00 )               D# 1427 shadow{ 
 }block

( 00365000 )               D# 1428 code{ 
 ( spi boot top/bot ) [ d# 4 kind h# AA reset host ]
: --- [ h# 2A ] lit ; ( do, ce-, clk )
: --+ [ h# 2B ] lit ;
: +-- [ h# 3A ] lit ;
: +-+ [ h# 3B ] lit ;
: -++ [ h# 2F ] lit ; [ target ] { cr }
 [ h# A1 org d# 1388 load ] ( relay ) { br }

 [ h# C2 org ]
: 8obits ( dw-dw' ) d# 7 for leap ( obit ) 2* *next ;
: ibit ^ C7 ^ ( dw-dw' ) { indent }
      @b . -if drop - 2* ; then drop 2* - ;
: half ^ CA ^ ( dwc-dw ) !b over for . . unext ;
: select ^ CC ^ ( dw-dw ) -++ half --+ half ;
: obit ^ D0 ^ ( dw-dw ) then { indent }
      -if +-- half +-+ half ; then
: rbit ^ D5 ^ ( dw-dw ) --- half --+ half ;
: 18ibits ^ D9 ^ ( d-dw ) dup d# 17 ( for ) push
: ibits begin rbit ibit - next ; { cr }
: u2/ 2/ h# 1FFFF and ; ^ E1 ^ { cr }
 [ h# A9 org ] { cr }
 ^ A9 ^ { -cr }
: warm await ; { cr }
 ^ AA ^ [ d# 1430 load ] ( the rest ) { cr }
 ^ C1 ^ }block

( 00365400 )               D# 1429 shadow{ 
 ( clock management is mode 3, high when idle. ) { , , }
: ibits ( is entered by jump with count already on return stack. no
 rom effect to adding this. ) }block

( 00365800 )               D# 1430 code{ 
 ( more spi )
: cold ^ AA ^ @b - .. [ h# 1B5 ] ( 'rdl- ) -until { indent }
      spispeed spiadr push spicmd
: spi-boot ^ B0 ^ ( dly adrh . adrl - dly x ) { indent }
      select 8obits 8obits { indent }
      drop pop . 8obits 8obits
: spi-exec ^ B6 ^ ( dx-dx ) drop 18ibits { indent }
      h# 1E000 . + [ h# 1B5 ] ( 'rdl- ) -until { indent }
      push 18ibits a! 18ibits
: spi-copy ^ BC ^ ( dn-dx ) push zif ; then begin { indent }
      18ibits ( push 18ibits pop !+ ) !+ next dup ; ^ C1 ^ ( was { 185F } )
 }block

( 00365C00 )               D# 1431 shadow{ 
 ( more spi ) { br }

 ( spi-copy reads one word per loop and the loop counter is the actual
 number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

( 00366000 )               D# 1432 code{ 
 ( analog ) [ d# 0 kind ] { br }

 [ h# A1 org ] { cr }
 ^ A1 ^ [ d# 1388 load ] ( relay ) { cr }
 ^ A9 ^ { -cr }
: warm await ; { br }

 [ h# B0 org ] { cr }
 ^ B0 ^ [ d# 1390 load ] ( multiply ) { cr }
 ^ B7 ^ [ d# 1396 load ] ( fractional multiply ) { cr }
 ^ BC ^ [ d# 1434 load ] ( -dac ) { cr }
 ^ C4 ^ [ d# 1384 load ] ( interpolate ) { cr }
 ^ CE ^ [ d# 1394 load ] ( triangle ) { cr }
 ^ D3 ^ [ d# 1398 load ] ( -u/mod ) { br }

 [ h# AA org ] { cr }
 ^ AA ^ [ d# 1382 load ] ( polynomial approximation ) { cr }
 ^ B0 ^ }block

( 00366400 )               D# 1433 shadow{ 
 }block

( 00366800 )               D# 1434 code{ 
 ( dac )
: -dac ( legacy entry name below )
: dac27 ^ BC ^ ( mcpaw-mcp ) dup push push { indent }
      over pop - . + push push h# 155 { indent }
      pop over or a { indent }
      begin unext !b . { indent }
      begin unext !b !b ; }block

( 00366C00 )               D# 1435 shadow{ 
 }block

( 00367000 )               D# 1436 code{ 
 ( 1-wire ) [ d# 3 kind h# AA org ] { br }

 [ h# 9E org ]
: rcv ( s-sn ) ^ 9E ^ a push dup dup a! d# 17 for begin
: bit ^ A1 ^ @ drop @b -if { indent }
      drop - 2* - *next pop a! ; then { indent }
      drop 2* next pop a! ; ^ A8 ^ { br }

 [ h# A9 org ]
: warm ^ A9 ^ await ;
: cold ^ AA ^ left center a! . io b! { indent }
      dup dup h# B7 ( rest ) dup push push d# 16 push { indent }
      @ drop @b [ h# 185 ] ( side ) -until { indent }
      drop a! . bit ; ^ B7 ^ ( rest ) { indent }
      push rcv a! rcv push zif ; then { indent }
      begin rcv !+ next ; ^ BE ^ { br }

 ^ BE ^ [ d# 1394 load ] ( triangle { AF } ) { cr }
 ^ C3 ^ [ d# 1390 load ] ( multiply *.17 { EF } ) { cr }
 ^ CA ^ [ d# 1396 load ] ( fractional multiply *. { AF } ) { cr }
 ^ CF { AD0F } ^ ( load interpolate interp { 14F } ) { cr }
 ^ CF ^ [ d# 1398 load ] ( -u/mod { 1CF } ) { cr }
 ^ DE ^ ( equals { 13DF } ) }block

( 00367400 )               D# 1437 shadow{ 
 }block

( 00367800 )               D# 1438 code{ 
 ( null rom anywhere ) [ d# 0 kind ] { br }

 [ h# A9 org ] { cr }
: warm ^ A9 ^ await ; }block

( 00367C00 )               D# 1439 shadow{ 
 ( default code for null rom, or for special rom to be loaded out of
 sequence. ) { br }

: warm ( is assumed by crawlers, and is also the destination of the
 call instruction that rom is initialized with. ) [ avoid clobbering
 this word since steven's test code will not work in its absence. tia ]
 }block


( 00368000 )               
