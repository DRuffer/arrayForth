%% LyX 2.0.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[10pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage[dvips]{geometry}
\geometry{verbose,lmargin=2cm,rmargin=2cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}
\usepackage[dvips]{color}
\usepackage{longtable}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{breakurl}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{\texorpdfstring%
  {L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}
  {LyX}}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\usepackage{noweb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\@ifundefined{definecolor}
 {\usepackage{color}}{}
\usepackage[dvips]{graphics}\usepackage{longtable}\usepackage{times}
\usepackage{comment}\usepackage{lastpage}
\usepackage{microtype}\DisableLigatures[-]{}

\usepackage[normalem]{ulem}\newcommand{\suppress}[1]{}\newcommand{\deleted}[1]{\xout{#1}}\newcommand{\revised}[1]{\uline{#1}}\newlength\wvtextpercent\setlength{\wvtextpercent}{0.009\textwidth}

\newbox\strikebox\def\strike#1{\setbox\strikebox \hbox{<#1>}\hbox{\raise0.5ex\hbox to 0pt{\vrule height 0.4pt width \wd\strikebox\hss}\copy\strikebox}}

\cfoot{Page \thepage\ of \pageref{LastPage}}

\makeatother

\begin{document}

\title{\textbf{ColorForth Assembler/Disassembler}}

\maketitle
\begin{longtable}{cc}
\hline 
\multicolumn{1}{c}{\textbf{Version}} & \textbf{Date}\tabularnewline
\multicolumn{1}{c}{0.0.1} & 22 May 2012\tabularnewline
\hline 
\end{longtable}

\tableofcontents{}


\section{\textit{Purpose} }

I took over this program originally from John Rible as an initial
contract with IntellaSys in Oct. 2006, with the purpose to convert
colorForth (\texttt{\textbf{cf}}) source into ASCII text and then
added Albert van der Horst's \texttt{\textbf{ciasdis}} to illuminate
the \texttt{\textbf{cf}} kernel. The goal is to produce a complete
round trip, reproducing the \texttt{\textbf{cf}} file with an ASCII
disassembly (\texttt{\textbf{dsm}}) file that can be used in its own
Literate Programming document. At this stage, the round trip is produced
with the following script:

<<OkadWork>>=
gforth cfasdis.frt -e "cfdis OkadWork bye" > OkadWork.dsm
gforth cfasdis.frt -e "cfas OkadWork bye" 
@

The cfasdis source is an extension of Albert's ciasdis as can be seen
here:

<<cfasdis.frt>>=
<<load-ciasdis>>
<<cfdis.f>>
<<cfas.f>>
<<run-ciasdis>>
@


\section{Color Blindness}

Before I start diving much deeper, I should explain that I am red/green
color blind. This means that I do not see, or react to color like
most people do. 7\% of males have this condition, as well as other
people who do not perceive color the same way as others do. I have
used a program called eyePilot (Version 1.0.12 from Tenebraex) so
I can figure out what colors ColorForth is using, but it has been
withdrawn from the market. So, most recently, I found WhatColor \url{http://www.hikarun.com/e/},
which appears to be supported, at least. I don't always need it, but
frequently, \texttt{\textbf{\textcolor{yellow}{yellow}}} and \texttt{\textbf{\textcolor{green}{green}}}
look far to much alike and on the block I will be using in a few moments,
I see that the green component can have an RGB value of 192 or 255.
I see that the User's manual explains that these are HEX numbers,
but this does not make using colorForth any easier for me.

Additionally, tools that I tend to rely on in my programming, have
not caught up with the use of color in source code. HTML editors are
getting closer, and colorForth even has an HTML listing utility, but
I have not found them good enough yet. Most explicitly, the use of
Literate Programming that I will be using in this documentation can
not be done with color attributes yet. Some day, the rest of us might
catch up with where Chuck wants us to be, but at the moment, I am
not there yet.

Therefore, for the rest of this document, I will be using an ASCII
translation of the syntax used by colorForth. This makes the code
look very similar to ANS Forth, but do not be mistaken, it will not
run in any other version of Forth that I know about. Here is the translation
matrix:

\begin{tabular}{|c|c|}
\hline 
colorForth & ASCII translation\tabularnewline
\hline 
\hline 
\texttt{\textbf{\textcolor{red}{red}}} & \texttt{\textbf{: red}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{white}{white}}} & \texttt{\textbf{( white )}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{green}{green}}} & \texttt{\textbf{: ... green ... ;}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{yellow}{yellow}}} & \texttt{\textbf{{[} yellow {]}}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{magenta}{magenta}}} & \texttt{\textbf{:\# magenta}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{blue}{blue}}} & \texttt{\textbf{\{ blue \}}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{cyan}{cyan}}} & \texttt{\textbf{< cyan >}}\tabularnewline
\hline 
\texttt{\textbf{\textcolor{black}{grey}}} & \texttt{\textbf{\textasciicircum{} grey \textasciicircum{}}}\tabularnewline
\hline 
\end{tabular}

Numbers will be preceded by the base operator that they are in (e.g.
\texttt{\textbf{D\#}} or \texttt{\textbf{H\#}}, but \texttt{\textbf{B\#}}
and \texttt{\textbf{O\#}} can not be translated back).

Notice that cyan and grey doesn't show up properly under the colors
that \LyX{} uses and I pity the person who is reading this with a
black and white ebook reader. The purpose of this exercise is to automate
this process.


\subsection{License}

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the \textquotedbl{}Software\textquotedbl{}),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \textquotedbl{}AS IS\textquotedbl{}, WITHOUT
WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


\subsection{ColoForth disassembler}

Disassembler support for OkadWork.cf the arrayForth for GA144-1.10.

<<cfdis.f>>=
\ Copyright (c) 2012 Dennis Ruffer

<<Restore.f>>

<<endians>>

: ?? ( "name" -- flag )  BL WORD FIND SWAP DROP 0= 0= ;
: uses ( flag -- )  0= IF POSTPONE \ THEN ;

?? CTRL 0= uses : CTRL CHAR 31 AND ;
?? [CTRL] 0= uses : [CTRL] CTRL POSTPONE LITERAL ; IMMEDIATE

?? ForGForth uses ALSO
ASSEMBLER

<<icons>>
<<unpack-words>>
<<word-adjustments>>

: DUMP-NAMES ( a2 a1 -- )   DO  I DUP S" names " CR+$
        @NAME TYPE SPACE  0 CELL+ +LOOP  CR ;
: DIS-NAMES ( a1 a2 -- )   TARGET>HOST SWAP TARGET>HOST
    DUP NEXT-CUT !  DUMP-NAMES ;
: -names ( a n -- )   2>R ['] DIS-NAMES  2R> RANGE ;
' -names RANGE: -names: ( -name- )
: -names- ( a n -- )   -warning >R  NONAME$ -names  R> +warning ;
' DIS-NAMES  ' -names:  ARE-COUPLED

<<transitions>>
<<token-output>>
<<dump-blocks>>

PREVIOUS
@


\subsubsection{Endian handlers}

The following are used to fetch data that is in known Endian format.
 E.g. in file system structures or network packets.  These words work
on un-aligned entities.

<<endians>>=
: SIGN-EXTEND ( x n -- x' )  32 SWAP - DUP >R
    LSHIFT  R> 0 DO  2/  LOOP ;

: @-LE ( a -- x )   4 1C@-LE ;
: !-LE ( x a -- )   4 1C!-LE ;

: W@-BE ( a -- x )   2 1C@-BE ;
: W!-BE ( x a -- )   2 1C!-BE ;
@


\subsubsection{Icon decompiler}

<<icons>>=
: .ICON-ROW ( x -- )   BASE @ >R  2 BASE !  S>D
    <#  16 0 DO  #  LOOP  #>  TYPE  R> BASE ! ;

16 CONSTANT ICON-COLUMNS
24 CONSTANT ICON-ROWS

: |ICON| ( -- n )   ICON-COLUMNS 8 / ICON-ROWS * ;

: IH. ( n -- a n )   0 1 (DH.) TYPE SPACE ;

: DUMP-ICONS ( a2 a1 -- )   DUP S" icons{ " CR+GENERIC  2DUP - |ICON| /
    0 DO  I  ICON-ROWS 0 DO  CR  4 0 DO  DUP I +
                J 0= IF  16 / IH.  ELSE
                    J 1 = IF  16 MOD IH.  ELSE
                        DROP 2 SPACES  THEN  THEN
                OVER |ICON| I * + J 2* + W@-BE .ICON-ROW  SPACE
        LOOP  LOOP  CR  DROP  4 |ICON| * +  4 +LOOP
    2DUP - IF  (DUMP-B)  ELSE  2DROP
    THEN  S" }icons" TYPE CR ;

: DIS-ICONS ( a1 a2 -- )   TARGET>HOST SWAP TARGET>HOST
    DUP NEXT-CUT ! DUMP-ICONS ;
: -icons ( a n -- )   2>R ['] DIS-ICONS 2R> RANGE ;
' -icons RANGE: -icons: ( -name- )
: -icons- ( a n -- )   -warning >R  NONAME$ -icons  R> +warning ;
' DIS-ICONS  ' -icons:  ARE-COUPLED
@


\subsubsection{Unpack words}

Unpack cf word to ascii text

\begin{tabular}{|c|c|c|}
\hline 
bits & prefix & range\tabularnewline
\hline 
\hline 
4 & 0.xxx & 0-7\tabularnewline
\hline 
5 & 10.xxx & 8-15\tabularnewline
\hline 
7 & 11xx.xxx & 16-47\tabularnewline
\hline 
\end{tabular}

<<unpack-words>>=
: UNPACK ( n -- n' chr )   DUP  DUP 0<
    IF       1 LSHIFT DUP 0<
        IF   6 LSHIFT SWAP 25 RSHIFT 63 AND  16 -    \ 11xxxxx.. 16-47
        ELSE 4 LSHIFT SWAP 27 RSHIFT  7 AND  8 XOR   \ 10xxx..    8-15
        THEN
    ELSE     4 LSHIFT SWAP 28 RSHIFT  7 AND          \ 0xxx..     0-7
    THEN ;

: PRESHIFT ( n -- n' )   32 0 DO  [ HEX ]
        DUP F0000000 AND IF
            UNLOOP EXIT
        THEN  2*
    LOOP ;

: s, ( a n -- )   DUP C,  0 ?DO  COUNT C,  LOOP  DROP ;

S"  rtoeanismcylgfwdvpbhxuq0123456789j-k.z/;'!+@*,?"
CREATE cf-ii ( -- adr)   s,  0 cf-ii 1+ C!

: CH ( n -- n' chr )   0FFFFFFF0 AND UNPACK DUP cf-ii COUNT
    ROT < ABORT" invalid character" + C@ ;
DECIMAL

VARIABLE PHERE
: PAD| ( -- )   0 PAD C! ;
: PAD+ ( a n -- )   PAD APPEND ;
: PAD+BL ( -- )   S"  " PAD+ ;
: PADTYPE ( -- )   PAD COUNT TYPE  PAD| ;
: PAD, ( chr -- )   PHERE @ C!  1 PHERE +! ;
: PADDECODE ( n -- )   BEGIN  CH DUP WHILE PAD,  REPEAT  2DROP ;
: PADCOUNT ( n -- adr len )   PAD COUNT + DUP >R PHERE !
    PADDECODE  R> PHERE @ OVER -  DUP PAD C@ + PAD C! ;

: @NAME ( a -- a' n )   @-LE PRESHIFT PAD| PADCOUNT
    ?DUP 0= IF  DROP S" _"  THEN  PAD| ;
@


\subsubsection{Word adjustments}

<<word-adjustments>>=
Files  FILE Words.dbf  FILE= Words.dbf

( Bytes  records   origin             name )
      8      256        0 BLOCK-DATA (WORD-NAMES)
     18      256  +ORIGIN BLOCK-DATA  WORD-NAMES
     10      256  +ORIGIN BLOCK-DATA  ADJUSTMENTS

: /Words ( -- )   Words.dbf  FILE-HANDLE @ 0= IF
        S" Words.dbf" >FILE  THEN
    (WORD-NAMES) INITIALIZE  WORD-NAMES INITIALIZE ;
: /Adjust ( -- )   ADJUSTMENTS INITIALIZE ;

4 ( LINK)
    LONG WORD-ADDR ( Address, used as the key)
 NUMERIC ADJUST    ( Difference from old)
 8 BYTES NAME-STR  ( Name, word name)
CONSTANT |Words|

: .WORD-ADDR ( -- )   BASE @ HEX  WORD-ADDR L@ 8 H.R SPACE  BASE ! ;

: .Word ( n -- )   WORD-NAMES READ  .WORD-ADDR  ADJUST N?
    NAME-STR OVER >R B@  FILE-PAD R> xTYPE  SPACE ;
: .Words ( -- )   CR  (WORD-NAMES) RECORDS ?DO
        I (WORD-NAMES) READ  LINK L@ .Word
        I 4 MOD 0= IF  CR  THEN
    LOOP  CR ;
: .Adjusts ( -- )   ADJUSTMENTS RECORDS ?DO
        CR  I READ  .WORD-ADDR  ADJUST N?
    LOOP ;

: FIND-ADDRESS ( a1 -- flag )   FILE-PAD #TB BLANK
    WORD-ADDR 4 nC!  4 WORD-ADDR -BINARY ;
: add-word ( a1 a2 n -- )   ROT (WORD-NAMES) FIND-ADDRESS IF
        SAVE  WORD-NAMES SLOT DUP READ  WORD-ADDR 4 nC@ WORD-ADDR L!
        RESTORE  DUP LINK 4 nC!  +ORDERED  WORD-NAMES READ
        FILE-PAD DUP #TB BLANK  SWAP MOVE  NAME-STR B!  0 ADJUST N!
    ELSE  ORDERED RELEASE  2DROP \ TYPE 1 ABORT" at duplicate address "
    THEN ;
: add-adjust ( a n -- )   SWAP ADJUSTMENTS FIND-ADDRESS IF
        ADJUST 2 nC!  +ORDERED  ELSE  ORDERED RELEASE
        1 ABORT" Duplicate adjustment "
    THEN ;

: adjust-address ( a -- n )   ADJUSTMENTS FIND-ADDRESS IF
    -1 R# +!  THEN  ORDERED RELEASE  ADJUST N@ ;
Assem

: MAKE-NAME-LABELS ( code names -- )
    2DUP - 0 DO  OVER TARGET>HOST I + @ ?DUP IF
            OVER TARGET>HOST I + @NAME
            Files add-word Assem
    THEN  0 CELL+ +LOOP  2DROP ;

: ADJUST-DELTA ( delta anew aold -- new-delta )
    ROT >R 2DUP - DUP R@ - ?DUP IF
        \ CR  PAD COUNT TYPE  ."  moved " DUP . ." bytes "
        R> 2DROP ROT DROP SWAP OVER
        Files add-adjust Assem
    ELSE  DROP 2DROP R>  THEN ;
: FIND-ADJUSTMENTS ( -- n )   TARGET-START  Files
    /Adjust 0 add-adjust  0 (WORD-NAMES) RECORDS ?DO
        I (WORD-NAMES) READ  LINK L@ WORD-NAMES READ
        WORD-ADDR L@  NAME-STR OVER >R B@  FILE-PAD R> -TRAILING  Assem
        S" X_" PAD PLACE  PAD APPEND  PAD FIND IF
            EXECUTE ADJUST-DELTA
        ELSE  2DROP  Files -1 ADJUST N! Assem  THEN
    LOOP ;

: ADJUST-RANGES   LAB-UPB 1+ 1 ?DO  I MAKE-CURRENT
        'RANGE-START @ Files adjust-address Assem 'RANGE-START +!
        'RANGE-END @ Files adjust-address Assem 'RANGE-END +!
    LOOP ;
: ADJUST-DIRECTIVES   LAB-UPB 1+ 1 ?DO  I LABELS[]
        DUP @ Files adjust-address Assem SWAP +!
    LOOP ;
: ADJUST-COMMENTS   LAB-UPB 1+ 1 ?DO  I LABELS[]
        DUP @ Files adjust-address Assem SWAP +!
    LOOP ;
: ADJUST-EQUS   LAB-UPB 1+ 1 ?DO
        I LABELS[] DUP @ DUP Files adjust-address Assem ?DUP IF
            ROT 2DUP +!  >R SWAP R> CELL+ @ >NFA @
            2DUP $@ INVENTED-NAME? IF
                >R + INVENT-NAME R> PLACE
            ELSE  2DROP DROP  THEN
        ELSE  2DROP  THEN
    LOOP ;

: ADD-LABELS ( -- )   Files  WORD-NAMES RECORDS ?DO
        I READ  ADJUST N@ -1 = IF
            WORD-ADDR L@  NAME-STR OVER >R B@  FILE-PAD R> -TRAILING
            Assem  S" LABEL X_" PAD PLACE  PAD APPEND
            PAD COUNT EVALUATE
        THEN
    LOOP ;
@


\subsubsection{Transitions}

<<transitions>>=
65 CONSTANT TRIM#
VARIABLE #OUT  0 #OUT !
VARIABLE #CRS  1 #CRS !
VARIABLE capext   0 capext !
VARIABLE curcolor   0 curcolor ! \ color of current token

: CRS ( -- )   PADTYPE  #CRS @ ?DUP IF
        ABS 0 DO  CR  LOOP
        #CRS @ 0< IF
            S"      " PAD+
        THEN
    ELSE  PAD+BL  THEN ;
: |CR ( -- )   #CRS @ IF  #OUT @ IF  CR  THEN  THEN  1 #CRS ! ;
: PAD?TYPE ( -- )   PAD C@ #OUT @ + TRIM# > IF  PADTYPE |CR  THEN ;

: TRANSITION ( new -- x )   \ check against multiple transitions
    ( new    <-- )  curcolor @
    OVER 14 <>  OVER 14 =  AND IF  S"  }" PAD+ CRS THEN   \  b -> ~b
    OVER 13 <>  OVER 13 =  AND IF  S"  ^" PAD+     THEN   \  g -> ~g
    OVER  9 <>  OVER  9 =  AND IF  S"  )" PAD+     THEN   \  w -> ~w
    OVER  1 <>  OVER  1 =  AND IF  S"  ]" PAD+     THEN   \  y -> ~y
    OVER  7 <>  OVER  7 =  AND IF  S"  >" PAD+     THEN   \  c -> ~c
    PAD?TYPE
    OVER  7 =   OVER  7 <> AND IF  S"  <" PAD+     THEN   \ ~c ->  c
    OVER  1 =   OVER  1 <> AND IF  S"  [" PAD+     THEN   \ ~y ->  y
    OVER  9 =   OVER  9 <> AND IF  S"  (" PAD+     THEN   \ ~w ->  w
    OVER 13 =   OVER 13 <> AND IF  S"  ^" PAD+     THEN   \ ~g ->  g
    OVER 14 =   OVER 14 <> AND IF  S"  {" PAD+     THEN   \ ~b ->  b
    SWAP curcolor ! ;

: NEWC ( new -- )  ( DUP curcolor @ XOR IF ) TRANSITION ( THEN ) DROP ;
@


\subsubsection{Token output}

<<token-output>>=
: gnn ( a -- a' n )   DUP >R  CELL+  R> @-LE ;
: n32 ( a x -- a' n )   DROP gnn ;
: n27 ( n -- n' )   2/ 2/ 2/ 2/ 2/ ;

HEX
: .NUMBER ( n -- )   DUP 1F AND
    DUP 02 = IF DROP PAD?TYPE S"  D# " PAD+ n32 (.)  PAD+ EXIT THEN \  y: execute 32-bit dec
    DUP 12 = IF DROP PAD?TYPE S"  H# " PAD+ n32 (H.) PAD+ EXIT THEN \ dy: execute 32-bit hex
    DUP 05 = IF DROP PAD?TYPE S"  D# " PAD+ n32 (.)  PAD+ EXIT THEN \  g: compile 32-bit dec
    DUP 15 = IF DROP PAD?TYPE S"  H# " PAD+ n32 (H.) PAD+ EXIT THEN \ dg: compile 32-bit hex
    DUP 06 = IF DROP PAD?TYPE S"  d# " PAD+ n27 (.)  PAD+ EXIT THEN \  g: compile 27-bit dec
    DUP 16 = IF DROP PAD?TYPE S"  h# " PAD+ n27 (H.) PAD+ EXIT THEN \ dg: compile 27-bit hex
    DUP 08 = IF DROP PAD?TYPE S"  d# " PAD+ n27 (.)  PAD+ EXIT THEN \  y: execute 27-bit dec
    DUP 18 = IF DROP PAD?TYPE S"  h# " PAD+ n27 (H.) PAD+ EXIT THEN \ dy: execute 27-bit hex
    DROP ;
DECIMAL

: 1CAP ( addr -- )   DUP C@ [CHAR] a [CHAR] z 1+ WITHIN
    IF  DUP C@ 32 - SWAP C!  ELSE  DROP  THEN ;
: CAPS ( addr len -- )   0 ?DO  DUP 1CAP 1+  LOOP  DROP ;

FALSE CONSTANT SHOW-UNKNOWN

: .WORD ( n -- )   0 capext !  PAD+BL  PADCOUNT 2DROP ;
: .BLUE ( n -- )   0 capext !  PAD+BL  PADCOUNT
    2DUP S" cr" COMPARE 0= IF  1  ELSE
    2DUP S" br" COMPARE 0= IF  2  ELSE
    2DUP S" -cr" COMPARE 0= IF  1  ELSE
    2DUP S" indent" COMPARE 0= IF  -1  ELSE
    2DUP S" ," COMPARE 0= IF  1  ELSE
    2DUP S" *" COMPARE 0= IF  1  ELSE
    OVER C@ [CHAR] . = IF  -1  ELSE
        SHOW-UNKNOWN IF  S"  ^" TYPE 2DUP DUMP  THEN  1
    THEN THEN THEN THEN THEN THEN THEN
    #CRS !  2DROP ;

: .CAPWORD ( n -- )   0 capext !  PADCOUNT DROP 1CAP ;
: .ALLCAPS ( n -- )   -1 capext !  PADCOUNT CAPS ;
: .EXTENSION ( n -- )   PADCOUNT capext @ IF  CAPS  ELSE  2DROP  THEN ;
: .COLONDEF ( -- )   PADTYPE  |CR S" :" PAD+ .WORD ;
: .VARIABLE ( -- )   S"  :#" PAD+ .WORD gnn  PAD+BL  (.) PAD+ ;
: .COMMENT# ( n -- )   S"  { " PAD+  (H.) PAD+  S"  }" PAD+ ;

HEX
: .GREY ( n -- )   PAD+BL  DUP 1F AND
    DUP 1D = IF  DROP  5 RSHIFT 2 (H.R) PAD+  ELSE
    DUP 0D = IF  2DROP  S" c01/1" PAD+  ELSE
        DROP 1 <?> 2 (H.R) PAD+
    THEN THEN ;

: .TOKEN ( n -- )   DUP 0F AND
    DUP  0 = IF DROP         .EXTENSION EXIT THEN \ --- extension word
    DUP  1 = IF DROP  1 NEWC .WORD      EXIT THEN \ yel execute word
    DUP  2 = IF DROP  1 NEWC .NUMBER    EXIT THEN \ yel execute 32-bit
    DUP  3 = IF DROP  3 NEWC .COLONDEF  EXIT THEN \ red define word
    DUP  4 = IF DROP  4 NEWC .WORD      EXIT THEN \ gre compile word
    DUP  5 = IF DROP  4 NEWC .NUMBER    EXIT THEN \ gre compile 32-bit
    DUP  6 = IF DROP  4 NEWC .NUMBER    EXIT THEN \ gre compile 27-bit
    DUP  7 = IF DROP  7 NEWC .WORD      EXIT THEN \ cya compile a macro
    DUP  8 = IF DROP  1 NEWC .NUMBER    EXIT THEN \ yel execute 27-bit
    DUP  9 = IF DROP  9 NEWC .WORD      EXIT THEN \ whi comment word
    DUP 0A = IF DROP  9 NEWC .CAPWORD   EXIT THEN \ whi Capitalized Word
    DUP 0B = IF DROP  9 NEWC .ALLCAPS   EXIT THEN \ whi ALL CAPS WORD
    DUP 0C = IF DROP 0C NEWC .VARIABLE  EXIT THEN \ mag variable + number
    DUP 0D = IF DROP 0D NEWC .GREY      EXIT THEN \ gre compiler feedback
    DUP 0E = IF DROP 0E NEWC .BLUE      EXIT THEN \ blu display word
    DROP         .COMMENT# ;          \ $F commented number
DECIMAL
@


\subsubsection{Dump blocks}

<<dump-blocks>>=
: ABLOCK ( a -- )   DUP 1020 + SWAP  0 curcolor !
    BEGIN  2DUP >  OVER @ 0= 0=  AND WHILE  gnn .TOKEN
    REPEAT  6 NEWC  2DROP ;   \ dummy color to mark end of block

: DUMP-BLOCKS ( a2 a1 -- )   \ display blocks ready to be translated back
    CUT-SIZE @ >R  1024 CUT-SIZE !  BASE @ >R  DECIMAL
    DO  I CODE-SPACE - 1024 /  S" D# " PAD $!  DUP S>D <# #S #> PAD $+!
        1 AND IF  S"  shadow{ "  ELSE  S"  code{ "  THEN  PAD $+!
        I PAD $@ CR+$  CR  PAD|  I ABLOCK  PADTYPE  S"  }block" TYPE  CR
    1024 +LOOP  R> BASE !  R> CUT-SIZE !  CR ;

?? ForGForth uses : GET-TYPE   'TYPE @ ;
?? ForGForth uses : SET-TYPE   'TYPE ! ;

?? ForGForth 0= uses : GET-TYPE   'TYPE >DFA @ ;
?? ForGForth 0= uses : SET-TYPE   'TYPE >DFA ! ;

: TRIM-EMIT ( c -- )   GET-TYPE  'TYPE RESTORED  SWAP
    DUP BL = IF \ #OUT @ TRIM# > IF
            \    CR  SPACE  1 #OUT !
        (    THEN ) BL EMIT  1 #OUT +!  ELSE
        DUP 10 = IF  10 EMIT  0 #OUT !  ELSE
            DUP EMIT  1 #OUT +!
    THEN THEN  DROP  SET-TYPE ;

: TRIM-TYPE ( a n -- )   0 ?DO  COUNT TRIM-EMIT  LOOP  DROP ;

?? ForGForth uses : GET-TRIM   ['] TRIM-TYPE ;
?? ForGForth 0= uses : GET-TRIM   'TRIM-TYPE >DFA @ ;

: DUMP-TRIM-BLOCKS   GET-TRIM SET-TYPE  DUMP-BLOCKS  'TYPE RESTORED ;

: DIS-BLOCKS ( a1 a2 -- )   TARGET>HOST SWAP TARGET>HOST
    DUP NEXT-CUT !  DUMP-TRIM-BLOCKS ;
: -blocks ( a n -- )   2>R ['] DIS-BLOCKS  2R> RANGE ;
' -blocks RANGE: -blocks: ( -name- )
: -blocks- ( a n -- )   -warning >R  NONAME$ -blocks  R> +warning ;
' DIS-BLOCKS  ' -blocks:  ARE-COUPLED
@


\subsection{Restore uncompressed version}

Pulled out of OkadWork.cf blocks

<<Restore.f>>=
\ Copyright (c) 2010 Dennis Ruffer

CREATE cfca 0 , \ address of compressed allocation
CREATE ebx 0 ,
CREATE ecx 0 ,

: 2*d ( n -- n )   DUP 32 ecx @ - RSHIFT  ebx @ ecx @ LSHIFT  + ebx ! ;
: 2*c ( n -- n' )   ecx @ LSHIFT ;

CREATE [na] 26 , \ bits remaining in source word
CREATE [nb] -6 , \ bits remaining in ebx
CREATE [h] 67510272 , \ destination address
CREATE [an] 0 ,
CREATE [aa] 67977026 ,
CREATE [nz] 4 ,

: NEW ( 32-bits in current word )   [aa] @ @ [an] !
    1 CELLS [aa] +!  32 [na] ! ;
: ?NEW ( fetch new word if necessary )   [na] @ 0= IF  NEW  THEN ;
: SHIFT ( n -- n ) ( into ebx, decrement nb )
    DUP NEGATE DUP [nb] +!  [na] +!  ecx !
    [an] @ 2*d 2*c [an] ! ;
: BITS ( n -- ) ( shift bits into ebx. overflow into next word )
    ?NEW DUP NEGATE [na] @ +  DUP 0< IF
        DUP >R + SHIFT NEW R> NEGATE SHIFT
    ELSE  DROP SHIFT  THEN ;

: h, ( n -- ) ( store at destination )   [h] @ !  1 CELLS [h] +! ;
: TBITS ( n n -- ) ( fill ebx with tag )   [nb] @ 8 + ecx !  2*c OR h, ;

: TZ ( n n -- n ? )   OVER [nz] !  DUP NEGATE >R + ebx @
    R> 0 DO  DUP 1 AND IF
            2DROP  UNLOOP  [nz] @ 0 EXIT
        THEN  2/
    LOOP  ebx ! DUP [nz] @ INVERT + INVERT [nb] +!  1 ;

: ?FULL ( n -- n ) ( is there room in ebx? )
    [nb] @ DUP AND DUP 0< IF
        TZ IF  EXIT  THEN
        DUP >R  4 - [nb] +!  TBITS
        0 DUP R> DUP INVERT 29 + [nb] !
    ELSE  DROP  THEN ;

: CHR ( -- n 1 | 0 ) \ examine high bits; shift 4, 5 or 7 bits
    0 ebx ! ( ?NEW )  4 BITS ebx @ 8 AND IF
        ebx @ 4 AND IF
            3 BITS 7 1 EXIT
        THEN  1 BITS 5 1 EXIT
    THEN  4 ebx @ 15 AND IF  1 EXIT
    THEN  DROP 0 ;
: CHRS ( n -- n ) \ shift characters until 0
    CHR IF  ?FULL ecx !  2*c ebx @ OR RECURSE  THEN ;
: WRD ( n -- ) \ shift characters, then tag
    28 [nb] !  DUP CHRS TBITS ;

: t, ( -- )   -4 [nb] !  ebx @ TBITS ;
: SHORT ( n -- ) ( 28-bit value+tag )   28 BITS t, ;
: 32BITS ( -- ) ( for values )   16 BITS  16 BITS  ebx @ h, ;
: LITRAL ( n -- ) \  1-bit base base, tag. value in next word
    0 ebx !  1 BITS t,  32BITS ;
: VAR ( n -- ) ( word, value )   WRD 32BITS ;

: TAG ( -- n 1 | 0 ) \ vector
    ebx @ 15 AND DUP
    DUP  0 = IF  2DROP          0 EXIT  THEN
    DUP  1 = IF   DROP  WRD     1 EXIT  THEN
    DUP  2 = IF   DROP  LITRAL  1 EXIT  THEN
    DUP  3 = IF   DROP  WRD     1 EXIT  THEN
    DUP  4 = IF   DROP  WRD     1 EXIT  THEN
    DUP  5 = IF   DROP  LITRAL  1 EXIT  THEN
    DUP  6 = IF   DROP  SHORT   1 EXIT  THEN
    DUP  7 = IF   DROP  WRD     1 EXIT  THEN
    DUP  8 = IF   DROP  SHORT   1 EXIT  THEN
    DUP  9 = IF   DROP  WRD     1 EXIT  THEN
    DUP 10 = IF   DROP  WRD     1 EXIT  THEN
    DUP 11 = IF   DROP  WRD     1 EXIT  THEN
    DUP 12 = IF   DROP  VAR     1 EXIT  THEN
    DUP 13 = IF   DROP  SHORT   1 EXIT  THEN
    DUP 14 = IF   DROP  WRD     1 EXIT  THEN
    DUP 15 = IF   DROP  SHORT   1 EXIT  THEN ;

: WRDS ( ?new -- ) \ examine tags
    4 BITS TAG IF  RECURSE  THEN ;

: BLOCKS ( blks -- bytes)   1024 * ;
: CFBLOCK ( blk -- addr)   BLOCKS CODE-SPACE + ;
: ERASEBLKS ( b n -- )   >R CFBLOCK R> BLOCKS ERASE ;

: BLOCK-RANGE ( a n n -- ) \ process each block
    OVER CFBLOCK [h] !  DUP >R ERASEBLKS  [aa] !  0 [na] !
    R> 0 DO  WRDS
        [h] @ CODE-SPACE - 1024 + -1024 AND
        CODE-SPACE + [h] !
    LOOP ;

: ns ( -- n )   18 CFBLOCK 1 CELLS + ;    \ compressed if negative
: cfc ( -- n )   CP @ CODE-SPACE - ;      \ size of compressed file
: nblk ( -- n )   18 CFBLOCK 3 CELLS + ;  \ size of uncompressed file

: RESTORE ( -- ) \ restore compressed blocks
    ns @ 0< IF  nblk @ BLOCKS CODE-LENGTH @ > ABORT" Too big!"
        36 CFBLOCK  HERE DUP cfca !  cfc 36 BLOCKS - DUP ALLOT
        MOVE  cfca @ 36 nblk @ OVER - BLOCK-RANGE
        nblk @ BLOCKS CODE-SPACE + CP !
    THEN ;
@


\subsection{ColorForth assembler}

Assembler support for OkadWork.cf the arrayForth for GA144-1.10

<<cfas.f>>=
\ Copyright (c) 2010 Dennis Ruffer

<<stacks>>

?? ForGForth uses ALSO ASSEMBLER

<<icon-assem>>
<<af2cf-support>>
<<get-words+numbers>>

: SETCOLOR ( n _ -- )   CREATE , DOES> @ curcolor ! ;   \ define format words

<<cfcharacters>>
<<cfwords>>
<<a2cf>>
<<cfblocks>>

: D# ( -n- n )   BASE @ DECIMAL  0 0 BL WORD COUNT
    >NUMBER ABORT" Invalid number" 2DROP  SWAP BASE ! ;

PREVIOUS
@


\subsubsection{Stack support}

Stack administration {*} originally from gforth's grey.fs {*} with
GNU v2 license. This implementation does not check overflow.

Creates a stack called word with n cells. The first cell is the stackpointer.

<<stacks>>=
FALSE CONSTANT STACK-DEBUG

: STACK ( n -- )   \ use: n stack word
    CREATE HERE CELL+ , HERE 0 ,
    SWAP CELLS ALLOT
    HERE SWAP ! ;

: STACK-CLEAR? ( stack -- f )   DUP @ [ 1 CELLS ] LITERAL - = ;

: STACK-DUMP ( stack -- )   DUP STACK-CLEAR? 0= IF
        ." > " DUP @ SWAP CELL+
        BEGIN  2DUP - WHILE  CELL+ DUP ?
        REPEAT  2DROP ." < "
    ELSE  DROP  THEN ;

: STACK-PUSH ( n stack -- )   CELL OVER +!
    DUP 2@ < ABORT" stack full"
    DUP -ROT @ !  STACK-DEBUG IF
        CR ." PUSH " DUP STACK-DUMP
    THEN  DROP ;

: STACK-TOP ( stack -- n )   \ returns top of stack
    DUP STACK-CLEAR? ABORT" no items on stack"
    DUP @ @  SWAP STACK-DEBUG IF
        CR ." TOP  " DUP STACK-DUMP
    THEN  DROP ;

: STACK-TOP? ( stack -- n|0 )   \ returns top or 0
    DUP STACK-CLEAR? IF  DROP 0
    ELSE  STACK-TOP  THEN ;

: STACK-POP ( stack -- )   \ discards top stack item
    DUP STACK-CLEAR? ABORT" no items on stack"
    -1 CELLS OVER +!  STACK-DEBUG IF
        CR ." POP  " DUP STACK-DUMP
    THEN  DROP ;

: STACK-PULL ( stack -- n )   DUP STACK-TOP SWAP STACK-POP ;

: STACK-PULL? ( stack -- n|0 )   \ pull top if available
    DUP STACK-CLEAR? IF  DROP 0
    ELSE  STACK-PULL  THEN ;

: STACK-CLEAR ( stack -- )   DUP CELL+ SWAP ! ;
@


\subsubsection{Icon assembler support}

<<icon-assem>>=
VARIABLE #ICONS      \ Number of icons in the array
VARIABLE #ICON-COL   \ Index into array of icons at HERE
VARIABLE #ICON-ROW   \ Scan row within the icons we are assembling

ICON-COLUMNS 8 / CONSTANT |ICON-ROW|
ICON-ROWS 1+ |ICON-ROW| * CONSTANT |ICON-BUFFER|

: >ICON ( i -- a )   |ICON-BUFFER| * HERE 32 + + ;
: >ICON-ROW ( i r -- a )   1+ |ICON-ROW| * SWAP >ICON + ;

: SAVE-ROW ( str len -- )   2 BASE !
    0 0 2SWAP >NUMBER 2DROP DROP
    #ICON-COL @  #ICON-ROW @
    >ICON-ROW W!-BE ;

: SAVE-ICON ( str len -- )   HEX
    0 0 2SWAP >NUMBER 2DROP DROP
    #ICON-COL @ >ICON >R  #ICON-ROW @ IF
        R@ W@-BE  4 LSHIFT +  R> W!-BE  ELSE
        R@ |ICON-BUFFER| ERASE  R> W!-BE  THEN ;

: SAVE-ICONS ( -- )   HEX  #ICONS @ 0 ?DO
        I >ICON DUP W@-BE >R  |ICON-ROW| +
        |ICON-BUFFER| |ICON-ROW| - DUP R> *
        AS-HERE + SWAP MOVE
    LOOP  0 #ICONS ! ;

: NEXT-ICON-ROW ( -- )
    REFILL 0= ABORT" End of input before icons finished"
    #ICON-COL @ IF  #ICON-COL @ #ICONS !  0 #ICON-COL !  1 #ICON-ROW +!
    ELSE  SAVE-ICONS  0 #ICON-COL !  0 #ICON-ROW !
    THEN ;

: icons{ ( -- )   BASE @ >R
    0 #ICONS !  0 #ICON-COL !  0 #ICON-ROW !
    BEGIN
        BEGIN
            BEGIN  #ICON-ROW @ 2 <
            WHILE  BL WORD COUNT  DUP 0=
                WHILE  2DROP  NEXT-ICON-ROW
                REPEAT
                2DUP S" }icons" COMPARE
                IF  SAVE-ICON
                ELSE  2DROP  SAVE-ICONS  R> BASE !  EXIT
                THEN
            THEN
            BL WORD COUNT  DUP 0=
        WHILE  2DROP  NEXT-ICON-ROW
        REPEAT
        2DUP S" }icons" COMPARE
        IF  SAVE-ROW  1 #ICON-COL +!
        ELSE  2DROP  SAVE-ICONS  R> BASE !  EXIT
        THEN
    AGAIN ;
@


\subsubsection{ASCII to colorForth support}

<<af2cf-support>>=
VARIABLE CFEND                    \ address of last colorForth token in block
VARIABLE NBITS                    \ number of bits left in token
VARIABLE WORDLEN  0 WORDLEN !    \ size of current ASCII word name
VARIABLE 1STCAP  TRUE 1STCAP !    \ 1st letter that can be capitalized

20 STACK SAVECOLOR    \ remember colors around extensions and comments

: /BITS ( -- )        \ reset token specific flags
    28 NBITS !  TRUE 1STCAP !
    curcolor CASE
         0 OF  SAVECOLOR STACK-TOP? ?DUP
            IF  curcolor !  THEN  ENDOF
         3 OF  4 curcolor !  ENDOF
        10 OF  9 curcolor !  ENDOF
        11 OF  9 curcolor !  ENDOF
        12 OF  1 curcolor !  ENDOF
    ENDCASE ;

: .CFPTR ( -- )   BASE @ >R  DECIMAL  CR            \ display block location
    CP @ CODE-SPACE -  1024 /MOD 3 .R  4 / 4 .R  SPACE
    R> BASE ! ;

: .AFPTR ( -- )   SOURCE DUP >R TYPE                \ display text location
    CR 27 SPACES  >IN @ DUP R@ - IF  DUP WORDLEN @ + R@ - 1-
        IF  1-  THEN  THEN  R> DROP  WORDLEN @ - SPACES
    WORDLEN @ 0 DO  S" ^" TYPE  LOOP ;
@


\subsubsection{Input words and numbers}

<<get-words+numbers>>=
FALSE CONSTANT TESTING

: ADDN ( n -- )   TESTING IF  DUP CP @ @-LE -    \ add a fully formed token
        IF  .CFPTR  DUP 8 H.R S" <>" TYPE CP @ @-LE 8 H.R SPACE .AFPTR
    THEN  THEN  CP @ !-LE  4 CP +!  /BITS ;

: ADDC ( n -- )   NBITS @ 4 + LSHIFT  curcolor @ ( DUP >R ) +    \ add text token
    ADDN ( ??? R> 0= IF  SAVECOLOR STACK-POP  THEN ) ;

FALSE CONSTANT GETWORD-DEBUG

: GETWORD ( -- str len )    \ get next ASCII word or abort if none left
    BEGIN  BL WORD COUNT  GETWORD-DEBUG IF
            2DUP TYPE SPACE  STACK-DEBUG IF
                SAVECOLOR STACK-DUMP
            THEN
        THEN  DUP WORDLEN !  DUP 0=
    WHILE  2DROP REFILL 0= ABORT" end of input before block finished"
    REPEAT ;

: GETN ( hex -- n )   BASE @ SWAP IF  HEX  ELSE  DECIMAL  THEN
    0 0 GETWORD OVER C@ [CHAR] - = DUP >R   \ get an ASCII number
    IF  1 /STRING  THEN  >NUMBER ROT OR
        IF  .CFPTR  S" Invalid number     " TYPE  .AFPTR
        THEN  DROP R>
    IF  NEGATE  THEN  SWAP BASE ! ;

: LARGEN ( -- color )   curcolor @ 1 = IF  2 EXIT  THEN  5 ;
: SMALLN ( -- color )   curcolor @ 1 = IF  8 EXIT  THEN  6 ;

HEX

: L/S ( hex -- n )   \ format a numeric token, adding prefix token if large
    DUP >R GETN DUP 80000000 = OVER ABS 2* F8000000 AND OR
    IF  LARGEN R> + ADDN EXIT  THEN
    5 LSHIFT SMALLN R> + + ;

DECIMAL
@


\subsubsection{ColorForth character encoding}

<<cfcharacters>>=
HEX

CREATE II-CF   HERE 60 DUP ALLOT  ERASE   \ ASCII to cf translation table

: /II-CF ( -- )   cf-ii COUNT 1
    DO  I 2DUP + C@  DUP [CHAR] a [CHAR] z 1+ WITHIN
        IF  SWAP 40 +  SWAP 20 -  2DUP II-CF + C!        \ lower case alpha
            SWAP 40 +  SWAP 20 -       II-CF + C!        \ upper case alpha
        ELSE                20 -       II-CF + C!        \ non-alpha chars
        THEN
    LOOP  DROP ;

/II-CF   \ fill programatically to reduce maintenance

: CHC ( ascii -- cf )   \ convert ASCII to cf character
    DUP 80 20 WITHIN IF  .CFPTR S" invalid character  " TYPE  .AFPTR  0=
    ELSE  -20 + II-CF + C@  THEN ;

DECIMAL

: HUF ( cf -- cf huf len )   \ convert cf char to huffman, #-bits
    DUP 63 AND
    DUP 16 < IF
        DUP 8 < IF
            4 ( 0xxx 0-7 )
        ELSE  24 XOR 5 ( 10xxx 8-15 )
        THEN
    ELSE  80 + 7 ( 11xxxxx 16-47 )
    THEN ;
@


\subsubsection{ColorForth words}

Chuck's 'trick': since he is shifting the bits left, which fills with
zeros, he allows the packed encoded characters to be larger than 28
bits if the trailing bits are zeros.

The capitalization support is no longer used.

<<cfwords>>=
: SHORTPACK ( n cf huf len -- cf huf' n' len' )   >R ROT R@ NBITS @ >
    IF  OVER DUP  R@ NBITS @ -  DUP >R RSHIFT  R@ LSHIFT XOR ( ??? ) drop 0
        IF  R> DROP  ADDC  0  curcolor @ SAVECOLOR STACK-PUSH  0 curcolor !
        ELSE  SWAP R> R> OVER - >R RSHIFT SWAP  THEN
    THEN  R> ;

: FIRSTCAP ( -- )   \ process 1st capital character
    curcolor @ 9 =  curcolor @ 0= OR NOT
    IF  .CFPTR  S" Cap not in comment " TYPE  .AFPTR  THEN
    curcolor @ IF  10 curcolor !  FALSE 1STCAP !  THEN ;

: ALLCAPS ( -- )   \ process folllowing capital characters
    curcolor @ 10 =  curcolor @ 11 = OR NOT
    IF  .CFPTR  S" Not 1st/all caps   " TYPE  .AFPTR  THEN
    curcolor @ IF  11 curcolor !  THEN ;

: NOTCAP ( -- )   \ process lower case characters
    curcolor @ 11 = IF  .CFPTR  S" Must be all caps   " TYPE  .AFPTR  THEN
    FALSE 1STCAP ! ;

: PACK ( n cf huf len -- n' )   SHORTPACK   \ pack huffman characters
    DUP >R ( len )  LSHIFT + >R ( n )  DUP 128 AND
    IF  1STCAP @ IF  FIRSTCAP  ELSE  ALLCAPS  THEN
    ELSE  DUP 64 AND IF  NOTCAP  THEN
    THEN  DROP R> ( n )  R> ( len ) NEGATE NBITS +! ;

: ADDWORD ( str len -- )   \ add ASCII word to image
    0 -ROT  OVER + SWAP ?DO
        I C@ CHC HUF PACK
    LOOP  ADDC ;

: names ( -- )   0 curcolor !  SAVECOLOR STACK-CLEAR  /BITS
    BEGIN  BL WORD COUNT  DUP WORDLEN !  ?DUP WHILE
            S" _" 2OVER COMPARE 0= IF
                2DROP 0 ADDN  ELSE  ADDWORD  THEN
    REPEAT  DROP ;
@


\subsubsection{Translate ASCII to colorForth}

<<a2cf>>=
FALSE CONSTANT SHOW-#TOKENS

: ENDBLOCK ( -- )   \ finish up the block by filling it with null tokens
    CFEND @ CP @ - 4 /MOD DUP >R 0< OR ABORT" bad pointers"
    SHOW-#TOKENS IF  .CFPTR S" tokens processed ok" TYPE
    THEN  0 curcolor !  R> 1+ 0 DO  0 ADDN  LOOP ;

GET-CURRENT ( * )   WORDLIST DUP CONSTANT AF-VOC   SET-CURRENT

: D# ( _ -- )   BASE @ DECIMAL 0 L/S ADDN BASE ! ;
: H# ( _ -- )   BASE @ HEX    16 L/S ADDN BASE ! ;

: :# ( _name _value -- )   curcolor @ SAVECOLOR STACK-PUSH \ compile a variable
    CP @  12 curcolor !  GETWORD ADDWORD  CP @ SWAP - 4 -
    IF  .CFPTR  S" Var name too long  " TYPE  .AFPTR  THEN
    0 GETN ADDN  SAVECOLOR STACK-PULL curcolor ! ;

: }blocks ( -- ) ;  \ terminate blocks
: }block ( -- )   \ terminate block
    ENDBLOCK  -1 curcolor ! ;

: }   SAVECOLOR STACK-PULL curcolor ! ; \ restore color
: { ( _value -- )   \ compile an error or comment
    curcolor @ SAVECOLOR STACK-PUSH  BASE @  HEX
    0 0 GETWORD 2DUP >R >R  OVER C@ [CHAR] - =
    DUP >R IF  1 /STRING  THEN  >NUMBER ROT OR
    IF  2DROP R> DROP  14 curcolor !  R> R> ADDWORD
    ELSE  DROP R> IF  NEGATE  THEN  ADDN  R> R> 2DROP
    THEN  BASE ! ;

: ^ ( _value -- )   \ compile a display token
    curcolor @ 13 = IF  SAVECOLOR STACK-PULL curcolor ! \ restore color
    ELSE  curcolor @ SAVECOLOR STACK-PUSH  BASE @  HEX
        GETWORD  2DUP S" c01/1" COMPARE 0= IF  2DROP 13  ELSE
            0 0 2SWAP >NUMBER NIP OR ABORT" Invalid display number"
        THEN  13 CURCOLOR !  5 LSHIFT 29 + ADDN  BASE !
    THEN ;

3 SETCOLOR :        \ define
1 SETCOLOR [        \ execute
4 SETCOLOR ]        \ compile
7 SETCOLOR <        \ compile macro
4 SETCOLOR >        \ compile

: )   SAVECOLOR STACK-PULL curcolor ! ;                \ restore color
: (   curcolor @ SAVECOLOR STACK-PUSH  9 curcolor ! ;    \ comment

( * ) SET-CURRENT
@


\subsubsection{ColorForth blocks}

<<cfblocks>>=
: +TOKEN ( str len -- )   \ process ASCII word
    2DUP AF-VOC SEARCH-WORDLIST
    IF  EXECUTE  2DROP  EXIT  THEN
    ADDWORD ;

: CBLOCK ( blk# -- )   \ process ASCII into a block
    CFBLOCK DUP CP !  1020 + CFEND !
    4 curcolor !  SAVECOLOR STACK-CLEAR  /BITS
    BEGIN  curcolor @ 0< NOT  WHILE
        CFEND CP @ > NOT
        IF  .CFPTR  S" Block too long     " TYPE  .AFPTR
            BEGIN  GETWORD S" }block" COMPARE 0=
            UNTIL  -1 curcolor !
        ELSE  GETWORD +TOKEN  THEN
    REPEAT ;

: code{ ( n -- )   DUP 1 AND   \ start code block
    IF  CR  8 SPACES S" Odd code block     " TYPE
        5 WORDLEN !  .AFPTR  THEN
    CBLOCK ;

: shadow{ ( n -- )   DUP 1 AND 0=   \ start shadow block
    IF  CR  8 SPACES S" Even shadow block  " TYPE
        7 WORDLEN !  .AFPTR  THEN
    CBLOCK ;
@


\section{Computer Intelligence Assembler/Disassembler}

Albert van der Horst, of the HCC FIG Holland, wrote \texttt{\textbf{ciasdis}}
between 2000-2008 and released it with a GNU Public License. He wrote
it based on \texttt{\textbf{lina}} 4.0.6 and I extended it to work
with \texttt{\textbf{gforth}} 0.7.9. My documentation will be included
here as Literate Programming, but Albert's overview was:
\begin{quotation}
``From day one the reverse engineering assembler had the property
that disassembly was based on the same tables as assembly, and that
disassembled binaries, could be reassembled to the exact same binary.
This is now complemented by consult files that supply the disassembler
with information to generate a readable and documented source with
label names. Consult files can be built up incrementally.''
\end{quotation}

\subsection{License}
\begin{quote}
This program is free software; you can redistribute it and/or modify
it under the terms of version 2 of the GNU General Public License
as published by the Free Software Foundation. This program is distributed
in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details. You
should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
\end{quote}

\subsection{Main Build}


\subsubsection{Main Load}

Albert wrote this to be used as Linux executables (\texttt{\textbf{cias}}
and \texttt{\textbf{cidis}}), but I use it in Windows 7 in source
form with \texttt{\textbf{gforth}} running under \texttt{\textbf{cygwin}}.
In reality, the two executbles are identical, but the 'd' in the name
triggers the disassembler behavior. For ColorForth, I split this into
2 parts so I could load the ColorForth portions in the middle.

<<ciasdis.frt>>=
<<load-ciasdis>>
<<run-ciasdis>>
@

Load the ciasdis support files:

<<load-ciasdis>>=
( $Id: ciasdis.frt,v 1.26 2009/03/26 19:40:39 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

CR \ Start compile time output on a new line

<<compat.f>>
<<noname>>

[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
    <<GET-FILE>>
    <<PUT-FILE>>
[THEN]
[DEFINED] ForCiForth [IF]
    REQUIRE OLD:    REQUIRE $=    REQUIRE class    REQUIRE W/O
    <<NEW-PRESENT>>
    <<FAR-at>>
[THEN]

\ --------------------------------------------------------------
<<tools.frt>>
include File/pFDatabase/pFDatabase.fth
Files FALSE REVERSE !  BIG-ENDIAN  ONLY FORTH DEFINITIONS
<<asgen.frt>>
<<aswrap.frt>>
<<asi386.frt>>

\ Tools
<<access.frt>>
<<labelas.frt>>
<<labeldis.frt>>
<<crawl.frt>>
@

This second part defines the run time behavior of ciasdis:

<<run-ciasdis>>=
[DEFINED] ForCiForth [IF]
    REQUIRE #-PREFIX    \ In behalf of user.
    REQUIRE ARGC    \ In behalf of building an executable.
[THEN]

<<WRITE-ONE-SECTION>>
<<WRITE-SECTIONS>>
<<OPEN-IT>>
<<CLOSE-IT>>

[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
    <<cf-SOURCE-AS>>
    <<cf-TARGET-AS>>
[THEN]
[DEFINED] ForCiForth [IF]
    <<ci-SOURCE-AS>>
    <<ci-TARGET-AS>>
[THEN]

<<WRITE-IT>>
<<filenames>>
<<PARSE-ASM>>
<<[ASM>>
<<cias>>
<<FETCHED>>
<<FETCH>>

[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
    <<cf-TARGET-DIS>>
[THEN]
[DEFINED] ForCiForth [IF]
    <<ci-TARGET-DIS>>
    REQUIRE DUMP
[THEN]

<<CONSULTED>>
<<CONSULT>>

[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
    <<cfdis>>
[THEN]
[DEFINED] ForCiForth [IF]
    <<cidis>>
[THEN]

<<RESTORE-ALL>>

[DEFINED] ForCiForth [IF]
    <<INTERACTIVE>>
    <<HANDLE-ARG>>
    <<CONTAINS-D?>>
    <<BLOCK-FILE>>
    <<SIGNON>>
    <<MAIN>>
[THEN]
@

Write current section to FILEHANDLE. Leave FILEHANDLE.

<<WRITE-ONE-SECTION>>=
: WRITE-ONE-SECTION ( handle -- handle )
    >R  FILE-OFFSET 0 R@ REPOSITION-FILE THROW
    CODE-SPACE CP @ OVER - R@ WRITE-FILE THROW  R> ;
@

Write all sections to FILEHANDLE. Leave FILEHANDLE.

<<WRITE-SECTIONS>>=
: WRITE-SECTIONS ( handle -- handle )   SECTION-REGISTRY DO-BAG
        I @ TO CURRENT-SECTION  WRITE-ONE-SECTION
    LOOP-BAG ;
@

Open NAME, return FILEHANDLE.

<<OPEN-IT>>=
: OPEN-IT ( a n -- handle )   R/W CREATE-FILE THROW ;
@

Close FILEHANDLE.

<<CLOSE-IT>>=
: CLOSE-IT ( handle -- )   CLOSE-FILE THROW ;
@

Write all sections to file NAME.

<<WRITE-IT>>=
: WRITE-IT ( a n -- )   OPEN-IT  WRITE-SECTIONS  CLOSE-IT ;
@

Handle all the filename extensions.

<<filenames>>=
VARIABLE file.cf    \ colorForth source
VARIABLE file.cfo   \ colorForth source reproduced
VARIABLE file.cul   \ consultant file
VARIABLE file.dsm   \ disassembled output

: make-filename ( aext next a n ahere -- )
    >R  DUP 5 + ALLOT  R@ PLACE  R> APPEND ;
: make-filenames ( a n -- )   HERE DUP >R file.cf !
    DUP 4 + ALLOT  R@ PLACE  R@ COUNT  S" .cf" R> APPEND
    S" .cfo" 2OVER  HERE DUP file.cfo ! make-filename
    S" .cul" 2OVER  HERE DUP file.cul ! make-filename
    S" .dsm" 2SWAP  HERE DUP file.dsm ! make-filename ;
@

Assembler parser.

<<PARSE-ASM>>=
: PARSE-ASM ( -- )
    BEGIN BEGIN  BL WORD DUP C@
            WHILE  FIND IF  EXECUTE
                ELSE  COUNT 2DUP S" ASM]" $= IF  2DROP EXIT
                    THEN  OVER C@ [CHAR] : = IF  1 /STRING
                        KNOWN-LABEL? IF  2DROP
                        ELSE  _AP_ -ROT LABELED
                        THEN
                    ELSE  OVER C@ [CHAR] - = DUP >R IF  1 /STRING
                        THEN  0 0 2SWAP >NUMBER 2DROP DROP  R> IF  NEGATE
                        THEN
                    THEN
                THEN
            REPEAT
        DROP REFILL 0= UNTIL ;
@

Parse assembler until \texttt{\textbf{ASM{]}}}.

<<[ASM>>=
: [ASM ( -- )   BASE @ >R  GET-ORDER
    POSTPONE ONLY POSTPONE FORTH POSTPONE ALSO POSTPONE ASSEMBLER
    SAVE-INPUT  FIRSTPASS  2 0 DO  DEPTH >R  PARSE-ASM  CR  DEPTH R> -
        IF  .S  TRUE ABORT" Stack depth error"  THEN
        I 0= IF  SECONDPASS  RESTORE-INPUT THROW  THEN
    LOOP  SET-ORDER  R> BASE ! ;
@

Perform the action of the program as per the spec's of '\texttt{\textbf{cias}}'.

<<cias>>=
: cias ( -- )   SOURCE-AS INCLUDED  TARGET-AS WRITE-IT ;
@

Fetch file NAME to the code buffer.

<<FETCHED>>=
: FETCHED ( a n -- )   GET-FILE DUP CODE-LENGTH @ > ABORT" Too big!"
    CODE-SPACE SWAP  2DUP + CP !  MOVE ;
@

Fetch file \textquotedbl{}name\textquotedbl{} to the code buffer.

<<FETCH>>=
: FETCH ( -- )   BL WORD COUNT FETCHED ;
@

Using (only) information from file with NAME, disassemble the current
program as stored in the '\texttt{\textbf{CODE-BUFFER}}'.

<<CONSULTED>>=
: CONSULTED ( a n -- )   INIT-ALL  HEX  INCLUDED ( file)  SORT-ALL
    PLUG-HOLES  ALL-L-LABELS  DISASSEMBLE-TARGET  DECIMAL ;
@

Consult \textquotedbl{}file\textquotedbl{} as per '\texttt{\textbf{CONSULT}}'.

<<CONSULT>>=
: CONSULT ( -- )   BL WORD COUNT CONSULTED ;
@

Restore all revectoring done while compiling to stand alone.

<<RESTORE-ALL>>=
: RESTORE-ALL ( -- )   '?ERROR RESTORED  'SECTION RESTORED
    'TYPE RESTORED ;
RESTORE-ALL
@


\subsubsection*{ANS Forth specific}

Return the NAME of the source file.

<<cf-SOURCE-AS>>=
: SOURCE-AS ( -- a n )   BL WORD COUNT ;
@

Return the NAME of the target file.

<<cf-TARGET-AS>>=
: TARGET-AS ( -- a n )   BL WORD COUNT ;
@

Return the NAME of the target file.

<<cf-TARGET-DIS>>=
: TARGET-DIS ( -- a n )   BL WORD COUNT ;
@

Perform the action of the program as per the spec's of '\texttt{\textbf{cidis}}'.

<<cfdis>>=
: cidis ( -- )   BL WORD COUNT FETCHED TARGET-DIS CONSULTED ;
: cfdis ( -- )   BL WORD COUNT make-filenames
    file.cf @ COUNT FETCHED  file.cul @ COUNT CONSULTED ;
: cfas ( -- )   BL WORD COUNT make-filenames
    TESTING IF  file.cf @ COUNT FETCHED  THEN
    file.dsm @ COUNT INCLUDED  file.cfo @ COUNT WRITE-IT ;
@


\subsubsection*{ciForth specific}

Return the NAME of the source file.

<<ci-SOURCE-AS>>=
: SOURCE-AS ( -- a n )   1 ARG[] ;
@

Return the NAME of the target file.

<<ci-TARGET-AS>>=
: TARGET-AS ( -- a n )   2 ARG[] ;
@

Return the NAME of the target file.

<<ci-TARGET-DIS>>=
: TARGET-DIS ( -- a n )   2 ARG[] ;
@

Perform the action of the program as per the spec's of '\texttt{\textbf{cidis}}'.

<<cidis>>=
: cidis ( -- )   1 ARG[] FETCHED TARGET-DIS CONSULTED ;
@

Start an interactive session or a filter. The startup code has changed
'\texttt{\textbf{OK}}' for a filter. In that case suppress the splat
screen. Note that '\texttt{\textbf{QUIT}}' is the command interpreter.

<<INTERACTIVE>>=
: INTERACTIVE    'OK DUP >DFA @ SWAP >PHA = IF 0 LIST OK THEN
    ASSEMBLER   0 ORG   QUIT ;
@

Handle arguments, start interactive system if no arguments. The second
argument is still obligatory for the moment.

<<HANDLE-ARG>>=
: HANDLE-ARG   ARGC 1 = IF INTERACTIVE THEN
    ARGC ( 2) 3 4 WITHIN 0= 13 ?ERROR ;
@

For \texttt{\textbf{STRING:}} \textquotedbl{}It CONTAINS a 'd' or
a 'D' \textquotedbl{}

<<CONTAINS-D?>>=
: CONTAINS-D?    2DUP &D $I >R  &d $I R>  OR ;
@

Fetch the library file from the current directory. We can't assume
\texttt{\textbf{lina}} has been installed so \texttt{\textbf{forth.lab}}
is supplied with the \texttt{\textbf{ciasdis}} program.

<<BLOCK-FILE>>=
"forth.lab" BLOCK-FILE $!
@

Make a cold start silent.

<<SIGNON>>=
'TASK >DFA @   '.SIGNON >DFA !
@

The name determines what to do.

<<MAIN>>=
: MAIN   RESTORE-ALL  DEFAULT-SEGMENT HANDLE-ARG
    0 ARG[] CONTAINS-D? IF cidis ELSE cias THEN ;
@


\subsubsection{Disgraceful adaptations}

Put here to draw attention.

This name might later be changed.

<<noname>>=
: NONAME$ ( -- a n )   s" NONAME" ;
@


\subsubsection*{ANS Forth specific}

<<GET-FILE>>=
: GET-FILE ( a1 n1 -- a2 n2 )
    r/o open-file throw
    dup >r file-size throw
    abort" file too large"
    dup allocate throw
    swap 2dup r@ read-file throw
    over <> abort" could not read whole file"
    r> close-file throw ;
@
<<PUT-FILE>>=
: PUT-FILE ( a1 n1 a2 n2 -- )
    r/w create-file throw
    dup >r write-file throw
    r> close-file throw ;
@


\subsubsection*{ciForth specific}

Patch the word '\texttt{\textbf{PRESENT}}' such that no name words
are no longer considered present. This prevents a zillion error messages.

<<NEW-PRESENT>>=
: NEW-PRESENT   OLD: PRESENT DUP IF DUP >NFA @ $@ NONAME$ $= 0= AND THEN ;
' NEW-PRESENT ' PRESENT 3 CELLS MOVE
@

Patch the word '\texttt{\textbf{L@}}' with the name '\texttt{\textbf{FAR@}}'.
Such that it no longer conflicts with the '\texttt{\textbf{L@}}' we
have.

<<FAR-at>>=
: FAR@ L@ ;    HIDE L@
@


\subsection{Compatibility}

I have created similar compatibility test systems before, but Josh
Grams (\texttt{\textbf{josh@qualdan.com}}) created this one, which
is smaller and covers more systems than I had even envisioned earlier.
He wrote this code to detect forth system and use appropriate prelude,
between 2009 and 2010-03-09. He gifted it to the public domain.  Specifically,
you may use, modify, and redistribute it without limitation, but it
comes with ABSOLUTELY NO WARRANTY.

Currently, it detects the following systems, but he had not tested
\texttt{\textbf{iForth}} or \texttt{\textbf{VFX Forth}} and I have
only tested \texttt{\textbf{gforth}} and \texttt{\textbf{ciforth}}:
\begin{description}
\item [{bigForth}] \url{http://www.jwdt.com/~paysan/bigforth.html}
\end{description}
<<ForBigForth>>=
\ bigforth compat.f -e bye
S" BIGFORTH" ENVIRONMENT? env-str?
    uses CREATE ForBigForth
@

\begin{description}
\item [{ciforth}] \url{http://home.hccnet.nl/a.w.m.van.der.horst/ciforth.html}
\end{description}
<<ForCiForth>>=
\ lina -s compat.f
S" NAME" ENVIRONMENT? S" ciforth" env-str=
    uses CREATE ForCiForth
@

\begin{description}
\item [{FICL}] \url{http://ficl.sourceforge.net}
\end{description}
<<ForFicl>>=
\ ficl compat.f
\ Grrr.  FICL has no way to quit automatically after running a script.
S" ficl-version" ENVIRONMENT? env-str?
    uses CREATE ForFicl
@

\begin{description}
\item [{gforth}] \url{http://www.jwdt.com/~paysan/gforth.html}
\end{description}
<<ForGForth>>=
\ gforth compat.f -e bye
S" gforth" ENVIRONMENT? env-str?
    uses CREATE ForGForth
@

\begin{description}
\item [{iForth}] \url{http://home.iae.nl/users/mhx/i4faq.html}
\end{description}
<<ForIForth>>=
\ ???
S" IFORTH" ENVIRONMENT? env-flag?
     uses CREATE ForIForth
@

\begin{description}
\item [{kForth}] \url{http://ccreweb.org/software/kforth/kforth.html}
\end{description}
<<ForKForth>>=
\ kforth compat.f -e bye
?? NONDEFERRED
    uses CREATE ForKForth
@

\begin{description}
\item [{PFE}] \url{http://pfe.sourceforge.net}
\end{description}
<<ForPfe>>=
\ pfe -q -y compat.f
S" FORTH-NAME" ENVIRONMENT? S" pfe" env-str=
    uses CREATE ForPfe
@

\begin{description}
\item [{pForth}] \url{http://www.softsynth.com/pforth}
\end{description}
<<ForPForth>>=
\ pforth compat.f
?? ::::loadp4th.fth
    uses CREATE ForPForth
@

\begin{description}
\item [{SP-Forth}] \url{http://spf.sourceforge.net}
\end{description}
<<ForSpf4>>=
\ spf4 compat.f BYE
S" FORTH-SYS" ENVIRONMENT? S" SP-FORTH" env-str=
    uses CREATE ForSpf4
        \ REQUIRE CASE-INS lib/ext/caseins.f
@

\begin{description}
\item [{VFX~Forth}] \url{http://www.mpeforth.com}
\end{description}
<<ForVfx>>=
\ ??? vfx include compat.f bye ???
?? VFXFORTH
    uses CREATE ForVfx
@

\begin{description}
\item [{Win32Forth}] \url{http://win32forth.sourceforge.net}
\end{description}
<<ForWin32Forth>>=
\ win32forth include compat.f bye
S" WIN32FORTH" ENVIRONMENT? env-str?
    uses CREATE ForWin32Forth
@

\begin{description}
\item [{SwiftForth}] \url{http://forth.com/swiftforth}
\end{description}
<<ForSwiftForth>>=
\ sf include compat.f bye
?? VERSION DUP uses S" SwiftForth" version over compare 0= AND
    uses CREATE ForSwiftForth
@

Other systems to consider, but most are not standard:
\begin{description}
\item [{4p}] \url{http://maschenwerk.de}
\item [{dsForth}] \url{http://www.delosoft.com}
\item [{FINA}] \url{http://code.google.com/p/fina-forth}
\item [{hForth}] \url{http://www.taygeta.com/hforth.html}
\item [{IsForth}] \url{http://isforth.com}
\item [{NTF/LXF}] \url{http://falth.homelinux.net/readme2.html}
\item [{MinForth}] \url{http://falth.homelinux.net/readme2.html}
\item [{RetroForth}] \url{http://retroforth.org}
\end{description}

\subsubsection{Rationale}

This eventually came to be fairly simple, but it took him several
iterations to get it \textquotedbl{}right\textquotedbl{}, so he published
it in case it may save someone else some work.

A good test must:
\begin{itemize}
\item Reliably detect the current system: some free systems don't provide
a way to test for this, so we have to get creative.
\item Run out of the box on all other systems.  Many useful words aren't
in the CORE wordset and hence aren't provided by even all standard
systems. Also, most so-called standard systems have words which are
implemented in a sub-standard fashion.
\end{itemize}

\subsubsection{Helper Words}

Process the rest of line only if \texttt{\textbf{flag}} is true. \texttt{\textbf{{[}IF{]}
.. {[}THEN{]}}} don't exist everywhere, so we use this conditional
comment word instead.

<<uses>>=
: uses ( flag -- )  0= IF POSTPONE \ THEN ;
@

\texttt{\textbf{{[}DEFINED{]}}} doesn't exist everywhere, and on some
systems the interpreter uses \texttt{\textbf{WORD}}, so \texttt{\textbf{BL
WORD FIND}} doesn't work in the interpreter.

<<??>>=
: ?? ( "name" -- flag )  BL WORD FIND SWAP DROP 0= 0= ;
@

We need a string comparison word, but on ciforth, \texttt{\textbf{COMPARE}}
is not loaded by default.

<<STR=>>=
?? STR= 0= uses : MATCH? >R COUNT ROT COUNT ROT = R> AND ;
?? STR= 0= uses : (STR=) BEGIN DUP 0 > WHILE MATCH? 1- REPEAT 0= ;
?? STR= 0= uses : STR= ROT 2DUP = >R MIN (STR=) >R 2DROP R> R> AND ;
@

Dummy \texttt{\textbf{ENVIRONMENT?}} (since kForth doesn't have it)

<<ENVIRONMENT?>>=
?? ENVIRONMENT? 0= uses : ENVIRONMENT? 2DROP 0 ;
@

The return from \texttt{\textbf{ENVIRONMENT?}} is a bit of a nuisance,
so we have words to deal with various possibilities and return a single
flag.

<<env-words>>=
: env-flag?  DUP IF DROP THEN ;              \ flag true?
: env-str?  DUP IF >R 2DROP R> THEN ;        \ string present?
: env-str=  ROT IF STR= ELSE 2DROP 0 THEN ;  \ string matches?
@


\subsubsection{System Tests}

Originally Josh defined a word to check for the presence of each system.
But Win32Forth doesn't like it if you compile \texttt{\textbf{ENVIRONMENT?}}
into a word (apparently it isn't available in turnkey applications).
 He could have gotten around that by precomputing the values and defining
constants. But then he realized that there was no sense in cluttering
up the dictionary with all those words.  So this version just uses
interpreted tests.  He recommend that your system-specific preludes
define a no-op word named after the Forth system.  Then you can later
do something like this:

\texttt{\textbf{}}
\begin{lstlisting}
[defined] ciforth [if] ... [then]
\end{lstlisting}


One reason {*}for{*} defining a test word for each system was that
ANS CORE doesn't require \texttt{\textbf{S\textquotedbl{}}} to work
in interpretation state.  But the \texttt{\textbf{FILE}} wordset does,
and since this is in a file...  At any rate, all systems which I have
tested have an interpreted \texttt{\textbf{S\textquotedbl{}}}.  If
you add a system which doesn't, you could replace \texttt{\textbf{S\textquotedbl{}}}
with something like:

\begin{lstlisting}
: PAD" ( -- c-addr u )  [CHAR] " WORD  COUNT PAD PLACE  PAD COUNT ;
\end{lstlisting}


Each system has a comment describing how to invoke the system for
testing purposes, the test itself, and the `\texttt{\textbf{uses}}`
line which gives an example of how to include another source file
(some systems are case-sensitive, some only define \texttt{\textbf{INCLUDED}},
and so on).

<<compat.f>>=
<<uses>>
<<??>>
<<STR=>>
<<ENVIRONMENT?>>
<<env-words>>

<<ForBigForth>>
<<ForCiForth>>
<<ForFicl>>
<<ForGForth>>
<<ForIForth>>
<<ForKForth>>
<<ForPfe>>
<<ForPForth>>
<<ForSpf4>>
<<ForVfx>>
<<ForWin32Forth>>
<<ForSwiftForth>>
@


\subsection{Tools}

Those auxiliary thingies that are not appropriate elsewhere.

<<tools.frt>>=
( $Id: tools.frt,v 1.2 2005/01/04 23:23:48 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

: <?> ( n -- )   .S DROP S" <?>" TYPE CR ;    \ a fence post to isolate issues

<<warnings>>
<<display>>

[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
     : NOT ( flag -- flag' )   0= ;

    <<string-primitives>>
    <<H.>>
    <<num-out>>

     : CORA swap over compare ;
     : ETYPE TYPE ;
     : TOGGLE ( a b -- ) over @ xor swap ! ;
     variable exit-code
     0 value _  ' _ to _

    <<BAGS>>
    <<BIN-SEARCH>>
    <<EXCHANGE>>
    <<QSORT>>
[ELSE]
    REQUIRE H.    REQUIRE RESTORED
    <<.NFA>>
[THEN]

<<debug>>
<<QSORT-SAFE>>
<<INVENTED-NAMES>>
<<=<>=>>
<<?ABORT>>

[DEFINED] ForCiForth [IF]
    REQUIRE $=    REQUIRE ."$"
[THEN]
@


\subsubsection{Hide known redefinition warnings}

Note that \texttt{\textbf{-warning}} leaves a value that is consumed
by \texttt{\textbf{+warning}}, so this must be accounted for and all
systems must define something here.

<<warnings>>=
[DEFINED] ForGForth [IF]
: -warning ( - x)   warnings @  0 warnings ! ;
: +warning ( x)   warnings ! ; 
[THEN]

[DEFINED] ForSwiftForth [IF]
: -warning ( -- x)   warning @  0 warning ! ;
: +warning ( x)   warning ! ;
[THEN]

[DEFINED] ForCiForth [IF]
: -warning 0 ; : +warning drop ;
[THEN]
@


\subsubsection{Vectored display}

To enable output to be turned off, or sent to a file.

<<display>>=
CREATE 'TYPE   ' TYPE DUP , ,

-warning
: TYPE ( a n -- )   'TYPE @ EXECUTE ;
+warning

: RESTORED ( a -- )   DUP CELL+ @  SWAP ! ;

<<SHUTUP>>

[DEFINED] ForSwiftForth [IF]  true constant ForDOS  [THEN]
[DEFINED] ForGForth [IF] \ Add missing GForth definitions
s" PWD" getenv drop c@ char \ = [IF]    \ using DOS path separators
     true constant ForDOS [THEN] [THEN]

[DEFINED] ForDOS [IF]
     CREATE <EOL>   2 C, 13 C, 10 C, \ We are assuming DOS line terminators
[ELSE]
     CREATE <EOL>   1 C, 10 C,       \ We are assuming UNIX line terminators
[THEN]

CREATE CHAR-BUF   0 C,

-warning
: CR ( -- )         'TYPE 2@ = IF  CR  ELSE  <EOL> COUNT TYPE  THEN ;
: EMIT ( c -- )     'TYPE 2@ = IF  EMIT  ELSE
         CHAR-BUF C!  CHAR-BUF 1 TYPE  THEN ;
: SPACE ( -- )      'TYPE 2@ = IF  SPACE  ELSE  BL EMIT  THEN ;
: SPACES ( n -- )   'TYPE 2@ = IF  SPACES  ELSE  0 ?DO  SPACE  LOOP  THEN ;
+warning
@

Make the output disappear till the end of the calling word.

<<SHUTUP>>=
: 2DROP'  2DROP ;      \ Need a high level word here.
: (SHUTUP) ( xt -- )   ['] 2DROP' 'TYPE !  EXECUTE  'TYPE RESTORED ;
: SHUTUP ( -name- )   ' POSTPONE LITERAL  POSTPONE (SHUTUP) ; IMMEDIATE
@


\paragraph{ANS Forth specific}

<<num-out>>=
-warning
: C.   S>D <# # #S #> TYPE SPACE ; ( print byte )
: (.)   S>D TUCK DABS <# #S ROT SIGN #> ;
: .   (.) TYPE SPACE ;
: .R   >R (.) R> OVER - 0 MAX SPACES TYPE ;
+warning
@


\subsubsection{String handling}


\paragraph{ANS Forth specific}

<<string-primitives>>=
-warning
: cappend ( char to -- )   DUP >R COUNT + C! R@ C@ 1+ R> C! ;
: append ( from len to -- )   2DUP >R >R  COUNT + SWAP MOVE
    R> R@ C@ + R> C! ;
: place ( from len to -- )   0 OVER C! SWAP 255 MIN SWAP APPEND ;

: @+ ( a -- a' n )   DUP >R CELL+ R> @ ;
: $= ( a1 n1 a2 n2 -- f )   COMPARE 0= ;
: $@ ( a -- a' n )   COUNT ;
: $, ( a n -- a' )   HERE >R  DUP C,  0 ?DO  $@ C,  LOOP  DROP R> ;
: $! ( a n a' -- )   PLACE ;
: $+! ( a n a' -- )   APPEND ;
: $C+ ( c a -- )   CAPPEND ;
+warning
@


\subsubsection{Hex output}


\paragraph{ANS Forth specific}

Print SINGLE in hex.

<<H.>>=
VARIABLE BASE'
: <HEX   BASE @ BASE' ! HEX ;       ( 0/1  SWITCH TO HEX)
: HEX>   BASE' @ BASE !     ;       ( 1/0  AND BACK)

[DEFINED] ForCiForth [IF]
<<4?>>
    : (DH.)   <HEX  <#  1- 0 ?DO  #  I 4?  LOOP  #  #>  HEX> ;
[ELSE]
    : (DH.)   <HEX  <#  1- 0 ?DO  #  LOOP  #  #>  HEX> ;
[THEN]
: (H.R) ( n digits -- a len )   >R S>D R> (DH.) ;
: H.R ( n digits -- )   (H.R) TYPE ;

: (H.) ( n -- a len )   DUP ABS 0  <HEX  <# #S ROT SIGN #>  HEX> ;
: H.   (H.) TYPE SPACE ;
@


\subsubsection*{ciForth specific}

In lina, Albert adds a , after 4 digits.

<<4?>>=
: 4? ( n -- )   1+ 4 MOD 0= IF  [CHAR] , HOLD THEN ;
@


\subsubsection{Bags of stacks}

<<BAGS>>=
<<BUILD-BAG>>
<<BAG>>
<<!BAG>>
<<BAG?>>
<<BAG+!>>
<<BAG@->>
<<BAG-REMOVE>>
<<BAG-HOLE>>
<<BAG-INSERT>>
<<|BAG|>>
<<BAG-LOOP>>
<<.BAG>>
<<BAG-WHERE>>
<<IN-BAG?>>
<<BAG->>
<<SET>>
@

Build a bag (i.e. stack) with X items.

<<BUILD-BAG>>=
: BUILD-BAG ( n -- )   HERE CELL+ , CELLS ALLOT ;
@

Create a bag \textquotedbl{}x\textquotedbl{} with X items.

<<BAG>>=
: BAG ( n -- )   CREATE HERE CELL+ , CELLS ALLOT DOES> ;
@

Make the BAG empty.

<<!BAG>>=
: !BAG ( bag -- )   DUP CELL+ SWAP ! ;
@

For the BAG : it IS non-empty.

<<BAG?>>=
: BAG? ( bag -- )   @+ = 0= ;
@

Push ITEM to the BAG

<<BAG+!>>=
: BAG+! ( x bag -- )   DUP >R @ ! 0 CELL+ R> +! ;
@

From BAG: pop ITEM

<<BAG@->>=
: BAG@- ( bag -- x )   0 CELL+ NEGATE OVER +! @ @ ;
@

Remove entry at ADDRESS from BAG.

<<BAG-REMOVE>>=
: BAG-REMOVE ( a bag -- )
    >R  DUP CELL+ SWAP  OVER R@ @ SWAP - MOVE  -1 CELLS R> +! ;
@

Make hole at ADDRESS in BAG.

<<BAG-HOLE>>=
: BAG-HOLE ( a bag -- )
    >R  DUP CELL+   OVER R@ @ SWAP - MOVE   0 CELL+ R> +! ;
@

Insert VALUE at ADDRESS in BAG.

<<BAG-INSERT>>=
: BAG-INSERT ( x a bag -- )   OVER SWAP BAG-HOLE ! ;
@

For BAG : NUMBER of items.

<<|BAG|>>=
: |BAG| ( bag -- n )   @+ SWAP - 0 CELL+ / ;
@

Loop over a bag, see '\texttt{\textbf{.BAG}}' for an example.

<<BAG-LOOP>>=
: DO-BAG  POSTPONE @+ POSTPONE SWAP POSTPONE ?DO ; IMMEDIATE
: LOOP-BAG 0 CELL+ POSTPONE LITERAL POSTPONE +LOOP ; IMMEDIATE
@

Print BAG.

<<.BAG>>=
: .BAG ( bag -- )   DO-BAG  I ?  LOOP-BAG ;
@

For VALUE and BAG : ADDRESS of value in bag/nill.

<<BAG-WHERE>>=
: BAG-WHERE ( x bag -- a )   DO-BAG  DUP I @ = IF
        DROP I UNLOOP EXIT  THEN
    LOOP-BAG  DROP 0 ;
@

For VALUE and BAG : value IS present in bag.

<<IN-BAG?>>=
: IN-BAG? ( x bag -- )   BAG-WHERE 0= 0= ;
@

Remove VALUE from BAG.

<<BAG->>=
: BAG- ( x bag -- )   DUP >R   BAG-WHERE   R> BAG-REMOVE ;
@

Add/remove VALUE to bag, used as a SET, i.e. no duplicates.

<<SET>>=
: SET+ ( x bag -- )   2DUP IN-BAG? IF 2DROP ELSE BAG+! THEN ;
: SET- ( x bag -- )   2DUP IN-BAG? IF BAG- ELSE 2DROP THEN ;
@


\subsubsection{Bin search}

Uses a comparison routine with execution token 'COMP'. 'COMP' must
have the stack diagram ( IT -- flag) , where flag typically means
that IT compares lower or equal to some fixed value. It may be  TRUE
, FALSE or undefined for `IMIN' , but it must be monotonic down in
the range {[}IMIN,IMAX), i.e. if IMIN<=IX<=IY<IMAX then if IX COMP
gives false, IY COMP cannot give true.

\texttt{\textbf{BIN-SEARCH}} finds the first index 'IT' between 'IMIN'
and 'IMAX' (exclusive) for which 'COMP' returns false or else 'IMAX'.
An empty range is possible, (e.g. 'IMIN' and 'IMAX' are equal).

<<BIN-SEARCH>>=
: BIN-SEARCH ( n IMIN, n IMAX, xt COMP -- n IRES )   >R
    BEGIN       \ Loop variant IMAX - IMIN
        2DUP  <> WHILE
            2DUP + 2/  ( -- ihalf )
            DUP R@ EXECUTE IF
                1+  SWAP ROT DROP \ Replace IMIN
            ELSE
                SWAP DROP \ Replace IMAX
            THEN
    REPEAT
    R> 2DROP ;
@


\subsubsection{Quick sort}

Make QSORT safe by allowing an empty range. Not tested and maybe not
necessary.

<<QSORT-SAFE>>=
\ : QSORT-SAFE 2>R 2DUP < IF 2R> QSORT ELSE 2DROP 2R> 2DROP THEN ;
@


\subsubsection*{ANS Forth specific}

The \texttt{\textbf{QSORT}} facility is part of \texttt{\textbf{lina}},
so it must be added to ANS Forths.

Sort the range FIRST to LAST (inclusive) of item compared by the xt
COMPARING and exchanged by the xt EXHANGING. All indices in this range
must be proper to pass to the xt's. The xt's are filled in into \texttt{\textbf{{*}<}}
and \texttt{\textbf{{*}<-{}->}} and must observe the interface. After
the call we have that : For FIRST<=I<J<=LAST      I J {*}<--> EXECUTE
leaves TRUE.

<<QSORT>>=
( QSORT ) \ AvdH A2apr22

\ Compare item N1 and N2. Return 'N1' IS lower and not equal.
VARIABLE *<
\ Exchange item N1 and N2.
VARIABLE *<-->
<<PARTITION>>
<<(QSORT)>>

: QSORT ( xt1 xt2 -- )   *<--> !  *< !  (QSORT) ;
@

Partition inclusive range LO HI leaving LO\_1 HI\_1 LO\_2 HI\_2.

<<PARTITION>>=
: PARTITION   2DUP + 2/   >R  ( R: median)
    2DUP BEGIN      ( lo_1 hi_2 lo_2 hi_1)
        SWAP BEGIN  DUP R@ *< @ EXECUTE WHILE  1+  REPEAT
        SWAP BEGIN  R@ OVER *< @ EXECUTE WHILE  1-  REPEAT
        2DUP > 0= IF
            \ Do we have a new position for our pivot?
            OVER R@ = IF R> DROP DUP >R ELSE
                DUP  R@ = IF R> DROP OVER >R THEN THEN
            2DUP *<--> @ EXECUTE
            >R 1+ R> 1-
        THEN
    2DUP > UNTIL    ( lo_1 hi_2 lo_2 hi_1)
    R> DROP                            ( R: )
    SWAP ROT ;      ( lo_1 hi_1 lo_2 hi_2)
@

Sort the range LOW to HIGH inclusive observing 'LOW' and 'HIGH' must
be indices compatible with the current values of \texttt{\textbf{{*}<}}
and \texttt{\textbf{{*}<-{}->}}.

<<(QSORT)>>=
: (QSORT)             ( lo hi -- )
    PARTITION         ( lo_1 hi_1 lo_2 hi_2)
    2DUP < IF  RECURSE  ELSE  2DROP  THEN
    2DUP < IF  RECURSE  ELSE  2DROP  THEN ;
@


\subsubsection{Invented names}

Make ADDRESS return some label NAME, static memory so use immediately.

<<INVENT-NAME>>=
: INVENT-NAME   s" L" NAME-BUF $!   0 8 (DH.) NAME-BUF $+! NAME-BUF $@ ;
@

For ADDRESS and NAME: \textquotedbl{}that name WAS invented\textquotedbl{}.

<<INVENTED-NAME?>>=
: INVENTED-NAME? ( a1 a2 n -- flag )  9 <> IF  2DROP 0
    ELSE  SWAP INVENT-NAME CORA 0=  THEN ;
@
<<INVENTED-NAMES>>=
CREATE NAME-BUF   256 ALLOT

<<INVENT-NAME>>
<<INVENTED-NAME?>>

HEX

: TEST-INVENT-NAME
    assert( 42 INVENT-NAME S" L00000042" COMPARE 0= )
    assert( 42 S" L00000043" INVENTED-NAME? 0= )
    assert( 42 S" L00000042" INVENTED-NAME? -1 = )
; TEST-INVENT-NAME

DECIMAL
@


\subsubsection{Miscellaneous}

Debug comments.

<<debug>>=
: \D POSTPONE \ ;
\ : \D ;
@

Missing conditionals.

<<=<>=>>=
[DEFINED] >= 0= [IF] : >= < 0= ; [THEN]
[DEFINED] <= 0= [IF] : <= > 0= ; [THEN]
@

If FLAG is not zero, output STRING on the error channel and exit with
an error code of 2.

<<?ABORT>>=
: ?ABORT ROT IF ETYPE 2 EXIT-CODE ! BYE ELSE 2DROP THEN ;
@


\subsubsection*{ANS Forth specific}

Exchange the content at ADDR1 and ADDR2 over a fixed LENGTH.

<<EXCHANGE>>=
: EXCHANGE ( a1 a2 n -- )   0 ?DO  OVER I +  OVER I +  OVER C@  OVER C@
        >R SWAP C!  R> SWAP C!  LOOP  2DROP ;
@


\subsubsection*{ciForth specific}

Print name of following definition.

<<.NFA>>=
: .^   .S R@ @ >NFA @ $@ TYPE ;
@


\subsection{Reverse Engineering Assembler}

This file '\texttt{\textbf{asgen.frt}}' contains generic tools and
has been used to make assemblers for 8080 8086 80386 Alpha 6809 and
should be usable for Pentium 68000 6502 8051. It should run on ISO
Forth's provided some ciforth facilities are present or emulated.
The assemblers -- with some care -- have the property that the disassembled
code can be assembled to the exact same code.

Most instruction sets follow this basic idea that they contain three
distinct parts:
\begin{enumerate}
\item the opcode that identifies the operation
\item modifiers such as the register working on
\item data, as a bit field in the instruction.
\item data, including addresses or offsets.
\end{enumerate}
This assembler goes through three stages for each instruction:
\begin{enumerate}
\item postit: assembles the opcode with holes for the modifiers. This has
a fixed length. Also posts requirements for commaers.
\item fixup: fill up the holes, either from the beginning or the end of
the post. These can also post required commaers.
\item fixup's with data. It has user supplied data in addition to opcode
bits. Both together fill up bits left by a postit.
\item The commaers. Any user supplied data in addition to opcode, that can
be added as separate bytes. Each has a separate command, where checks
are built in.
\end{enumerate}
Keeping track of this is done by bit arrays, similar to the a.i. blackboard
concept. This is ONLY to notify the user of mistakes, they are NOT
needed for the assembler proper. This setup allows a complete check
of validity of code and complete control over what code is generated.
Even so all checks can be defeated if need be.

The generic tools include:
\begin{itemize}
\item the defining words:\\
for 1 2 3 4 byte postits,\\
for fixups from front and behind\\
for comma-ers.
\item showing a list of possible instructions, for all opcodes or for a
single one.
\item disassembly of a single instruction or a range.
\item hooks for more tools, e.g. print the opcode map as postscript.
\item hooks for prefix instructions
\item hooks for classes of instructions, to be turned off as a whole.
\end{itemize}
To write an assembler, make the tables, generate the complete list
of instructions, assemble it and disassemble it again. If equal, you
have a starting point for confidence in your work.

This code was at some time big-endian dependant and assumed a 32 bit
machine! It is not sure that all traces of this have vanished. You
cannot use this program as a cross-assembler if there are instructions
that don't fit in a hosts cell (i.e. its postit) IT USES THE VOCABULARY
AS A LINKED LIST OF STRUCTS (ciforth)! IT USED KNOWLEDGE OF THE INTERPRETER
AND THE HEADERS! Now if you think that this makes this code non-portable,
think again. You have to change about 8 lines to adapt. Now if you
only have to adapt 8 lines in a 40k lines c-program with the same
functionality, it would smack portable. Wouldn't it?

The blackboard consist of three bit arrays. At the start of an instruction
they are all zero. '\texttt{\textbf{TALLY-BI}}' '\texttt{\textbf{TALLY-BY}}'
'\texttt{\textbf{TALLY-BA}}' keep track of instruction bits, instruction
byte and bad things respectively.

An instructions generally has a single postit that defines the opcode.
It assembles the opcode, advancing '\texttt{\textbf{HERE}}' leaving
zero bits that needs still filling in by fixups. It sets these bits
in '\texttt{\textbf{TALLY-BI}}'. It may also post that commaers are
required by setting a bit in '\texttt{\textbf{TALLY-BY}}'.

Then comes the fixups. They fill up the holes left in the instruction
-- before '\texttt{\textbf{HERE}}' -- by or-ing and maintain '\texttt{\textbf{TALLY-BI}}',
resetting bits. They end in '\texttt{\textbf{|}}' where the other
assembly actions end in '\texttt{\textbf{,}}'. They may require more
commaers, posting to '\texttt{\textbf{TALLY-BY}}'. The commaers advance
'\texttt{\textbf{HERE}}' by a whole number of bytes assembling user
supplied information and reset the corresponding bits in '\texttt{\textbf{TALLY-BY}}'.

All parts of an instruction can add bits to '\texttt{\textbf{TALLY-BA}}'.
If any two consecutive bits are up this is bad. Its bits can never
be reset but '\texttt{\textbf{TALLY-BA}}' is reset as a whole at the
start of an instruction.

An example: load an index register with a 16 bit value, 8080.

\begin{tabular}{|c|c|c|c|c|c|}
\hline 
TALLY-BI & TALLY-BY & TALLY-BA & HERE & 8A43 4 DUMP & \tabularnewline
\hline 
\hline 
0000 & 0000 & 0801 & 8A43 & \texttt{\textbf{.. .. .. ..}} & \texttt{\textbf{LXI,}}\tabularnewline
\hline 
0030 & 0002 & 0002 & 8A44 & \texttt{\textbf{01 .. .. ..}} & \texttt{\textbf{SP|}}\tabularnewline
\hline 
0000 & 0002 & 0002 & 8A44 & \texttt{\textbf{31 .. .. ..}} & \texttt{\textbf{SP0 @ X,}}\tabularnewline
\hline 
0000 & 0000 & 0002 & 8A46 & \texttt{\textbf{31 00 FE ..}} & \texttt{\textbf{HLT,}}\tabularnewline
\hline 
0000 & 0000 & 0000 & 8A47 & \texttt{\textbf{31 00 FE 76}} & \texttt{\textbf{...}}\tabularnewline
\hline 
\end{tabular}

The bit in '\texttt{\textbf{TALLY-BA}}' means a 16 bit operation.
Now if '\texttt{\textbf{TALLY-BA}}' contains 3 it would mean that
it is at the same time an 8 bit and 16 bit operation. Bad!                                                  )

The following problems can be detected:
\begin{itemize}
\item postit when '\texttt{\textbf{TALLY-BI}}' or '\texttt{\textbf{TALLY-BY}}'
contains bits up
\item setting or resetting bits for the second time in '\texttt{\textbf{TALLY-BI}}'
or '\texttt{\textbf{TALLY-BY}}'
\item commaing when '\texttt{\textbf{TALLY-BI}}' still contains bits up
\item setting '\texttt{\textbf{TALLY-BA}}' bad
\end{itemize}
A prefix PostIt has its prefix field filled in with an execution token.
This token represents the action performed on the \texttt{\textbf{TALLY-BA}}
flags, that is used instead of resetting it. This can be used for
example for the OS -- operand size -- prefix in the Pentium. Instead
of putting the information that we are in a 16 bit operand segment
in \texttt{\textbf{TALLY-BA}}, it transforms that information to 32
bit.

<<asgen.frt>>=
( $Id: asgen.frt,v 4.31 2005/03/07 11:54:58 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

<<prelude>>
( ############### PART I ASSEMBLER #################################### )
<<assembler-utilities>>
<<dependant-utilities>>
<<independant-utilities>>
<<assembler-bookkeeping>>
<<assembler-defining-words>>
<<obsolescent>>
<<preferred>>
<<end-preferred>>
<<super-defining-words>>
( ############### PART II DISASSEMBLER ################################ )
<<structures>>
<<tryers>>
<<disassemblers>>
<<defining-words>>
<<conveniences>>
PREVIOUS 
@


\subsubsection{Prelude}

Wrapper for asgen, when we want to test without label mechanisms.
These are hot patched for reverse engineering.

<<prelude>>=
[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
    : (?ERROR) ( f n -- )   swap if throw else drop then ;
    CREATE '?ERROR   ' (?ERROR) DUP , ,   : ?ERROR '?ERROR @ EXECUTE ;
    
    -warning
    : ?CSP ( -- ) ; \ check stack
    : !CSP ( -- ) ; \ set stack check
    +warning
    : ?EXEC ( -- ) ;
    : asm-create ( -- )   create ;
[THEN]
[DEFINED] ForCiForth [IF]
    : asm-create ( -- )   (WORD) (CREATE) ;
    REQUIRE ALIAS
    REQUIRE @+ ( Fetch from ADDRES. Leave incremented ADDRESS and DATA )
    REQUIRE BAG
    REQUIRE POSTFIX
[THEN]

\ Vectors that are hot-patched in aswrap.frt
CREATE 'AS-ALLOT   ' ALLOT DUP , ,   : AS-ALLOT 'AS-ALLOT @ EXECUTE ;
CREATE 'AS-HERE    ' HERE DUP , ,    : AS-HERE 'AS-HERE @ EXECUTE ;
CREATE 'AS-C,      ' C, DUP , ,      : AS-C, 'AS-C, @ EXECUTE ;
CREATE '_AP_       ' HERE DUP , ,    : _AP_ '_AP_ @ EXECUTE ;

: (-ADORN-ADDRESS) DROP CR ;   ( Action between two disassembled instr.    )

CREATE 'ADORN-ADDRESS   ' (-ADORN-ADDRESS) DUP , ,
: ADORN-ADDRESS ( a -- )   'ADORN-ADDRESS @ EXECUTE ;
@


\subsubsection{Maybe not present utilities}

<<assembler-utilities>>=
<<!+>>
<<@->>
<<CTRL>>
<<TABLE1>>
<<ROTLEFT>>

[DEFINED] ForCiForth [IF]
    'TABLE1 HIDDEN
[THEN]
@

Store DATA to ADDRES. Leave incremented ADDRESS

<<!+>>=
: !+ ( x a -- a' )   >R R@ ! R> CELL+ ;
@

Fetch from decremented ADDRES. Leave DATA and ADDRESS

<<@->>=
: @- ( a -- x a' )   0 CELL+ - >R R@ @ R>  ;
@
<<CTRL>>=
-warning
: CTRL CHAR 31 AND ;
: [CTRL] CTRL POSTPONE LITERAL ; IMMEDIATE
+warning
@

\texttt{\textbf{x TABLE1 + @}} yields \$100\textasciicircum{}{[}-x
mod 4{]}

<<TABLE1>>=
CREATE TABLE1   1 , 1 ,
@

Rotate X by I bytes left leaving X' Left i.e. such as it appears in
memory! Not as printed on a big endian machine! aqa \textquotedbl{}\texttt{\textbf{8
{*} LSHIFT}}\textquotedbl{} on bigendian.

<<ROTLEFT>>=
: ROTLEFT ( x n -- x' )   TABLE1 + @ UM* OR ;
@


\subsubsection{System dependant utilities}

Common fields in the defining words for posits fixups and commaers.
All leave a single ADDRESS. The first data field for a postit/fixup
contains instruction bits, for a commaer it contains the xt of the
comma action for a data fixup it contains the position of the bits.

<<dependant-utilities>>=
: %>BODY ; ( From DEA to the DATA field of a created word, now the same )
: %BODY> ; ( Reverse of above)

: DEA-FIELD ( u size -- u' )   CREATE  OVER , +
    DOES> ( dea -- a )   @ SWAP %>BODY + ;

0
  1 CELLS DEA-FIELD >LFA    ( link to previous word for compatibility   )
  1 CELLS DEA-FIELD >NFA    ( variable length name field is at the end  )
  1 CELLS DEA-FIELD >DATA

( Work on TALLY-BI etc.        Effects  for posits fixups and commaers. )
(                                            |||    |||       |||       )
  1 CELLS DEA-FIELD >BI                    ( OR!    AND!      --        )
  1 CELLS DEA-FIELD >BY                    ( OR!    OR!       AND!      )
  1 CELLS DEA-FIELD >BA                    ( OR!U   OR!U      OR!U      )
  1 CELLS DEA-FIELD >CNT    ( `HERE' advances with count )
  0 CELLS DEA-FIELD >DIS    ( disassembler only for COMMA , 0 -> default)
  1 CELLS DEA-FIELD >PRF    ( prefix flag, only for PI ,    0 -> default)
  1 CELLS DEA-FIELD >DFA    ( type of word, replacing the DOES> check   )
CONSTANT |DEA| ( the name is tacked onto the end when it is created     )

<<ID.>>

-warning
VOCABULARY ASSEMBLER IMMEDIATE
+warning

: Assem   ONLY FORTH ALSO POSTPONE ASSEMBLER ALSO DEFINITIONS ; IMMEDIATE

Assem HEX

[DEFINED] ForCiForth [IF]
    <<'alias>>
[THEN]

<<DOES>>
<<IGNORE?>>
<<VOCEND?>>
<<NEXT>>
<<STARTVOC>>
<<IS-A>>
<<MEMBER>>
<<?ERROR->>
<<CREATE-->>
@

Print a definition's name from its DEA.

<<ID.>>=
: %ID. >NFA @ $@ TYPE SPACE ;
@

From DEA to the \texttt{\textbf{DOES>}} pointer for a '\texttt{\textbf{DOES>}}'
word

<<DOES>>=
: %>DOES ( dea -- x ) >DFA ;
@

Leave for DEA : it is to be ignored in disassemblies. This is used
for supressing the bare bones of the sib mechanism in i586.

<<IGNORE?>>=
: IGNORE? >NFA @ CHAR+ C@ [CHAR] ~ = ;
@

Given a DEA, return the next DEA. For a DEA as returned from \texttt{\textbf{(>NEXT\%)}}
: it is the end, not a real DEA.

<<VOCEND?>>=
: VOCEND? ( dea -- f )   >LFA @ 0= ;
@

As \texttt{\textbf{(>NEXT\%)}} but skip holes, i.e. words with names
starting in '\texttt{\textbf{-}}'.

<<NEXT>>=
: (>NEXT%) ( dea -- dea )   >LFA @ ;
: >NEXT% ( dea -- dea' )   BEGIN  (>NEXT%) DUP >NFA @ CHAR+ C@
    [CHAR] - - UNTIL ;
@

Leave the first DEA of the assembler vocabulary.

<<STARTVOC>>=
0 VALUE STARTVOC ( -- dea )
@

Build: allocate place to remember a \texttt{\textbf{DOES>}} address
of a '\texttt{\textbf{CREATE}}'d word. Leave that ADDRESS to be filled
in by '\texttt{\textbf{REMEMBER}}' Execution: Leave for DEA : it is
of same type as the remembered \texttt{\textbf{DOES>}}.

<<IS-A>>=
VARIABLE 'IS-A   1 'IS-A !
: IS-A ( -- )   CREATE  'IS-A @ ,  DOES> ( dea -- f ) @ SWAP %>DOES @ = ;
@

Patch up the data field of a preceeding word defined by '\texttt{\textbf{IS-A}}'.
To be called when sitting at the \texttt{\textbf{DOES>}} address.
The \texttt{\textbf{!CSP}} / \texttt{\textbf{?CSP}} detects stack
changes. Now split it into 2 checks.

<<MEMBER>>=
: MEMBER ( n -- )   STARTVOC >DFA ! ;
: REMEMBER ( -- )   ?CSP  'IS-A @ POSTPONE LITERAL  POSTPONE MEMBER
    1 'IS-A +!  !CSP ; IMMEDIATE
@

Also needed : ?ERROR that defeats all checks.

<<?ERROR->>=
\ : ?ERROR DROP DROP ;
@

Behaves as 'CREATE' except, if the word to be created has name \textquotedbl{}--\textquotedbl{}
it is ignored, by making the header unfindable. Not strictly needed.

<<CREATE-->>=
: CREATE--   SAVE-INPUT  BL WORD $@ $, >R  RESTORE-INPUT THROW
    R> DUP $@ S" --" COMPARE 0= IF  -warning CREATE +warning
    ELSE  CREATE  THEN  HERE DUP >R  |DEA| DUP ALLOT  ERASE
    R@ >NFA !  STARTVOC R@ >LFA !  R> TO STARTVOC ;
@


\subsubsection*{ciForth specific}

Make an alias for \textquotedbl{}\texttt{\textbf{'}}\textquotedbl{}
in the minimum search order called \textquotedbl{}\texttt{\textbf{\%}}\textquotedbl{}.

<<'alias>>=
'ONLY >WID CURRENT !    \ Making ONLY the CONTEXT is dangerous! This will do.
"'" 'ONLY >WID (FIND)   ALIAS %         ( "'" ) 2DROP
CONTEXT @ CURRENT !     \ Restore current.
@


\subsubsection{System independant utilities}

Note that the assembler works with multi-character bigendian numbers.

<<independant-utilities>>=
<<CONTAINED-IN>>
<<lsbyte,>>
<<lsbyte-at>>
<<lsbytes>>
<<MCat>>
<<MC<0>>
<<MC@-S>>
@

The FIRST bitset is contained in the SECOND one, leaving it IS.

<<CONTAINED-IN>>=
: CONTAINED-IN OVER AND = ;
@

Compile the ls 8 bits of X at here, leaving the REMAINING bits.

<<lsbyte,>>=
: lsbyte, DUP AS-C, 0008 RSHIFT ;
@

For X and ADDRESS , add the byte below address to x at l.s. place.
Leave X and decremented ADDRESS.

<<lsbyte-at>>=
: lsbyte@ 1- SWAP 8 LSHIFT OVER C@ OR SWAP ;
@

For X ADDRESS LENGTH , return the NUMBER that at address (bigendian).
x provides a filler, -1 results in sign extension.

<<lsbytes>>=
: lsbytes  >R R@ + BEGIN R> DUP WHILE 1- >R  lsbyte@ REPEAT 2DROP ;
@

For ADDRESS LENGTH , return the NUMBER that is there (bigendian).
\textquotedbl{}Multiple byte fetch\textquotedbl{}.

<<MCat>>=
: MC@ 0 ROT ROT lsbytes ;
@

For ADDRESS LENGTH , return the \textquotedbl{}number there IS negative\textquotedbl{}.

<<MC<0>>=
: MC<0 + 1- C@ 80 AND 80 = ;
@

For ADDRESS LENGTH , return the NUMBER that is there. bigendian and
signextended. \textquotedbl{}Multiple byte fetch, signed\textquotedbl{}.

<<MC@-S>>=
: MC@-S 2DUP MC<0 ROT ROT lsbytes ;
@


\subsubsection{Assembler bookkeeping}

The bookkeeping is needed for error detection and disassembly.

<<assembler-bookkeeping>>=
<<TALLY-BI>>
<<TALLY-BY>>
<<TALLY-BA>>
<<BA-DEFAULT>>
<<OLDCOMMA>>
<<ISS>>
<<ISL>>
<<BA-XT>>
<<RESET-BAD>>
<<!TALLY>>
<<AT-REST?>>
<<BADPAIRS?>>
<<CONSISTENT?>>
DECIMAL
<<CHECK26>>
<<CHECK32>>
<<CHECK31>>
<<CHECK31A>>
<<CHECK32B>>
<<CHECK33>>
<<CHECK28>>
<<CHECK29>>
<<CHECK30>>
HEX
<<OR!>>
<<AND!>>
@

Bits that need to be fixed up.

<<TALLY-BI>>=
VARIABLE TALLY-BI
@

Bits represent a commaer that is to be supplied.

<<TALLY-BY>>=
VARIABLE TALLY-BY
@

State bits, bad if two consequitive bits are up.

<<TALLY-BA>>=
VARIABLE TALLY-BA
@

Bits set in the default can be used to exclude certain classes of
instructions, e.g. because they are not implemented.

<<BA-DEFAULT>>=
VARIABLE BA-DEFAULT    0 BA-DEFAULT !
@

Previous comma, or zero.

<<OLDCOMMA>>=
VARIABLE OLDCOMMA
@

Start of current instruction.

<<ISS>>=
VARIABLE ISS
@

Length of current instruction

<<ISL>>=
VARIABLE ISL
@

To be executed instead of reset BA between prefix and instruction.

<<BA-XT>>=
VARIABLE BA-XT
@

Reset '\texttt{\textbf{BA}}' to default for begin instruction, unless
prefix.

<<RESET-BAD>>=
: RESET-BAD ( -- )   BA-XT @ DUP IF EXECUTE ELSE
        DROP  BA-DEFAULT @ TALLY-BA ! THEN ;
@

Initialise '\texttt{\textbf{TALLY}}'.

<<!TALLY>>=
: !TALLY ( -- )   0 TALLY-BI !   0 TALLY-BY !   RESET-BAD   0 OLDCOMMA ! ;
    0 BA-XT !   !TALLY
@

Return: instruction IS complete, or not started.

<<AT-REST?>>=
: AT-REST? TALLY-BI @ 0=   TALLY-BY @ 0=  AND ;
@

For N : it CONTAINS bad pairs.

<<BADPAIRS?>>=
: BADPAIRS? DUP 1 LSHIFT AND AAAAAAAAAAAAAAAA AND ;
: BAD? TALLY-BA @ BADPAIRS? ;
@

The state of assembling is inconsistent. If STATUS were added to '\texttt{\textbf{TALLY-BA}}'
would that create a bad situation?

<<CONSISTENT?>>=
: CONSISTENT? TALLY-BA @ OR BADPAIRS? 0= ;
@

Generate errors. None have net stack effects, such that they may be
replaced by NULL definitions. Error at postit time.

<<CHECK26>>=
: CHECK26 AT-REST? 0= ABORT" PREVIOUS INSTRUCTION INCOMPLETE" ;
@

Always an error.

<<CHECK32>>=
: CHECK32 BAD? ABORT" PREVIOUS OPCODE PLUS FIXUPS INCONSISTENT" ;
@

Generate error for fixup, if for the BI, some of the BITS would stick
out it. Leave MASK and BITS . Programming error!

<<CHECK31>>=
: CHECK31 2DUP SWAP CONTAINED-IN 0=
    ABORT" DESIGN ERROR, INCOMPATIBLE MASK" ;
@

Generate error for ``FIXUP-DATA'' , if the BI and the LEN are not
compatible. Leave BI and LEN . Programming error!

<<CHECK31A>>=
: CHECK31A 2DUP OVER >R RSHIFT 1 OR OVER LSHIFT R> <>
    ABORT" DESIGN ERROR, INCOMPATIBLE MASK" ;
@

The part of BITS outside of BITFIELD must be either all ones or zeros.
This checks for a shifted signed field.

<<CHECK32B>>=
: CHECK32B  2DUP OR INVERT 0= ( all ones) >R
    INVERT AND 0= ( all zero's ) R> OR ( okay)
    0= ABORT" PREVIOUS OPCODE PLUS FIXUPS INCONSISTENT" ;
@

Generate error for postit, if for the inverted BI , some of the the
BITS would stick out it. Leave MASK and BITS . Programming error!

<<CHECK33>>=
: CHECK33 2DUP SWAP INVERT CONTAINED-IN 0=
    ABORT" DESIGN ERROR, INCOMPATIBLE MASK" ;
@

BITS would stick out it. Leave MASK and BITS . Programming error!
Generate error on data for postit/fixup, if some BITS to fill in are
already in the MASK. Leave BITS and MASK.

<<CHECK28>>=
: CHECK28 2DUP AND ABORT" UNEXPECTED FIXUP/COMMAER" ;
@

Generate error on data for commaer, if the BITS to reset are not present
in the MASK. Leave BITS and MASK.

<<CHECK29>>=
: CHECK29 2DUP OR -1 - ABORT" DUPLICATE FIXUP/UNEXPECTED COMMAER" ;
@

Generate error if COMMAMASK is not in ascending order. Leave IT.

<<CHECK30>>=
: CHECK30 DUP OLDCOMMA @ < ABORT" COMMAERS IN WRONG ORDER"
    DUP OLDCOMMA ! ;
@

Or DATA into ADDRESS. If bits were already up its wrong.

<<OR!>>=
: OR! >R R@ @  CHECK28 OR R> ! ;
: OR!U >R R@ @  OR R> ! ;
@

Or DATA into ADDRESS. Unchecked. Reset bits of DATA into ADDRESS.
If bits were already down it's wrong.

<<AND!>>=
: AND! >R INVERT R@ @ CHECK29 AND R> ! ;
@


\subsubsection{Assembler defining words}

<<assembler-defining-words>>=
<<assemble,>>
<<!POSTIT>>
<<TALLY:,>>
<<POSTIT>>
<<BUILD-IP>>
<<PIS>>
<<IS-PI>>
<<TALLY:|>>
<<FIXUP>>
<<xFI>>
<<TRIM-SIGNED>>
<<FIXUP-DATA>>
<<FIXUP-SIGNED>>
<<DFI>>
<<DFIs>>
@

Assemble INSTRUCTION for ``ISL'' bytes. ls byte first.

<<assemble,>>=
: assemble, ( x -- )   ISL @ 0 DO  lsbyte,  LOOP  DROP ;
@

Initialise in behalf of postit.

<<!POSTIT>>=
: !POSTIT ( -- )   AS-HERE ISS !  0 OLDCOMMA ! ;
@

Bookkeeping for a postit using a pointer to the BIBYBA information,
can fake a postit in disassembling too.

<<TALLY:,>>=
: TALLY:, ( a -- )   DUP >BI @ TALLY-BI !  DUP >BY @ TALLY-BY !
    DUP >BA @ TALLY-BA OR!U  DUP >CNT @ ISL !  >DIS @ BA-XT ! ;
@

Post the instruction using DATA.

<<POSTIT>>=
: POSTIT ( a -- )   CHECK26   !TALLY   !POSTIT
    DUP >DATA @ >R   TALLY:,   R> assemble, ;
@

Build an instruction given by BA BY BI the OPCODE and COUNT.

<<BUILD-IP>>=
: BUILD-IP ( ba by bi opc cnt -- )   STARTVOC >CNT !  STARTVOC >DATA !
    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !
    0 ( prefix) STARTVOC >PRF ! ;
@

Define an instruction by BA BY BI and the OPCODE. For 1 2 3 and 4
byte opcodes.

<<PIS>>=
IS-A IS-1PI : 1PI  CHECK33 CREATE-- REMEMBER  1 BUILD-IP DOES>  POSTIT ;
IS-A IS-2PI : 2PI  CHECK33 CREATE-- REMEMBER  2 BUILD-IP DOES>  POSTIT ;
IS-A IS-3PI : 3PI  CHECK33 CREATE-- REMEMBER  3 BUILD-IP DOES>  POSTIT ;
IS-A IS-4PI : 4PI  CHECK33 CREATE-- REMEMBER  4 BUILD-IP DOES>  POSTIT ;
@

For DEA : it REPRESENTS some kind of opcode.

<<IS-PI>>=
: IS-PI  >R 0
    R@ IS-1PI OR  R@ IS-2PI OR  R@ IS-3PI OR   R@ IS-4PI OR R> DROP ;
@

Bookkeeping for a fixup using a pointer to the BIBYBA information,
can fake a fixup in disassembling too.

<<TALLY:|>>=
: TALLY:| ( a -- )   DUP >BI @ TALLY-BI AND!  DUP >BY @ TALLY-BY OR!
    >BA @ TALLY-BA OR!U ;
@

Fix up the instruction using a pointer to DATA.

<<FIXUP>>=
: FIXUP>   DUP >DATA @ ISS @ OR!   TALLY:|   CHECK32 ;
@

Define a fixup by BA BY BI and the FIXUP bits. One size fits all,
because of the or character of the operations.

<<xFI>>=
IS-A IS-xFI : xFI  CHECK31 CREATE-- REMEMBER STARTVOC >DATA !
    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA ! DOES>  FIXUP> ;
@

For a signed DATA item a LENGTH and a BITFIELD. Shift the data item
into the bit field and leave IT. Check if it doesn't fit.

<<TRIM-SIGNED>>=
: TRIM-SIGNED >R   2DUP R@ SWAP RSHIFT CHECK32B   LSHIFT R> AND ;
@

Fix up the instruction using DATA and a pointer to the bit POSITION.

<<FIXUP-DATA>>=
: FIXUP-DATA ( a -- )   DUP >DATA @  SWAP >R  LSHIFT ISS @ OR!
    R> TALLY:|  CHECK32 ;
@

Fix up the instruction using DATA and a pointer to the bit POSITION.

<<FIXUP-SIGNED>>=
: FIXUP-SIGNED ( a -- )   DUP >DATA @  SWAP >R
    R@ >BI @ TRIM-SIGNED ISS @ OR!
    R> TALLY:| CHECK32 ;
@

Define a data fixup by BA BY BI, and LEN the bit position. At assembly
time: expect DATA that is shifted before use. One size fits all, because
of the or character of the operations.

<<DFI>>=
IS-A IS-DFI : DFI  CHECK31A CREATE-- REMEMBER STARTVOC >DATA !
    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !  DOES>  FIXUP-DATA ;
@

Same, but for signed data.

<<DFIs>>=
IS-A IS-DFIs : DFIs  CHECK31A CREATE-- REMEMBER STARTVOC >DATA !
    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !  DOES>  FIXUP-SIGNED ;
@


\subsubsection{Obsolescent}

<<obsolescent>>=
<<REVERSE-BYTES>>
<<CORRECT-R>>
<<TALLY:|R>>
<<FIXUP<>>
<<FIR>>
<<DFIR>>
@

Reverses bytes in a WORD. Return IT.

<<REVERSE-BYTES>>=
: REVERSE-BYTES
    1 CELLS 0 DO DUP  FF AND SWAP 8 RSHIFT   LOOP
    8 CELLS 0 DO SWAP I LSHIFT OR   8 +LOOP ;
@

Rotate the MASK etc from a fixup-from-reverse into a NEW mask fit
for using from the start of the instruction. We know the length!

<<CORRECT-R>>=
: CORRECT-R 0 CELL+ ISL @ - ROTLEFT ;
@

Bookkeeping for a fixup-from-reverse using a pointer to the BIBYBA
information, can fake a fixup in disassembling too.

<<TALLY:|R>>=
: TALLY:|R ( a -- )   DUP >BI @ CORRECT-R TALLY-BI AND!
    DUP >BY @ TALLY-BY OR!  >BA @ TALLY-BA OR!U ;
@

Fix up the instruction from reverse with DATA.

<<FIXUP<>>=
: FIXUP<   CORRECT-R ISS @ OR! ;
@

Define a fixup-from-reverse by BA BY BI and the FIXUP bits. One size
fits all, because of the character of the or-operations. BI and fixup
are specified that last byte is lsb, such as you read it.

<<FIR>>=
IS-A IS-FIR : FIR  CHECK31 CREATE-- REMEMBER REVERSE-BYTES STARTVOC >DATA !
    REVERSE-BYTES STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !
    DOES>  DUP >DATA @  FIXUP< TALLY:|R  CHECK32 ;
@

Define a fixup-from-reverse by BA BY BI and LEN to shift. One size
fits all, because of the character of the or-operations. BI and fixup
are specified that last byte is lsb, such as you read it.

<<DFIR>>=
IS-A IS-DFIR : DFIR  CHECK31 CREATE-- REMEMBER STARTVOC >DATA !
    REVERSE-BYTES STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !
    DOES>  DUP >DATA @  SWAP >R  LSHIFT REVERSE-BYTES FIXUP<
        R> TALLY:|R  CHECK32 ;
@


\subsubsection{Preferred}

Not yet used???
<<preferred>>=
<<(AND!BYTE)>>
<<AND!BYTE>>
<<(OR!BYTE)>>
<<OR!BYTE>>
<<TALLY:|R'>>
<<FIXUP<'>>
@

If bits were already down it is wrong, for next two words. Reset bits
of DATA into ADDRESS bytewise.

<<(AND!BYTE)>>=
: (AND!BYTE) >R 0FF AND INVERT R@ C@ CHECK29 AND R> C! ;
@

Reset bits of DATA byte by byte into ADDRESS.

<<AND!BYTE>>=
: AND!BYTE BEGIN 2DUP (AND!BYTE) SWAP 8 RSHIFT DUP WHILE SWAP 1+ REPEAT 2DROP ;
@

If bits were already up its wrong, for next two words. Or DATA into
ADDRESS bytewise.

<<(OR!BYTE)>>=
: (OR!BYTE) >R R@ C@  CHECK28 OR R> C! ;
@

Or DATA byte by byte from behind into ADDRESS.

<<OR!BYTE>>=
: OR!BYTE BEGIN 1- 2DUP (OR!BYTE) SWAP 8 RSHIFT DUP WHILE SWAP REPEAT 2DROP ;
@

Bookkeeping for a fixup-from-reverse using a pointer to the BIBYBA
information, can fake a fixup in disassembling too.

<<TALLY:|R'>>=
: TALLY:|R'  DUP >BI @ TALLY-BI AND!BYTE  DUP >BY @ TALLY-BY OR!
    >BA @ TALLY-BA OR!U ;
@

Fix up the instruction from reverse using a pointer to DATA.

<<FIXUP<'>>=
: FIXUP<'   DUP >DATA @ ISS @ ISL @ + OR!BYTE  TALLY:|R'  CHECK32 ;
@


\subsubsection{End preferred}

<<end-preferred>>=
<<TALLY:,,>>
<<COMMA>>
<<COMMAER>>
@

Bookkeeping for a commaer using a pointer to the BIBYBA information.
Not used by the disassembler.

<<TALLY:,,>>=
: TALLY:,, ( a -- )   DUP >BY @ CHECK30 TALLY-BY AND!  >BA @ TALLY-BA OR!U ;
@
<<COMMA>>=
: COMMA ( a -- )   DUP >DATA @ >R  TALLY:,,  CHECK32  R> EXECUTE ;
@

Build with an disassembly ROUTINE, with the LENGTH to comma, the BA
BY information and the ADDRESS that is executing the commaer. A disassembly
routine gets the ``DEA'' of the commaer on stack.

<<COMMAER>>=
IS-A IS-COMMA : COMMAER CREATE-- REMEMBER STARTVOC >DATA !  0 STARTVOC >BI !
    STARTVOC >BY !  STARTVOC >BA !  STARTVOC >CNT !  STARTVOC >DIS !
    DOES>  COMMA ;
@


\subsubsection{Assembler super defining words}

<<super-defining-words>>=
<<PRO-TALLY>>
<<T!>>
<<T!R>>
<<Tat>>
<<FAMILIES>>
@

Prototype for TALLY-BI BY BA.

<<PRO-TALLY>>=
CREATE PRO-TALLY 3 CELLS ALLOT
@

Fill in the tally prototype with BA BY BI.

<<T!>>=
: T! PRO-TALLY !+ !+ !+ DROP ;
@

Reversed BI information.

<<T!R>>=
: T!R   REVERSE-BYTES T! ; 
@

Get the data from the tally prototype back BA BY BI.

<<Tat>>=
: T@ PRO-TALLY 3 CELLS +  @- @- @- DROP ;
@

Add INCREMENT to the OPCODE a NUMBER of times, and generate as much
instructions, all with the same BI-BA-BY from '\texttt{\textbf{PRO-TALLY}}'.
For each assembler defining word there is a corresponding family word.
Words named \textquotedbl{}--\textquotedbl{} are mere placeholders.

<<FAMILIES>>=
: 1FAMILY,    0 DO   DUP >R T@ R> 1PI   OVER + LOOP DROP DROP ;
: 2FAMILY,    0 DO   DUP >R T@ R> 2PI   OVER + LOOP DROP DROP ;
: 3FAMILY,    0 DO   DUP >R T@ R> 3PI   OVER + LOOP DROP DROP ;
: 4FAMILY,    0 DO   DUP >R T@ R> 4PI   OVER + LOOP DROP DROP ;
: xFAMILY|    0 DO   DUP >R T@ R> xFI   OVER + LOOP DROP DROP ;
: FAMILY|R    0 DO   DUP >R T@ REVERSE-BYTES R> FIR   OVER + LOOP DROP DROP ;
: xFAMILY|F   0 DO   DUP >R T@ R> DFI   OVER + LOOP DROP DROP ;
@


\subsubsection{Disassembler data structures}

<<structures>>=
<<DISS>>
: !DISS DISS !BAG ;
: .DISS-AUX DISS @+ SWAP DO
        I @ DUP IS-COMMA OVER IS-DFI OR OVER IS-DFIs OR IF I DISS - . THEN
        [DEFINED] ForSwiftForth [IF]  .'  [THEN]
        [DEFINED] ForGForth [IF]  ID.  [THEN]
    0 CELL+ +LOOP  CR ;
<<DISS-VECTOR>>
: +DISS DISS BAG+! ;
: DISS? DISS BAG? ;
<<DISS->>
@

A row of dea's representing a disassembly.

<<DISS>>=
12 BAG DISS
@

\texttt{\textbf{DISS-VECTOR}} can be redefined to generate testsets.

<<DISS-VECTOR>>=
VARIABLE DISS-VECTOR    ' .DISS-AUX DISS-VECTOR !
@

Discard last item of '\texttt{\textbf{DISS}}'

<<DISS->>=
: DISS- 0 CELL+ NEGATE DISS +! ;
@


\subsubsection{Tryers}

Tryers try to construct an instruction from current bookkeeping. They
can backtrack to show all possibilities.

<<tryers>>=
<<TRY-PI>>
<<TRY-xFI>>
<<TRY-DFI>>
<<TRY-FIR>>
<<TRY-COMMA>>
<<REBUILD>>
<<BACKTRACK>>
<<RESULT?>>
<<.RESULT>>
\     % RESULT +DISS Spurious? Remove after next total test.
<<SHOW-STEP>>
<<SHOW-ALL>>
<<SHOW-OPCODES>>
<<SHOW:>>
@

These tryers are quite similar: if the DEA on the stack is of the
right type and if the precondition is fullfilled it does the reassuring
actions toward the tally as with assembling and add the fixup/posti/commaer
to the disassembly struct. as if this instruction were assembled.
Leave the DEA.

<<TRY-PI>>=
: TRY-PI
    DUP IS-PI IF
    AT-REST? IF
        DUP TALLY:,
        DUP +DISS
    THEN
    THEN ;
@
<<TRY-xFI>>=
: TRY-xFI
    DUP IS-xFI IF
    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
        DUP TALLY:|
        DUP +DISS
    THEN
    THEN ;
@
<<TRY-DFI>>=
: TRY-DFI
    DUP IS-DFI OVER IS-DFIs OR IF
    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
        DUP TALLY:|
        DUP +DISS
    THEN
    THEN ;
@
<<TRY-FIR>>=
: TRY-FIR
    DUP IS-FIR IF
    DUP >BI @ CORRECT-R TALLY-BI @ CONTAINED-IN IF
        DUP TALLY:|R
        DUP +DISS
    THEN
    THEN ;
@
<<TRY-COMMA>>=
: TRY-COMMA
    DUP IS-COMMA IF
    DUP >BY @ TALLY-BY @ CONTAINED-IN IF
        DUP TALLY:,,
        DUP +DISS
    THEN
    THEN ;
@

Generate bookkeeping such as to correspond with '\texttt{\textbf{DISS}}'.

<<REBUILD>>=
: REBUILD
    !TALLY
    DISS? IF
        DISS @+ SWAP !DISS DO  ( Get bounds before clearing)
            I @ TRY-PI TRY-xFI TRY-DFI TRY-FIR TRY-COMMA DROP
        0 CELL+ +LOOP
    THEN ;
@

Discard the last item of the disassembly -- it is either used up or
incorrect --. Replace DEA with the proper DEA to inspect from here.

<<BACKTRACK>>=
: BACKTRACK
(   S" BACKTRACKING" TYPE                                               )
    DROP DISS @ @- DISS !
(   DROP DISS @ 0 CELL+ - @                                             )
(   S" Failed at :" TYPE DUP ID. CR                                     )
    >NEXT%
(   DISS-                                                               )
    REBUILD ;
@

If the disassembly contains something: '\texttt{\textbf{AT-REST?}}'
means we have gone full cycle rest->postits->fixups->commaers. Return:
the disassembly contains a result.

<<RESULT?>>=
: RESULT? AT-REST? DISS? AND   BAD? 0= AND ;
@

If present, print a result and continue searching for a new last item.

<<.RESULT>>=
: .RESULT
    RESULT? IF
        DISS-VECTOR @ EXECUTE
        DISS-
        REBUILD
    THEN ;
@

Try to expand the current instruction in '\texttt{\textbf{DISS}}'
by looking whether DEA fits. Leave the next DEA.

<<SHOW-STEP>>=
: SHOW-STEP
    TRY-PI TRY-DFI TRY-xFI TRY-FIR TRY-COMMA
    .RESULT
    >NEXT%
(       DUP ID.                                                         )
    BAD? IF BACKTRACK THEN
    BEGIN DUP VOCEND? DISS? AND WHILE BACKTRACK REPEAT ;
@

Show all the instructions present in the assembler vocabulary.

<<SHOW-ALL>>=
: SHOW-ALL ( -- )
    !DISS   !TALLY
    STARTVOC BEGIN
        SHOW-STEP
    DUP VOCEND? UNTIL DROP ;
@

Show all the opcodes present in the assembler vocabulary.

<<SHOW-OPCODES>>=
: SHOW-OPCODES ( -- )
    !DISS   !TALLY
    STARTVOC BEGIN
        DUP IS-PI IF DUP %ID. THEN >NEXT%
    DUP VOCEND? UNTIL DROP ;
@

Show at least all instructions valid for the \textquotedbl{}OPCODE\textquotedbl{}
given.

<<SHOW:>>=
: SHOW:
    !DISS   !TALLY
    ' DUP BEGIN
        SHOW-STEP
    OVER DISS CELL+ @ - OVER VOCEND? OR UNTIL DROP DROP ;
@


\subsubsection{Disassemblers}

Disassemblers try to reconstruct an instruction from current bookkeeping.
They are similar to tryers but disassemblers take one more aspect
into account, a piece of actual code. They do not backtrack but fail.

<<disassemblers>>=
<<AS-POINTER>>
<<INSTRUCTION>>
<<LATEST-INSTRUCTION>>
<<DIS-PI>>
<<DIS-xFI>>
<<DIS-DFI>>
<<DIS-DFIR>>
<<DIS-FIR>>
<<DIS-COMMA>>
<<.DFI>>
<<.DFIR>>
<<.COMMA-STANDARD>>
<<.COMMA-SIGNED>>
<<.COMMA>>
<<~ID.>>
<<.DISS>>
<<SHOW-MEMORY>>
<<((DISASSEMBLE))>>
<<DIS>>
<<FORCED-DISASSEMBLY>>
<<DISASSEMBLE-RANGE>>
@

Contains the position that is being disassembled.

<<AS-POINTER>>=
VARIABLE AS-POINTER       HERE AS-POINTER !
@

Get the valid part of the INSTRUCTION under examination.

<<INSTRUCTION>>=
: INSTRUCTION  ISS @   ISL @   MC@ ;
@

This is kept up to date during disassembly. It is useful for intelligent
disassemblers.

<<LATEST-INSTRUCTION>>=
VARIABLE LATEST-INSTRUCTION
@

These disassemblers are quite similar: if the DEA on the stack is
of the right type and if the precondition is fullfilled and if the
dissassembly fits, it does the reassuring actions toward the tally
as with assembling and add the fixup/posti/commaer to the disassembly
struct. Leave the DEA.

<<DIS-PI>>=
: DIS-PI ( dea -- dea )
    DUP IS-PI IF
    AT-REST? IF
    DUP >BI OVER >CNT @  MC@ INVERT
    >R AS-POINTER @ OVER >CNT @  MC@ R>   AND
    OVER >DATA @ = IF
        DUP TALLY:,
        DUP +DISS
        DUP LATEST-INSTRUCTION !
        AS-POINTER @ ISS !
        DUP >CNT @ AS-POINTER +!
    THEN
    THEN
    THEN ;
@
<<DIS-xFI>>=
: DIS-xFI ( dea -- dea )
    DUP IS-xFI IF
    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
    DUP >BI @ INSTRUCTION AND   OVER >DATA @ = IF
    DUP >BA @  CONSISTENT? IF
        DUP TALLY:|
        DUP +DISS
    THEN
    THEN
    THEN
    THEN ;
@
<<DIS-DFI>>=
: DIS-DFI ( dea -- dea )
    DUP IS-DFI OVER IS-DFIs OR IF
    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
    DUP >BA @  CONSISTENT? IF
        DUP TALLY:|
        DUP +DISS
    THEN
    THEN
    THEN ;
@
<<DIS-DFIR>>=
: DIS-DFIR ( dea -- dea )
    DUP IS-DFIR IF
    DUP >BI @ CORRECT-R   TALLY-BI @ CONTAINED-IN IF
    DUP >BA @  CONSISTENT? IF
        DUP TALLY:|R
        DUP +DISS
    THEN
    THEN
    THEN ;
@
<<DIS-FIR>>=
: DIS-FIR ( dea -- dea )
    DUP IS-FIR IF
    DUP >BI @ CORRECT-R   TALLY-BI @ CONTAINED-IN IF
    DUP >BI @ CORRECT-R   INSTRUCTION AND   OVER >DATA @ CORRECT-R = IF
    DUP >BA @  CONSISTENT? IF
        DUP TALLY:|R
        DUP +DISS
    THEN
    THEN
    THEN
    THEN ;
@
<<DIS-COMMA>>=
: DIS-COMMA ( dea -- dea )
    DUP IS-COMMA IF
    DUP >BY @ TALLY-BY @ CONTAINED-IN IF
    DUP >BA @  CONSISTENT? IF
        DUP TALLY:,,
        DUP +DISS
    THEN
    THEN
    THEN ;
@

Print a disassembly for the data-fixup DEA.

<<.DFI>>=
: .DFI
    INSTRUCTION   OVER >BI @ AND   OVER >DATA @ RSHIFT   U.
    %ID. ;
@

Print a disassembly for the data-fixup from reverse DEA.

<<.DFIR>>=
: .DFIR
    INSTRUCTION   OVER >BI @ CORRECT-R AND   OVER >DATA @ RSHIFT
    REVERSE-BYTES CORRECT-R U.
    %ID. ;
@

Print a standard disassembly for the commaer DEA.

<<.COMMA-STANDARD>>=
: .COMMA-STANDARD
    AS-POINTER @ OVER >CNT @ MC@ U.
    DUP >CNT @ AS-POINTER +!
    %ID. ;
@

Print a signed disassembly for the commaer DEA.

<<.COMMA-SIGNED>>=
: .COMMA-SIGNED
    AS-POINTER @ OVER >CNT @ MC@ .
    DUP >CNT @ AS-POINTER +!
    %ID. ;
@

Print the disassembly for the commaer DEA, advancing '\texttt{\textbf{AS-POINTER}}'
past the comma-content.

<<.COMMA>>=
: .COMMA   DUP >DIS @ IF   DUP >DIS @ EXECUTE   ELSE
        .COMMA-STANDARD   THEN ;
@

Print the DEA but with suppression, i.e. ignore those starting in
'\textasciitilde{}'.

<<~ID.>>=
: %~ID. DUP IGNORE? IF DROP ELSE %ID. THEN  ;
@

Print the disassembly '\texttt{\textbf{DISS}}'.

<<.DISS>>=
: .DISS   DISS @+ SWAP DO
        I @
        DUP IS-COMMA IF
            .COMMA
        ELSE DUP IS-DFI IF
            .DFI
        ELSE DUP IS-DFIs IF
            .DFI            \ For the moment.
        ELSE DUP IS-DFIR IF
            .DFIR
        ELSE
            %~ID.
        THEN THEN THEN THEN
    0 CELL+ +LOOP ;
@

From \texttt{\textbf{AS-POINTER}} show memory because the code there
can't be disassembled. Leave incremented \texttt{\textbf{AS-POINTER}}.

<<SHOW-MEMORY>>=
VARIABLE I-ALIGNMENT    1 I-ALIGNMENT !   ( Instruction alignment )

: SHOW-MEMORY ( a -- a' )   BEGIN  COUNT C. S"  C, " TYPE
        DUP I-ALIGNMENT @ MOD WHILE  REPEAT ;
@

Dissassemble one instruction from \texttt{\textbf{AS-POINTER}} starting
at DEA. Based on what is currently left in '\texttt{\textbf{TALLY}}'!
Leave a \texttt{\textbf{AS-POINTER}} pointing after that instruction.

<<((DISASSEMBLE))>>=
: ((DISASSEMBLE)) ( a dea -- a' )
    SWAP
    DUP AS-POINTER !  >R
    3 SPACES
    ( startdea -- ) BEGIN
        DIS-PI DIS-xFI DIS-DFI DIS-DFIR DIS-FIR DIS-COMMA
        >NEXT%
(       DUP ID. S" : " TYPE  DISS-VECTOR @ EXECUTE                         )
    DUP VOCEND? RESULT? OR UNTIL DROP
    RESULT? IF
        .DISS     \ Advances pointer past commaers
        LATEST-INSTRUCTION @ >PRF @ BA-XT !
        R> DROP AS-POINTER @
    ELSE
        R> SHOW-MEMORY
    THEN ;
@

Dissassemble one instruction from ADDRESS using the whole instruction
set and starting with a clean slate. Leave an ADDRESS pointing after
that instruction.

<<DIS>>=
: (DISASSEMBLE) ( a -- a' )   !DISS !TALLY STARTVOC ((DISASSEMBLE)) ;
: DIS ( x -- )   PAD !  PAD (DISASSEMBLE) ;
@

Forced dissassembly of one instruction from '\texttt{\textbf{AS-POINTER}}'.
Force interpretation as DEA instruction. This is useful for instructions
that are known or hidden by another instruction that is found first.

<<FORCED-DISASSEMBLY>>=
: FORCED-DISASSEMBLY ( dea -- )
    !DISS  !TALLY  AS-POINTER @ SWAP ((DISASSEMBLE)) DROP ;
@

Dissassemble one instruction from address ONE to address TWO.

<<DISASSEMBLE-RANGE>>=
: DISASSEMBLE-RANGE ( first last -- )
    SWAP  BEGIN DUP ADORN-ADDRESS  (DISASSEMBLE) 2DUP > 0= UNTIL  2DROP ;
@


\subsubsection{Defining words framework}

Close an assembly definition: restore and check.

<<defining-words>>=
: END-CODE
    ?CSP ?EXEC CHECK26 CHECK32 PREVIOUS ; IMMEDIATE

( FIXME : we must get rid of this one )
: ;C POSTPONE END-CODE S" WARNING: get rid of C;" TYPE CR ; IMMEDIATE

\ The following two definitions must *NOT* be in the assembler wordlist.
PREVIOUS DEFINITIONS DECIMAL

ALSO ASSEMBLER
<<CODE>>
<<;CODE>>
@

Define \textquotedbl{}word\textquotedbl{} using assembly instructions
up till \texttt{\textbf{END-CODE}}. One could put a '\texttt{\textbf{SMUDGE}}'
in both.

<<CODE>>=
: CODE
    ?EXEC ASM-CREATE POSTPONE ASSEMBLER !TALLY !CSP ; IMMEDIATE
@

Like '\texttt{\textbf{DOES>}}' but assembly code follows, closed by
\texttt{\textbf{END-CODE}}.

<<;CODE>>=
: ;CODE
    ?CSP   POSTPONE (;CODE)   POSTPONE [   POSTPONE ASSEMBLER ; IMMEDIATE
@


\subsubsection{Conveniences}

Abbreviations for interactive use. In the current dictionary.

<<conveniences>>=
: DDD ( a -- a' )   (DISASSEMBLE) ;
: D-R ( first last -- )   DISASSEMBLE-RANGE ;
@


\subsubsection{Notes}
\begin{enumerate}
\item We use the abstraction of a DEA \textquotedbl{}dictionary entry address\textquotedbl{}.
aqa \textquotedbl{}xt\textquotedbl{}. Return the DEA from \textquotedbl{}word\textquotedbl{}.
A DEA is an address that allows to get at header data like flags and
names. In ciforth an xt will do.
\end{enumerate}

\subsection{Assembler wrapper}

This file hot patches some words in the prelude of asgen.frt. It must
be loaded after asgen.frt.

<<aswrap.frt>>=
( $Id: aswrap.frt,v 1.21 2009/03/26 19:40:39 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

<<HOT-PATCH>>
<<CODE-LENGTH>>
<<SECTION-REGISTRY>>
<<CURRENT-SECTION>>
<<SECTION>>
<<DEFAULT-SECTION>>
<<'AS-HERE>>
<<TARGET-END>>
<<PLAUSIBLE-LABEL?>>
<<HOST-END>>
<<ORG>>
<<HOST>TARGET>>
<<TARGET>HOST>>
<<FILE>TARGET>>
<<TARGET>FILE>>

\ Abbreviation.
[DEFINED] ForSwiftForth NOT [IF]
    ' TARGET>HOST ALIAS th
[THEN]

<<SUB-SECTION>>
<<'AP>>
<<SWAP-AS>>
<<'AS-ALLOT>>
<<'AS-C,>>
<<RESB>>
<<RES-TIL>>
<<AS-ALIGN>>
@

Copy the behaviour of the latest definition into \textquotedbl{}name\textquotedbl{}
affecting all words already using that word.

<<HOT-PATCH>>=
: HOT-PATCH ( xt -- ) ' >BODY ! ;
@

Length of the code buffer.

<<CODE-LENGTH>>=
VARIABLE CODE-LENGTH 2000000 CODE-LENGTH !
@

A bag with the DEA's of all segments.

<<SECTION-REGISTRY>>=
100 BAG SECTION-REGISTRY
@

Current segment pointer. Create section pointers with \texttt{\textbf{FILE-OFFSET}}
\texttt{\textbf{TARGET-START}} and \texttt{\textbf{CODE-SPACE}}

<<CURRENT-SECTION>>=
0 VALUE CURRENT-SECTION

: SECTION-FIELD ( u size -- u' ) CREATE OVER , +
    DOES> ( -- a ) @ CURRENT-SECTION + ;

0
    2 CELLS SECTION-FIELD SECTION-RESERVED
    1 CELLS SECTION-FIELD CP \ The local dictionary pointer ("code pointer")
    1 CELLS SECTION-FIELD 'CODE-SPACE \ Start of the code space
    1 CELLS SECTION-FIELD 'TARGET-START \ Return corresponding target address.
    1 CELLS SECTION-FIELD 'FILE-OFFSET \ Return corresponding files address.
CONSTANT |SECTION|

: CODE-SPACE ( -- a ) 'CODE-SPACE @ ;
: -ORG- ( a -- ) 'TARGET-START ! ;
: TARGET-START ( -- a ) 'TARGET-START @ ;
: FILE-OFFSET ( -- a ) 'FILE-OFFSET @ ;
@

Create section with \texttt{\textbf{FILE-OFFSET}} \texttt{\textbf{TARGET-START}}.
Assign ample code space. Leave it current.

<<SECTION>>=
: ((SECTION)) ( file target code -name- )
    SAVE-INPUT CREATE HERE DUP >R DUP SECTION-REGISTRY BAG+!
    |SECTION| DUP ALLOT ERASE RESTORE-INPUT THROW BL WORD $@ $, R@ >NFA !
    CURRENT-SECTION R@ >LFA ! R> TO CURRENT-SECTION DUP CP !
    'CODE-SPACE ! 'TARGET-START ! 'FILE-OFFSET !
    DOES> TO CURRENT-SECTION ;
: (SECTION) ( file target -- ) CODE-LENGTH @ ALLOCATE THROW ((SECTION)) ;
CREATE 'SECTION ' (SECTION) DUP , , : SECTION 'SECTION @ EXECUTE ;
@

Define at least one segment lest the user forgets.

<<DEFAULT-SECTION>>=
: DEFAULT-SECTION ( -- )
    0 \ File start address
    0 \ Target start address
    s" SECTION the-default-section" EVALUATE ;
DEFAULT-SECTION
@

'\texttt{\textbf{HERE}}' such as used in assembly.

<<'AS-HERE>>=
:NONAME ( -- a ) CP @ ; HOT-PATCH 'AS-HERE
@

Use only while disassembling. Return the END of the file as a target
address (non-inclusive).

<<TARGET-END>>=
: TARGET-END ( -- a ) TARGET-START CP @ CODE-SPACE - + ;
@

For ADDR return \textquotedbl{}it is a pointing into the target space\textquotedbl{}

<<PLAUSIBLE-LABEL?>>=
: PLAUSIBLE-LABEL? ( a -- f ) TARGET-START TARGET-END WITHIN ;
@

Use only while disassembling. The end of the code area while disassembling:
a host address.

<<HOST-END>>=
: HOST-END ( -- a ) CP @ ;
@

Associate target ADDRESS with start of '\texttt{\textbf{CODE-BUFFER}}'.
The valid range from the code buffer goes to '\texttt{\textbf{CP @}}'
and is not affected.

Associate ADDRESS with the start of '\texttt{\textbf{CODE-SPACE}}'.

<<ORG>>=
: ORG ( a -- ) -ORG- CODE-SPACE CP ! ;
@

Convert host memory ADDRESS. Leave target memory ADDRESS.

<<HOST>TARGET>>=
: HOST>TARGET ( a -- a' ) CODE-SPACE - TARGET-START + ;
@

Convert target memory ADDRESS. Leave host memory ADDRESS.

<<TARGET>HOST>>=
: TARGET>HOST ( a -- a' ) TARGET-START - CODE-SPACE + ;
@

Convert file memory ADDRESS. Leave target memory ADDRESS.

<<FILE>TARGET>>=
: FILE>TARGET ( a -- a' ) FILE-OFFSET - TARGET-START + ;
@

Convert target memory ADDRESS. Leave file memory ADDRESS.

<<TARGET>FILE>>=
: TARGET>FILE ( a -- a' ) TARGET-START - FILE-OFFSET + ;
@
<<SUB-SECTION>>=
: SUB-SECTION ( a -name- ) DUP TARGET>FILE
    OVER ROT TARGET>HOST CP @ >R ((SECTION)) R> CP ! ;
@

Instruction pointer in assembly. View used in branches etc.

<<'AP>>=
:NONAME ( -- a ) CP @ HOST>TARGET ; HOT-PATCH '_AP_
@

Swap dictionary pointer back and forth to assembler area.

<<SWAP-AS>>=
[DEFINED] ForCiForth
[DEFINED] ForGForth OR [IF]
    : SWAP-AS ( -- ) CP @ DP @ CP ! DP ! ;
[THEN]
[DEFINED] ForSwiftForth [IF]
    : SWAP-AS ( -- ) CP @ H @ CP ! H ! ;
[THEN]
@

Wrapper for '\texttt{\textbf{ALLOT}}' such as used in assembly.

<<'AS-ALLOT>>=
:NONAME ( n -- ) CP +! ; HOT-PATCH 'AS-ALLOT
@

Only Needed. Maybe '\texttt{\textbf{CP C! 1 CP +!}}'. Wrapper for
'\texttt{\textbf{C,}}' such as used in assembly.

<<'AS-C,>>=
:NONAME ( c -- ) CP @ 1 AS-ALLOT C! ; HOT-PATCH 'AS-C,
@

Reserve X bytes, without specifying a content.

<<RESB>>=
: RESB ( u -- ) AS-HERE OVER AS-ALLOT SWAP ERASE ;
@

Reserve bytes till target ADDRES. (Compare '\texttt{\textbf{ORG}}'.)

<<RES-TIL>>=
: RES-TIL ( a -- ) _AP_ - AS-ALLOT ;
@

Align to a target address, that is multiple of N.

<<AS-ALIGN>>=
: AS-ALIGN ( n -- ) _AP_ BEGIN 2DUP SWAP MOD WHILE 1+ REPEAT RES-TIL DROP ; 
@


\subsection{80386 Assembler}

<<asi386.frt>>=
( $Id: asi386.frt,v 4.23 2005/05/09 01:00:40 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)

ALSO ASSEMBLER DEFINITIONS HEX

<<additions>>

 ( ############## 80386 ASSEMBLER PROPER ############################### )
 ( The decreasing BY means that a decompiler hits them in the right      )
 ( order to reassemble.                                                  )
 ( Fields: a disassembly XT,      LENGTH to comma, the BA BY information )
 ( and the XT that puts data in the dictionary.                          )
 ( Where there is a placeholder ``_'' the execution token is filled in   )
 ( later. )
 (   CNT                                                                 )
 ( XT   BA   BY     XT-AS          NAME                                  )
   0 2  0000 00100 ' (W,) COMMAER OW,    ( obligatory word     )
   0 4  8000 00080 ' (L,) COMMAER (RL,)  ( cell relative to IP )
   0 2  4000 00080 ' (W,) COMMAER (RW,)  ( cell relative to IP )
   0 1  0000 00040 ' AS-C, COMMAER (RB,) ( byte relative to IP )
   0 2  0000 00020 ' (W,) COMMAER SG,    (  Segment: WORD      )
   0 1  0000 00010 ' AS-C, COMMAER P,    ( port number ; byte     )
   0 1  0000 00008 ' AS-C, COMMAER IS,   ( Single -obl-  byte )
   0 4 20002 00004 ' (L,) COMMAER IL,    ( immediate data : cell)
   0 2 10002 00004 ' (W,) COMMAER IW,    ( immediate data : cell)
   0 1  0001 00004 ' AS-C, COMMAER IB,   ( immediate byte data)
   0 4  8008 00002 ' (L,) COMMAER L,     ( immediate data : address/offset )
   0 2  4008 00002 ' (W,) COMMAER W,     ( immediate data : address/offset )
   0 1  0004 00002 ' AS-C, COMMAER B,    ( immediate byte : address/offset )
   _ 1  0000 00001 _    COMMAER SIB,, ( An instruction with in an instruction )

 ( Meaning of the bits in TALLY-BA :                                     )
 ( Inconsistent:  0001 OPERAND IS BYTE     0002 OPERAND IS CELL  W/L     )
 (                0004 OFFSET  IS BYTE     0008 OFFSET  IS CELL  W/L     )
 ( By setting 0020 an opcode can force a memory reference, e.g. CALLFARO )
 (               0010 Register op         0020 Memory op                 )
 (               0040 ZO|                 0080 [BP]% {16} [BP] [BP  {32} )
 (  sib:         0100 no ..             0200 [AX +8*| DI]                )
 (  logical      0400 no ..             0800 Y| Y'| Z| Z'|               )
 (  segment      1000 no ..             2000 ES| ..                      )
 (  AS:          4000 16 bit Addr       8000 32 bit Address              )
 (  OS:         10000 16 bit Op        20000 32 bit Operand              )
 (  Use debug   40000 no ..            80000 CR0 ..DB0                   )
 (  FP:        100000 FP-specific     200000 Not FP                      )

 ( Names *ending* in percent BP|% -- not BP'| the prime registers -- are )
 ( only valid for 16 bits mode, or with an address overwite. Use W, L,   )
 ( appropriately.                                                        )

8200 0 38 T!R
  08 00 8 FAMILY|R AX] CX] DX] BX] 0] BP] SI] DI]
 8200 0 0C0 T!R
  40 00 4 FAMILY|R  +1* +2* +4* +8*
 8200 0 7 REVERSE-BYTES 1 + T!
  01 00 8 FAMILY|R [AX [CX [DX [BX [SP -- [SI [DI
 8280 00 1 REVERSE-BYTES 7 + 05 FIR [BP   ( Fits in the hole, but disallow ZO| )
 8248 02 1 REVERSE-BYTES 7 + 05 FIR [MEM  ( Fits in the hole, but requires ZO| )

4120 0 07 T!R
   01 00 8
     FAMILY|R [BX+SI]% [BX+DI]% [BP+SI]% [BP+DI]% [SI]% [DI]% -- [BX]%
 40A0 0000 07 06 FIR [BP]%  ( Fits in the hole, safe inconsistency check)
 8120 0 07 T!R
  01 00 4 FAMILY|R [AX] [CX] [DX] [BX]
 8120 01 07 04 FIR ~SIB|   ( Fits in the hole, but requires ~SIB, )
 81A0 00 07 05 FIR [BP]   ( Fits in the hole, but disallow ZO| )
 8120 0 07 T!R  01 06 2 FAMILY|R [SI] [DI]

 200111 0 07 T!R  01 00 8 FAMILY|R AL| CL| DL| BL| AH| CH| DH| BH|
 200112 0 07 T!R
  01 00 8 FAMILY|R AX| CX| DX| BX| SP| BP| SI| DI|
 0160 00 0C0 00 FIR      ZO|
 0124 02 0C0 40 FIR      BO| 0128 02 0C0 80 FIR      XO|
 200110 00 0C0 0C0 FIR      R|
 204048 02 0C7 06 FIR      MEM|% ( Overrules ZO| [BP]% )
 208108 02 0C7 05 FIR      MEM| ( Overrules ZO| [BP] )

 241101 0000 38 T!R
  08 00 8 FAMILY|R AL'| CL'| DL'| BL'| AH'| CH'| DH'| BH'|
 241102 0000 38 T!R  08 00 8 FAMILY|R AX'| CX'| DX'| BX'| SP'| BP'| SI'| DI'|
 242100 0000  38 T!R   08 00 6 FAMILY|R ES| CS| SS| DS| FS| GS|
 280002 0000 138 REVERSE-BYTES T!   ( 3)
  08 00 5 FAMILY|R CR0| -- CR2| CR3| CR4|                 ( 3)
  0008 0100 8 FAMILY|R DR0| DR1| DR2| DR3| DR4| DR5| DR6| DR7| ( 3)

 200000 0000 0200 T!R  0200 00 2 FAMILY|R F| T|
 240401 0000 0100 0000 FIR B|
 240402 0000 0100 0100 FIR X|

<<~SIB,>>
<<two-fixup-operands>>
<<one-fixup-operands>>
<<no-fixup-operands>>
<<special-fixups>>
<<no-fixups>>
<<SIB-bytes>>
<<AS:,OS:,>>

( ############## 80386 ASSEMBLER PROPER END ########################### )
<<Rx,alt>>
<<BITS>>

BITS-32
PREVIOUS DEFINITIONS DECIMAL
( ############## 8086 ASSEMBLER POST ################################## )
@

These definitions are such that they work regardless of the endianness
of the host. Lay down word (16 bits) and long (32 bits) constants.

<<additions>>=
 : (W,) lsbyte, lsbyte, DROP ;
 : (L,) lsbyte, lsbyte, lsbyte, lsbyte, DROP ;
@

Fill in the transformation to TALLY-BA for \texttt{\textbf{AS:,}}
and \texttt{\textbf{OS:,}} This flags them as prefixes. The toggle
inverts the 16 and 32 bits at the same time.

<<AS:,OS:,>>=
:NONAME   TALLY-BA  C000 TOGGLE ;  ' AS:, >BODY >PRF !
:NONAME   TALLY-BA 30000 TOGGLE ;  ' OS:, >BODY >PRF !
@

You may want to use these always instead of \texttt{\textbf{(Rx,)}}

<<Rx,alt>>=
: RB, _AP_ 1 + - (RB,) ;    ' .COMMA-SIGNED   ' (RB,) >BODY >DIS !
: RW, _AP_ 2 + - (RW,) ;    ' .COMMA-SIGNED   ' (RW,) >BODY >DIS !
: RL, _AP_ 4 + - (RL,) ;    ' .COMMA-SIGNED   ' (RL,) >BODY >DIS !
@

Require instructions as per a 32 resp. 16 bits segment.

<<BITS>>=
: BITS-32   28000 BA-DEFAULT ! ;
: BITS-16   14000 BA-DEFAULT ! ;
@


\subsubsection{Two fixup operands}

<<two-fixup-operands>>=
 041000 0000 FF03 T!
  0008 0000 8 2FAMILY, ADD, OR, ADC, SBB, AND, SUB, XOR, CMP,
 041000 0000 FF01 T!
  0002 0084 2 2FAMILY, TEST, XCHG,
 041000 0000 FF03 0088 2PI MOV,
 1022 0 FF00 008D 2PI LEA,
 1022 0 FF00 T!   0001 00C4 2 2FAMILY, LES, LDS,
 1022 0 FF00 0062 2PI BOUND,  ( 3)
 1002 0 FF00 0063 2PI ARPL,   ( 3)
 1002 04 FF00 0069 2PI IMULI, ( 3)
 1002 08 FF00 006B 2PI IMULSI, ( 3)
 1002 0 FF0000 T! 0100 00020F 2 3FAMILY, LAR, LSL, ( 3)
 1002 0 FF0000 T! 0800 00A30F 4 3FAMILY, BT, BTS, BTR, BTC, ( 3)
 1002 0 FF0000 T! 0800 00A50F 2 3FAMILY, SHLD|C, SHRD|C,    ( 3)
 1002 0 FF0000 T! 0100 00BC0F 2 3FAMILY, BSF, BSR,          ( 3)
 1002 08 FF0000 T! 0800 00A40F 2 3FAMILY, SHLDI, SHRDI,    ( 3)
 1022 0 FF0000 T! 0100 00B20F 4 3FAMILY, LSS, -- LFS, LGS, ( 3)
 1501 0 FF0000 T! 0800 00B60F 2 3FAMILY, MOVZX|B, MOVSX|B,  ( 3)
 1502 0 FF0000 T! 0800 00B70F 2 3FAMILY, MOVZX|W, MOVSX|W,  ( 3)
 1002 0 FF0000 00AF0F 3PI IMUL,                     ( 3)
@


\subsubsection{One fixup operands}

It is dubious but fairly intractible whether the logical operation
with sign extended bytes belong in the 386 instruction set. They are
certainly there in the Pentium.

<<one-fixup-operands>>=
 0 04 C701 00C6 2PI MOVI,
 0012 0 0007 T!   0008 40 4 1FAMILY, INC|X, DEC|X, PUSH|X, POP|X,
 0012 0 0007 90 1PI XCHG|AX,
 0011 04 0007 B0 1PI MOVI|B,
 0012 04 0007 B8 1PI MOVI|X,
 0 04 C701 T!
  0800 0080 8 2FAMILY, ADDI, ORI, ADCI, SBBI, ANDI, SUBI, XORI, CMPI,
 0002 08 C700 T!
  0800 0083 8 2FAMILY, ADDSI, ORSI, ADCSI, SBBSI, ANDSI, SUBSI, XORSI, CMPSI,
 0000 0 C701 T!
  0800 10F6 6 2FAMILY, NOT, NEG, MUL|AD, IMUL|AD, DIV|AD, IDIV|AD,
  0800 00FE 2 2FAMILY, INC, DEC,
 0 04 C701 00F6 2PI TESTI,
 0002 0 C700 008F 2PI POP,
 0002 0 C700 30FF 2PI PUSH,
 0002 0 C700 T!  1000 10FF 2 2FAMILY, CALLO, JMPO,
 0022 0 C700 T!  1000 18FF 2 2FAMILY, CALLFARO, JMPFARO,
 0002 08 C70000 T!  080000 20BA0F 4 3FAMILY, BTI, BTSI, BTRI, BTCI, ( 3)
 0002 0 C70000 T! ( It says X but in fact W : descriptor mostly - ) ( 3)
   080000 00000F 6 3FAMILY, SLDT, STR, LLDT, LTR, VERR, VERW,  ( 3)
   100000 20010F 2 3FAMILY, SMSW, LMSW,       ( 3)
 0022 0 C70000 T! ( It says X but in fact memory of different sizes) ( 3)
   080000 00010F 4 3FAMILY, SGDT, SIDT, LGDT, LIDT, ( 3)
@


\subsubsection{No fixup operands}

<<no-fixup-operands>>=
 0001 0 02000001 00 FIR B'|
 0002 0 02000001 01 FIR X'|
 0008 02 0201 T!    0002 A0 2 1FAMILY, MOV|TA, MOV|FA,
 0 04 0201 T!
  0008 04 8 1FAMILY, ADDI|A, ORI|A, ADCI|A, SBBI|A, ANDI|A, SUBI|A, XORI|A, CMPI|A,
 0000 04 0201 00A8 1PI TESTI|A,
 0000 0 0201 T!  0002 A4 6 1FAMILY, MOVS, CMPS, -- STOS, LODS, SCAS,
 0 10 0201 T!   0002 E4 2 1FAMILY, IN|P, OUT|P,
 0 00 0201 T!   0002 EC 2 1FAMILY, IN|D, OUT|D,
 0 00 0201 T!   0002 6C 2 1FAMILY, INS, OUTS,     ( 3)
@


\subsubsection{Special fixups}

<<special-fixups>>=
 0800     0000 01000001 T!R     01 00 2 FAMILY|R Y| N|
 0800     0000 0400000E T!R     02 00 8 FAMILY|R O| C| Z| CZ| S| P| L| LE|
 0800 40 050F 0070 1PI J,

 2102 0 FF02 008C 2PI MOV|SG,

 0000 0 02000200 0000 FIR 1|   0000 0 02000200 0200 FIR V|          ( 3)
 0100 0 2C703 T! ( 20000 is a lockin for 1| V|)                   ( 3)
  0800 00D0 8 2FAMILY, ROL, ROR, RCL, RCR, SHL, SHR, -- SAR,  ( 3)
 0000 8 C701 T!  0800 00C0 8 2FAMILY, ROLI, RORI, RCLI, RCRI, SHLI, SHRI, -- SARI,  ( 3)
 80012 0000 3F0300 C0200F 3PI  MOV|CD,  ( 3)

 0800 80 50F00 800F 2PI J|X,                                           ( 3)
 0800 0 0100 T!R  0100 0000 2 FAMILY|R Y'| N'|                          ( 3)
 0800 0 0E00 T!R  0200 0000 8 FAMILY|R O'| C'| Z'| CZ'| S'| P'| L'| LE'| ( 3)
 0901 0 C70F00 00900F 3PI SET,  ( 3)
@


\subsubsection{No fixups}

<<no-fixups>>=
 2000 0000 0 T!  0008 06 4 1FAMILY, PUSH|ES, PUSH|CS, PUSH|SS, PUSH|DS,
 2000 0000 0 T!  0008 07 4 1FAMILY, POP|ES, -- POP|SS, POP|DS,

 0001 04 0000 T!    0001 D4 2 1FAMILY, AAM, AAD, 0001 04 0000 0CD 1PI INT,
 0008 22 0000 09A 1PI CALLFAR,
 0008 22 0000 0EA 1PI JMPFAR,
 0 0100 0000 T!   0008 C2 2 1FAMILY, RET+, RETFAR+,
 0004 80 0000 T!   0001 E8 2 1FAMILY, CALL, JMP,
 0 40 0000 0EB 1PI JMPS,
 0 40 0000 T!   0001 E0 4 1FAMILY, LOOPNZ, LOOPZ, LOOP, JCXZ,
 0000 0 0000 T!
    0008   0026 4 1FAMILY, ES:, CS:, SS:, DS:,
    0008   0027 4 1FAMILY, DAA, DAS, AAA, AAS,
    0001   0098 8 1FAMILY, CBW, CWD, -- WAIT, PUSHF, POPF, SAHF, LAHF,
    0008   00C3 2 1FAMILY, RET,  RETFAR,
    0001   00CC 4 1FAMILY, INT3, -- INTO, IRET,
    0001   00F0 6 1FAMILY, LOCK, -- REPNZ, REPZ, HLT, CMC,
    0001   00F8 6 1FAMILY, CLC, STC, CLI, STI, CLD, STD,
    0001   0060 2 1FAMILY, PUSH|ALL, POP|ALL, ( 3)
    0001   0064 4 1FAMILY, FS:, GS:, OS:, AS:, ( 3)
  0100 A00F 3 2FAMILY, PUSH|FS, POP|FS, CPUID,
  0100 A80F 2 2FAMILY, PUSH|GS, POP|GS, ( RSM,)
   0002 04 0000   0068 1PI PUSHI|X,  ( 3)
   0001 04 0000   006A 1PI PUSHI|B,  ( 3)
   0001 0104 0000   00C8 1PI ENTER, ( 3)
       0000 0 00   00C9 1PI LEAVE, ( 3)
       0000 0 00   00D7 1PI XLAT,  ( 3)
       0000 0 00 060F 2PI CLTS,  ( 3)
@


\subsubsection{Handling the SIB byte}

These must be found last

<<~SIB,>>=
0600 0 01FF 0000 1PI ~SIB,
@

Handle a 'sib' bytes as an instruction-within-an-instruction. This
is really straightforward, we say the sib commaer is a sib instruction.
as per -- error checking omitted -- \textquotedbl{}\texttt{\textbf{10000
' \textasciitilde{}SIB, >CFA COMMAER SIB,,}}\textquotedbl{}. All the
rest is to nest the state in this recursive situation: Leaving BY
would flag commaers to be done after the sib byte as errors.

<<SIB-bytes>>=
<<(SIB),,>>
<<DIS-SIB>>
<<SIBfixups>>
@

Handle bad bits by hand, prevent resetting of '\texttt{\textbf{TALLY-BA}}'
which could switch 16/32 bits modes. 0900 are the bad bits conflicting
with \texttt{\textbf{\textasciitilde{}SIB,}}. Fill in deferred data
creation action.

<<(SIB),,>>=
: (SIB),,   TALLY-BY @   0 TALLY-BY !
    CHECK32 TALLY-BA @ 0900 INVERT AND TALLY-BA !   ['] NOOP BA-XT !
    ~SIB,   TALLY-BY !   ;
' (SIB),,  ' SIB,, >BODY >DATA !
@

Disassemble the sib byte where the disassembler sits now. '\texttt{\textbf{FORCED-DISASSEMBLY}}'
takes care itself of incrementing the disassembly pointer. Fill in
deferred disassembler action.

<<DIS-SIB>>=
: DIS-SIB DROP
    LATEST-INSTRUCTION @        \ We don't want sib visible.
    [ ' ~SIB, >BODY ] LITERAL FORCED-DISASSEMBLY
    LATEST-INSTRUCTION ! ;
' DIS-SIB    ' SIB,, >BODY >DIS !
@

Redefine some fixups, such that the user may say \textquotedbl{}\texttt{\textbf{{[}AX}}\textquotedbl{}
instead of \textquotedbl{}\texttt{\textbf{\textasciitilde{}SIB| SIB,,
{[}AX}}\textquotedbl{}. Note that the disassembly is made to look
like the same. The \texttt{\textbf{\textasciitilde{}SIB|}} and the
\texttt{\textbf{\textasciitilde{}SIB,}} inside the \texttt{\textbf{SIB,,}}
are print-suppressed.

<<SIBfixups>>=
-warning
: [AX   ~SIB| SIB,, [AX ;
: [SP   ~SIB| SIB,, [SP ;
: [CX   ~SIB| SIB,, [CX ;
: [BP   ~SIB| SIB,, [BP ;
: [DX   ~SIB| SIB,, [DX ;
: [SI   ~SIB| SIB,, [SI ;
: [BX   ~SIB| SIB,, [BX ;
: [DI   ~SIB| SIB,, [DI ;
: [MEM  ~SIB| SIB,, [MEM ;
+warning
@


\subsection{Access words}

Contains access words and other little utilities that complement ciasdis.
In particular regarding unexpected missing words.

<<access.frt>>=
( $Id: access.frt,v 1.6 2005/01/04 19:20:35 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

ALSO ASSEMBLER
: B@ TARGET>HOST C@ ;
: W@ TARGET>HOST 2 MC@ ;
: L@ TARGET>HOST 4 MC@ ;
PREVIOUS
@


\subsection{Handle labels}

<<labelas.frt>>=
( $Id: labelas.frt,v 1.17 2009/03/26 19:40:39 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

[DEFINED] ForCiForth [IF]
    REQUIRE BAG             \ Simple bag facility
    REQUIRE DO-BAG          \ More advanced bag facility
    REQUIRE POSTFIX
[THEN]

<<FIX-DEA>>
<<BACKSPACE-IN>>
<<FIX-NMB>>
<<ERROR10>>
<<ERROR12>>

[DEFINED] ForCiForth [IF]
    REQUIRE OLD:
[THEN]

<<?ERROR-FIXING>>
<<RESET-SECTION>>
<<PASSES>>
<<'LABELS>>
<<IS-A-LABEL?>>
<<KNOWN-LABEL?>>

[DEFINED] ForCiForth [IF]
    <<:PREFIX>>
[THEN]

<<constant-data>>
@

Make sure undefined labels don't fool up the first pass of the assembly.
Replace not found FLAG, by a valid DEA with the stack effect of a
label. The result is that unknown words are compiled as a \texttt{\textbf{\_}},
i.e. it generates a don't care value. Supposedly these are labels
that have not been defined yet. Go on compiling. Loading the same
code another time will give correct code.

<<FIX-DEA>>=
: FIX-DEA DROP ['] _ ;
@

Backspace a character, but not if we are at the end of input. We find
out by trial reading another character, then back two up.

<<BACKSPACE-IN>>=
[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
     : BACKSPACE-IN   -2 >IN +! 0 ;
[THEN]
[DEFINED] ForCiForth [IF]
    : BACKSPACE-IN   IN[] IF -2 IN +! THEN DROP ;
[THEN]
@

Make sure undefined labels that looks like numbers, don't fool up
the first pass of the assembly. Not that we endorse the idea to name
labels like \texttt{\textbf{250HUP}}. All of a word may have been
scanned, so before using \texttt{\textbf{(WORD)}}, we backspace one
char. Afterwards we backspace again, such that the number routine
we return to concludes it is ready. We leave some random number, which
is okay, but it must be single precision!

<<FIX-NMB>>=
[DEFINED] ForSwiftForth
[DEFINED] ForGForth OR [IF]
    : FIX-NMB   -1 >IN +!  BL WORD DROP  BACKSPACE-IN ;
[THEN]
[DEFINED] ForCiForth [IF]
    : FIX-NMB   -1 IN +!  (WORD) 2DROP  BACKSPACE-IN   0 DPL ! ;
[THEN]
@

If FLAG we have a misspelled number, skip its remainder.

<<ERROR10>>=
: ERROR10 ( f n -- )   DROP IF  FIX-NMB  THEN ;
@

If FLAG we have an unknown word, treat it as a label.

<<ERROR12>>=
: ERROR12 ( f n -- )   DROP IF  FIX-DEA  THEN ;
@

Replacement for \texttt{\textbf{?ERROR}}, if FLAG, give error NUMBER.
Fix up errors, see \texttt{\textbf{FIX-NMB}} and \texttt{\textbf{FIX-DEA}}.

<<?ERROR-FIXING>>=
: ?ERROR-FIXING ( f n -- )
    DUP 10 = IF  ERROR10  ELSE
    DUP 12 = IF  ERROR12  ELSE
        (?ERROR)
    THEN THEN ;
@

Ignore \texttt{\textbf{FILE-OFFSET}} and \texttt{\textbf{TARGET}}
address. Make section \textquotedbl{}name\textquotedbl{} current,
and reset its allocation pointer. Like '\texttt{\textbf{SECTION}}'
but this behaviour is appropriate for the second pass.

<<RESET-SECTION>>=
: RESET-SECTION ( file target -- )   2DROP  BL WORD COUNT EVALUATE  CODE-SPACE CP ! ;
@

Ignore undefined labels during first pass ... Define section in the
first pass ... but just start section, and have normal errors in the
second pass.

<<PASSES>>=
: FIRSTPASS ( -- )   CR S" FIRSTPASS " TYPE CR
    ['] ?ERROR-FIXING '?ERROR !
    'SECTION RESTORED ;

: SECONDPASS ( -- )   CR S" SECONDPASS " TYPE CR
    ['] RESET-SECTION 'SECTION !
    '?ERROR RESTORED ;
@

All labels link back to here.

<<'LABELS>>=
CREATE 'LABELS  HERE ,
@

For NAME: \textquotedbl{}name REPRESENTS a label.\textquotedbl{}

<<IS-A-LABEL?>>=
: IS-A-LABEL? ( a n -- f )   GET-CURRENT SEARCH-WORDLIST DUP IF
        SWAP >BODY  BEGIN  >LFA ['] @ CATCH IF  DROP 0= EXIT
            THEN  ?DUP WHILE  DUP 'LABELS = IF  DROP EXIT
                THEN  REPEAT  0=  THEN ;
@

For NAME: NAME and \textquotedbl{}it is a KNOWN label.\textquotedbl{}
We don't need to define it if there is already a label of that name.
If it has not the value of the program counter we must report a phase
error.

<<KNOWN-LABEL?>>=
: KNOWN-LABEL? ( a n -- a n f )   2DUP IS-A-LABEL? >R
    R@ IF  2DUP GET-CURRENT SEARCH-WORDLIST IF
            EXECUTE _AP_ <> IF  S" ERROR: phase error defining label "
                TYPE  2DUP TYPE  CR
    THEN THEN THEN  R> ;
@


\subsubsection*{ciForth specific}

Make a denotation for labels. They look like '\texttt{\textbf{:LABEL}}'.
Put '\texttt{\textbf{:}}' in the \texttt{\textbf{ONLY}} wordlist,
such that it doesn't interfere with the normal semicolon. A word starting
with a '\texttt{\textbf{:}}' is a label definition denotation. The
part after the '\texttt{\textbf{:}}' may be defined already, but if
it is a label it must have the value of the current program counter.
So it is possible to redefine words as labels (heed the warnings).
This is very tricky, but the assembler programmer must not be restricted
by what words are in Forth. Note: this is actually an abuse of the
denotation mechanism.

<<:PREFIX>>=
'ONLY >WID CURRENT !  \ Making ONLY the CONTEXT is dangerous! This will do.
: : (WORD)
    KNOWN-LABEL? IF 2DROP ELSE 2>R _AP_ 2R> POSTFIX CONSTANT THEN ;
PREFIX IMMEDIATE DEFINITIONS
@


\subsubsection{Handle constant data}

Handle constant data in assembler.

<<constant-data>>=
<<DX-SET>>
<<GET-DX-SET>>
<<C,-DX-SET>>
<<db>>
ALSO ASSEMBLER
<<W,-DX-SET>>
<<dw>>
<<L,-DX-SET>>
<<dl>>
<<(,)>>
<<,-DX-SET>>
<<d>>
PREVIOUS
@

Contains the data on the remainder of the line in reverse order.

<<DX-SET>>=
100 BAG DX-SET    : !DX-SET DX-SET !BAG ;
@

Fill '\texttt{\textbf{DX-SET}}' from the remainder of the line in
reverse order.

<<GET-DX-SET>>=
: GET-DX-SET ( -- )   DEPTH >R
    BEGIN  BL WORD DUP C@  WHILE  FIND IF  EXECUTE  ELSE
            COUNT 0 0 2SWAP >NUMBER 2DROP DROP
        THEN  REPEAT  DROP
    DEPTH R> ?DO  DX-SET BAG+!  LOOP ;
@

Output '\texttt{\textbf{DX-SET}}' as bytes.

<<C,-DX-SET>>=
: C,-DX-SET ( -- )   BEGIN  DX-SET BAG@- AS-C,  DX-SET BAG? 0=  UNTIL ;
@

Add remainder of line to codespace, as bytes.

<<db>>=
: db ( -- )   !DX-SET  GET-DX-SET  C,-DX-SET ;
@

NOTE: The following assumes \texttt{\textbf{(W,)}} and \texttt{\textbf{(L,)}}
are defined in the specific assembler. These must not be commaers,
just lay down 16 or 32 bits entities in the right endian format.

Output '\texttt{\textbf{DX-SET}}' as words (16-bits).

<<W,-DX-SET>>=
: W,-DX-SET ( -- )   BEGIN  DX-SET BAG@- (W,)  DX-SET BAG? 0=  UNTIL ;
@

Add remainder of line to codespace, as words.

<<dw>>=
: dw ( -- )   !DX-SET  GET-DX-SET  W,-DX-SET ;
@

Output '\texttt{\textbf{DX-SET}}' as longs (32-bits)

<<L,-DX-SET>>=
: L,-DX-SET ( -- )   BEGIN  DX-SET BAG@- (L,)  DX-SET BAG? 0=  UNTIL ;
@

Add remainder of line to codespace, as longs (or, mostly, cells).

<<dl>>=
: dl ( -- )   !DX-SET  GET-DX-SET  L,-DX-SET ;
@

Lay down a STRING in assembler memory.

<<(,)>>=
: ($,) ( a n -- )   AS-HERE SWAP DUP AS-ALLOT MOVE ;
@

Output '\texttt{\textbf{DX-SET}}' as longs (32-bits)

<<,-DX-SET>>=
: $,-DX-SET ( -- )
    BEGIN  DX-SET BAG@- DUP 256 0 WITHIN IF
        DX-SET BAG@- ($,)  ELSE  AS-C,  THEN
    DX-SET BAG? 0=  UNTIL ;
@

Add remainder of line to codespace, as strings.

<<d>>=
: d$ ( -- )   !DX-SET  GET-DX-SET  $,-DX-SET ;
: "   [CHAR] " PARSE ;
@


\subsection{Handle labels in disassembly}

Handle labels as far as disassembly is concerned. There is a separate
one for the assembler.

<<labeldis.frt>>=
( $Id: labeldis.frt,v 1.86 2010/06/03 23:27:28 albert Exp $ )
( Copyright{2004}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

[DEFINED] ForCiForth [IF]
    REQUIRE ALIAS    REQUIRE @+    REQUIRE QSORT    REQUIRE EXCHANGE
    REQUIRE BIN-SEARCH    REQUIRE POSTFIX    REQUIRE H. \ In behalf of (DH.)
    REQUIRE 2>R REQUIRE BAG \ Simple bag facility
[THEN]

1000 CONSTANT MAX-LABEL

\ -------------------- INTRODUCTION --------------------------------

<<generic-labels>>
<<names-of-labels>>
<<comment-remainder>>
<<multi-line-comment>>
<<printing-strings>>
<<start-of-line>>
<<disassembly-ranges>>
<<disassemble>>
<<unspecified>>
<<bytes>>
<<words>>
<<longs>>
<<strings>>
<<IGNORE>>
<<.HOW-FIT>>
<<HOW-FIT>>
<<HOW-FIT-END>>
<<DISASSEMBLE-ALL>>

\ ------------------- Generic again -------------------

<<(ADORN-ADDRESS)>>
<<INIT-ALL>>
<<SORT-ALL>>
<<DECOMP-ONE>>
<<DECOMP-ALL>>
<<MAKE-CUL>>
<<SHOW-REGISTER>>
<<DISASSEMBLE-TARGET>>
<<DISASSEMBLE-TARGET-i386>>
<<DEFAULT-DISASSEMBLY>>

ALSO ASSEMBLER

<<ranges>>

DEFINITIONS

<<instructions>>

PREVIOUS DEFINITIONS
@

Ignore addresses in this range. Define range to ignore.

<<IGNORE>>=
' 2DROP DIS: IGNORE ( a1 a2 -- )
: -ignore ( a n -- )   2>R ['] IGNORE 2R> RANGE ;
' -ignore RANGE: -ignore: ( -name- )
: -ignore- ( a n -- )   -warning >R  NONAME$ -ignore  R> +warning ;
@

Print a remark about whether START and END fit.

<<.HOW-FIT>>=
: .HOW-FIT ( a1 a2 -- )   2DUP = IF  2DROP  ELSE  > IF
            S" \ WARNING: This range overlaps with the previous one."  ELSE
            S" \ WARNING: There is hole between this range and the previous one"
    THEN  CR TYPE CR  THEN ;
@

Print a remark about whether start of the current range fits to the
END of the previous range. Leave END of current range for the next
check.

<<HOW-FIT>>=
: HOW-FIT ( a -- a' )   RANGE-START .HOW-FIT  RANGE-END ;
@

Print a remark about whether the END of the previous range is really
the end of the input file.

<<HOW-FIT-END>>=
: HOW-FIT-END ( a -- )   TARGET-END .HOW-FIT ;
@

Disassemble all those ranges with their own disassemblers. No range
will print their end labels, which is no problem if everything fits,
except for the last range. Do that expressly.

<<DISASSEMBLE-ALL>>=
: DISASSEMBLE-ALL ( -- )   TARGET-START  RANGE-LABELS DO-LAB
        I CELL+ @ RANGE-SECTION  HOW-FIT RANGE-DECODE
    LOOP-LAB  HOW-FIT-END   HOST-END CR-ADORNED ;
@

During assembly there is no decision needed whether to have a new
line. Just do new line at ADDRESS, and get the eol-comment, if any.
Revector '\texttt{\textbf{ADORN-ADDRESS}}' used in \textquotedbl{}\texttt{\textbf{asgen.frt}}\textquotedbl{}.

<<(ADORN-ADDRESS)>>=
: (ADORN-ADDRESS)   DUP CR-ADORNED   REMEMBER-COMMENT: ;
' (ADORN-ADDRESS) 'ADORN-ADDRESS !
@

Initialise all registered label classes.

<<INIT-ALL>>=
: INIT-ALL   THE-REGISTER DO-BAG  I @ TO CURRENT-LABELSTRUCT  LABELS !BAG
    LOOP-BAG  INIT-COMMENT: ;
@

Sort all registered label classes.

<<SORT-ALL>>=
: SORT-ALL   THE-REGISTER DO-BAG  I @ TO CURRENT-LABELSTRUCT  SORT-LABELS
    LOOP-BAG ;
@

Decompile all labels of current label class.

<<DECOMP-ONE>>=
: DECOMP-ONE  LAB-UPB 1+ 1 ?DO  I DECOMP  LOOP ;
@

Generate the source of all label classs.

<<DECOMP-ALL>>=
: DECOMP-ALL   THE-REGISTER DO-BAG  I @ TO CURRENT-LABELSTRUCT  DECOMP-ONE
    LOOP-BAG ;
@

Make a full blown cul file from the internal data.

<<MAKE-CUL>>=
: MAKE-CUL  S" HEX" TYPE CR  TARGET-START 8 H.R
    S"  -ORG-" TYPE CR DECOMP-ALL ;
@

Show what type of labels there are.

<<SHOW-REGISTER>>=
: SHOW-REGISTER   THE-REGISTER DO-BAG  I @ %ID.  LOOP-BAG ;
@

Disassemble the current program as stored in the '\texttt{\textbf{CODE-BUFFER}}'.
Using what is known about it.

<<DISASSEMBLE-TARGET>>=
: DISASSEMBLE-TARGET ( -- )   TARGET-START . S"  ORG" TYPE CR
    DISASSEMBLE-ALL ;
@

i386 dependant, should somehow be separated out.

<<DISASSEMBLE-TARGET-i386>>=
-warning
: DISASSEMBLE-TARGET ( -- )   S" [ASM HEX BITS-32" TYPE CR  DISASSEMBLE-TARGET CR ;
+warning
@

This is used to plug holes, where the user doesn't specify how to
disassemble.

<<DEFAULT-DISASSEMBLY>>=
VARIABLE DEFAULT-DISASSEMBLY
' -d$- DEFAULT-DISASSEMBLY !
: -ddef- DEFAULT-DISASSEMBLY @ EXECUTE ;
@


\subsubsection{Generic definition of labels}

Labels are bags of two cell structs, a target address and a pointer
to the payload (mostly a string). They are sorted on target address
for convenience.

<<generic-labels>>=
<<THE-REGISTER>>
<<REALLOC>>
<<REALLOC-POINTER>>
<<LABEL-FIELD>>

<<LABELS[]>>
<<REMOVE-LABEL>>
<<DO-LAB>>
<<.PAY.>>
<<.PAY>>
<<.PAY-DEA>>
<<LABEL-NAME>>
<<.LABELS>>
<<LAB-BOUNDS>>
<<LAB<>>
<<LAB<->>
<<SORT-LABELS>>
<<CONT>>
<<L<>>
<<WHERE-LABEL>>

VARIABLE LABEL-CACHE    \ Index of next label.

<<FIND-LABEL>>
<<>LABEL>>

VARIABLE MAX-DEV-P   -8 MAX-DEV-P !    \ Max deviation acceptable with previous
VARIABLE MAX-DEV-N    8 MAX-DEV-N !    \ Max deviation acceptable with next

<<(~LABEL)>>
<<IMPROVE-LABEL>>
<<~LABEL>>
<<ROLL-LABEL>>
<<NEXT-LABEL>>
@

A bag with the dea's of all labelclasses.

<<THE-REGISTER>>=
100 BAG THE-REGISTER
@

Realloc ADDRESS to new LENGTH, return new ADDRESS. Ignoring old length,
we may copy garbage, too bad.

<<REALLOC>>=
: REALLOC ( u -- a )   HERE >R  DUP ALLOT  R@ SWAP MOVE   R> ;
@

Realloc POINTER to old buffer to new LENGTH. Afterwards pointer points
to new buffer.

<<REALLOC-POINTER>>=
: REALLOC-POINTER ( a n -- )   >R  DUP @ R> REALLOC  SWAP ! ;
@

Define a class for label-like things of length N. A label-like thing
is two cells: address and a payload.

<<LABEL-FIELD>>=
0 VALUE CURRENT-LABELSTRUCT \ current label pointer

: LABEL-FIELD ( u size -- u' )   CREATE  OVER , +
    DOES> ( -- a )   @ CURRENT-LABELSTRUCT + ;

0
    2 CELLS LABEL-FIELD LABEL-RESERVED
    1 CELLS LABEL-FIELD 'CURRENT-LABEL
    1 CELLS LABEL-FIELD 'DECOMP           \ (Re)generate source for INDEX.
    1 CELLS LABEL-FIELD '.PAY             \ Print payload
    1 CELLS LABEL-FIELD 'MAX-LAB
    0 LABEL-FIELD LABELS            \ Return ADDRESS
CONSTANT |LABELSTRUCT|

: CURRENT-LABEL ( -- a )   'CURRENT-LABEL @ ;
: DECOMP ( -- )   'DECOMP @ EXECUTE ;
: .PAY ( -- )   '.PAY @ EXECUTE ;

<<DOUBLE-SIZE>>
<<MAX-LAB>>
<<LAB-UPB>>
<<RELOCATABLE>>

: LABELSTRUCT ( n print gen -- )   SAVE-INPUT  CREATE  HERE DUP >R
    DUP THE-REGISTER BAG+!  |LABELSTRUCT| DUP ALLOT  ERASE
    RESTORE-INPUT THROW  BL WORD $@ $, R@ >NFA !
    CURRENT-LABELSTRUCT R@ >LFA !  R> TO CURRENT-LABELSTRUCT
    DUP 'CURRENT-LABEL !  'DECOMP !  '.PAY !  DUP 'MAX-LAB ! 2* BUILD-BAG
    DOES>  TO CURRENT-LABELSTRUCT ;
@

Remember that from now on two times as much labels are allowed.

<<DOUBLE-SIZE>>=
: DOUBLE-SIZE ( -- )   'MAX-LAB DUP @ 2* SWAP ! ;
@

Return a VARIABLE containing the max labels allowed.

<<MAX-LAB>>=
: MAX-LAB ( -- n )   'MAX-LAB @ ;
@

Return largest INDEX of labels present.

<<LAB-UPB>>=
: LAB-UPB ( -- n )   LABELS |BAG| 2/ ;
@

Add to '\texttt{\textbf{LABELS}}'. Reallocate if the class is full.
6 cells : does> pointer, 4 fields and upperbound of bag. Make label
relocatable and back. Don't use in between!

<<RELOCATABLE>>=
: >RELOCATABLE ( -- )   LABELS DUP @  OVER - SWAP ! ;
: RELOCATABLE> ( -- )   LABELS DUP +! ;
: ?REALLOC? ( -- )
    MAX-LAB LAB-UPB = IF  DOUBLE-SIZE
        >RELOCATABLE  CURRENT-LABEL MAX-LAB 2* 6 + CELLS REALLOC-POINTER
        CURRENT-LABEL EXECUTE   RELOCATABLE>  THEN ;

: LAB+! ( a -- )   LABELS BAG+!  ?REALLOC? ;
@

For I return the ith LABEL . 1 returns the first label. All indices
are compatible with this.

<<LABELS[]>>=
: LABELS[] ( n -- a )   1- 2* CELLS LABELS CELL+ + ;
@

Remove label I.

<<REMOVE-LABEL>>=
: REMOVE-LABEL ( -- )   LABELS[] LABELS  2DUP BAG-REMOVE BAG-REMOVE ;
@

Loop through all '\texttt{\textbf{LABELS}}', similar to '\texttt{\textbf{DO-BAG
.. DO-LOOP}}' but with a stride of 2 cells and the bag built-in.

<<DO-LAB>>=
: DO-LAB   POSTPONE LABELS POSTPONE DO-BAG ; IMMEDIATE
: LOOP-LAB   2 CELLS POSTPONE LITERAL POSTPONE +LOOP ; IMMEDIATE
@

A simple printout of the payload.

<<.PAY.>>=
: .PAY. ( a -- )   CELL+ ? ;
@

Print the payload of the label at ADDRESS , provided it is a string.

<<.PAY>>=
: .PAY$ ( a -- )   CELL+ @ $@ TYPE  3 SPACES ;
@

Print the name of the label at ADDRESS , provided it is a dea. This
applies to plain labels that are in fact constants.

<<.PAY-DEA>>=
: .PAY-DEA ( a -- )   CELL+ @ %ID. ;
@

For label INDEX return the label NAME, provided it is a dea.

<<LABEL-NAME>>=
: LABEL-NAME ( n -- a n )   LABELS[] CELL+ @ >BODY >NFA @ $@ ;
@

Print the addresses and payloads of the labels.

<<.LABELS>>=
: .LABELS ( -- )   DO-LAB  I @ .  I .PAY  CR  LOOP-LAB ;
@

Return LOWER and UPPER indices of the labels, inclusive. The lower
index is 1 and the upper index is corresponding.

<<LAB-BOUNDS>>=
: LAB-BOUNDS ( -- l u )   1 LAB-UPB ;
@

In behalf of qsort. For INDEX1 and INDEX2: \textquotedbl{}the value
of the first label is less than that of the second\textquotedbl{}

<<LAB<>>=
: LAB< ( i1 i2 -- f )   LABELS[] @  SWAP LABELS[] @  SWAP < ;
@

In behalf of qsort. Exchange the labels with INDEX1 and INDEX2 .

<<LAB<->>=
: LAB<-> ( i1 i2 -- )   LABELS[] SWAP LABELS[]  2 CELLS EXCHANGE ;
@

Sort the labels of '\texttt{\textbf{LABELS}}' in ascending order.

<<SORT-LABELS>>=
: SORT-LABELS ( -- )   LAB-BOUNDS  ['] LAB<  ['] LAB<->  QSORT ;
@

In behalf of bin-search. Comparant.

<<CONT>>=
VARIABLE CONT
@

In behalf of bin-search. For INDEX1 : \textquotedbl{}the value of
the label is less than '\texttt{\textbf{CONT}}'\textquotedbl{}

<<L<>>=
: L< ( n -- f )   LABELS[] @  CONT @ < ;
@

Find where ADDRESS belongs in a sorted array. Return the INDEX. If
address is already present, its index is returned. This may be outside,
if it is larger than any.

<<WHERE-LABEL>>=
: WHERE-LABEL ( a -- )   CONT !  LAB-BOUNDS 1+  ['] L<  BIN-SEARCH ;
@

Find the first label that is equal to (or greater than) VALUE. Return
INDEX or zero if not found. Put it in the label-cache too. Note '\texttt{\textbf{BIN-SEARCH}}'
returns the non-inclusive upper bound if not found.

<<FIND-LABEL>>=
: FIND-LABEL ( n -- )   WHERE-LABEL  DUP LAB-UPB 1+ <> AND  DUP LABEL-CACHE ! ;
@

Find ADDRESS in the label table. Return table ADDRESS of an exact
matching label or zero if not found.

<<>LABEL>>=
: >LABEL ( a -- )   DUP >R  FIND-LABEL DUP IF  LABELS[] DUP @  R@ <> IF
    DROP 0  THEN THEN
    R> DROP ;
@

Find ADDRESS in the label table. Return INDEX of an approximately
matching label or zero if not found.

<<(~LABEL)>>=
: (~LABEL)   DUP MAX-DEV-P @ + FIND-LABEL
    DUP 0= IF 2DROP 0 ELSE
        OVER MAX-DEV-N @ + OVER LABELS[] @  < IF 2DROP 0 ELSE
    SWAP DROP THEN THEN ;
@

For ADDRESS and INDEX return ADDRESS and INDEX where the deviation
is minimal.

<<IMPROVE-LABEL>>=
: IMPROVE-LABEL
    BEGIN  DUP LAB-UPB <> IF  2DUP 1+ LABELS[] @ < 0=  ELSE  0  THEN
    WHILE  1+  REPEAT ;
@

Find target ADDRESS in the label table. Return table ADDRESS of an
approximately matching label, or zero if not found, plus the OFFSET.

<<~LABEL>>=
: ~LABEL   DUP (~LABEL) DUP 0= IF  2DROP 0 0
    ELSE  IMPROVE-LABEL  LABELS[] SWAP OVER @ -  THEN ;
@

Roll the last label to place INDEX. A label occupies two consecutive
places!

<<ROLL-LABEL>>=
: ROLL-LABEL   DUP   LABELS[]  DUP LABELS BAG-HOLE   LABELS BAG-HOLE
    LAB-BOUNDS SWAP DROP   LAB<->   -2 CELLS LABELS  +! ;
@

FIXME: The following is dead code. (As is \texttt{\textbf{LABEL-CACHE}}).
Return the next label or 0.

<<NEXT-LABEL>>=
: NEXT-LABEL   LABEL-CACHE @   DUP IF
        1+ DUP LAB-BOUNDS + = IF DROP 0 THEN
    DUP LABEL-CACHE ! THEN ;
@


\subsubsection{Names of labels}

<<names-of-labels>>=
<<.EQU>>
<<EQU-LABELS>>
<<LABELED>>
<<LABEL>>
<<=EQU-LABEL>>
<<.EQU-ALL>>
<<ADORN-WITH-LABEL>>

HEX FFFF0000 CONSTANT LARGE-NUMBER-MASK

<<.0?>>
<<SMART.>>
<<.~LABEL>>

DECIMAL
VARIABLE SMALL-LABEL-LIMIT   100 SMALL-LABEL-LIMIT !

<<.LABEL/.>>

\D 0 SMALL-LABEL-LIMIT !
\D 12 LABEL AAP
\D 5 LABEL NOOT
\D 2 LABEL MIES
\D 123 LABEL POPI

\D .LABELS CR
\D SORT-LABELS
\D .LABELS CR

\D 200 FIND-LABEL . CR
\D 12 FIND-LABEL  LABELS[] .PAY CR
\D 12 1- FIND-LABEL  LABELS[] .PAY CR
\D 12 >LABEL .PAY CR
\D 12 1- >LABEL H. CR
\D 12 ADORN-WITH-LABEL  4 <?> CR  \ Should give zero, not found!
\D 12 0 HOST>TARGET - ADORN-WITH-LABEL  CR

<<@LABEL>>
<<LABEL=>>
<<REMOVE-TRIVIAL>>
<<CLEAN-LABELS>>
@

Decompile label INDEX.

<<.EQU>>=
: .EQU    LABELS[] DUP @ 8 H.R S"  LABEL " TYPE  CELL+ @ %ID. CR ;
@

Contains equ labels, i.e. classes as associate with '\texttt{\textbf{LABEL}}'.

<<EQU-LABELS>>=
MAX-LABEL ' .PAY-DEA ' .EQU LABELSTRUCT EQU-LABELS  LABELS !BAG
@

Generate a equ label at (target) ADDRESS with NAME, this can be any
symbolic constant in fact. The payload is the dea of a constant leaving
that address.

<<LABELED>>=
: LABELED ( x a n -- )   S" CREATE " PAD $!  PAD COUNT + OVER
    2SWAP PAD $+!  PAD $@ EVALUATE  HERE >R  'LABELS @ , ( >LFA )
    R@ 'LABELS !  HERE 2 CELLS + , ( >NFA )  ROT DUP , ( >DATA )
    -ROT $, DROP  EQU-LABELS  LAB+!  R> LAB+!
    DOES> ( -- x )   >DATA @ ;
@

Generate a equ label at (target) ADDRESS with \textquotedbl{}NAME\textquotedbl{}.
Like '\texttt{\textbf{LABEL}}'.

<<LABEL>>=
: LABEL   BL WORD COUNT LABELED ;
: EQU LABEL ;
@

For host ADDRESS return an associated equ LABEL or 0. CAVEAT: if there
are more than one label for the same addres, just the first one is
returned.

<<=EQU-LABEL>>=
: =EQU-LABEL   HOST>TARGET  EQU-LABELS >LABEL ;
@

For host ADDRESS print all labels at that addres, return the NUMBER
of labels printed.

<<.EQU-ALL>>=
: .EQU-ALL   HOST>TARGET  EQU-LABELS   0 ( no labels printed) SWAP
    LAB-UPB 1+ OVER WHERE-LABEL ?DO
        DUP I LABELS[] @ <> IF LEAVE THEN
        SWAP 1+ SWAP
        [CHAR] : EMIT I LABELS[] .PAY
    LOOP DROP ;
@

Adorn the ADDRESS we are currently disassembling with a named label
if any.

<<ADORN-WITH-LABEL>>=
: ADORN-WITH-LABEL   .EQU-ALL    0= IF 12 SPACES THEN ;
@

Prevent leading hex letter for NUMBER by printing a zero.

<<.0?>>=
: .0?   DUP 0A0 100 WITHIN SWAP 0A 10 WITHIN OR IF [CHAR] 0 EMIT THEN ;
@

Print a NUMBER in hex in a smart way.

<<SMART.>>=
: SMART.   DUP ABS 100 < IF DUP .0? . ELSE
    LARGE-NUMBER-MASK OVER AND IF 8 ELSE 4 THEN H.R SPACE THEN ;
@

For label INDEX and OFFSET print the label with offset.

<<.~LABEL>>=
: .~LABEL   SWAP .PAY   ?DUP IF
    DUP 0< IF NEGATE . S" - " TYPE ELSE . S" + " TYPE THEN THEN ;
@

Print X as a symbolic label if possible, else as a number.

<<.LABEL/.>>=
: .LABEL/.   EQU-LABELS
    DUP ABS SMALL-LABEL-LIMIT @ < IF SMART.
    ELSE DUP ~LABEL OVER IF .~LABEL DROP
    ELSE 2DROP SMART.
    THEN THEN ;
@

For label INDEX , return its XT.

<<@LABEL>>=
: @LABEL    LABELS[] CELL+ @ ;

\D 5 DUP INVENT-NAME LABELED
\D SORT-LABELS .LABELS 5 <?> CR
\D .LABELS 6 <?> CR
\D S" EXPECT 5: " TYPE 5 FIND-LABEL @LABEL >DATA @ . 7 <?> CR
@

For labels INDEX1 and INDEX2 return \textquotedbl{}they are equal\textquotedbl{}.

<<LABEL=>>=
: LABEL=   @LABEL >DATA @   SWAP @LABEL >DATA @   = ;

\D S" EXPECT -1:" TYPE 5 FIND-LABEL DUP 1+ LABEL= . CR
@

Get rid of a label with INDEX if trivial . Return next INDEX to try.

<<REMOVE-TRIVIAL>>=
: REMOVE-TRIVIAL   DUP @LABEL DUP >DATA @ SWAP >NFA @ $@ INVENTED-NAME? IF
        DUP REMOVE-LABEL ELSE 1+ THEN ;

\D 5 FIND-LABEL  DUP REMOVE-TRIVIAL .  REMOVE-TRIVIAL .
\D .LABELS 8 <?> CR
@

Get rid of superfluous equ labels

<<CLEAN-LABELS>>=
: CLEAN-LABELS   EQU-LABELS
    2 BEGIN DUP LAB-UPB < WHILE DUP DUP 1- LABEL= >R DUP DUP 1+ LABEL= R> OR IF
            REMOVE-TRIVIAL ELSE 1+ THEN REPEAT DROP ;

\D 5 DUP INVENT-NAME LABELED  SORT-LABELS
\D .LABELS 9 <?> CR
\D CLEAN-LABELS
\D .LABELS 10 <?> CR
@


\subsubsection{Comment remainder of line}

Comment till remainder of line.

<<comment-remainder>>=
<<.COMMENT:>>
<<COMMENT:-LABELS>>
<<COMMENT:>>
<<COMMENT:-TO-BE>>
<<INIT-COMMENT:>>
<<PRINT-OLD-COMMENT:>>
<<REMEMBER-COMMENT:>>

\D .LABELS CR
\D SORT-LABELS
\D .LABELS CR

\D 200 FIND-LABEL . CR
\D 12 FIND-LABEL  LABELS[] .PAY CR
\D 12 1- FIND-LABEL  LABELS[] .PAY CR
\D 12 >LABEL .PAY CR
\D 12 1- >LABEL H. CR
@

Decompile comment: label INDEX.

<<.COMMENT:>>=
: .COMMENT:   LABELS[] DUP @ 8 H.R S"  COMMENT: " TYPE  CELL+ @ $@ TYPE CR ;
@

Contains comment labels, i.e. classes as associate with '\texttt{\textbf{COMMENT:}}'

<<COMMENT:-LABELS>>=
MAX-LABEL ' .PAY$ ' .COMMENT: LABELSTRUCT COMMENT:-LABELS  LABELS !BAG
@

Generate a comment label at ADDRESS. A pointer to the remainder of
the line is the payload.

<<COMMENT:>>=
: COMMENT:   COMMENT:-LABELS   LAB+!  [CTRL] J PARSE $, LAB+! ;

\D 12 COMMENT: AAP
\D 115 COMMENT: NOOTJE
\D 2 COMMENT: MIES
\D 123 COMMENT: POPI
@

Remember the comment at the end of this instruction. Zero means no
comment.

<<COMMENT:-TO-BE>>=
VARIABLE COMMENT:-TO-BE
@

Initialise to no comment.

<<INIT-COMMENT:>>=
: INIT-COMMENT:   0 COMMENT:-TO-BE ! ;
  INIT-COMMENT:
@

Print comment at the end of previous instruction.

<<PRINT-OLD-COMMENT:>>=
: PRINT-OLD-COMMENT:   COMMENT:-TO-BE @ DUP IF
    S" \ " TYPE   $@ TYPE _ THEN DROP
    INIT-COMMENT: ;
@

Remember what comment to put after the disassembly of ADDRESS.

<<REMEMBER-COMMENT:>>=
: REMEMBER-COMMENT:   COMMENT:-LABELS   HOST>TARGET >LABEL
    DUP IF CELL+ @ COMMENT:-TO-BE ! _ THEN DROP  ;

\D 12 REMEMBER-COMMENT: PRINT-OLD-COMMENT: CR  \ Should give nothing, not found!
\D 12 0 HOST>TARGET - REMEMBER-COMMENT: PRINT-OLD-COMMENT: CR
@


\subsubsection{Multi-line comments}

Multiple line comment/command in front.

<<multi-line-comment>>=
<<.MDIRECTIVE>>
<<MCOMMENT-LABELS>>
<<NEW-DIRECTIVE>>
<<OLD-DIRECTIVE>>
<<DIRECTIVE>>
<<COMMENT>>
<<PRINT-DIRECTIVE>>

\D .LABELS CR
\D SORT-LABELS
\D .LABELS CR

\D 200 FIND-LABEL . CR
\D 12 FIND-LABEL  LABELS[] .PAY CR
\D 12 1- FIND-LABEL  LABELS[] .PAY CR
\D 12 >LABEL .PAY CR
\D 12 1- >LABEL H. CR
@

Decompile mcomment label INDEX. Duplicate the line heading on each
line of output.

<<.MDIRECTIVE>>=
: .MDIRECTIVE   LABELS[] DUP @ DUP >R 8 H.R S"  :COMMENT " TYPE
    CELL+ @ $@  BEGIN  2DUP 10 SCAN ?DUP
    WHILE  1 /STRING 2SWAP 2OVER NIP - 1- 2 /STRING TYPE CR
        R@ 8 H.R S"  :COMMENT " TYPE
    REPEAT  R> 2DROP 2 /STRING TYPE CR ;
@

Contains multiple line comment labels, i.e. classes associate with
'\texttt{\textbf{COMMENT}}'

<<MCOMMENT-LABELS>>=
MAX-LABEL ' .PAY$ ' .MDIRECTIVE LABELSTRUCT MCOMMENT-LABELS  LABELS !BAG
@

New directive STRING at ADDRESS. (See '\texttt{\textbf{DIRECTIVE}}').
Primitive, doesn't keep it sorted.

<<NEW-DIRECTIVE>>=
: NEW-DIRECTIVE ( a n x -- )   LAB+! $, LAB+! ;
@

Directive STRING to old ADDRESS. Append. (See '\texttt{\textbf{DIRECTIVE}}').

<<OLD-DIRECTIVE>>=
: OLD-DIRECTIVE ( a n -- )   >LABEL CELL+ DUP >R
    @ $@ PAD $!  [CTRL] J PAD $C+  PAD $+!  PAD $@ $, R> ! ;
@

Make STRING the command in front of label at ADDRESS. A pointer to
this string the payload. If there is already a directive there, this
one is appended. Keep things sorted.

<<DIRECTIVE>>=
: DIRECTIVE ( a n x -- )   MCOMMENT-LABELS >R
    R@ >LABEL IF   R@ OLD-DIRECTIVE   ELSE
    R@ NEW-DIRECTIVE   R@ WHERE-LABEL ROLL-LABEL THEN R> DROP ;
@

Make STRING the comment in front of label at ADDRESS. A pointer to
this string the payload.

<<COMMENT>>=
: COMMENT ( a n x -- )   >R  S" \ " $,  DUP >R  OVER ALLOT  $+!
    R> $@  R> DIRECTIVE ;
: :COMMENT ( x -line- )   [CTRL] J PARSE $, $@ ROT COMMENT ;

\D S" AAP" 12 COMMENT
\D S" NOOT" 5 COMMENT
\D S" MIES" 2 COMMENT
\D S" POPI
\ \D JOPI"
\D 123 COMMENT
@

Print comment for instruction at ADDRESS , if any.

<<PRINT-DIRECTIVE>>=
: PRINT-DIRECTIVE MCOMMENT-LABELS  HOST>TARGET  >LABEL DUP IF
    CR   .PAY _ THEN DROP ;

\D 12 PRINT-DIRECTIVE CR  \ Should give nothing, not found!
\D 12 0 HOST>TARGET - PRINT-DIRECTIVE CR
@


\subsubsection{Printing strings}

The special printing of strings.

<<printing-strings>>=
[DEFINED] ForCiForth [IF]
    REQUIRE NEW-IF
[THEN]

<<TABLE2>>
<<IS-CTRL>>
<<IS-PRINT>>
<<ACCU>>
<<.ACCU>>
<<.C>>

\ FIXME: to be renamd in WHERE-FLUSH
VARIABLE NEXT-CUT       \ Host address where to separate db etc. in chunks.
VARIABLE CUT-SIZE    16 CUT-SIZE !   \ Chunks for data-disassembly.

<<ACCU-C+>>
@

Contains a printing indicator:

\begin{tabular}{|c|c|c|c|}
\hline 
 & description & syntax & example\tabularnewline
\hline 
\hline 
0 & as hex & 8A & \tabularnewline
\hline 
1 & control character & \textasciicircum{}J & \tabularnewline
\hline 
2 & a blank & BL & \textquotedbl{}xxx xxx\textquotedbl{}\tabularnewline
\hline 
3 & normal printable & \&Z & \textquotedbl{}xxxZxxx\textquotedbl{}\tabularnewline
\hline 
\end{tabular} 

<<TABLE2>>=
CREATE TABLE2 256 ALLOT      TABLE2 256 ERASE
: /TABLE2 [CHAR] ~ 1 + BL 1 + DO 3 TABLE2 I + C! LOOP ;
/TABLE2
2 BL TABLE2 + C!
1 CTRL I TABLE2 + C!
1 CTRL J TABLE2 + C!
1 CTRL M TABLE2 + C!
1 CTRL L TABLE2 + C!
@

For CHAR: \textquotedbl{}it is control\textquotedbl{}

<<IS-CTRL>>=
: IS-CTRL   TABLE2 + C@ 1 = ;

\D S" EXPECT 0 -1 :" TYPE CHAR A IS-CTRL .   CTRL J IS-CTRL . CR 11 <?>
@

For CHAR: \textquotedbl{}it is printable\textquotedbl{}.

<<IS-PRINT>>=
: IS-PRINT   TABLE2 + C@ 1 > ;

\D S" EXPECT 0 -1 -1 :" TYPE CTRL A IS-PRINT .
\D CHAR A IS-PRINT . BL IS-PRINT . CR 12 <?>
@

Accumulates characters that may form a string.

<<ACCU>>=
CREATE ACCU 100 ALLOT           ACCU 100 ERASE

\ \D S" Expect " TYPE  """ AA""""AA """ TYPE CHAR : EMIT " AA""AA " S" $" TYPE CR 13 <?>
@

Print the accumulated chars, if any.

<<.ACCU>>=
: .ACCU   ACCU $@
    OVER C@ BL = OVER 1 = AND IF  2DROP  S"  BL" TYPE  ELSE
        DUP 1 > IF  SPACE [CHAR] " EMIT SPACE TYPE [CHAR] " EMIT  ELSE
            IF  SPACE [CHAR] " EMIT SPACE C@ EMIT [CHAR] " EMIT  ELSE  DROP
    THEN THEN THEN  0 0 ACCU $! ;

\D S" EXPECT " TYPE  S" XY :" TYPE  S" XY" ACCU $! .ACCU CR 14 <?>
\D S" EXPECT BL :" TYPE   S"  " ACCU $!   .ACCU CR 15 <?>
\D S" EXPECT CHAR Y :" TYPE   S" Y" ACCU $!   .ACCU CR 16 <?>
@

Display a BYTE in clean hex. Display the non-printable character.

<<.C>>=
: .B-CLEAN   DUP .0? 0 <# BL HOLD #S #> TYPE ;
: .C   .ACCU SPACE DUP IS-CTRL IF  S" CTRL " TYPE  [CHAR] @ + EMIT
    ELSE  .B-CLEAN  THEN  ;

\D S" EXPECT CTRL J :" TYPE  CTRL J .C CR 17 <?>
\D S" EXPECT 0: " TYPE  0 .C CR 18 <?>
\D S" EXPECT 9A: " TYPE  HEX 9A .C CR 19 <?> DECIMAL
\D S" EXPECT 0FA: " TYPE  HEX FA .C CR 20 <?> DECIMAL
@

For ADDR of a (printable) char, add it to the accumulated range. Force
an immediate flush, if the range is full. Otherwise postpone the flush
at least one char. If the character following is a string ender, this
is a desirable place to break. (String enders like \textasciicircum{}J
and 0 are not printable.)

<<ACCU-C+>>=
: ACCU-$C+   DUP C@ ACCU $C+   ACCU @ 64 = IF 1+ ELSE 2 + THEN NEXT-CUT ! ;
@


\subsubsection{Start of line}

Things to print at the start of a line.

<<start-of-line>>=
<<.TARGET-ADDRESS>>
<<CR-ADORNED>>
<<NEXT-CUT?>>
<<CR+GENERIC>>
<<CR+dx>>
@

Print the ADDRES as target address in hex.

<<.TARGET-ADDRESS>>=
: .TARGET-ADDRESS S" ( " TYPE DUP HOST>TARGET 8 H.R S"  )   " TYPE ;
@

Start a new line, with printing the decompiled ADDRESS as seen.

<<CR-ADORNED>>=
: CR-ADORNED
    PRINT-OLD-COMMENT:
    DUP PRINT-DIRECTIVE
    CR 'ADORN-ADDRESS 2@ - IF  .TARGET-ADDRESS  THEN
    ADORN-WITH-LABEL ;
@

For ADDRESS: \textquotedbl{}it is at next cut.\textquotedbl{} If so,
advance.

<<NEXT-CUT?>>=
: NEXT-CUT?   NEXT-CUT @ =  DUP IF CUT-SIZE @ NEXT-CUT +! THEN ;
@

For ADDRESS and assembler directive STRING (such \textquotedbl{}\texttt{\textbf{db}}\textquotedbl{}),
interrupt the laying down of memory classes by a new line and possibly
a label, when appropriate.

<<CR+GENERIC>>=
: CR+GENERIC   2>R DUP =EQU-LABEL >R DUP NEXT-CUT?   R> OR IF
    DUP CR-ADORNED  2R@ TYPE THEN REMEMBER-COMMENT: 2R> 2DROP ;

: CR+$         2>R DUP =EQU-LABEL >R DUP NEXT-CUT?   R> OR IF .ACCU
    DUP CR-ADORNED  2R@ TYPE THEN REMEMBER-COMMENT: 2R> 2DROP ;
@

For ADDRESS : interupt byte display.

<<CR+dx>>=
: CR+dn   S"   " CR+GENERIC ;
: CR+db   S"   db " CR+GENERIC ;
: CR+dw   S"   dw " CR+GENERIC ;
: CR+dl   S"   dl " CR+GENERIC ;
: CR+d$   S"   d$ " CR+$ ;
@


\subsubsection{Disassembly ranges}

A 'range' is defined here as a range of addresses that is kept together,
even during relocation and such, and contains data for the same type.
A 'section' is defined here as a range of addresses that is kept together,
even during relocation and such, where data need not be of the same
type. 'Disassembly' is to be understood as interpreting the content
of a range, not necessarily as executable code. Range ADDRESS1 ..
ADDRESS2 always refers to a target range, where address2 is exclusive.

<<disassembly-ranges>>=
0 VALUE CURRENT-RANGE \ current range pointer

<<RANGE-FIELD>>

0
    2 CELLS RANGE-FIELD RANGE-RESERVED
    1 CELLS RANGE-FIELD 'RANGE-START      \ Start of range
    1 CELLS RANGE-FIELD 'RANGE-END        \ End of range
    1 CELLS RANGE-FIELD 'RANGE-STRIDE     \ For the moment = 1 FIXME!
    1 CELLS RANGE-FIELD 'RANGE-XT
    1 CELLS RANGE-FIELD 'RANGE-SECTION
CONSTANT |RANGE|

: RANGE-START ( -- a )   'RANGE-START @ ;
: RANGE-END! ( a -- )   'RANGE-END ! ;
: RANGE-END ( -- a )   'RANGE-END @ ;
: RANGE-STRIDE ( -- n )   'RANGE-STRIDE @ ;
: RANGE-XT ( -- xt )   'RANGE-XT @ ;
: RANGE-DECODE ( -- )   'RANGE-XT @ >R RANGE-START RANGE-END R> EXECUTE ;
: RANGE-SECTION ( a -- )   TO CURRENT-RANGE
    'RANGE-SECTION @ TO CURRENT-SECTION ;
<<.PAY-RANGE>>

20 BAG RANGE-TYPES  \ Contains dea of dumper, creator, alternating.

<<ARE-COUPLED>>
<<CREATOR-XT>>
<<MAKE-CURRENT>>
<<DECOMP-RANGE>>
<<RANGE-LABELS>>
<<RANGE>>

0 VALUE DISASSEMBLERS
0 VALUE RANGE-RANGES

0
    2 CELLS DEA-FIELD DEA-RESERVED
    1 CELLS DEA-FIELD >DIS:
CONSTANT |DISASSEMBLER|

<<DIS:>>
<<RANGE:>>
@

Define a range.

<<RANGE-FIELD>>=
: RANGE-FIELD ( u size -- u' )   CREATE  OVER , +
    DOES> ( -- a )   @ CURRENT-RANGE + ;
@

Print the range LAB as a matter of testing.

<<.PAY-RANGE>>=
: .PAY-RANGE   CELL+ @ DUP RANGE-SECTION
    RANGE-START 8 H.R SPACE  RANGE-END 8 H.R  S"  BY " TYPE
    RANGE-XT >BODY %ID.  %ID. ;
@

DEA of dump belongs to DEA of creator. Add to '\texttt{\textbf{RANGE-TYPES}}'.

<<ARE-COUPLED>>=
: ARE-COUPLED   >BODY SWAP >BODY  RANGE-TYPES BAG+! RANGE-TYPES BAG+! ;
@

For current range, return the XT of a proper defining word.

<<CREATOR-XT>>=
: CREATOR-XT   RANGE-XT >BODY RANGE-TYPES BAG-WHERE CELL+ @ ;
@

Make range I current, provided the payload is a dea.

<<MAKE-CURRENT>>=
: MAKE-CURRENT ( n -- )   LABELS[] CELL+ @ RANGE-SECTION ;
@

Display range INDEX in a reconsumable form. Shortens the \texttt{\textbf{NONAME}}
ranges with a ``\texttt{\textbf{-}}'' replacing the ``\texttt{\textbf{:}}''
at the end of the type name.

<<DECOMP-RANGE>>=
: DECOMP-RANGE   MAKE-CURRENT RANGE-START 8 H.R SPACE RANGE-END 8 H.R SPACE
    CURRENT-RANGE >NFA @ $@  CREATOR-XT >NFA @ $@
    2OVER S" NONAME" COMPARE 0= IF
        1- TYPE ." - "  2DROP
    ELSE  TYPE SPACE  TYPE
    THEN  CR ;
@

Contains range specification, limits plus type.

<<RANGE-LABELS>>=
MAX-LABEL ' .PAY-RANGE ' DECOMP-RANGE LABELSTRUCT RANGE-LABELS  LABELS !BAG
@

Create a disassembly range from AD1 to AD2 using dis-assembler DEA1
with or without a name. Register it as a labeled range.

<<RANGE>>=
: RANGE ( ad1 ad2 dea1 a n -- )   S" CREATE " PAD $!  PAD COUNT + OVER
    2SWAP PAD $+!  PAD $@ EVALUATE  HERE DUP >R  |RANGE| DUP ALLOT  ERASE
    $, R@ >NFA !  CURRENT-RANGE R@ >LFA !  R> TO CURRENT-RANGE
    'RANGE-XT !  1 'RANGE-STRIDE !  'RANGE-END !  'RANGE-START !
    RANGE-LABELS  RANGE-START LAB+!  CURRENT-RANGE LAB+!
    CURRENT-SECTION 'RANGE-SECTION !
    DOES>  RANGE-SECTION ;

: ANON-RANGE ( ad1 ad2 dea1 -- )   -warning >R  NONAME$ RANGE  R> +warning ;
@
<<DIS:>>=
: DIS: ( xt -- )   SAVE-INPUT  CREATE  HERE DUP >R  |DISASSEMBLER| DUP
    ALLOT  ERASE  RESTORE-INPUT THROW  BL WORD $@ $, R@ >NFA !
    DISASSEMBLERS R@ >LFA !  R@ >DIS: !  R> TO DISASSEMBLERS
    DOES> ( a1 a2 -- )   >R TARGET>HOST SWAP TARGET>HOST
        DUP NEXT-CUT !  R> >DIS: @ EXECUTE ;
@
<<RANGE:>>=
: RANGE: ( xt -- )   SAVE-INPUT  CREATE  HERE DUP >R  |DISASSEMBLER| DUP
    ALLOT  ERASE  RESTORE-INPUT THROW  BL WORD $@ $, R@ >NFA !
    RANGE-RANGES R@ >LFA !  R@ >DIS: !  R> TO RANGE-RANGES
    DOES> ( a1 a2 -- )   >R BL WORD COUNT  R> >DIS: @ EXECUTE ;
@


\subsubsection{Disassemble}

<<disassemble>>=
<<(D-R-T)>>
<<D-R-T>>
<<-dc>>
<<-dc:>>
<<-dc->>
' D-R-T  ' -dc:  ARE-COUPLED
@

Disassemble to ADDRESS2 from ADDRESS1.

<<(D-R-T)>>=
: (D-R-T) ( a2 a1 -- )   SWAP DISASSEMBLE-RANGE ;
@

Disassemble from target ADDRESS1 to ADDRESS2.

<<D-R-T>>=
' (D-R-T) DIS: D-R-T ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 is code with name NAME.

<<-dc>>=
: -dc ( a n -- )   2>R ['] D-R-T 2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 is code with name \textquotedbl{}name\textquotedbl{}.

<<-dc:>>=
' -dc RANGE: -dc: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous code range.

<<-dc->>=
: -dc- ( a n -- )   -warning >R  NONAME$ -dc  R> +warning ;
@


\subsubsection{Dump unspecified content}

<<unspecified>>=
<<(DUMP-N)>>
<<DUMP-N>>
<<-dn>>
<<-dn:>>
<<-dn->>
' DUMP-N  ' -dn:  ARE-COUPLED
@

Dump storage with unspecified content to ADDRESS2 from ADDRESS1.

<<(DUMP-N)>>=
: (DUMP-N) ( a2 a1 -- )   DUP CR+dn - .LABEL/. S"  RESB" TYPE CR   ;
@

Dump such from target ADDRESS1 to ADDRESS2 where only address1 may
be adorned with with a label.

<<DUMP-N>>=
' (DUMP-N) DIS: DUMP-N ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 are such with name NAME.

<<-dn>>=
: -dn ( a n -- )   2>R ['] DUMP-N 2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 are such with name \textquotedbl{}name\textquotedbl{}.

<<-dn:>>=
' -dn RANGE: -dn: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous such range.

<<-dn->>=
: -dn- ( a n -- )   -warning >R  NONAME$ -dn  R> +warning ;
@


\subsubsection{Dump bytes}

<<bytes>>=
<<(DUMP-B)>>
<<DUMP-B>>
<<-db>>
<<-db:>>
<<-db->>
' DUMP-B  ' -db:  ARE-COUPLED \ Register the decompiler.
@

Dump bytes from target ADDRESS1 to ADDRESS2 plain.

<<(DUMP-B)>>=
: (DUMP-B) ( a2 a1 -- )   DO  I DUP CR+db C@ .B-CLEAN  LOOP     PRINT-OLD-COMMENT: CR ;
@

Dump bytes from target ADDRESS1 to ADDRESS2 adorned with labels.

<<DUMP-B>>=
' (DUMP-B) DIS: DUMP-B ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 are bytes with name NAME.

<<-db>>=
: -db ( a n -- )   2>R ['] DUMP-B 2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 are bytes with name \textquotedbl{}name\textquotedbl{}.

<<-db:>>=
' -db RANGE: -db: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous byte range.

<<-db->>=
: -db- ( a n -- )   -warning >R  NONAME$ -db  R> +warning ;
@


\subsubsection{Dump words}

<<words>>=
<<W.>>
<<(DUMP-W)>>
<<DUMP-W>>
<<-dw>>
<<-dw:>>
<<-dw->>
' DUMP-W  ' -dw:  ARE-COUPLED
@

Print X as a word (4 hex digits).

<<W.>>=
: W. 4 H.R SPACE ;
@

Dump words to ADDRESS1 from ADDRESS2, plain.

<<(DUMP-W)>>=
: (DUMP-W) ( a2 a1 -- )   DO  I DUP CR+dw @ W.  2 +LOOP
    PRINT-OLD-COMMENT: CR ;
@

Dump words from target ADDRESS1 to ADDRESS2 adorned with labels.

<<DUMP-W>>=
' (DUMP-W) DIS: DUMP-W ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 are words with name NAME.

<<-dw>>=
: -dw ( a n -- )   2>R ['] DUMP-W 2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 are words with name \textquotedbl{}name\textquotedbl{}.

<<-dw:>>=
' -dw RANGE: -dw: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous word range.

<<-dw->>=
: -dw- ( a n -- )   -warning >R  NONAME$ -dw  R> +warning ;
@


\subsubsection{Dump longs}

<<longs>>=
<<(DUMP-L)>>
<<DUMP-L>>
<<-dl>>
<<-dl:>>
<<-dl->>
' DUMP-L  ' -dl:  ARE-COUPLED
@

Dump longs to ADDRESS1 from ADDRESS2, plain.

<<(DUMP-L)>>=
: (DUMP-L) ( a2 a1 -- )   DO  I DUP CR+dl @ .LABEL/.  4 +LOOP
    PRINT-OLD-COMMENT: CR ;
@

Dump words from target ADDRESS1 to ADDRESS2 adorned with labels.

<<DUMP-L>>=
' (DUMP-L) DIS: DUMP-L ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 are longs with name NAME.

<<-dl>>=
: -dl ( a n -- )   2>R ['] DUMP-L 2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 are longs with name \textquotedbl{}name\textquotedbl{}.

<<-dl:>>=
' -dl RANGE: -dl: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous long range.

<<-dl->>=
: -dl- ( a n -- )   -warning >R  NONAME$ -dl  R> +warning ;
@


\subsubsection{Dump strings}

<<strings>>=
<<(DUMP-)>>
<<DUMP->>
<<-d>>
<<-d:>>
<<-d->>
' DUMP-$  ' -d$:  ARE-COUPLED
@

Print all chars to ADDR1 from ADDR2 appropriately. Try to combine,
playing with the next flush.

<<(DUMP-)>>=
: (DUMP-$) ( a2 a1 -- )
    DO  I CR+d$
        I C@ IS-PRINT   IF I ACCU-$C+ ELSE I C@ .C THEN
    LOOP  .ACCU   PRINT-OLD-COMMENT: CR ;

\D 'ADORN-ADDRESS @  'ADORN-ADDRESS RESTORED  HERE
\D S" AAP" $, DROP CTRL J C, CTRL M C, CHAR A C, CHAR A C, BL C, CHAR P C,
\D 0 C, 1 C, BL C, 2 C, 3 C,
\D HERE
\D S" EXPECT  ``3 0 0 0 'AAP' XX ^J ^M 'AA P' 0 1 BL 2 3 '':" TYPE
\D SWAP (DUMP-$) CR  'ADORN-ADDRESS !  22 <?>
@

Dump words from target ADDRESS1 to ADDRESS2 adorned with labels.

<<DUMP->>=
' (DUMP-$) DIS: DUMP-$ ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 are longs with name NAME.

<<-d>>=
: -d$ ( a n -- )   2>R ['] DUMP-$ 2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 are longs with name \textquotedbl{}name\textquotedbl{}.

<<-d:>>=
' -d$ RANGE: -d$: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous long range.

<<-d->>=
: -d$- ( a n -- )   -warning >R  NONAME$ -d$  R> +warning ;
@


\subsubsection{Ranges}

\texttt{\textbf{asi386}} dependant part, does it belong here?

Not yet definitions, these thingies must be visible in the disassembler.

<<ranges>>=
<<(D-R-T-16)>>
<<D-R-T-16>>
<<-dc16>>
<<-dc16:>>
<<-dc16->>

' D-R-T-16  ' -dc16:  ARE-COUPLED
@

Disassemble from target ADDRESS1 to ADDRESS2 as 16 bit.

<<(D-R-T-16)>>=
: (D-R-T-16) ( a2 a1 -- )   BITS-16 CR S" BITS-16" TYPE  SWAP DISASSEMBLE-RANGE
    BITS-32 CR S" BITS-32" TYPE ;
@

Disassemble from target ADDRESS1 to ADDRESS2.

<<D-R-T-16>>=
' (D-R-T-16) DIS: D-R-T-16 ( a1 a2 -- )
@

Range ADDRESS1 .. ADDRESS2 is 16-bit code with name NAME.

<<-dc16>>=
: -dc16 ( a n -- )   2>R ['] D-R-T-16   2R> RANGE ;
@

Range ADDRESS1 .. ADDRESS2 is 16-bit code with name \textquotedbl{}name\textquotedbl{}.

<<-dc16:>>=
' -dc16 RANGE: -dc16: ( -name- )
@

Range ADDRESS1 .. ADDRESS2 is an anonymous 16-bit code-range.

<<-dc16->>=
: -dc16- ( a n -- )   -warning >R  NONAME$ -dc16  R> +warning ;
@


\subsubsection{Instructions}

<<instructions>>=
<<AS-@+>>
<<AS-S-@+>>
<<LATEST-OFFSET>>
<<.COMMA-LABEL>>
<<ID.-NO()>>
<<NEXT-INSTRUCTION>>
<<GET-OFFSET>>
<<GOAL-RB>>
<<.BRANCH/.>>
<<.COMMA-REL>>
<<UNCONDITIONAL-TRANSFERS>>
<<JUMPS>>
@

DEA is a commaer. Fetch proper DATA from autoincremented '\texttt{\textbf{AS-POINTER}}'

<<AS-@+>>=
: AS-@+ ( xt -- )   >CNT @ >R  AS-POINTER @ R@ MC@  R> AS-POINTER +! ;

\D HEX
\D S" EXPECT 34 12 " TYPE 1234 PAD ! PAD AS-POINTER !
\D ' IB, >BODY DUP AS-@+ . AS-@+ . CR 23 <?>
\D DECIMAL
@

DEA is a commaer. Fetch proper signed DATA from autoincremented '\texttt{\textbf{AS-POINTER}}'

<<AS-S-@+>>=
: AS-S-@+ ( xt -- )   >CNT @ >R  AS-POINTER @ R@ MC@-S  R> AS-POINTER +! ;

\D HEX
\D S" EXPECT -1 12 " TYPE 12FF PAD ! PAD AS-POINTER !
\D ' IB, >BODY DUP AS-S-@+ . AS-S-@+ . CR
\D DECIMAL
@

This is kept up to date during disassembly. It is useful for the code
crawler.

<<LATEST-OFFSET>>=
VARIABLE LATEST-OFFSET
@

Print a disassembly, for a commaer DEA , taking into account labels,
(suitable for e.g. the commaer '\texttt{\textbf{IX,}}').

<<.COMMA-LABEL>>=
: .COMMA-LABEL   DUP AS-@+ .LABEL/. %ID. ;
@

For DEA print the name without the surrounding brackets.

<<ID.-NO()>>=
: ID.-NO() ( xt -- )   >NFA @ $@  2 - SWAP 1 + SWAP TYPE SPACE ;
@

Assuming the disassembly sits at the offset of a relative branch assembled
by commaer DEA , return the host space ADDRESS of the next instruction.

<<NEXT-INSTRUCTION>>=
: NEXT-INSTRUCTION  >CNT @ AS-POINTER @ + ;
@

Assuming the disassembly sits at the offset of a relative branch assembled
by commaer DEA , return that OFFSET.

<<GET-OFFSET>>=
: GET-OFFSET   AS-POINTER @ SWAP >CNT @ MC@-S DUP LATEST-OFFSET ! ;
@

For the commaer DEA return ADDRESS in host space that is the target
of the current relative jump.

<<GOAL-RB>>=
: GOAL-RB   DUP GET-OFFSET SWAP NEXT-INSTRUCTION + ;
@

For the relative branch commaer DEA print the target ADDRESS as a
symbolic label if possible else print the branch offset, followed
by an appropriate commaer for each case.

<<.BRANCH/.>>=
: .BRANCH/.  EQU-LABELS   ~LABEL OVER IF .~LABEL ID.-NO() ELSE
    2DROP DUP GET-OFFSET . %ID. THEN  ;
@

Print a disassembly for a relative branch DEA. This relies on the
convention that the commaer that consumes an absolute address has
the name of that with a relative address surrounded with brackets.

<<.COMMA-REL>>=
: .COMMA-REL
    DUP  DUP GOAL-RB HOST>TARGET  .BRANCH/.
    >CNT @ AS-POINTER +! ;

\D 5 .LABEL/. CR
\D 5 .LABEL/. CR
\D ' (RB,) >BODY ID.-NO() CR

' .COMMA-LABEL  ' OW,   >BODY >DIS !  ( obligatory word     )
' .COMMA-REL    ' (RL,) >BODY >DIS !  ( cell relative to IP )
' .COMMA-REL    ' (RW,) >BODY >DIS !  ( cell relative to IP )
' .COMMA-REL    ' (RB,) >BODY >DIS !  ( byte relative to IP )
' .COMMA-LABEL  ' SG,   >BODY >DIS !  (  Segment: WORD      )
' .COMMA-LABEL  ' P,    >BODY >DIS !  ( port number ; byte     )
' .COMMA-LABEL  ' IS,   >BODY >DIS !  ( Single -obl-  byte )
' .COMMA-LABEL  ' IL,   >BODY >DIS !  ( immediate data : cell)
' .COMMA-LABEL  ' IW,   >BODY >DIS !  ( immediate data : cell)
' .COMMA-LABEL  ' IB,   >BODY >DIS !  ( immediate byte data)
' .COMMA-LABEL  ' L,    >BODY >DIS !  ( immediate data : address/offset )
' .COMMA-LABEL  ' W,    >BODY >DIS !  ( immediate data : address/offset )
' .COMMA-LABEL  ' B,    >BODY >DIS !  ( immediate byte : address/offset )
@

Contains all instruction that represent an unconditional transfer
of control. It may be followed by data instead of code.

<<UNCONDITIONAL-TRANSFERS>>=
0 BAG UNCONDITIONAL-TRANSFERS
    ' CALL, , ' CALLFAR, , ' CALLFARO, , ' CALLO, , ' INT, , ' INT3, , ' INTO, ,
    ' IRET, , ' JMP, , ' JMPFAR, , ' JMPFARO, , ' JMPO, , ' JMPS, , ' RET+, ,
    ' RET, , ' RETFAR+, , ' RETFAR, ,
HERE UNCONDITIONAL-TRANSFERS ! 100 CELLS ALLOT         \ Allow to put more here
@

Contains all instructions that represent intra-segment jumps.

<<JUMPS>>=
0 BAG JUMPS
    ' CALL, , ' J, , ' JCXZ, , ' JMP, , ' JMPS, , ' J|X, ,
    ' LOOP, , ' LOOPNZ, , ' LOOPZ, ,
HERE JUMPS ! 100 CELLS ALLOT         \ Allow to put more here
@


\subsection{Crawler}

Crawling is the process of following jumps to determine code space.

<<crawl.frt>>=
( $Id: crawl.frt,v 1.36 2009/03/26 09:07:17 albert Exp $ )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
( Uses Richard Stallmans convention. Uppercased word are parameters.    )

[DEFINED] ForCiForth [IF]
    REQUIRE H.
    REQUIRE BAG
[THEN]

<<INSERT-EQU>>
<<INSERT-EQU-INVENT>>
<<?INSERT-EQU?>>

HEX

RANGE-LABELS LABELS !BAG
4FE 510 -dc-
520 530 -dc: oops
530 570 -dc-
560 590 -db: bytes

: TEST-RANGES
    assert( LABELS |BAG| 8 = )
; TEST-RANGES

DECIMAL

<<COMPATIBLE?>>
<<RANGE-NAME>>
<<NEW-RANGE-START>>
<<NEW-RANGE-END>>
<<REPLACE>>
<<SAME-ALIGN>>
<<END+START>>
<<OVERLAP?>>
<<OVERLAP-OR-BORDER?>>
<<GAP?>>
<<IS-NAMED>>
<<COLLAPSE>>
<<TRIM-RANGE>>
<<COMBINE>>
<<KILL-OVERLAP>>
<<FILL-GAP>>
<<CLEANUP-RANGES>>
<<PLUG-FIRST>>
<<PLUG-LAST>>
<<PLUG-SPECIAL>>
<<PLUG-HOLES>>

ALSO ASSEMBLER

<<STARTERS>>
<<REQUIRED-XT>>
<<NORMAL-DISASSEMBLY>>
<<IN-CURRENT-CODE?>>
<<IN-CODE-N?>>
<<IN-CODE?>>
<<KNOWN-CODE?>>
<<IN-CODE-SPACE?>>
<<STARTER?>>
<<JUMP-TARGET>>
<<ANALYSE-INSTRUCTION>>
<<COLLAPSE[I1]>>
<<INSERT-RANGE>>
<<CRAWL-ONE>>
<<?CRAWL-ONE?>>
<<(CRAWL)>>
<<CRAWL>>
<<dl-range>>
<<CRAWL16>>

PREVIOUS
@

Insert the equ-label ADDRESS1 with an NAME. If equ labels was sorted,
it remains so.

<<INSERT-EQU>>=
: INSERT-EQU 2>R DUP EQU-LABELS WHERE-LABEL SWAP 2R> LABELED
    ROLL-LABEL ;
@

Insert the equ-label ADDRESS1 with an invented name. If equ labels
was sorted, it remains so.

<<INSERT-EQU-INVENT>>=
: INSERT-EQU-INVENT DUP INVENT-NAME INSERT-EQU ;
@

Add target ADDRESS to the equ labels if it is not there. Invent a
name.

<<?INSERT-EQU?>>=
: ?INSERT-EQU?    EQU-LABELS DUP >LABEL IF DROP ELSE INSERT-EQU-INVENT THEN ;

EQU-LABELS LABELS !BAG

HEX

: TEST-?INSERT-EQU?
    assert( EQU-LABELS LABELS |BAG| 0= )
    42 ?INSERT-EQU?
    assert( EQU-LABELS LABELS |BAG| 2 = )
    42 ?INSERT-EQU?
    assert( EQU-LABELS LABELS |BAG| 2 = )
; TEST-?INSERT-EQU?

DECIMAL
@

For range INDEX : \textquotedbl{}it is of the same type as the previous
one\textquotedbl{}.

<<COMPATIBLE?>>=
: COMPATIBLE?   DUP MAKE-CURRENT RANGE-XT   SWAP 1- MAKE-CURRENT RANGE-XT  = ;

: TEST-COMPATIBLE?
    assert( 2 COMPATIBLE? -1 = )
    assert( 3 COMPATIBLE? -1 = )
    assert( 4 COMPATIBLE? 0= )
; TEST-COMPATIBLE?
@

Get the name of range INDEX.

<<RANGE-NAME>>=
: RANGE-NAME LABELS[] CELL+ @ >NFA @ $@ ;

: TEST-RANGE-NAME
    assert( 1 RANGE-NAME S" NONAME" COMPARE 0= )
    assert( 2 RANGE-NAME S" oops" COMPARE 0= )
; TEST-RANGE-NAME
@

For a collapsible pair of range with INDEX1 and INDEX2 return INDEX1
and INDEX2 plus a new START for the combined range.

<<NEW-RANGE-START>>=
: NEW-RANGE-START OVER MAKE-CURRENT RANGE-START  OVER MAKE-CURRENT RANGE-START
    MIN ;

HEX

: TEST-NEW-RANGE-START
    assert( 2 3 NEW-RANGE-START NIP NIP 520 = )
; TEST-NEW-RANGE-START

DECIMAL
@

For a collapsible pair of range with INDEX1 and INDEX2 return INDEX1
and INDEX2 plus a new END for the combined range.

<<NEW-RANGE-END>>=
: NEW-RANGE-END OVER MAKE-CURRENT RANGE-END  OVER MAKE-CURRENT RANGE-END
    MAX ;

HEX

: TEST-NEW-RANGE-END
    assert( 3 4 NEW-RANGE-END NIP NIP 590 = )
; TEST-NEW-RANGE-END

DECIMAL
@

Replace the two ranges INDEX1 and INDEX2 with the last range. Place
it at index1 (which has the correct start address).

<<REPLACE>>=
: REPLACE  OVER >R REMOVE-LABEL REMOVE-LABEL R> ROLL-LABEL ;

: TEST-REPLACE
   assert( LABELS |BAG| 2 3 REPLACE LABELS |BAG| - 4 = )
; TEST-REPLACE
@

This looks like a proper design.
\begin{itemize}
\item sort on the start address, type (disassembler) and end address.
\item start with the last range and work down until the second.
\item if it overlaps with or borders at the previous one and has the same
type and alignment, and the second one is not named collapse the ranges.
\item if it overlaps with the previous one and has the same type and alignment,
and the second one is named, trim the first range.
\item if it overlaps with the previous and has different type, issue warning.
\item if it has a gap, introduce a character range. This may lead to an
extra range, one less range, or no change in the number of ranges,
but only at or after the current range.
\item As a last action, introduce extra ranges at the beginning and end.
\end{itemize}
This leads to words: \texttt{\textbf{SAME-TYPE}} \texttt{\textbf{SAME-ALIGN}}
\texttt{\textbf{OVERLAP}} \texttt{\textbf{BORDER}} \texttt{\textbf{GAP}}
\texttt{\textbf{IS-NAMED}}.

For range INDEX: \textquotedbl{}It has the same type and alignment
as the previous one.\textquotedbl{}

<<SAME-ALIGN>>=
: SAME-ALIGN    DUP MAKE-CURRENT  RANGE-START SWAP
    1- MAKE-CURRENT   RANGE-START - RANGE-STRIDE MOD 0= ;

HEX

INIT-ALL RANGE-LABELS
12 34 -dc-
34 65 -db: AAP
38 80 -dl-
82 90 -dl-
88 94 -dl-

DECIMAL

: TEST-SAME-ALIGN
    assert( 2 SAME-ALIGN -1 = )
    assert( 3 SAME-ALIGN -1 = ) \ Must become 0
    assert( 4 SAME-ALIGN -1 = )
; TEST-SAME-ALIGN
@

For range INDEX return END of previous, START of this one,

<<END+START>>=
: END+START DUP MAKE-CURRENT RANGE-START SWAP 1- MAKE-CURRENT RANGE-END SWAP ;

HEX

: TEST-END+START
    assert( 2 END+START 34 = SWAP 34 = AND )
    assert( 3 END+START 38 = SWAP 65 = AND )
; TEST-END+START

DECIMAL
@

Range INDEX overlaps with previous one.

<<OVERLAP?>>=
: OVERLAP? END+START > ;

: TEST-OVERLAP?
    assert( 2 OVERLAP? 0= )
    assert( 3 OVERLAP? -1 = )
    assert( 4 OVERLAP? 0= )
; TEST-OVERLAP?
@

Range INDEX overlaps or borders with the previous one.

<<OVERLAP-OR-BORDER?>>=
: OVERLAP-OR-BORDER? END+START >= ;

: TEST-OVERLAP-OR-BORDER?
    assert( 2 OVERLAP-OR-BORDER? -1 = )
    assert( 3 OVERLAP-OR-BORDER? -1 = )
    assert( 4 OVERLAP-OR-BORDER? 0= )
; TEST-OVERLAP-OR-BORDER?
@

Range INDEX has a gap with the previous one.

<<GAP?>>=
: GAP? END+START < ;

: TEST-GAP?
    assert( 2 GAP? 0 = )
    assert( 3 GAP? 0= )
    assert( 4 GAP? -1 = )
; TEST-GAP?
@

For range INDEX: \textquotedbl{}It has a name\textquotedbl{}

<<IS-NAMED>>=
: IS-NAMED ( n -- )   RANGE-NAME NONAME$ $= 0= ;

: TEST-IS-NAMED
    assert( 2 IS-NAMED -1 = )
    assert( 3 IS-NAMED 0= )
; TEST-IS-NAMED
@

Collapse range I into the previous range, that determines the properties.

<<COLLAPSE>>=
: COLLAPSE ( i -- )   DUP MAKE-CURRENT  RANGE-END OVER 1- MAKE-CURRENT
    RANGE-END MAX RANGE-END!  REMOVE-LABEL ;

HEX

: TEST-COLLAPSE
    assert( LAB-UPB 5 = ) 5 COLLAPSE 4 MAKE-CURRENT
    assert( RANGE-START 82 = )
    assert( RANGE-END 94 = )
    assert( LAB-UPB 4 = )
; TEST-COLLAPSE

DECIMAL
@

Trim the range previous to INDEX, such that it borders to range index.

<<TRIM-RANGE>>=
: TRIM-RANGE ( i -- )   DUP MAKE-CURRENT  RANGE-START SWAP 1- MAKE-CURRENT
    RANGE-END! ;

HEX

90 1000 -dl-

: TEST-TRIM-RANGE
    5 TRIM-RANGE 4 MAKE-CURRENT
    assert( RANGE-START 82 = ) assert( RANGE-END 90 = )
; TEST-TRIM-RANGE

DECIMAL
@

Combine range INDEX with the previous one.

<<COMBINE>>=
: COMBINE ( n -- )
    DUP OVERLAP-OR-BORDER? OVER IS-NAMED 0= AND IF DUP COLLAPSE THEN
    DUP OVERLAP? OVER IS-NAMED AND IF DUP TRIM-RANGE THEN  DROP ;

HEX

INIT-ALL
10  30 -dl-
20  40 -dl-
30  50 -dl: aap0
60  80 -dl-
90 100 -dl: noot

: TEST-COMBINE
    assert( LAB-UPB 5 = ) 5 COMBINE assert( LAB-UPB 5 = )
    assert( LAB-UPB 5 = ) 4 COMBINE assert( LAB-UPB 5 = )
    assert( LAB-UPB 5 = ) 3 COMBINE assert( LAB-UPB 5 = )
    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 30 = )
    assert( LAB-UPB 5 = ) 2 COMBINE assert( LAB-UPB 4 = )
    1 MAKE-CURRENT assert( RANGE-START 10 = ) assert( RANGE-END 30 = )
; TEST-COMBINE

DECIMAL
@

Combine range INDEX with a previous overlapping or bordering range.

<<KILL-OVERLAP>>=
: KILL-OVERLAP ( i -- )   DUP SAME-ALIGN  OVER COMPATIBLE? AND IF
        DUP COMBINE  THEN  DROP ;

HEX

INIT-ALL
10  30 -dl-
20  40 -dl-
30  50 -dl: aap1
60  80 -dl-
90 100 -dl: noot1

: TEST-KILL-OVERLAP-1
    assert( LAB-UPB 5 = ) 5 KILL-OVERLAP assert( LAB-UPB 5 = )
    assert( LAB-UPB 5 = ) 4 KILL-OVERLAP assert( LAB-UPB 5 = )
    assert( LAB-UPB 5 = ) 3 KILL-OVERLAP assert( LAB-UPB 5 = )
    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 30 = )
    assert( LAB-UPB 5 = ) 2 KILL-OVERLAP assert( LAB-UPB 4 = )
    1 MAKE-CURRENT assert( RANGE-START 10 = ) assert( RANGE-END 30 = )
; TEST-KILL-OVERLAP-1

INIT-ALL
10  30 -dl-
20  28 -db-
30  70 -dl: aap2
60  80 -dl-
7F 10F -dl-

\ The following is actually wrong because the aligning is not tested yet.
: TEST-KILL-OVERLAP-2
    assert( LAB-UPB 5 = ) 5 KILL-OVERLAP assert( LAB-UPB 4 = )
    4 MAKE-CURRENT assert( RANGE-START 60 = ) assert( RANGE-END 10F = )
    assert( LAB-UPB 4 = ) 4 KILL-OVERLAP assert( LAB-UPB 3 = )
    3 MAKE-CURRENT assert( RANGE-START 30 = ) assert( RANGE-END 10F = )
    assert( LAB-UPB 3 = ) 3 KILL-OVERLAP assert( LAB-UPB 3 = )
    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 28 = )
    assert( LAB-UPB 3 = ) 2 KILL-OVERLAP assert( LAB-UPB 3 = )
    1 MAKE-CURRENT assert( RANGE-START 10 = ) assert( RANGE-END 30 = )
; TEST-KILL-OVERLAP-2

DECIMAL
@

Introduce char range to fill the gap at INDEX. Note that the result
is unordered.

<<FILL-GAP>>=
: FILL-GAP ( i -- )   DUP GAP? IF   DUP END+START -ddef-
        DUP 1+ LAB-UPB MAX KILL-OVERLAP
        DUP KILL-OVERLAP  THEN  DROP ;

HEX

: TEST-FILL-GAP
    assert( LAB-UPB 3 = ) 3 FILL-GAP assert( LAB-UPB 4 = )
    4 MAKE-CURRENT assert( RANGE-START 28 = ) assert( RANGE-END 30 = )
    assert( LAB-UPB 4 = ) 2 FILL-GAP assert( LAB-UPB 4 = )
    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 28 = )
; TEST-FILL-GAP

DECIMAL
@

Clean up the range labels, from behind. Although the bounds may not
be valid after a clean up, this works because a clean up of a range
only concerns higher ranges, no longer considered. So a range can
comfortably be removed using the regular removal mechanism for bags.
A newly introduced range automatically falls into place, because of
the conditions regarding the start addresses.

<<CLEANUP-RANGES>>=
: CLEANUP-RANGES ( -- )   RANGE-LABELS
    2 LAB-UPB 2DUP <= IF  DO  I KILL-OVERLAP  -1 +LOOP  THEN ;
@

Plug a hole at the first range.

<<PLUG-FIRST>>=
: PLUG-FIRST ( -- )   1 MAKE-CURRENT
    TARGET-START RANGE-START 2DUP <> IF
        -ddef- _ _  THEN  2DROP ;
@

Plug a hole at the last range.

<<PLUG-LAST>>=
: PLUG-LAST ( -- )   LAB-UPB MAKE-CURRENT
    RANGE-END TARGET-END 2DUP <> IF
        -ddef- _ _  THEN  2DROP ;
@

If there are no ranges at all, make the buffer into a default range.
Else check last and first ranges. Note that plugging results in a
change of the number of ranges, interfering with other plugging.

<<PLUG-SPECIAL>>=
: PLUG-SPECIAL ( -- )   LAB-UPB IF  PLUG-LAST PLUG-FIRST  ELSE
    TARGET-START TARGET-END -ddef-  THEN ;
@

Fill any holes with character ranges.

<<PLUG-HOLES>>=
: PLUG-HOLES ( -- )   CURRENT-SECTION  RANGE-LABELS LAB-UPB 1+ 2
    2DUP > IF  DO  I FILL-GAP  LOOP  ELSE  2DROP  THEN
    SORT-LABELS  PLUG-SPECIAL  SORT-LABELS
    TO CURRENT-SECTION ;
@

Jump targets that are starting points for further crawling. Adding
and removing from this bag ressembles a recursive action. Recursion
will not do here! This is because ranges are not added until the end
is detected.

<<STARTERS>>=
1000 BAG STARTERS
@

Required xt. Return the XT that is required for the current disassembly.

<<REQUIRED-XT>>=
VARIABLE (R-XT)
: REQUIRED-XT (R-XT) @ ;
@

Specify normal disassembly.

<<NORMAL-DISASSEMBLY>>=
: NORMAL-DISASSEMBLY ['] D-R-T (R-XT) ! BITS-32 ;
  NORMAL-DISASSEMBLY
@

The following are auxiliary words for '\texttt{\textbf{KNOWN-CODE?}}'
mainly. For all those range labels must be current and sorted. Prepend
'\texttt{\textbf{RANGE-LABELS}}' if you want to use the auxiliary
words.

For ADDRESS : \textquotedbl{}it is in a current code range\textquotedbl{}

<<IN-CURRENT-CODE?>>=
: IN-CURRENT-CODE? ( -- f )   RANGE-START RANGE-END WITHIN
    RANGE-XT REQUIRED-XT =  AND ;
@

For ADDRESS and range number N: \textquotedbl{}address SITS in code
range n\textquotedbl{}

<<IN-CODE-N?>>=
: IN-CODE-N? ( i -- f ) MAKE-CURRENT IN-CURRENT-CODE? ;
@

For ADDRESS and range I : \textquotedbl{}It is code and address is
part of it, or same holds for previous range.\textquotedbl{}

<<IN-CODE?>>=
: IN-CODE?  DUP 0 = IF 2DROP 0 ELSE   \ Not present.
        2DUP IN-CODE-N? IF 2DROP -1 ELSE
            DUP 1 = IF 2DROP 0 ELSE   \ Previous not present.
                1- IN-CODE-N? THEN THEN THEN ;
@

For ADDRESS: \textquotedbl{}It is known code, according to '\texttt{\textbf{RANGE-LABELS}}'\textquotedbl{}.

<<KNOWN-CODE?>>=
: KNOWN-CODE?   RANGE-LABELS DUP WHERE-LABEL LAB-UPB MIN IN-CODE? ;
@

For ADDRESS : \textquotedbl{}it falls within the binary image\textquotedbl{}

<<IN-CODE-SPACE?>>=
: IN-CODE-SPACE?   TARGET-START TARGET-END WITHIN ;
@

For ADDRESS: \textquotedbl{}It is usable as a new starter\textquotedbl{}.

<<STARTER?>>=
: STARTER?   DUP KNOWN-CODE? 0=  SWAP IN-CODE-SPACE? AND ;
@

Return the target ADDRESS of the current instruction. It must be a
jump of course.

<<JUMP-TARGET>>=
: JUMP-TARGET   AS-POINTER @   LATEST-OFFSET @  + HOST>TARGET ;
@

Analyse current instruction after disassembly. \texttt{\textbf{DISS}}
\texttt{\textbf{LATEST-INSTRUCTION}} \texttt{\textbf{ISS}} \texttt{\textbf{ISL}}
are all valid.

<<ANALYSE-INSTRUCTION>>=
: ANALYSE-INSTRUCTION   LATEST-INSTRUCTION @ JUMPS IN-BAG? IF
    JUMP-TARGET DUP ?INSERT-EQU?
    STARTER? IF JUMP-TARGET STARTERS SET+ THEN THEN ;
@

Collapse the label at INDEX with the next and or previous labels.

<<COLLAPSE[I1]>>=
: COLLAPSE[I1] RANGE-LABELS
    DUP LAB-UPB < IF DUP 1+ KILL-OVERLAP THEN
    DUP 1 > IF DUP KILL-OVERLAP THEN
    DROP ;

HEX
LABELS !BAG
4FE 520 -dc-
520 530 -dc: oops1
52A 570 -dc-
560 590 -db: bytes1
DECIMAL

: TEST-COLLAPSE[I1]
    assert( LABELS |BAG| 2 COLLAPSE[I1] LABELS |BAG| - 2 = )
; TEST-COLLAPSE[I1]
@

Add the information that ADDRESS1 to ADDRESS2 is a code range. If
range labels was sorted, it remains so.

<<INSERT-RANGE>>=
: INSERT-RANGE   OVER RANGE-LABELS WHERE-LABEL >R
    REQUIRED-XT ANON-RANGE   R@ ROLL-LABEL   R> COLLAPSE[I1] ;
@

Analyse the code range from ADDRESS up to an unconditional transfer.
Add information about jumps to '\texttt{\textbf{STARTERS}}' and new
ranges to '\texttt{\textbf{LABELS}}'.

<<CRAWL-ONE>>=
: CRAWL-ONE  DUP >R TARGET>HOST BEGIN
        (DISASSEMBLE) ANALYSE-INSTRUCTION DUP HOST-END >=
        LATEST-INSTRUCTION @ UNCONDITIONAL-TRANSFERS IN-BAG? OR
    UNTIL R> SWAP HOST>TARGET INSERT-RANGE ;
@

Analyse code from ADDRESS , unless already known.

<<?CRAWL-ONE?>>=
: ?CRAWL-ONE? DUP STARTER? IF CRAWL-ONE _ THEN DROP ;
@

Crawl through code from all points in '\texttt{\textbf{STARTERS}}'.

<<(CRAWL)>>=
: (CRAWL)   BEGIN STARTERS BAG? WHILE STARTERS BAG@- ?CRAWL-ONE? REPEAT ;
@

ADDRESS points into code. Crawl through code from there, i.e. add
all information about code ranges that can be derived from that.

<<CRAWL>>=
: CRAWL   DUP ?INSERT-EQU?   RANGE-LABELS SORT-LABELS
    STARTERS DUP !BAG BAG+!   SHUTUP (CRAWL) ;
@

INTEL 80386 specific. There is a need to specify the disassembly xt.
Crawl with normal disassembly (observing '\texttt{\textbf{TALLY-BA}}')
resp. Crawl through 16 / 32 bits code. The other owns change it all
the time.

<<CRAWL16>>=
: CRAWL16  ['] D-R-T-16 (R-XT) ! BITS-16 CRAWL NORMAL-DISASSEMBLY ;
@


\subsubsection{DL range}

<<dl-range>>=
<<NEW-LABEL?>>
<<ADD-L-LABELS>>
<<ALL-L-LABELS>>
@

For ADDR create a label if it points in the target space.

<<NEW-LABEL?>>=
: NEW-LABEL? ( a -- )   DUP PLAUSIBLE-LABEL? IF  ?INSERT-EQU? _  THEN  DROP ;
@

For dl-range from ADDR1 to ADDR2 add all plausible labels found in
data.

<<ADD-L-LABELS>>=
: ADD-L-LABELS ( l h -- )   SWAP DO  I L@ NEW-LABEL?  0 CELL+ +LOOP ;
@

For all dl-ranges add all plausible labels.

<<ALL-L-LABELS>>=
: ALL-L-LABELS ( -- )   CURRENT-SECTION  RANGE-LABELS DO-LAB
        I CELL+ @ RANGE-SECTION  RANGE-XT ['] DUMP-L = IF
            RANGE-START RANGE-END ADD-L-LABELS  THEN
    LOOP-LAB  TO CURRENT-SECTION ;
@


\section{Extracting code}

A script for converting this document to PDF form follows:

<<final>>=
lyx -e pdf cfasdis.lyx
@
<<*>>=
echo "Extract script cfasdis.frt from cfasdis.lyx..."
rm -f cfasdis.nw
lyx -e literate cfasdis.lyx
notangle -Rcfasdis.frt cfasdis.nw > cfasdis
chmod a+x cfasdis
@

Each of these scripts can be pulled out manually given the default
\texttt{\textbf{{*}}} script defined above.
\end{document}
