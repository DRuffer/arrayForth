\ color4th.af

   18 code{ 
:# ns 258
:# nblk 1440
:# nc 8 { cr }
 ( colorforth v3.4k1+ g144/1.10 chuck moore ) { cr }
 [ d# 20 load d# 22 load d# 24 load ] ( colors ) [ d# 28 load ] { cr }
 ( decompress ) [ mark d# 30 load restore empt ]
: env [ d# 34 ] winver 2* + ; [ env ] ( ironmental ) [ load d# 46 load
   d# 62 d# 4 loads d# 88 load ] { br }
: dump d# 48 load ; ( background dump )
: floppy d# 52 load ; ( format, archive, set video )
: icons d# 54 load ; ( edit chars )
: c-a-c d# 70 ; ( ascii )
: audit d# 90 load ; ( disk audit utility )
: png d# 168 load ; ( png file format )
: html d# 176 load ; ( html file write ) { br }
 ( blocks 0-143 are public domain software ) { cr }
 [ mark empty ] ( arrayforth ) [ d# 144 load ] }block

   19 shadow{  ( compile x86 colorforth )
: ns ( number of sectors compressed if neg, ) { cr }
 ( last compressed if pos. )
: nblk ( number of uncompressed blocks. )
: nc ( no. of compressed cylinders, deprecated ) { cr }
 [ these vars must be first things in block! ] { br }
: dump ( compile memory display background task )
: icons ( compile icon editor )
: png ( screen image to file )
: ---
: editor
: sct [ yrg* ] ( all-caps cap lower-case yellow red green * toggles shadow
   comment block )
: fj [ ludr ] ( find jump left up down right )
: .. [ -mc+ ] ( dec-block magenta cyan inc-block )
: x.i ( delete exit insert )
: . ( jump jumps between -edited- blocks )
: f ( finds next word from ) [ find word ] }block

   20 code{  [ macro ]
: swap h# 168B 2, H# C28B0689 , ;
: 0 < ?dup > h# C031 2, ;
: if h# 74 2, here ;
: -if h# 79 2, here ;
: while ( n-nn ) < if > swap ;
: -while ( n-nn ) < -if > swap ;
: a < ?dup > h# C28B 2, ;
: a! ?lit if h# BA 1, , ; then h# D08B 2, < drop > ;
: 2* h# E0D1 2, ; [ forth ]
: a, 2* 2* , ; [ macro ]
: @ ?lit if < ?dup > h# 58B 2, a, ; then h# 85048B 3, 0 , ;
: ! ?lit if ?lit if h# 5C7 2, swap a, , ; then h# 589 2, a, < drop > ;
   then < a! > h# 950489 3, 0 , < drop > ;
: nip h# 4768D 3, ;
: + ?lit if h# 5 1, , ; then h# 603 2, < nip > ;
: or h# 633
: binary ?lit if swap d# 2 + 1, , ; then 2, < nip > ;
: and h# 623 < binary > ;
: u+ ?lit if h# 681 2, , ; then h# 44601 3, < drop > ;
: ? ?lit h# A9 1, , ;
: over < ?dup > h# 4468B 3, ; }block

   21 shadow{  ( pentium macros' 1, 2, 3, , compile 1-4 bytes )
: drop ( lodsd, flags unchanged, why sp is in esi - in kernel )
: then ( fix address - in kernel )
: swap ( sp xchg )
: 0 ( 0 0 xor, macro 0 identical to number 0 )
: if ( jz, flags set, max 127 bytes, leave address )
: -if ( jns, same )
: a ( 2 0 mov, never used? )
: a! ( 0 2 mov, unoptimized )
: 2* ( shift left )
: a, ( compile word address )
: @/! ( fetch/store from/to word address, or eax )
: nip swap drop
: +/or/and ( number or sp with eax )
: u+ ( add to 2nd number, number or sp )
: ? ( test bits, set flags, literal only! )
: over ( sp 4 + @ ) }block

   22 code{  ( macros )
: push ?lit if h# 68 1, , ; then h# 50 1, < drop > ;
: pop < ?dup > h# 58 1, ;
: - h# D0F7 2, ;
: *end swap
: end h# EB
: loop 1, here - + 1, ;
: until h# 74 < loop > ;
: -until h# 79 < loop > ;
: for < push begin > ;
: *next swap
: next H# 75240CFF
: 0next , here - + 1, h# 4C483 3, ;
: -next H# 79240CFF < 0next > ;
: i < ?dup > h# 24048B 3, ;
: +! ?lit if ?lit if h# 581 2, swap a, , ; then h# 501 2, a, < drop >
   ; then < a! > h# 950401 3, 0 , < drop > ;
: nop h# 90 1, ;
: align here - d# 3 and drop if < nop align > ; then ;
: or! < a! > h# 950409 3, 0 , < drop > ;
: * h# 6AF0F 3, < nip > ;
: */ h# C88B 2, < drop > H# F9F72EF7 , < nip > ;
: /mod < swap > h# 99 1, H# 16893EF7 , ;
: / < /mod nip > ;
: mod < /mod drop > ; }block

   23 shadow{ 
: push ( lit to sp; eax to sp )
: pop ( sp to eax )
: - ( ones-complement )
: begin -a ( current code address - byte )
: while a-aa ( if-escape from any structure usage example begin xxx while
   xxx next xxx then )
: for n ( push count onto return stack, ) begin
: *next aa-aa ( swap ) for ( and ) if ( addresses )
: next a ( decrement count, jnz to ) for, ( pop return stack when done )
: -next a ( same, jns - loop includes 0 )
: i -n ( copy loop index to data stack )
: *end aa-aa ( swap ) end ( and ) if ( addresses )
: end a ( jmp to ) begin
: +! na ( add to memory, 2 literals optimized )
: align ( next call to end on word boundary )
: or! na ( inclusive-or to memory, unoptimized )
: * mm-p ( 32-bit product )
: */ mnd-q ( 64-bit product, then quotient )
: /mod nd-rq ( remainder and quotient )
: / nd-q ( quotient )
: mod nd-r ( remainder ) }block

   24 code{  ( compiled macros )
: 2/ h# F8D1 2, ;
: time < ?dup > h# 310F 2, ;
: 7push h# 57 1, ;
: 7pop h# 5F 1, ; [ forth ]
: @ @ ; { -cr }
: ! ! ; { -cr }
: + + ; { -cr }
: - - ;
: */ */ ; { -cr }
: * * ; { -cr }
: / / ; { -cr }
: 2/ 2/ ;
: dup dup ; { -cr }
: drop drop ; { -cr }
: nip nip ;
: or or ; ( arithmetic )
: negate - d# 1 + ;
: min less if drop ; then swap drop ;
: abs dup negate
: max less if swap then drop ;
: v+ ( vv-v ) push u+ pop + ; ( vector )
: loads ( bn ) for dup push load pop d# 2 + next drop ;
: writes ( acn ) for write next drop drop ;
: reads ( acn ) for read next drop drop ; }block

   25 shadow{ 
: 2/ ( arithmetic right shift )
: time -n ( pentium cycle counter, calibrate to actual clock rate )
: 7push/7pop ( save/restore save register 7, edi )
: @-drop ( these macros redefined in ) forth ( so they may be executed )
: negate n-n ( when you just cant use ) -
: min nn-n ( minimum )
: abs n-u ( absolute value )
: max nn-n ( maximum )
: v+ vv-v ( add 2-vectors )
: loads ( load successive blocks )
: nc -a ( number of cylinders booted and saved )
: writes ( address, cylinder, cylinder count )
: reads ( address, cylinder, count. ) [ floppy access note do not hit
   any keys while floppy is being written - wait for light to go out ] }block

   26 code{  }block

   27 shadow{  }block

   28 code{  ( colors etc )
: -offset ( n-n ) [ offset ] @ negate + ;
: block [ offset ] @ +
: blks h# 100 * ;
: wrtboot [ d# 0 block ] d# 0 d# 1 writes stop ;
: save [ d# 84 ] load ;
: white h# FFFFFF color ;
: red h# FF0000 color ;
: green h# FF00 color ;
: blue h# FF color ;
: silver h# BFBFBF color ;
: black d# 0 color ;
: 5* d# 5 for 2emit next ;
: cf d# 25 dup at red h# 1 h# 3 h# C h# 3 h# A 5* green h# 14 h# 2 h# 1
   h# 3 h# E 5* ;
: fill ( nan ) for over over ! d# 1 + next drop drop ;
: move ( sdn ) for over @ over ! d# 1 + d# 1 u+ next drop drop ;
: erase ( bn ) push d# 0 swap block pop blks fill ;
: copy ( n ) [ blk ] @ block over block d# 512 move [ blk ] ! ; }block

   29 shadow{ 
: block n-a ( block number to word address )
: wrtboot ( write boot and kernel )
: save ( write entire image to floppy )
: colors ( specified as rgb' 888 bits )
: at xy ( set current screen position - in kernel )
: box xy ( lower-right of colored rectangle - in kernel )
: 5* emit ( letters )
: cf ( display double-size colorforth )
: fill n an ( writes n into a cell string )
: move sdn ( copies a cell string from s to d )
: erase bn ( zeroes a string of blocks )
: copy n ( copies current editor block and its shadow to the given block ) }block

   30 code{  ( decompress ) [ empt d# 32 load ]
: char ( -n ) 0 b! ( ?new ) d# 4 bits b d# 8 and drop if b d# 4 and drop
   if d# 3 bits d# 7 ; then d# 1 bits d# 5 ; then d# 4 b h# F and drop
   if ; then
: eob ( n ) drop pop drop ;
: chars ( n-n ) char ?full c! 2*c b or chars ;
: word ( n ) d# 28 [ nb ] ! dup chars tbits ;
: short ( n ) d# 28 bits
: t, d# -4 [ nb ] ! b tbits ;
: literal ( n ) 0 b! d# 1 bits t,
: 32bits d# 16 bits d# 16 bits b , ;
: variable ( n ) word 32bits ;
: tag ( -n ) b h# F and dup jump eob word literal word word literal short
   word short word word word variable short word short
: words ( ?new ) d# 4 bits tag words ;
: range ( ann ) over block [ h ] ! dup push erase [ aa ] ! 0 [ na ] !
   begin words [ h ] @ d# 256 + d# -256 and [ h ] ! next ;
: restore [ ns ] @ dup and -if abs [ ns ] ! d# 36 block d# 3000 block
   [ d# 18 blks nc @ d# -2 + * ] move [ d# 3000 block ] d# 36 [ nblk @
   d# -36 + ] range ; then drop ; }block

   31 shadow{ 
: char ( examine high bits; shift 4, 5 or 7 bits )
: eob ( end of block )
: chars ( shift characters until 0 )
: word ( shift characters, then tag )
: short ( 28-bit value+tag )
: literal ( 1-bit base base, tag. value in next word )
: 32bits ( for values )
: variable ( word, value )
: tag ( vector )
: words ( examine tags )
: range ( process each block )
: move ( blocks 72 thru 1419 to 3000 )
: res ( restore compressed blocks ) }block

   32 code{  ( decompress ) [ macro ] ( uses ebx )
: b < ?dup > h# C38B 2, ;
: b! h# D88B 2, < drop > ;
: c! h# C88B 2, < drop > ;
: 2*d h# C3A50F 3, ;
: 2*c h# E0D3 2, ; [ forth ]
:# na 26
:# nb 9
:# h 67510272
:# an 0
:# aa 67933438
:# nz 4
: ?new [ na ] @ dup and drop if ; then
: new [ aa ] @ @ [ an ] ! d# 1 [ aa ] +! d# 32 [ na ] ! ;
: shift ( n-n ) dup negate dup [ nb ] +! [ na ] +! c! [ an ] @ 2*d 2*c
   [ an ] ! ;
: bits ( n ) ?new dup negate [ na ] @ + -if dup push + shift new pop negate
   shift ; then drop shift ;
: tbits ( nn ) [ nb ] @ d# 8 + c! 2*c or
: , [ h ] @ ! d# 1 [ h ] +! ;
: tz ( nn-n ) over [ nz ] ! dup negate push + b begin dup d# 1 and drop
   if drop drop pop drop [ nz ] @ ; then 2/ next b! dup [ nz ] @ - + -
   [ nb ] +! pop drop ;
: ?full ( n-n ) [ nb ] @ dup and -if tz dup push d# -4 + [ nb ] +! tbits
   0 dup pop dup - d# 29 + [ nb ] ! ; then drop ; }block

   33 shadow{ 
: b ( pop ebx, register 3, into eax )
: c! ( push eax into register 1, ecx )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: na ( bits remaining in source word )
: nb ( bits remaining in ebx )
: h ( destination address )
: , ( store at destination )
: ?new ( fetch new word if necessary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: tbits ( fill ebx with tag )
: ?full ( is there room in ebx? )
: bits ( shift bits into ebx. overflow into next word ) }block

   34 code{  ( native system dependencies ) [ macro ]
: p@ < a! ?dup > h# EC 1, ; [ forth ]
: key? h# 64 p@ d# 1 and drop if h# 60 p@ h# 80 and drop if ; then pop
   drop then ;
: clock [ d# 40 ] load ;
: altfrm ( -b ) [ aper @ d# 1024 d# 768 * d# -4 * + ] ;
: topram ( -b ) [ H# 30000000 ] ;
: !work ( n ) block d# 0 over [ d# 1 ] + @ [ d# 35 ] + [ d# 36 ] / writes
   stop ;
: @rest ( nn ) push [ d# 36 ] + block [ d# 2 ] pop reads stop ;
: @back ( n ) dup block d# 0 [ d# 2 ] reads dup [ d# 18 ] + block dup
   @ [ d# 18 block @ ] or drop if drop [ d# 78 ] @rest ; then dup [ d# 1 ]
   + @ dup and -if nip abs [ d# 35 ] + [ d# 36 ] / [ d# -2 ] + @rest ;
   then drop drop [ d# 78 ] @rest ;
: !back ( n ) block d# 0 [ nblk ] @ [ d# 18 ] / writes stop ;
: @cyls ( acn ) reads stop ;
: screen d# 0 dup at d# 1024 d# 768 box ;
: utime ( -n ) d# 0 ; { br }
: serial ( -n ) d# 96 ; }block

   35 shadow{ 
: key? ( exits calling defn if key struck )
: clock ( loads time of day suppt )
: altfrm ( byte addr of alternate frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads only
   active part of compressed ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color )
: utime ( null definition for now for compatability ) }block

   36 code{  ( windows system dependencies )
: key? [ keych ] @ d# 0 or drop if pop drop ; then ;
: beep ; { -cr }
: clock d# 38 load ;
: topram { -cr }
: altfrm ( -b ) [ endram d# -4096 d# 768 * + ] ;
: !work ( n ) dup block [ d# 1 ] + @ [ d# 1 ] + 2/ wwork ;
: @back ( n ) dup d# 19 rback dup [ d# 18 ] + block dup @ [ d# 18 block
   @ ] or drop if drop [ d# 1440 ] rback ; then dup [ d# 1 ] + @ dup and
   -if nip abs [ d# 1 ] + 2/ rback ; then drop [ d# 3 ] + @ rback ;
: !back ( n ) [ nblk ] @ wback ;
: @cyls ( acn ) d# 3000 @back push [ d# 18 ] * [ d# 3000 ] + block swap
   pop [ d# 18 d# 256 * ] * move ;
: screen d# 0 dup at d# 868 for d# 0 d# 1024 line next d# 0 dup at ;
: serial ( -n ) d# 114 ;
: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 3 d# 0 d# 0 pop pop
   swap [ d# 4 ] * fcreate ;
:# flng 30 [ flng d# 4 * dup ]
: frd ( anh-n ) push push push [ d# 0 + ] pop pop swap pop fread
: frw? ( ok-n ) if drop [ flng ] @ then ;
: fwr ( anh-n ) push push push [ d# 0 + ] pop pop swap pop fwrite frw?
   ; { -cr }
: r/o [ H# 80000000 ] ;
: w/o [ H# 40000000 ] ; { -cr }
: r/w [ r/o w/o + ] ; }block

   37 shadow{ 
: key? ( exits calling defn if key struck )
: save ( writes full disk image )
: beep ( alert in hardsim )
: clock ( loads time of day suppt )
: altfrm ( byte adr of alt frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads only
   active part of compressed, and only active part of straight disks with
   vars ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color ) { br }
: fopen ( opens an existing win32 file given word adr of name and access
   code of ) r/o w/o ( or ) r/w. ( returns handle, indicators nz if it's
   good. )
: frd ( and ) fwr ( read and write on things with win32 handles. ) }block

   38 code{  ( windows clock )
: sec ( -n ) utime [ d# 60 d# 60 * d# 24 * ] mod ;
: minute ( -n ) sec d# 60 / ; }block

   39 shadow{ 
: utime ( returns unix time in sec since epoch 0000z fri 1/01/1970 )
: sec ( seconds since midnight needs unsigned mod by time we are all dead )
: min ( minutes past midnight ) }block

   40 code{  ( native clock ) [ macro ] ( pentium timer )
: p@ < a! ?dup > h# EC 1, ;
: p! < a! > h# EE 1, < drop > ; [ forth ]
: ms d# 100000 * for next ;
: ca h# 70 p! h# 71 ;
: c@ ca p@ ;
: c! ca p! ;
: !bcd push d# 10 /mod d# 16 * + pop c! ;
: !hm d# 100 /mod d# 4 !bcd d# 2 !bcd 0 dup c! ;
: bcd c@ d# 16 /mod d# 10 * + ;
: sec0 d# 4 bcd d# 60 * d# 2 bcd + d# 60 * d# 0 bcd + ;
: sec sec0 d# 2 ms dup sec0 or drop if drop sec ; then ;
: minute sec d# 60 / ;
: hms sec d# 60 /mod d# 60 /mod d# 100 * + d# 100 * + ;
: ymd d# 9 bcd d# 100 * d# 8 bcd + d# 100 * d# 7 bcd + ;
: day d# 6 c@ d# -1 + ;
: hi d# 10 c@ h# 80 and drop if ; then hi ;
: lo d# 10 c@ h# 80 and drop if lo ; then ;
: cal hi lo time - hi lo time + ( 748 ) ;
: beep h# B6 h# 43 p! h# EE h# 42 p! 0 h# 42 p! ( on ) h# 61 p@ d# 3 or
   h# 61 p! d# 50000000 for next ( off ) h# 61 p@ d# 3 or h# 61 p! ; }block

   41 shadow{  }block

   42 code{  }block

   43 shadow{  }block

   44 code{ 
: def a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { br }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { br }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { br }
 a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 }block

   45 shadow{  }block

   46 code{  ( logo, etc )
: list ( n ) [ blk ] @ [ blk d# 1 + ] ! [ blk ] ! lis ;
: logo show black screen d# 800 d# 710 blue box d# 600 d# 50 at d# 1024
   d# 620 red box d# 200 d# 100 at d# 700 d# 500 green box { 24F } ( list )
   text cf keyboard ;
: empty empt logo ;
: wait [ d# 10 d# 30 * ] for 7push pause 7pop next ;
: l [ blk ] @ load ; { br }
 [ d# 156 load ]
: watermark show black screen d# 16 center h# 404060 color [ blk ] @ 4.
   +list keyboard ;
: edit ( n ) [ blk ] @ [ blk d# 1 + ] ! [ blk ] !
: e watermark +e ; { br }
: -kbd ( -t ) 7push pop dup and drop ; }block

   47 shadow{  ( logo, etc )
: logo ( displays colorforth logo )
: show ( background task executes following code repeatedly )
: keyboard ( displays keypad and stack )
: empty ( empty dictionary w/ empt display logo )
: wait ( while saving edi, in interrupt dead code artifact )
: list ( displays the given block without entering the editor. ) { br }
: -kbd ( returns true/nonzero flag if a word that calls it is being interpreted
   from a block as opposed to from the keyboard. use with caution from
   deep within an app that might have monkeyed with register { EF } ) }block

   48 code{  ( dump ) [ empty ]
:# x 67153136
:# y -79636688
: 5-8 d# 8 /mod d# 32 /mod d# 32 /mod h# 100 * + h# 100 * + h# 100 * swap
   d# 4 * + ;
: one dup @ dup 5-8 h. space h. space dup h. cr ;
: lines for one d# -1 + next drop ;
: dump [ x ] !
: r show black screen [ x ] @ d# 15 + d# 16 text lines keyboard ;
: it @ + @ dup h. space ;
: lines for white i [ x ] it i [ y ] it or drop if red then i . cr -next
   ;
: cmp show blue screen text d# 19 lines red [ x ] @ h. space [ y ] @ h.
   keyboard ;
: u d# 16
: +xy dup [ x ] +! [ y ] +! ;
: d d# -16 +xy ;
: ati H# F4100000 ( ff7fc000 ) or ( agp graphics reg )
: byte d# 4 / dump ;
: fix for d# 0 over ! d# 1 + next ; [ dump ] }block

   49 shadow{  ( does not say empty, compiles on top of application )
: x -a ( current address )
: one a-a ( line of display )
: lines an
: dump a ( background task continually displays memory --- takes address
   -- displays three cols with address on right contents in middle and-
   the left col is g18 instruction view )
: u ( increment address )
: d ( decrement )
: ati ( address of agp graphic registers )
: byte a ( byte address dump )
: fix an-a ( test word ) }block

   50 code{  ( timing greg )
:# tmt 286630312
:# tmn -162350156
:# tmp 64245270
:# secs 0
: tmclr d# 0 [ tmt ] ! d# 0 [ tmn ] ! d# 0 [ tmp ] ! d# 0 [ secs ] ! ;
: tms ( a ) time - [ d# 1 ] + swap +! ;
: tme ( a ) time swap +! ;
: tare [ tmt ] tms pause [ tmt ] tme ;
: 0tare [ tmn ] tms switch [ tmn ] tme ;
: counter utime negate [ secs ] +! ;
: timer utime [ secs ] +! ; }block

   51 shadow{  }block

   52 code{  ( format floppy ) [ empty ]
:# hd 1
:# ad 152338
: array pop 2/ 2/ ;
: com align array [ H# 1202004D , h# 6C 2, ]
: word ( n ) [ ad ] @ ! d# 1 [ ad ] +! ;
: sectors ( cs-c ) buffer [ ad ] ! d# 18 for over [ hd ] @ h# 100 * +
   over d# 18 mod d# 1 + h# 10000 * + h# 2000000 + word d# 1 + next drop
   ;
: head ( ch-c ) dup [ hd ] ! h# 400 * H# 1202004D + [ com ] ! dup 2* -
   d# 1801 + sectors format ;
: cylinders ( n ) push [ com ] d# 0 pop for d# 0 head d# 1 head d# 1 +
   next ( stop ) drop drop ;
: format ( nc @ ) d# 80 cylinders stop ;
: archive [ d# 0 block ] d# 0 [ nc ] @ writes stop ;
: check [ d# 3000 block ] d# 0 [ nc ] @ reads stop ;
: ati H# 10CD4123 [ vesa ] ! ; ( setup for ati video card )
: nvidia H# 10CD4118 [ vesa ] ! ; ( for nvidia card then save ) }block

   53 shadow{ 
: format ( issue format command 30 cyl - in kernel )
: hd ( disk head )
: ad ( current address in ) buffer
: buffer ( usual floppy cylinder buffer )
: array ( return word address )
: com ( format command )
: word ( store word into command string )
: sectors ( build sector table )
: head ( build sectors for selected head )
: cylinders ( sectors advance 1 for each cylinder - to allow time for
   head step )
: format ( only desired cylinders to save time )
: bytes ( arguments for crc )
: archive ( verify save' compute crc, save, read-back, recompute crc -
   first 64 bytes used by floppy read/write -- the two crc numbers should
   be the same ! ) }block

   54 code{  ( icons ) [ empty macro ]
: @w h# 8B66 3, ;
: !w < a! > h# 28966 3, < drop > ;
: *byte h# C486 2, ; [ forth ]
:# ic 53
:# cu 169
: sq [ xy ] @ h# 10000 /mod d# 16 + swap d# 16 + box { cr }
 d# 17 d# 0 +at ;
: loc [ ic ] @ [ d# 16 d# 24 d# 8 */ ] * [ d# 12 block d# 4 * ] + ;
: 0/1 h# 8000 ? if green sq ; then blue sq ;
: row dup @w *byte d# 16 for 0/1 2* next drop { cr }
 [ d# -17 d# 16 * ] d# 17 +at ;
: ikon loc d# 24 for row d# 2 + next drop ;
: adj d# 17 * swap ;
: cursor [ cu ] @ d# 16 /mod adj adj over over at { cr }
 red d# 52 u+ d# 52 + box ;
: line ( i-in ) for dup emit d# 1 + next ;
: set ( xy ) over lm at d# 0 d# 10 for d# 12 line cr next { cr }
 d# 8 line drop ;
: ok show black screen cursor d# 18 dup at ikon { cr }
 text [ ic ] @ . d# 400 d# 60 set keyboard ; [ d# 56 load ok h ] }block

   55 shadow{  ( draw big-bits icon )
: @w a-n ( fetch 16-bit word from byte address )
: !w na ( store same )
: *byte n-n ( swap bytes )
: ic -a ( current icon )
: cu -a ( cursor )
: sq ( draw small square )
: xy -a ( current screen position, set by ) at
: loc -a ( location of current icons bit-map )
: 0/1 n-n ( color square depending on bit 15 )
: row a-a ( draw row of icon )
: ikon ( draw big-bits icon )
: adj nn-nn ( magnify cursor position )
: cursor ( draw red box for cursor )
: ok ( background task to continually draw icon, icon number at top ) }block

   56 code{  ( edit character set application )
: +ic d# 1 [ ic ] +! ;
: -ic [ ic ] @ d# -1 + d# 0 max [ ic ] ! ;
: bit [ cu ] @ 2/ 2/ 2/ 2/ 2* loc + h# 10000 [ cu ] @ h# F and d# 1 +
   for 2/ next *byte ;
: toggle bit over @w or swap !w ;
: td toggle
: d d# 16
: wrap [ cu ] @ + [ d# 16 d# 24 * ] dup u+ /mod drop [ cu ] ! ;
: tu toggle
: u d# -16 wrap ;
: tr toggle
: r d# 1 wrap ;
: tl toggle
: l d# -1 wrap ;
: h pad nul nul accept nul tl tu td tr l u d r -ic nul nul +ic nul nul
   nul nul nul nul nul nul nul nul nul nul [ h# 2500 , h# 110160C dup
   , , H# 2B000023 , d# 0 , d# 0 , d# 0 , ] }block

   57 shadow{  ( edit icon ) }block

   58 code{  ( lan ) [ empty h# 3F8 d# 60 load init ]
: no block d# 4 * d# 1024 ;
: send no for dup 1@ xmit d# 1 + next drop ;
: receive no for rcv over 1! d# 1 + next drop ;
: no d# 18 [ d# 7 d# 18 * ] ;
: backup no for dup send d# 1 + next drop ;
: accept no for dup receive d# 1 + next drop ; }block

   59 shadow{  }block

   60 code{  ( serial 3f8 2e8 1050 ) [ macro ]
: p@ < a! dup > h# EC 1, ;
: p! < a! > h# EE 1, < drop > ;
: 1@ h# 8A 2, ;
: 1! < a! > h# 288 2, < drop > ; [ forth ]
: r [ d# 0 + ] + ;
: 9600 d# 12 ;
: 115200 d# 1 ;
: b/s h# 83 [ d# 3 r ] p! d# 115200 [ d# 0 r ] p! d# 0 [ d# 1 r ] p! d# 3
   [ d# 3 r ] p! ;
: init b/s ( 16550 ) d# 1 [ d# 2 r ] p! d# 0 [ d# 4 r ] p! ;
: xmit ( n ) [ d# 5 r ] p@ h# 20 and drop if [ d# 0 r ] p! ; then ( pause )
   xmit ;
: cts [ d# 6 r ] p@ h# 30 and h# 30 or drop if cts ; then xmit ;
: st [ d# 6 r ] p@
: xbits h# 30 and h# 10 / dup d# 1 and 2* 2* + 2/ ;
: st! [ d# 4 r ] p! ;
: ?rcv [ d# 5 r ] p@ d# 1 and drop if [ d# 0 r ] p@ then ;
: rcv ?rcv if ; then ( pause ) rcv ; }block

   61 shadow{ 
: p@ p-n ( fetch byte from port )
: p! np ( store byte to port )
: 1@ a-n ( fetch byte from byte address )
: 1! na ( store byte to byte address )
: r n-p ( convert relative to absolute port address. base port on stack
   at compile time. compiled as literal at yellow-green transition )
: 9600
: 115200 ( baud-rate divisors. these are names, not numbers )
: b/s ( set baud rate. edit to change )
: init ( initialize uart )
: xmit n ( wait for ready and transmit byte )
: cts n ( wait for clear-to-send then xmit )
: st -n ( fetch status byte )
: xbits n-n ( exchange status bits )
: st! n ( store control byte )
: ?rcv ( fetch byte if ready. set flag to be tested by ) if
: rcv -n ( wait for ready and fetch byte ) }block

   62 code{  ( word search tcurs ) [ macro ]
: bt ( nm-n ) [ H# 68BD08B ] , [ H# F04768D ] , [ H# D21BC2A3 ] , ; [
   forth ]
: t2 ( nn-nn ) d# 1 +
: t1 ( nn-nn ) d# 1 [ curs ] +!
: t0 ( nn-nn ) d# 1 + ;
: map ( nnn-nn ) h# F and jump t0 t1 t2 t1 t1 t2 t1 t1 t1 t1 t1 t1 t2
   t1 t1 t1
: tcurs ( nn-n ) over block push d# -1 [ curs ] ! d# 0
: tcu1 ( nnn-n ) dup i + @ map over over negate + drop -if t1 drop drop
   pop drop ; then tcu1 ;
: -curs ( - ) [ curs ] @ d# -1 + d# 0 max [ curs ] ! ; [ here ]
: tpoint [ blk ] @ [ curs ] @ tcurs drop -curs ; [ cpoint ! ] }block

   63 shadow{  ( word search tcurs )
: bt ( returns nz and less if bit n of m is set. pops t to 2, bit test
   index t mask 2, 2-2-sbb to set nz if carry. )
: t2 nn-nn ( 2 cell - big nums, var )
: t1 nn-nn ( 1 cell )
: t0 nn-nn ( extensions, undefined )
: map end n wrd-end n ( inc n and maybe curs )
: tcurs blk offset-blk ( convert offset to tokens in curs )
: -curs - ( decrement curs to zero )
: tpoint - ( fix abort to point cursor correctly, except if last word
   in block ) }block

   64 code{  ( word search )
:# fmask -16
:# fnn -403177453
:# fna 67146240
:# fbits 16530 [ d# 18 block fna ! ]
: tag? ( nm-n ) over h# F and swap bt drop ;
: +shad ( a-a ) dup [ fna ] @ or d# 256 and + ;
: 1word ( -n ) word [ words ] @
: 1wz d# 2 less drop if drop ; then nip d# -1 + 1wz ;
: want? ( nm-n ) tag? if or ; then drop drop d# -1 ;
: find 1word h# 5E9A
: fnd+ d# 18 block d# -16
: fnd ( nbam ) [ fmask ] ! [ fna ] ! [ fbits ] ! d# 16 or [ fnn ] !
: f [ fnn ] @ d# 16 or [ fna ] @ begin +shad [ nblk ] @ block less drop
   while over over @ [ fbits ] @ want? [ fmask ] @ and drop while d# 1
   + end then dup d# 1 + [ fna ] ! nip h# 100 /mod -offset swap tcurs
   edit ; then drop drop ;
: red? ( n-nm ) [ h# 1008 ] tag? if [ h# 4092 ] ; then [ h# 1008 ] ;
: def 1word [ h# 1008 ] fnd+ ; [ here ekt d# 21 + ! ]
: fkc drop ( drop ) [ pcad ] @ @ [ h# 140 ] tag? if [ d# 32 ] / edit ;
   then red? fnd+ ( blk @ ) dup ; [ here ekt d# 22 + ! ]
: fk drop ( drop ) [ cad ] @ [ fna ] ! f ( blk @ ) dup ;
: from ( n- ) 1word swap [ h# 5E9A ] swap block [ d# -16 ] fnd ;
: literal ( n- ) h# 20 * [ h# 140 ] d# 18 block [ d# -32 ] fnd ; }block

   65 shadow{  ( word search )
: tag? ( nz and less if bit in m indexed by tag of token n is 1. )
: +shad ( skips shadows if in one and skipping. )
: 1word -n ( return 1st cell of word from kbd. )
: find ( finds following short word, starting in block 18, regardless
   of color. )
: def ( finds only definitions. )
: f ( find next occurrence of word last found )
: fk ( 'f' key in edit keyboard. drops key and block number and behaves
   like f except continues search from current editor position in current
   kind of block src/shad. )
: fkc ( if word left of cursor is a number, list that block. if red or
   magenta definition, searches for references. otherwise searches for
   definitions. )
: from n- ( like find but start from block number )
: literal n- ( finds any equivalent literal ) }block

   66 code{  ( editor recolor ) [ d# 8 display + @ d# 13 display + ! ]
: array pop 2/ 2/ + @ ; ( 1-4-9 2-5 8-6-15 )
: reclr align array { cr }
 [ d# 0 , d# 4 , d# 5 , d# 3 , d# 9 , d# 2 , d# 15 , d# 7 , ] { cr }
 [ d# 6 , d# 1 , d# 10 , d# 11 , d# 12 , d# 13 , d# 14 , d# 8 , ]
: wadr ( -a ) [ pcad ] @ [ blk ] @ max ; [ here ekt d# 20 + ! ]
: change wadr @ h# F and reclr wadr @ h# FFFFFFF0 and or wadr ! ; [ H# 220E100A
   ekt d# 33 + ! ] }block

   67 shadow{  ( tags ) { cr }
 ( extend ) [ execute 32-bit ] ( define ) { cr }
 compile 32-bit [ 27-bit ] < immediate > { cr }
 27-bit ( comment cap caps ) { cr }
 ( variable address blue 27-bit ) { br }
: array ( fetch new tag )
: reclr ( table of color cycles )
: wadr -a ( address of word to left of cursor )
: change ( color of word to left of cursor )
: 220e100a ( 0a-c 10-d 0e-f 22-j ) }block

   68 code{  ( blue words )
: -w@ ( -n ) 7push pop d# -1 + @ ;
: ?xqt -w@ d# -16 and itick if drop ; then push ;
: @lit -w@ d# 32 / ; [ here display d# 13 + ! ]
: tadr h# C0C0C0 color @lit d# 3 h.n space ;
: blu h# FF color
: type1 [ d# 9 display + @ d# 5 + ] push ;
: d14 [ d# 14 display + ] ; [ here d14 ! ]
: exb blu { 2F } ( sp + @ push ) ?xqt ;
: tab ( n ) for space next ;
: indent cr d# 5 tab ;
: br cr cr ;
: sp/2 h# B0000 [ xy ] +! ;
: d03 ( -a ) [ d# 3 display + ] ; [ here ]
: exr [ d03 @ ] nop [ d03 ] ! space red type1 ;
: -cr [ d# 0 + ] nop [ d03 ] ! ;
: seeb [ d14 ] @ [ d14 @ dup d# 5 + or ] or [ d14 ] ! ;
: ?seeb ( -t ) [ d14 ] @ [ d14 @ d# 5 + ] or drop ; [ seeb ] }block

   69 shadow{ 
: ?xqt ( executes the word just passed over if it exists in the dictionary. )
: @lit ( fetch 27-bit literal )
: tadr ( display target address )
: blu ( display blue word )
: d14 ( tag 14 display entry )
: exb ( display and execute blue word if found. )
: tab ( advance n spaces )
: indent ( 5 spaces )
: br ( blank line )
: s/2 ( halfspace for reports. )
: -cr ( suppress cr on next red word. )
: seeb ( toggle display of blue words )
: ?seeb ( set flag non-zero if blue words visible ) }block

   70 code{  ( convert colorforth character to/from ascii ) [ macro ]
: 1@ h# 8A 2, ; [ forth ]
: string pop ;
: cf-ii string [ H# 6F747200 , H# 696E6165 , H# 79636D73 , H# 7766676C
   , H# 62707664 , H# 71757868 , ] ( 336a7a6b ) [ H# 33323130 , H# 37363534
   , ] ( 2d313938 - 2d7a3938 ) [ H# 5F7A3938 , ] ( 2f322e30 ) [ H# 2F6A2E6B
   , ] ( 2b213a3b ) [ H# 24213A3B , H# 3F2C2A40 , ]
: ch h# FFFFFFF0 and unpack [ cf-ii ] + 1@ h# FF and ;
: ii-cf string [ h# 2A00 , ] ( 0 + ) [ h# 2B , H# 2B2D0000 , H# 2725232E
   , ] ( zjk 1b262224 ) [ H# 1B1A1918 , H# 1F1E1D1C , H# 28292120 , H# 2F000000
   , H# 3A43355C , H# 3D3E3440 , ] ( 02 484a3744 kj ) [ H# 54523744 ,
   H# 3336393C , H# 38314742 , H# 3F414632 , ] ( 1 493b45 z ) [ h# 563B45
   , ] ( - ) [ H# 23000000 , H# A13052C , H# D0E0410 , ] ( 02 181a0714
   kj ) [ H# 24220714 , h# 306090C , H# 8011712 , H# F111602 , ] ( 1 190b15
   z ) [ h# 260B15 , ]
: chc h# FFFFFFE0 + [ ii-cf ] + 1@ h# FF and ; }block

   71 shadow{  ( colorforth to ascii and ascii to colorforth ) [ to load,
   type c-a-c not d# 54 load ]
: cf-ii ( otr inae ycms wfgl bpvd quxh 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? cba@ gfed 02ih onml srqp wvut 1yx
   cba@ gfed 02ih onml srqp wvut 1yx )
: notice [ j and z transposed in cf-ii; - converts to underscore, + to
   dollar. ] }block

   72 code{  ( convert cf character to/from ascii ) [ macro ]
: 1@ h# 8A 2, ;
: 1! < a! > h# 288 2, < drop > ; [ forth ]
: string pop ;
: cf-ii align string [ H# 6F747200 , H# 696E6165 , H# 79636D73 , H# 7766676C
   , H# 62707664 , H# 71757868 , H# 33323130 , H# 37363534 , H# 2D6A3938
   , H# 2F7A2E6B , H# 2B21273B , H# 3F2C2A40 , ]
: ch h# FFFFFFF0 and unpack [ cf-ii ] + 1@ h# FF and ;
: ii-cf string [ h# 2A00 , h# 2B , H# 2B2D0000 , H# 2725232E , H# 1B1A1918
   , H# 1F1E1D1C , H# 28292120 , H# 2F000000 , H# 3A43355C , H# 3D3E3440
   , H# 54523744 , H# 3336393C , H# 38314742 , H# 3F414632 , h# 563B45
   , H# 23000000 , H# A13052C , H# D0E0410 , H# 24220714 , h# 306090C
   , H# 8011712 , H# F111602 , h# 260B15 , ]
: chc h# FFFFFFE0 + [ ii-cf ] + 1@ h# FF and ;
: set1 H# 3D21223A H# 3E2C203C
: !8 ( nn- ) [ cf-ii h# 2C + 2/ 2/ ] ! [ cf-ii h# 28 + 2/ 2/ ] ! ;
: set0 H# 2B21273B H# 3F2C2A40 !8 ; }block

   73 shadow{  ( colorforth to ascii and ascii to colorforth )
: cf-ii ( otr inae ycms wfgl bpvd quxh 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? cba@ gfed 02ih onml srqp wvut 1yx
   cba@ gfed 02ih onml srqp wvut 1yx )
: set1 ( modifies cf-ii table. ) { cr }
 ( ; to colon, ' to doublequote, + to equal, ) { cr }
 ( @ to lessthan, * to blank, ? to greaterthan )
: set0 ( converts back to ascii. ) }block

   74 code{  ( pathname input ) [ d# 72 load set1 ]
: strng ( n-a ) pop + ;
: fnam ( n-a ) align strng [ here d# 80 + h ! ]
:# hld 8
: emt ( n- ) [ hld ] @ fnam 1! d# 1 [ hld ] +! ;
: +shan ch emt dup and if +shan ; then drop ; { br }
: ,src 7@+ @
: xx dup and if +shan 7@+ @ dup d# 15 and drop { cr }
 while then [ d# 0 ] and emt 7dec ; then xx ;
: named ( string ) d# 0 [ hld ] ! -kbd if ,src ; { cr }
 then ( keyboard ) d# 0 word d# 0 { cr }
 begin push dup and while end then drop { cr }
 begin pop dup and while +shan end then emt ; { cr }
 [ exit ] ( testing )
: ccc dup 1@ d# 255 and swap d# 1 + ; { cr }
 [ named ] ( //./a; ) }block

   75 shadow{  ( filename input )
: strng ( defines an array of bytes. )
: fnam ( is a zero terminated ascii string consisting of ) hld ( chars
   including the null. ) emt ( appends a character to this string. )
: +shan ( appends a shannon word to fnam. ) { br }
: named ( returns the byte address of a null terminated ascii string representing
   the following colorforth string, which may follow in either source
   code or in keyboard input. ) { br }
: inam ( accept filename input from keyboard, store zero terminated ascii
   string to fnam, and return byte address of fnam. ) }block

   76 code{  ( index ) [ empty ] { cr }
 [ d# 72 load ] { cr }
:# hld 401 [ d# 0 hld ! ]
:# spot 2 [ d# 0 spot ! ]
: nxt ( a-an ) dup d# 1 + swap @ ;
: emit ( c ) [ spot ] @ [ d# -72 ] + drop -if [ hld ] @ [ d# 3000 block
   d# 4 * ] + 1! d# 1 [ hld ] +! d# 1 [ spot ] +! ; then drop ;
: space d# 32 emit ;
: crlf d# 0 [ spot ] ! d# 13 emit d# 10 emit ;
: digit ( n ) [ d# -10 ] + -if [ h# 3A ] + emit ; then [ h# 41 ] + emit
   ;
: .h ( n ) space [ d# -1 ] swap { cr }
 begin dup [ h# F ] and swap 2/ 2/ 2/ 2/ { cr }
 H# FFFFFFF and while end then drop { cr }
 [ d# 0 ] + -if drop d# 0 digit ; then
: spit [ d# 0 ] + -if drop ; then digit spit ;
: .d ( n ) space [ d# 0 ] + -if h# 2D emit negate then [ d# -1 ] swap
   begin [ d# 10 ] /mod dup and while end then { cr }
 drop spit ; { cr }
 [ d# 78 load ] }block

   77 shadow{  ( index )
: hld ( place in file )
: spot ( in line )
: nxt ( fetch next word )
: emit ( ascii character, won't go past column { 90F } )
: space ( written to file )
: crlf ( to file )
: digit ( hex digit to file )
: .h ( print hex number )
: .d ( decimal number ) }block

   78 code{  ( index.1 )
: short ( n ) 2/ 2/ 2/ 2/ dup d# 1 and drop { cr }
 if 2/ .h ; then 2/ .d ;
: literal ( an-a ) push nxt pop h# 10 and drop { cr }
 if .h ; then .d ;
: word ( n ) space [ h# FFFFFFF0 ] and
: cont ( n ) dup and if ch emit cont ; then drop ;
: variable ( an-a ) word nxt .d ;
: eol ( n ) drop pop drop pop drop drop ;
: tag ( a-a ) dup h# F and jump cont word literal { cr }
 eol word literal short word short word { cr }
 word word variable short word short
: words ( n ) for nxt tag next drop ;
: index ( 1st lst+1 ) d# 0 [ hld ] ! over negate + 2/ { cr }
 for dup .d dup space block d# 10 words crlf { cr }
 [ d# 2 ] + next drop
: sav [ d# 3000 block d# 4 * ] olog [ hld ] @ wlog clog ; }block

   79 shadow{  ( index.1 )
: short ( number )
: literal ( long number )
: word ( text, not number )
: cont ( inuation word )
: variable ( name and value )
: eol ( red word means end of line )
: tag ( vector table )
: words ( print maximum n words or to eol )
: index [ first-block last+1 ] { cr }
 ( prints first line of each block in range ) { cr }
 ( to a log file ) [ in windows ] }block

   80 code{  }block

   81 shadow{  }block

   82 code{  }block

   83 shadow{  }block

   84 code{  ( compress ) [ empty d# 86 load ]
: short d# 4 rbits d# 28 bits ;
: literal d# 4 rbits 2/ 2/ 2/ 2/ d# 1 rbits
: 32bits drop d# 1 + dup @ d# 16 bits d# 16 bits ;
: variable 1word 32bits ;
: /whit ( n-n ) d# -16 and d# 9 or word ;
: tag ( an-an ) dup h# F and jump cont word literal word word literal
   short word short word /whit /whit variable short word short
: words ( a ) dup @ dup and if tag drop d# 1 + words ; then d# 4 bits
   drop drop ;
: range ( nn-an ) here/4 here4 push new for dup block words d# 1 + next
   drop 0 d# 31 bits drop pop here4 over negate + ;
: !lng ( nw ) [ d# 127 ] + [ d# 128 ] / [ d# 72 ] + dup ( nsec ) [ d# 0 ]
   block [ d# 1 ] + ! dup negate [ ns ] ! [ d# 35 ] + [ d# 36 ] / [ nc ]
   ! ;
: sve 7push d# 36 [ nblk @ d# -36 + ] range ( an ) !lng drop 0 block [
   d# 3000 ] block [ d# 36 blks ] move [ d# 3000 ] !work [ ns ] @ abs
   [ ns ] ! 7pop ; [ d# 3036 block d# 4 * h ! sve ] }block

   85 shadow{ 
: short ( tag, then 28bit value+base )
: literal ( tag, then base )
: 32bits ( from next word. 2 chunks )
: variable ( single word, then 32-bits )
: /whit ( replaces a word's tag with 9, making it a lowercase comment. )
: tag ( identify kind of word ) [ note /whit used for tags h# A and h# B
   to convert these deprecated capitalized comments to lower case. when
   all source of interest has been compressed at least once this may be
   removed. ]
: words ( scan thru block. 8 0s eob )
: range ( process blocks, number and count. 31 0s eof )
: sve ( compress blocks 72 thru 1419 )
: flop ( write floppy; save number of cylinders ) }block

   86 code{  ( compress ) [ macro ] ( uses ebx )
: b < ?dup > h# C38B 2, ;
: c! h# C88B 2, < drop > ;
: 2*d h# C3A50F 3, ;
: 2*c h# E0D3 2, ;
: 2/r h# C8D3 2, ; [ forth ]
:# nb 19
: here/4 here d# 3 and if 1, here/4 ; then drop ;
: here4 here 2/ 2/ ;
: new d# 32 [ nb ] ! ;
: shift ( nn-n ) dup negate [ nb ] +! c! 2*d 2*c ;
: rbits dup c! swap 2/r swap
: bits ( nn-n ) dup negate [ nb ] @ + -if dup push + shift b , new pop
   negate shift ; then drop shift ;
: char -if 2* -if 2/ d# 7 bits ; then 2/ H# 80000000 or d# 5 bits ; then
   d# 4 bits ;
: chars dup and if char chars ; then ;
: 1word d# 4 rbits chars d# 4 bits ;
: word ( an-an ) d# 4 rbits
: cont chars over d# 1 + @ dup and if h# F and drop if d# 4 bits ; then
   ; then drop d# 4 bits ; }block

   87 shadow{ 
: b ( pop ebx, register 3, into eax )
: c! ( push eax into register 1, ecx )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: 2/r ( rotate eax right by ecx )
: nb ( number of bits remaining in word )
: here/4 ( align to word boundary )
: here4 ( word address in dictionary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: rbits ( rotate bits to high-order position )
: bits ( shift bits into ebx; cross word boundary )
: char ( examine high bits. shift 4, 5 or 7 bits )
: chars ( shift all non-zero characters )
: 1word ( short word without continuation for variable )
: word ( shift tag, then characters )
: cont ( continue without tag ) }block

   88 code{  ( display text ) [ macro ]
: 7@+ ( -a ) < ?dup > h# C78B 2, h# 47 1, ;
: 7dec h# 4F 1, ;
: @ret ( -b ) < ?dup > h# 24048B 3, H# 5240483 , ;
: 4@ ( b-n ) h# 8B 2, ; [ forth ]
: tick ( b-b ) dup [ d# 1 ] + 4@ + d# 5 + ;
: call h# E8 { -cr }
: dst 1, @ret tick here d# 3 + - + , ;
: jmp h# E9 dst ; { br }
: .shan ( n- ) dup and if unpack emit .shan ; then drop ; { -cr }
: +str ( a-a ) + ; [ macro ]
: ,lit ( n ) < ?dup > h# B8 1, , ;
: strings ( i-a ) 7push pop < ,lit > jmp +str nop ;
: .' ( comment ) 7@+ @ d# -16 and < ,lit > call .shan nop ; [ forth ]
   { br }
: ' ( -b ) -kbd if 7@+ @ itick if abort then ; { cr }
 then tic ;
: execute ( b ) push ;
: eval ( a ) 7push [ d# 1 ] + push 7pop [ sp d# 1 + ] @ execute 7pop ; }block

   89 shadow{  ( these definitions support text display and are used in
   other parts of okad as well. ) { br }
: 7@+ ( interpret only, returns adr of next word in block and skips over
   it ... 7-0-mov 7-inc )
: 7dec ( used to correct address after 7@+ )
: @ret ( fetch return address, skip bytes of code. )
: 4@ ( cell fetch on byte boundary )
: tick ( given adr of call instr, return tgt adr )
: call ( and ) jmp ( generate xfers to next word ) { br }
: .shan ( displays a shannon coded string )
: ,lit ( compiles a literal. )
: .' ( displays the following one-word comment. ) { br }
: strings ( starts an array of words in source. )
: ' ( interp only, returns next word's code addr. )
: execute ( is a call to the given routine adr. )
: eval ( interprets the source word whose address is given. ) }block

   90 code{  ( disk audit utility ) [ empty d# 30 load ]
:# bias 0 { cr }
:# sep 3000 [ d# 3000 sep ! ]
:# head 1439 [ d# 1439 head ! ]
: +blocks ( sdn ) 2* ( bloks ; )
: bloks ( sdn ) push swap block swap block pop [ d# 256 ] * move ; { -cr }
: n18 ( i-a ) [ d# 3018 block ] + ;
: wipe [ blk ] @ d# 1 erase ( e ) lis ; { -cr }
: to ( n ) [ head ] ! ;
: obliterate ( lh ) over negate + erase ;
: matching ( sd ) less if swap then dup [ bias ] ! negate + [ sep ] !
   ;
: cast ( nm-n' ) dup push /mod d# 1 or pop * + ;
: other ( n-n' ) [ bias ] @ negate + [ sep ] @ cast [ bias ] @ + ;
: lesser ( n-n ) dup other min ; [ d# 92 load ]
: ?blk ( n-n?n+ ) lesser dup block over other block [ d# 256 ] for over
   @ over @ or drop if drop drop dup [ d# 1 ] + pop drop ; then [ d# 1 ]
   + [ d# 1 ] u+ next drop drop [ d# 1 ] + ; { -cr }
: ?blks ( sn-? ) for ?blk next drop ;
: ?bin ( kernel ) d# 0 d# 12 ?blks ( icons ) d# 12 d# 6 ?blks ;
: unpk abs [ d# 1 n18 ] ! [ d# 3036 ] block [ d# 5000 ] block [ d# 1404 ]
   blks move [ d# 5000 block ] d# 3036 [ d# 3 n18 ] @ [ d# -36 ] + range
   ;
: check [ d# 3000 ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or drop if
   ; then [ d# 1 n18 ] @ dup and -if unpk ; then drop ; }block

   91 shadow{  ( disk mgmt and reconciliation utility. )
: bloks ( copies n blocks from s to d, front to back so only moves overlap
   downward safely. )
: +blocks ( copies n blocks and their shadows. )
: obliterate ( wipes from block l to block h. )
: matching ( sets up to match s to d. )
: to ( sets block no. past end of source area. )
: other ( given a block number in one of the areas returns the corresponding
   block no. in the other area. )
: lesser ( given a block number returns the lesser of the pair it is a
   member of )
: ?blks ( scans a range of blks leaving nos of any differing blks on the
   stack. )
: ?bin ( scans the binary parts of okad disk. )
: check ( reads backup to { 1770F } and decompresses if appropriate ) }block

   92 code{  ( compare )
: blink ( n ) dup other [ blk ] ! edit ;
: var ( nnxx-nnd ) push push d# 1 + d# 1 u+ pop pop
: *1 ( nnxx-nnd ) or ;
: *2 ( nnxx-nnd ) var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# F and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1 *1 *1 var
   *1 *1 *1
: +or ( nn-n ) over - and or ;
: ?nul ( nnxx-nnxx ) over over +or drop if ; then drop drop pop drop drop
   drop ;
: co ( naa-n ) over @ over @ ?nul tag drop if drop drop blink ; then d# 1
   + d# 1 u+ co ;
: com ( n-n ) dup block over other block co ;
: g blk @ lesser
: gg ( n ) [ head ] @ over - + drop -if drop ; then [ d# 1 ] + com gg
   ;
: v [ blk ] @ other edit ;
: give blk @ dup other d# 1 bloks ;
: take blk @ dup other swap d# 1 bloks ;
: check [ d# 3000 ] @back ;
: all d# 0 [ d# 3000 ] matching [ nblk ] @ [ d# -1 ] + to [ d# 17 ] gg
   ; }block

   93 shadow{ 
: blink ( displays the given block with its other set as the editor's
   'other' block )
: var ( compares a variable name, advancing pointers to skip its value. )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compares source cells given, true if diff, advancing ptrs and
   ignoring variable vals. )
: ?nul ( ends loop in co if nuls hit in both blks. )
: co ( does work of com given adrs of both blks. )
: com ( invokes editor to blink the given block if it differs from the
   other, otherwise returns. )
: g ( scans for diffs after current editor block. )
: v ( shows the other block )
: give ( writes current editor block over its twin )
: take ( writes twin over current editor block. )
: check ( reads backup to 3000 for matching. )
: all ( scans the whole usable area of the disk. ) }block

   94 code{  }block

   95 shadow{  }block

   96 code{  ( native async ) [ d# 96 orgn ! macro ]
: 1@ ( b-c ) h# 8A 2, ;
: 1! ( cb ) < a! > h# 288 2, < drop > ;
: 2@ ( b-h ) h# 8B66 3, ;
: 2! ( hb ) < a! > h# 28966 3, < drop > ;
: 4@ ( b-n ) h# 8B 2, ;
: 4! ( nb ) < a! > h# 289 2, < drop > ;
: swab ( h-h ) h# C486 2, ;
: swa4 ( n-n ) h# C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ;
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ;
: rez ( n ) h +! ;
: +or ( nn-n ) over - and or ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }
:# act 0
:# vport 373
:# 0tg 1
:# 1tg 1
:# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] ! ; {
   br }
 ( ser ) [ d# 98 load d# 118 load ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load ] ( canon ) [ d# 138 load ] }block

   97 shadow{  ( talk to chip via native rs232. ) { br }
: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }
: bofs ( and ) ofs ( make byte and cell offset adrs in a structure given
   byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
   in dictionary. ) [ note that writing into such allocations invalidates
   nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. ) {
   br }
: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

   98 code{  ( async umbilical ) [ h# 3F8 ] ( serial ) [ d# 60 load ]
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 16384 rez ]
:# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }
: @18 ( -n ) /str 4@ [ h# 3FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 3FFFF ] or [ h# 40 ] * [ h# 12 ] + /str 4! +wd ; { br }
: +sea ( -ok ) init d# 1 [ d# 0 ] + ;
: -sea ;
: reset [ d# 2 ] st! [ d# 100000 ] for next [ d# 0 ] st! ;
: tosea ( bn ) for dup 1@ xmit [ d# 1 ] + next drop ;
: insea ( w ) stream swap [ d# 3 ] * for { indent }
 rcv over 1! [ d# 1 ] + next drop ; }block

   99 shadow{  ( async data are 18 bits per 3 bytes. to chip word inverted,
   shifted up 6, '12' inserted, then sent low order byte first. from chip
   are tbd. ) { br }
: sport ( com port address )
: 4@ ( and ) 4! ( full cell on byte address. )
: +sea ( opens serial; true if good, handle in dh. )
: -sea ( closes the handle. )
: /sea ( resets the chip. )
: tosea ( transmits n bytes to chip. )
: insea ( receives w g18 words from the chip. ) { br }
: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }
: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be present! ) }block

  100 code{  ( onspec usb interface ) [ d# 100 orgn ! macro ]
: 1@ ( b-c ) h# 8A 2, ;
: 1! ( cb ) < a! > h# 288 2, < drop > ;
: 2@ ( b-h ) h# 8B66 3, ;
: 2! ( hb ) < a! > h# 28966 3, < drop > ;
: swab ( h-h ) h# C486 2, ;
: swa4 ( n-n ) h# C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ;
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: bofs ( bw-b'b ) over + swap ;
: ofs ( bw-b'a ) bofs b-a ;
: create ( -a ) pop b-a ;
: rez ( n ) h +! ;
: +or ( nn-n ) over - and or ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }
:# act 0
:# vport 325
:# 0tg 1
:# 1tg 1
:# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] ! ; {
   br }
 ( usb ) [ d# 102 d# 5 loads ] ( routes ) [ d# 112 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load ] ( canon ) [ d# 138 load ] }block

  101 shadow{  ( talk to seaforth via onspec usb. ) { br }
: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }
: bofs ( and ) ofs ( make byte and cell offset adrs in a structure given
   byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
   in dictionary. ) [ note that writing into such allocations invalidates
   nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. ) {
   br }
: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

  102 code{  ( find/open/close onspec )
: nam ( -a ) align create ( //./ ) [ H# 2F2E2F2F , ] ( d' ) [ h# 3A47
   , ]
: obuf ( -a ) align create [ d# 512 rez ]
:# len 100
: spq ( -a ) align create [ d# 0 , d# 0 , d# 0 , ]
: inq ( -ok ) [ len ] d# 512 obuf d# 12 spq h# 2D1400 [ dh ] @ fioctl
   ; { br }
: -sea [ dh ] @ [ d# 0 ] + if fclose d# 0 then [ dh ] ! ;
: ?sea ( -t ) obuf dup [ d# 3 ] + @ b-a + dup @ [ H# 66414553 ] or swap
   [ d# 1 ] + @ [ H# 6874726F ] or +or ?zero ;
: +sea ( -ok ) h# 3A44 [ nam d# 1 + ] ! d# 20 for nam r/w fopen [ dh ]
   ! if inq drop if ?sea if pop drop ; then drop then then -sea d# 1 [
   nam d# 1 + ] +! next d# 0 ; }block

  103 shadow{ 
: nam ( pathname buffer )
: spq ( argument for inquiry )
: obuf ( buffer for inquiry return )
: len ( bytes returned from fioctl calls ) { br }
: inq ( makes device inquiry, returns true if ok )
: ?sea ( true with indic if reply vendor seaforth ) { cr }
: +sea ( finds a forthdrive. true if found, handle in dh. )
: -sea ( closes the handle. ) }block

  104 code{  ( scsi operations )
: /sdb ( -n ) [ d# 28 d# 16 + d# 32 + d# 16 d# 1024 * + ] ; { br }
: sdb align create [ /sdb rez ] ( struc ) [ sdb a-b ]
: nsdb ( -b ) [ d# 2 bofs ] ; ( sstat ) [ d# 1 + d# 3 + ]
: ncdb ( -b ) [ d# 1 bofs ] ; ( nsns ) [ d# 1 + ]
: i/o ( -b ) [ d# 1 bofs ] ; [ d# 3 + ]
: ndata ( -a ) [ d# 4 ofs ] ;
: nto ( -a ) [ d# 4 ofs ] ;
: 'data ( -a ) [ d# 4 ofs ] ;
: 'sns ( -a ) [ d# 4 ofs ] ;
: cdb ( -b ) [ d# 16 bofs ] ; ( sns ) [ d# 32 + ]
: sdat ( -b ) [ d# 16 d# 1024 * bofs ] ; [ drop ] { br }
: !cdb ( an ) d# 0 sdb [ d# 28 d# 16 + d# 32 + b-a ] fill [ d# 28 d# 16
   + dup ] nsdb 2! [ dup ] 'sns ! [ d# 32 + ] 'data ! d# 20 [ nto ] !
   dup [ ncdb ] 1! [ cdb b-a ] swap b-a move ;
: !xfer ( ni ) [ i/o ] 1! [ ndata ] ! ;
: /scsi ( -ok ) [ len ] /sdb sdb over over h# 4D004 [ dh ] @ fioctl ; }block

  105 shadow{ 
: /sdb ( total length of scsi structure, bytes ) { br }
: sdb ( scsi structure word adr unless -b )
: nsdb ( -b length in bytes thru cdb )
: ncdb ( -b length of cdb in bytes )
: i/o ( -b 0 out 1 in 2 no data )
: ndata ( -a length in bytes of data transfer )
: nto ( -a timeout in seconds )
: 'data ( -a offset in bytes to sdat )
: 'sns ( -a offset in bytes to sns )
: cdb ( -b scsi command )
: sdat ( -b scsi data ) { br }
: !cdb ( initializes sdb for cmd whose word adr and byte lng are given.
   data xfer params must be set before /scsi. )
: !xfer ( sets length in bytes and direction of data transfer. )
: /scsi ( executes scsi command returning api status not necessarily scsi
   status. ) }block

  106 code{  ( onspec vendor unique ops )
: /lok ( f-ok ) push [ len ] d# 0 d# 0 d# 0 d# 0 pop [ dh ] @ fioctl ;
: lok [ h# 90018 ] /lok drop ;
: -lok [ h# 9001C ] /lok drop ;
: scsi ( -ok lok ) /scsi ( -lok ) [ d# 0 ] + ; { br }
: /os align create [ h# FA20 , h# 0 , h# 0 2, ]
: wos align create [ h# FB20 , h# 0 , h# 0 2, ]
: wos! align create [ h# 2FB20 , h# 0 , h# 0 2, ]
: ros align create [ h# 1FB20 , h# 0 , h# 0 2, ]
: !nbits ( h ) swab [ cdb d# 7 + ] 2! ; { br }
: /sea ( -ok ) /os d# 10 !cdb d# 0 d# 2 !xfer scsi drop ;
: tosea ( wbo ) d# 10 !cdb !nbits 2* d# 0 !xfer scsi drop ;
: insea ( w ) ros d# 10 !cdb [ d# 18 ] * dup !nbits [ d# 14 ] + [ d# 16 ]
   / 2* d# 1 !xfer scsi drop ;
: mute -lok -sea ; }block

  107 shadow{ 
: lok ( and ) -lok ( perform the lock and unlock volume functions that
   are apparently required around a scsi command. )
: scsi ( executes a scsi passthrough command with proper lock protection. )
   { br }
 ( onspec custom scsi command blocks- )
: /os ( cycles chip power and resets it. )
: wos ( writes synch to chip )
: wos! ( writes and leaves lines tristate. )
: ros ( reads synch from chip. )
: !nbits ( sets bit count field in command, limit 32 or 64k ) { br }
: /sea ( resets the chip. )
: tosea ( transmits w halfwords, b bits with op ) [ wos ] ( or ) [ wos! ]
   ( as you wish. )
: insea ( receives w g18 words from the sync boot node. the data in our
   memory are in onspec format both directions. )
: mute ( properly closes the handle. ) }block

  108 code{  ( onspec bitstream )
:# bi 180 [ macro ]
: 4@ ( b-n ) h# 8B 2, ;
: 4! ( nb ) < a! > h# 289 2, < drop > ;
: swah ( n-n ) h# C1 1, h# 10C8 2, ; [ forth ]
: lsh ( ni-n ) d# 0 + if for 2* next ; then drop ;
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ; { br }
: -stream d# 0 [ bi ] ! ;
: stream ( -wb ) [ bi ] @ dup [ d# 15 ] + [ d# 16 ] / swap ;
: /str ( -bi ) [ bi ] @ [ d# 16 ] /mod 2* [ sdat ] + swap - [ d# 15 ]
   + ; { cr }
: @18 ( -n ) /str push 4@ swah pop rsh [ h# 3FFFF ] and
: +wd d# 18 [ bi ] +! ;
: !18 ( n ) [ h# 3FFFF ] and /str swap push i 4@ swah push push i lsh
   h# FFFC0000 pop lsh pop and or swah pop 4! +wd ; }block

  109 shadow{  ( onspec data are a continuous stream of bits in consecutive
   bytes, left to right, except that bytes are swapped in halfcell units.
   cell fetched on any halfcell boundary and half-swapped has continuous
   bits running from hi to lo. ) { br }
: 4@ ( and ) 4! ( full cell on byte address. )
: lsh ( and ) rsh ( left and right arith shifts. )
: swah ( swaps hi and lo halfcells of a number. ) { br }
: -stream ( clears bit index ) bi ( in sdat buffer. )
: stream ( halfcells and bits within index. )
: /str ( cell addr, shift count for next 18. ) { br }
: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be present! ) }block

  110 code{  ( node { 258F } sync boot frames )
: /frame ( nw xfr jmp ) -stream [ h# 10000 ] + !18 !18 [ d# 1 ] + 2/ (
   words ) 2* ( actual { FFFFFFEF } + ) !18 ;
: +frame ( wn ) for dup @ !18 [ d# 1 ] + next drop ;
: +ram ( w n node ) nn-n 2* [ h# 8000 ] + block u+ for dup @ [ h# 15555 ]
   or !18 [ d# 1 ] + next drop ;
: !frame ( op ) push stream pop tosea ; { br }
: exec [ h# B6 ] ;
: talk cold mute +sea if lok drop /sea h# 40 d# 0 [ exec ] /frame h# 0
   h# 40 { 22F } d# 300 +ram [ wos ] !frame ( good ) ; then ( bad ) -sea
   ; { br }
: exch ( w n f n ) push push dup [ h# 2 ] + [ d# -2 ] and [ vport ] @
   pop /frame [ vport ] @ [ h# 12000 ] + !18 dup - [ h# 1 ] and drop if
   [ vport ] @ [ h# 10000 ] + !18 then +frame wos! !frame pop insea -stream
   ; { br }
: ok [ h# 18 ] ;
: fet [ h# 1C ] ;
: stat [ h# 23 ] ;
: bstk [ h# 25 ] ; }block

  111 shadow{  ( boot frames begin with a 3 word header; ) { indent }
 100xx ( jump to xx when done ) { indent }
 ddd ( mem/port adr to store payload ) { indent }
 nnn ( transfer length ) { indent }
 [ nnn+1 * 2 ] ( words of payload )
: /frame ( heads a new given ) [ even ] ( words of payload, destination
   addr, final jump addr. )
: +frame ( appends words to payload. )
: +ram ( appends a string of code from binary produced by ) compile (
   for the given ) [ node. ]
: !frame ( transmits frame given ) [ wos ] ( or ) [ wos! ] { br }
: talk ( prepares chip for control thru node 19. )
: exch ( performs a transaction with target given addr and length of port
   stream, stream end action in node 19, and number of words reply. )
   { br }
: ok ( stream end to simply ack completion; ) fet ( pumps one word from
   target; ) bstk ( shepherds stack dump; ) stat ( pumps ten. ) exec (
   is next boot frame. ) }block

  112 code{  ( route lists )
: 0pa align create [ d# 300 , d# 400 , d# 17 , d# 27 , d# 37 , d# 36 ,
   d# 35 , d# 34 , d# 33 , d# 32 , d# 31 , d# 30 , d# 20 , d# 10 , d# -1
   , ] { br }
: 1pa align create [ d# 300 , d# 301 , d# 17 , d# 16 , d# 15 , d# 14 ,
   d# 13 , d# 12 , d# 11 , d# 21 , d# 22 , d# 23 , d# 24 , d# 25 , d# 26
   , d# -1 , ] { br }
: 2pa align create [ d# 300 , d# 200 , d# 17 , d# 7 , d# 6 , d# 5 , d# 4
   , d# 3 , d# 2 , d# 1 , d# 11 , d# 10 , d# 20 , d# 30 , d# 31 , d# 32
   , d# 33 , d# 34 , d# 35 , d# 36 , d# 37 , d# 27 , d# 26 , d# 25 , d# 24
   , d# 23 , d# 22 , d# 12 , d# 13 , d# 14 , d# 15 , d# 16 , d# 17 , d# -1
   , ] { br }
 }block

  113 shadow{ 
: 0pth 1pth 2pth ( are manually set route lists for using the north, south,
   and west ports of node 19. end list is marked by -1 ) { br }
 ( this block has plenty of extra room so that you may customize the available
   lists without changing the reference versions. ) }block

  114 code{  ( windows async ) [ d# 114 orgn ! macro ]
: 1@ ( b-c ) h# 8A 2, ; { -cr }
: 1! ( cb ) < a! > h# 288 2, < drop > ;
: 2@ ( b-h ) h# 8B66 3, ; { -cr }
: 2! ( hb ) < a! > h# 28966 3, < drop > ;
: 4@ ( b-n ) h# 8B 2, ; { -cr }
: 4! ( nb ) < a! > h# 289 2, < drop > ;
: swab ( h-h ) h# C486 2, ;
: swa4 ( n-n ) h# C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ; { -cr }
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ; { -cr }
: rez ( n ) h +! ;
: +or ( nn-n ) over - and or ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br }
:# act 0
:# vport 373
:# 0tg 1
:# 1tg 1
:# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] ! ; {
   br }
 ( ser ) [ d# 116 d# 2 loads ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load ] ( canon ) [ d# 138 load ] }block

  115 shadow{  ( talk to chip via onspec usb. ) { br }
: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }
: bofs ( and ) ofs ( make byte and cell offset adrs in a structure given
   byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
   in dictionary. ) [ note that writing into such allocations invalidates
   nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. ) {
   br }
: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

  116 code{  ( async umbilical )
:# sport 18 [ d# 18 sport ! ]
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 24576 rez ]
:# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }
: @18 ( -n ) /str 4@ [ h# 3FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 3FFFF ] or [ h# 40 ] * [ h# 12 ] + /str 4! +wd ; { br }
: snam ( -a ) align create ( //./ ) [ H# 2F2E2F2F , ] ( com ) [ h# 6D6F63
   , h# 0 , ]
: !nam [ sport ] @ d# 10 over - + drop -if d# 256 * d# 2560 /mod + h# 3000
   + then h# 30 + snam a-b d# 7 + 4! ; [ !nam ]
: +sea ( -ok ) snam r/w fopen [ dh ] ! if d# 1 ; then d# 0 ;
: -sea [ dh ] @ [ d# 0 ] + if fclose d# 0 then [ dh ] ! ;
: ctl! ( n ) [ dh ] @ fesc drop ;
: reset [ d# 3 ] ctl! [ d# 500000 ] for next [ d# 4 ] ctl! ;
: tosea ( bn ) [ dh ] @ fwr drop ;
: insea ( w ) stream swap [ d# 3 ] * [ dh ] @ frd drop ; }block

  117 shadow{  ( async data are 18 bits per 3 bytes. to chip word inverted,
   shifted up 6, '12' inserted, then sent low order byte first. from chip
   are tbd. ) { br }
: sport ( comp com port number )
: 4@ ( and ) 4! ( full cell on byte address. )
: snam ( null terminated string //./comx )
: !nam ( sets port number in snam. )
: +sea ( opens serial; true if good, handle in dh. )
: -sea ( closes the handle. )
: /sea ( resets the chip. )
: tosea ( transmits w halfwords, b bits with op ) [ wos ] ( or ) [ wos! ]
   ( as you wish. )
: insea ( receives w g18 words from the sync boot node. ) { br }
: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }
: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be present! ) }block

  118 code{  ( node { 588F } boot frames )
: wos ( -n ) d# 0 ;
: /frame ( nw xfr jmp ) -stream [ h# 10000 ] + !18 !18 [ d# 1 ] + 2/ (
   words ) 2* ( actual { FFFFFFEF } + ) !18 ;
: +frame ( wn ) for dup @ !18 [ d# 1 ] + next drop ;
: +ram ( w n node ) nn-n 2* [ h# 8000 ] + block u+ for dup @ [ h# 15555 ]
   or !18 [ d# 1 ] + next drop ;
: !frame ( f ) drop stream [ bi ] @ tosea ; { br }
: exec [ h# AE ] ;
: talk cold -sea +sea if drop reset h# 40 d# 0 [ exec ] /frame h# 0 h# 40
   { 42F } d# 708 +ram [ wos ] !frame ( good ) ; then ( bad ) -sea ; {
   cr }
: exch ( w n f n ) push push dup [ h# 2 ] + [ d# -2 ] and [ vport ] @
   pop /frame [ vport ] @ [ h# 12000 ] + !18 dup - [ h# 1 ] and drop if
   [ vport ] @ [ h# 10000 ] + !18 then +frame [ wos ] !frame pop insea
   -stream ; { br }
: ok [ h# 12 ] ;
: fet [ h# 15 ] ;
: stat [ h# 1B ] ;
: bstk [ h# 1D ] ; }block

  119 shadow{  ( boot frames begin with a 3 word header; ) { indent }
 100xx ( jump to xx when done ) { indent }
 ddd ( mem/port adr to store payload ) { indent }
 nnn ( transfer length ) { indent }
 [ nnn+1 * 2 ] ( words of payload )
: /frame ( heads a new given ) [ even ] ( words of payload, destination
   addr, final jump addr. )
: +frame ( appends words to payload. )
: +ram ( appends a string of code from binary produced by ) compile (
   for the given ) [ node. ]
: !frame ( transmits frame given ) [ wos ] ( or ) [ wos! ] { br }
: talk ( prepares chip for control thru node 19. )
: exch ( performs a transaction with target given addr and length of port
   stream, stream end action in boot node, and number of words reply. )
   { cr }
: ok ( stream end to simply ack completion; ) fet ( pumps one word from
   target; ) bstk ( shepherds stack dump; ) stat ( pumps ten. ) exec (
   is next boot frame. ) }block

  120 code{  ( node { 588F } route lists )
: 0pa align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 , d# 703
   , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , d# 300 , d# 200
   , d# 100 , d# 0 , d# 1 , d# 2 , d# 3 , d# 4 , d# 5 , d# 6 , d# 7 ,
   d# 8 , d# 9 , d# 10 , d# 11 , d# 12 , d# 13 , d# 14 , d# 15 , d# 16
   , d# 17 , d# 117 , d# 217 , d# 317 , d# 417 , d# 517 , d# 617 , d# 717
   , d# 716 , d# 715 , d# 714 , d# 713 , d# 712 , d# 711 , d# 710 , d# 709
   , d# 708 , d# -1 , ]
: 1pa align create [ d# 708 , d# 608 , d# -1 , ]
: 2pa align create [ d# 708 , d# 709 , d# 710 , d# 711 , d# 712 , d# 713
   , d# 714 , d# 715 , d# 716 , d# 717 , d# 617 , d# 517 , d# 417 , d# 317
   , d# 217 , d# 117 , d# 17 , d# 16 , d# 15 , d# 14 , d# 13 , d# 12 ,
   d# 11 , d# 10 , d# 9 , d# 8 , d# 7 , d# 6 , d# 5 , d# 4 , d# 3 , d# 2
   , d# 1 , d# 0 , d# 100 , d# 101 , d# 102 , d# 103 , d# 104 , d# 105
   , d# 106 , d# 107 , d# 108 , d# 109 , d# 110 , d# 111 , d# 112 , d# 113
   , d# 114 , d# 115 , d# 116 , ] { cr }
 ( rest ) [ d# 140 load ] }block

  121 shadow{ 
: 0pth 1pth 2pth ( are manually set route lists for using the north, south,
   and west ports of node 19. end list is marked by -1 ) { br }
 ( this block has plenty of extra room so that you may customize the available
   lists without changing the reference versions. ) }block

  122 code{  ( boot target adjacent )
: wall ( nn-i ) over over or [ d# 1 ] and drop if or [ d# 2 ] and ; then
   { 14F } [ d# 100 ] / swap { 14F } [ d# 100 ] / or [ d# 2 ] and [ d# 1 ]
   + ; { br }
: do! align create ( @p+a!.@p+ ) [ h# 4AB7 , ] { indent }
 [ h# 0 , h# 0 , ] ( !;;; ) [ h# B555 , ]
: do@ align create ( ...@p+ ) [ h# 2C9B7 , ] { indent }
 [ h# 0 , ] ( a!@!p+; ) [ h# 2BE35 , ]
: doi align create [ h# 10000 , ]
: dopu align create ( @p+; ) [ h# 5555 , h# 0 , ]
: dostk align create ( !p+dup-push!p+ ) [ h# CDBE , ] { br }
: aa@ ( a-n ) [ do@ d# 1 + ] ! do@ [ d# 3 ] fet [ d# 1 ] exch @18 ;
: aa! ( na ) [ do! d# 1 + ] ! [ do! d# 2 + ] ! do! [ d# 4 ] ok [ d# 1 ]
   exch ;
: acall ( a ) [ h# 10000 ] +
: ains ( w ) [ doi ] ! doi [ d# 1 ] ok [ d# 1 ] exch ;
: apsh ( n ) [ dopu d# 1 + ] ! dopu [ d# 2 ] ok [ d# 1 ] exch ;
: astk dostk [ d# 1 ] bstk [ d# 10 ] exch ; }block

  123 shadow{  ( this code supports boot node controlling one of its immediate
   neighbors directly. ) [ these all begin with focusing call and each
   must return! ] { cr }
: port ( returns port for 0-3 rdlu ndx, then edges )
: wall ( is index for port between two nodes ) { br }
: doxxx ( port execution templates for target. )
: aa@ ( fetches from memory or port in target onto our stack here. )
: aa! ( stores a value from our stack here to port or memory in target. )
: ains ( executes an arbitrary instruction word which must end by returning. )
: acall ( executes a target word which must return or jump to ports. )
: apsh ( pushes a number onto target stack. )
: astk ( queries target stack nondestructively. ) }block

  124 code{  ( stream components )
:# 'pth 67522897
: nstream ( an-n'w ) swap [ 'pth ] ! [ d# -2 ] + -if [ d# 0 ] pop drop
   ; then ( pre ) [ d# 2 ] ;
: ?path ( i-n ) [ 'pth ] @ + @ ;
: side ( n-a ) [ 'pth ] @ + dup @ swap [ d# 1 ] + @ wall port ;
: /hdr ( w-w ) dup [ d# -2 ] and [ d# 0 ] side [ exec ] /frame ( pre )
   [ d# 0 ] side [ h# 12000 ] + !18 [ d# -1 ] + dup [ d# 1 ] and drop
   if [ d# 0 ] side [ h# 10000 ] + !18 then [ d# -1 ] + ; { br }
: +pump ( nw-nw ) [ d# -8 ] + ( @p+b!@p+@p+ ) [ h# 4B17 ] !18 { cr }
 [ h# 1 ] side dup !18 dup [ h# 10000 ] + !18 [ h# 12000 ] + !18 { cr }
 ( !b!b.@p+ ) [ h# 9BB7 ] !18 ( w ) dup [ d# -1 ] + !18 { cr }
 ( dup-push-if ) [ h# 24861 ] !18 ( @p+!b.unext ) [ h# 5BB4 ] !18 ;
: +load ( w n nb nd ) push push ( @p+a!.@p+ ) [ h# 4AB7 ] !18 ( a ) over
   !18 ( n ) [ d# -1 ] + !18 ( dup-push-if ) [ h# 24861 ] !18 { cr }
 ( @p+!+.unxt ) [ h# 58B4 ] !18 pop pop +ram ;
: +post ( p @p+b!.@p+ ) [ h# 4BB7 ] !18 [ d# 1 ] side !18 [ d# 0 ] side
   !18 ( a!@p+push; ) [ h# 2BDBD ] !18 ( p ) !18 ; }block

  125 shadow{  ( templates and load streams )
: 'pth ( current posn in path list of nodes. )
: nstream ( given addr of path tbl, nodes away, gives no of wire nodes
   and total stream length )
: ?path ( returns node number relative to current posn in selected path. )
: side ( gives adr of ) 0 ( near, ) 1 ( far side next node )
: /hdr ( starts a stream of given length; if odd, we leave out jump after
   waking 1st node. ) { br }
: +pump ( makes port pump thru next node; its ram load and init postamble
   must be out of w. )
: +load ( builds a program load from binary given node ram addr, word
   count, words to take from binary, and node number. caller must append
   any words not taken from binary. )
: +post ( follows a node's ram load to set b to out, a to in, and jump
   to ) p. }block

  126 code{  ( umbilical plumbing )
: using ( nn ) wall port [ vport ] ! ;
: avail ( n-p ) nn-n idle ; { br }
: +path ( n'wn-n'w ) dup [ 'pth ] +! negate u+ ; { br }
: rip ( nw-nw ) [ d# 0 ] u+ if ( post ) [ d# -5 ] + +pump [ d# 1 ] +path
   rip [ d# -1 ] +path then [ d# 1 ] ?path avail +post ;
: rips ( an-n'w ) nstream over [ d# 13 ] * + [ d# 5 ] + /hdr rip
: hose ( nw ) drop drop d# 0 ?path d# 1 ?path using [ wos ] !frame ; {
   br }
: wire ( nw-nw ) [ d# 0 ] u+ if ( wire ) [ h# 16 d# 10 + negate ] + +pump
   [ d# 1 ] +path wire [ d# -1 ] +path ( wire ) h# 0 [ h# 16 ] dup { EF }
   d# 17 +load [ d# 0 ] side +post ; then ( last ) h# 0 [ h# 20 ] dup
   [ d# -1 ] + { CF } d# 16 +load [ d# 1 ] side [ h# 12000 ] + !18 [ d# 0 ]
   side +post ;
: wires ( an-n'w ) nstream over [ d# 18 ] ( lwire ) [ h# 16 + ] * + [
   d# 10 ] ( llast ) [ h# 20 + ] + nop /hdr wire hose ; }block

  127 shadow{  ( this block creates and destroys umbilical wiring within
   the chip. ) { br }
: using ( sets ) vport ( between given pair of nodes. )
: avail ( is idle pc val for given node. ) { br }
: +path ( steps ) pos ( to, ) neg ( away from target. ) { br }
: wires ( builds wire for path table ) [ a. ] ( entry zero is boot node. )
   [ n ] ( is number of nodes away from boot in path; ) 0 ( no uut, )
   1 ( no wire, uut is meighbor, ) 2 ( neighbor is last guy, ) 3 [ n-2 ]
   ( wire nodes then last guy. generates call at end of last guy pgm that
   last guy sends target for focus. )
: rips ( rips out a wire built by ) wire }block

  128 code{  ( routing control )
: targets ( -a ) [ act ] @ align tbl [ 0tg , 1tg , 2tg , ]
: paths ( -a ) [ act ] @ align tbl [ 0pa , 1pa , 2pa , ] { br }
: path ( i ) [ act ] ! paths dup @ swap [ d# 1 ] + @ wall port [ vport ]
   ! ;
: node ( n ) [ d# 3 ] for i [ d# -1 ] + path paths targets @ + @ over
   or drop while next drop ; then pop drop drop ; { br }
: -hook ( i ) path targets @ [ d# 1 ] or drop if paths targets @ rips
   [ d# 1 ] targets ! then ;
: hook ( i n ) swap -hook [ d# 2 ] begin over over paths + @ or drop while
   dup paths + @ [ d# 0 ] + drop -if drop drop ; then [ d# 1 ] + end then
   dup targets ! paths swap wires drop ; { br }
: ?adj pop [ d# 1 ] + dup 4@ swap [ d# 4 ] + targets @ d# 1 or drop if
   push drop ; then + push ; }block

  129 shadow{  ( these functions support route setup and selection for
   internal wiring. ) { br }
: targets ( table of target index variables. )
: paths ( table of route lists. ) { br }
: path ( selects active path ) [ i ] ( 0,1,2 )
: node ( selects path whose target is node ) [ n ] { br }
: -hook ( rips out any wiring on path ) [ i ]
: hook ( hooks up path ) [ i ] ( to node ) [ n ] ( ripping out any old
   wiring on that path. ) { br }
: ?adj ( executes following word and exits defn if selected path is to
   adjacent node, otherwise skips following word. ) }block

  130 code{  ( target anywhere )
: dor! align create [ h# 12005 , h# 0 , h# 0 , ]
: dor@ align create [ h# 12000 , h# 0 , ]
: dori align create [ h# 1200A , h# 0 , ]
: dorp align create [ h# 1200D , h# 0 , ]
: dorst align create [ h# 12010 , ]
: stak align create [ d# 40 rez ] { br }
: r@ ( a-n ) ?adj aa@ [ dor@ d# 1 + ] ! dor@ [ d# 2 ] fet [ d# 1 ] exch
   @18 ;
: r! ( na ) ?adj aa! [ dor! d# 1 + ] ! [ dor! d# 2 + ] ! dor! [ d# 3 ]
   ok [ d# 1 ] exch ;
: call ( a ) [ h# 10000 ] +
: rins ( w ) ?adj ains [ dori d# 1 + ] ! dori [ d# 2 ] ok [ d# 1 ] exch
   ;
: lit' ( n ) ?adj apsh [ dorp d# 1 + ] ! dorp [ d# 2 ] ok [ d# 1 ] exch
   ;
: aupd astk
: @stk @18 ( s ) [ stak d# 1 + ] ! @18 ( t ) [ stak ] ! [ stak d# 2 + ]
   d# 8 for @18 over ! [ d# 1 ] + next drop ;
: upd ?adj aupd dorst [ d# 1 ] stat [ d# 10 ] exch @stk ;
: lit lit' upd ;
: boot ( a n nd ) nn-n swap push 2* d# 32768 + block over + swap begin
   over @ [ h# 15555 ] or over r! [ d# 1 ] + [ d# 1 ] u+ next drop drop
   ; }block

  131 shadow{  ( these operations work on any target node. ) { br }
: dorx ( port templates for remote target. ) { br }
: r@ r! rins lit call ( are the specific names for the primitives using
   appropriate sequences for adjacent or remote target nodes. ) { br }
: boot ( loads code into current remote node from binary image for node )
   [ nd ] ( from addr ) [ a ] ( in both image and ram for ) [ n ] ( words. ) }block

  132 code{  ( remote instructions )
: compile recompile ;
: focus paths targets @ + dup @ swap d# -1 + @ wall port call ;
: virgin paths targets @ + @ avail call ; { br }
: rop ( n ) [ h# A ] or [ d# 13 ] for 2* next ( ;s ) [ h# 1555 ] + rins
   upd ;
: @+ [ h# 9 ] rop ; { -cr }
: !+ [ h# D ] rop ; { -cr }
: !b [ h# E ] rop ;
: r+* [ h# 10 ] rop ;
: r2* [ h# 11 ] rop ; { -cr }
: r2/ [ h# 12 ] rop ;
: r- [ h# 13 ] rop ; { -cr }
: r+ [ h# 14 ] rop ;
: rand [ h# 15 ] rop ; { -cr }
: ror [ h# 16 ] rop ;
: rdrop [ h# 17 ] rop ; { -cr }
: rdup [ h# 18 ] rop ;
: rover [ h# 1A ] rop ;
: ra! [ h# 1F ] rop ; { -cr }
: ra@ [ h# 1B ] rop ;
: rb! [ h# 1E ] rop ; { br }
: io h# 15D ; { -cr }
: data h# 141 ; { -cr }
: up h# 145 ;
: down h# 115 ; { -cr }
: left h# 175 ; { -cr }
: right h# 1D5 ; }block

  133 shadow{  ( single instruction words that may be executed by the
   target. these must end with return for s40 restriction compliance. )
   { br }
 ( the following won't work on s40 due to bug 1. )
: r@p+ [ h# C ] rop ;
: psh ( n ) r@p+ ( value ) rins ; }block

  134 code{  ( indicator panel ) [ d# 135 load ] ( node stack / upd )
   { .s br }
 ( path, via, hops, tgt - green selected ) { .pth br }
 ( mem dump / ?ram or ?rom ) { .ram }
 }block

  135 shadow{  ( code for panel )
: panel [ d# 134 ] list ;
: .s silver cr cr [ stak d# 6 + ] d# 4 for dup @ d# 5 h.n space [ d# 1 ]
   + next [ d# -5 ] + cr d# 6 for dup @ d# 5 h.n space [ d# -1 ] + next
   drop ;
: ?color ( nn-nn ) over over or drop if silver ; then green ;
: .pth [ act ] @ cr d# 3 for cr i [ d# -1 ] + path [ act ] @ ?color .
   paths dup [ d# 1 ] + @ . targets @ dup . + @ . next path ; { br }
: /ram align create [ d# 64 a-b rez ]
: rsp ( n dup ) d# 1 and drop if sp/2 then ;
: .ram silver cr [ /ram ] d# 64 for i [ d# 7 ] and ?zero drop if cr space
   then i rsp dup @ d# 5 h.n i d# 1 and drop if space then [ d# 1 ] +
   next drop ; }block

  136 code{  ( tester )
: ent d# 0 ;
: n6tst d# 0 d# 64 d# 6 boot ent call d# 0 r@ dup d# 123 + dup d# 0 r!
   d# 0 r@ or if abort then drop d# 0 r! ( upd ) ;
: rot ( n-n ) [ h# 3FFFF ] and 2* [ h# 40000 ] /mod + ;
: sto ( n ) dup [ d# 63 ] for rot dup i r! -next drop { cr }
 [ d# 63 ] for rot i r@ over over or { indent }
 drop if i abort then drop -next drop ;
: pat ( n ) [ d# 18 ] for dup sto rot next drop ;
: ramtst d# 0 sto h# 3FFFF sto d# 1 pat h# 3FFFE pat ;
: one ( n ) d# 2 swap hook pause ( n6tst ) ramtst ;
: ?ok ( n-t ) [ 0pa @ nn-n ] or ;
: all ( n ) nn-n [ d# 1 ] + for i [ d# -1 ] + ?ok drop if i [ d# -1 ]
   + n-nn one then next ;
: !dac ( n i ) d# 2 swap hook h# 155 or io r! ;
: !dacs ( n ) dup d# 709 !dac dup d# 713 !dac dup d# 717 !dac dup d# 617
   !dac d# 117 !dac ;
: nn ( n-n ) d# -1 + dup !dacs ;
: ms d# 100000 * for next ;
: watch begin upd pause d# 1000 ms key? end ;
: ?ram d# 0
: suck ( a ) [ /ram ] d# 64 for over r@ over ! [ d# 1 ] + [ d# 1 ] u+
   next drop drop ;
: ?rom [ h# 80 ] suck ; }block

  137 shadow{  ( this test routine tester loads and runs the code compiled
   for node 6 on all other nodes except the root, stopping if a node crashes
   or, possibly, other failure criteria are met ) { br }
: one ( runs the test routine from node 6 compilation, entry point ) ent
   ( , on node ) [ n ] ( . aborts if we cannot write and read back memory. )
: all ( tries the test starting with node n and going down to node zero,
   skipping node 19. ) { br }
: watch ( displays live stack from current node. this and other interactive
   functions can be enabled in a running program by placing a definition
   like this in outer loop... )
: poll @b h# 200 and if up b! @b push ;' h# 15D b! then drop ; { br }
: !dac ( sets given output value in node i )
: !dacs ( sets given value in all dacs. ) }block

  138 code{  ( canonical words )
: @ ( a-n ) r@ ;
: ! ( na ) r! ; ( call lit upd rins boot !b already ok )
: +* r+* ;
: 2* r2* ;
: 2/ r2/ ;
: - r- ;
: + r+ ;
: and rand ;
: or ror ;
: drop rdrop ;
: dup rdup ;
: over rover ;
: a! ra! ;
: a ra@ ;
: b! rb! ; }block

  139 shadow{  ( the final step in loading the ide is to redefine the
   canonical forth words to operate on the target node. this is done as
   a separate step so that you may define any sort of exerciser before
   losing access to host colorforth words. ) }block

  140 code{  ( node { 588F } route lists contd ) { cr }
 [ d# 216 , d# 215 , d# 214 , d# 213 , d# 212 , d# 211 , ] { cr }
 [ d# 210 , d# 209 , d# 208 , d# 207 , d# 206 , d# 205 , ] { cr }
 [ d# 204 , d# 203 , d# 202 , d# 201 , d# 200 , ] { cr }
 [ d# 300 , d# 301 , d# 302 , d# 303 , d# 304 , d# 305 , ] { cr }
 [ d# 306 , d# 307 , d# 308 , d# 309 , d# 310 , d# 311 , ] { cr }
 [ d# 312 , d# 313 , d# 314 , d# 315 , d# 316 , ] { cr }
 [ d# 416 , d# 415 , d# 414 , d# 413 , d# 412 , d# 411 , ] { cr }
 [ d# 410 , d# 409 , d# 408 , d# 407 , d# 406 , d# 405 , ] { cr }
 [ d# 404 , d# 403 , d# 402 , d# 401 , d# 400 , ] { cr }
 [ d# 500 , d# 501 , d# 502 , d# 503 , d# 504 , d# 505 , ] { cr }
 [ d# 506 , d# 507 , d# 508 , d# 509 , d# 510 , d# 511 , ] { cr }
 [ d# 512 , d# 513 , d# 514 , d# 515 , d# 516 , ] { cr }
 [ d# 616 , d# 615 , d# 614 , d# 613 , d# 612 , d# 611 , ] { cr }
 [ d# 610 , d# 609 , d# 608 , d# 607 , d# 606 , d# 605 , ] { cr }
 [ d# 604 , d# 603 , d# 602 , d# 601 , d# 600 , ] { cr }
 [ d# 700 , d# 701 , d# 702 , d# 703 , d# 704 , d# 705 , ] { cr }
 [ d# 706 , d# 707 , d# 708 , d# -1 , ] }block

  141 shadow{  }block

  142 code{  }block

  143 shadow{  }block

  144 code{  ( arrayforth tm and okad tools and designs ) { cr }
 ( copyright 2009-2010 greenarrays, inc. ) { cr }
:# first -1 [ d# -1 first ! ] { cr }
:# cur 23492085 ( config ) [ d# 148 load ] { br }
: .s ; ( defaults for blue words )
: .pth ;
: .ram ; { br }
: ray ( i-a ) pop 2/ 2/ + ;
:# ntbl 0 [ d# 0 ntbl ! ]
: aray ( n ) < align > call ray [ d# 4 ] * [ h ] +! ;
: uatbl ( i-a ) [ d# 1000 aray ]
: nil d# 0 [ ntbl ] ! ; { br }
 ( png screen capture ) [ png ] { cr }
 ( chip design ) [ d# 900 load ] }block

  145 shadow{  ( main load block for okad2 applications )
: cur ( cursor position )
: first ( execution of hardsim. initializes least-squares variables )
   { br }
: ray ( defines i-a array usage ) align ray
: aray ( use after red to make ray of n cells )
: uatbl ( lists transistor table addresses of the devices so far found
   to be conducting current. )
: ntbl ( is number of active uatbl entries. )
: nil ( clears the table. ) }block

  146 code{  }block

  147 shadow{  }block

  148 code{  ( configuration blocks )
:# orgn 0 [ d# 0 orgn ! ]
: exit 7pop 7pop ;
: tbl ( i-n ) pop 2/ 2/ + @ ;
: assign ( a ) pop swap ! ;
: xqt ( a ) @ push ;
: cfuse d# 648 ; ( active ) [ cfuse load ]
: cfchip d# 650 ;
: cfpins d# 654 ;
: cfstart d# 656 ;
: cfpads d# 658 ;
: cfprobe d# 660 ;
: cfsim d# 662 ;
: cfstep d# 664 ;
: cfscale d# 666 ;
: cftape d# 756 ; ( tapeout default )
: readme [ cfuse block ] nop [ cfuse d# 18 / ] d# 2 @cyls ;
: tapeout [ cftape block ] nop [ cfuse block ] nop [ d# 36 d# 256 * ]
   move ;
: recompile d# 940 load [ orgn ] @ load lis ; }block

  149 shadow{  ( names for blocks that are customized to configure tools
   while designing and testing. )
: cfuse ( two cylinders on cylinder boundary - 18 blocks plus shadows
   - actively loaded and used )
: cftape ( default image of config area under change control in base )
   { br }
: exit ( terminates interpretation of a block. )
: tbl ( self fetching cell array. usage' )
: squared ( i-n ) align tbl [ d# 0 , d# 1 , d# 4 , d# 9 , d# 16 , ]
: assign ( places addr of following code in the location given and exits
   current definition. )
: xqt ( calls the code whose adr is in the var given. ) }block

  150 code{  ( redact okad disk ) [ audit ] { br }
 ( to arm this block, make ) { cr }
 ( this word white... ) [ exit ] { br }
 ( okad ) [ d# 146 d# 148 obliterate d# 190 cfuse obliterate cfpins d# 890
   obliterate ] { cr }
 ( chip ) [ d# 902 d# 940 obliterate d# 944 d# 1248 obliterate ] { br }
 ( type save to commit changes ) }block

  151 shadow{  ( load this block to redact an okad disk for public release
   or extensive programming. ) }block

  152 code{  }block

  153 shadow{  }block

  154 code{  }block

  155 shadow{  }block

  156 code{  ( big letters ) [ macro ]
: *byte h# C80F 2, ; [ forth ]
: clr [ aper d# 2 + ] ;
:# sz 14
:# cur 9462784 [ d# 14 sz ! ]
: ptab ( xy ) d# 1024 * + [ aper @ d# 4 / ] + [ cur ] ! ;
: center ( n ) [ sz ] @ d# -24 * d# 768 + 2/ ptab ;
: table d# 12 * [ d# 12 block ] + ;
: 1line ( a ) [ sz ] @ for [ clr ] @ over ! d# 1 + next drop ;
: pix ( a ) [ sz ] @ for dup 1line d# 1024 + next drop ;
: row ( an-an ) d# 16 for dup and -if over pix then [ sz ] @ u+ 2* next
   d# 1024 [ sz ] @ * [ sz ] @ d# -16 * + u+ ;
: !emit table [ cur ] @ d# 12 for over @ *byte row row drop d# 1 u+ next
   drop drop [ sz ] @ d# 18 * [ cur ] +! ;
: !digit d# 24 + !emit ;
: 2. ( nn ) /mod !digit !digit ;
: 4. ( n ) d# 100 /mod d# 10 2. d# 10 2. ; }block

  157 shadow{  }block

  158 code{  ( big clock ) [ empty d# 40 load d# 156 load ]
: hm sec d# 60 /
: sex ( n ) d# 60 /mod d# 100 mod d# 10 2. d# 10 2. ;
:# t0 32458
: ?beep if ; then beep ;
: till [ t0 ] @ sec negate + green -if negate red then ?beep sex ;
: set ( n ) d# 60 * sec + [ t0 ] !
: ok show black screen blue d# 0 center hm ( till ) ;
: run dup pause drop key? run ; [ ok run ] }block

  159 shadow{  }block

  160 code{  ( compare ) [ empty d# 30 load ]
: n18 ( i-a ) [ d# 3018 block ] + ;
: unpk abs [ d# 1 n18 ] ! [ d# 3036 ] block [ d# 5000 ] block [ d# 1404 ]
   blks move [ d# 5000 block ] d# 3036 [ d# 3 n18 ] @ [ d# -36 ] + range
   ;
: check [ d# 3000 ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or drop if
   ; then [ d# 1 n18 ] @ dup and -if unpk ; then drop ;
: blink dup d# 3000 + [ blk ] ! edit ;
: var push push d# 1 + d# 1 u+ pop pop
: *1 or ;
: *2 var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# F and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1 *1 *1 var
   *1 *1 *1
: co ( naa-n ) d# 256 for over @ over @ tag drop if drop drop pop drop
   pop drop dup d# 2 u+ ( i ) pop swap blink ; then d# 1 + d# 1 u+ next
   drop drop ;
: com ( n ) dup block over d# 3000 + block co ;
: q ( nn ) for com d# 2 + next drop ;
: all d# 18 [ d# 1439 d# -18 + 2/ ] q ;
: old [ blk ] @ d# 3000 mod dup d# 3000 + [ blk ] ! copy ; }block

  161 shadow{ 
: check ( reads backup to { 1770F } and decompresses if appropriate )
: blink ( displays the given block with its other set as the editor's
   'other' block )
: var ( compares a variable name, advancing pointers to skip its value. )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compare compares the two source cells given, returning true if
   they differ. ignores variable differences. )
: ?nul ( ends the loop in co when nuls are found in both blocks. )
: co ( given the addresses of the two blocks does the work of com. )
: com ( invokes editor to blink the given block if it differs from the
   other, leaving stack set to continue the scan by typing q. otherwise
   returns. )
: all ( scans the whole usable area of the disk. )
: q ( scans for differences given starting block and number of source
   blocks skipping shadows. )
: note! ( return stk probably grows! ) }block

  162 code{  ( compare roms ) [ compile empty ]
:# x 887904
:# y 8913568
: old ( n-a ) d# 64 * d# 1420 block + ;
: new ( n-a ) 2* h# 8000 + block h# 80 + ;
: spaces for space next ;
: 5-8 d# 8 /mod d# 32 /mod d# 32 /mod h# 100 * + h# 100 * + h# 100 * swap
   d# 4 * + ;
: it @ + @ dup 5-8 white h. space dup h# 15555 or d# 5 silver h.n space
   ;
: lines for i [ x ] it i [ y ] it white or if red dup d# 5 h.n then drop
   space i d# 1 h.n cr -next ;
: u d# 16
: +xy dup [ x ] +! [ y ] +! ;
: d d# -16 +xy ;
: n d# 1 +
: see ( n-n ) dup old [ x ] ! dup new [ y ] ! show black screen text d# 15
   lines green [ x ] @ h. d# 7 spaces [ y ] @ h. keyboard ;
: b d# -1 + see ;
: diff ( n-n ) dup old over new d# 64 for over @ over @ or drop if drop
   drop pop drop pop drop see ; then d# 1 + d# 1 u+ next drop drop ;
: check d# 40
: more d# -1 + diff d# 0 or if more ; then drop show green screen keyboard
   ; }block

  163 shadow{  ( compare roms )
: . ( put t18 rom into blocks 1420ff )
: see n-n ( compare roms for node n )
: u ( up 16 words )
: d ( down 16 words )
: n ( next node )
: b ( back one node )
: diff ( compare up to 64 words, t18 binary vs g18 compile. total match
   gets green screen. first non-matching word causes a dump of that node.
   note the double pop drop in diff. don't run it as a command. )
: check ( run diff on all 40 nodes ) }block

  164 code{  ( timing ) [ empty macro ]
: out h# E1E6 2, ; [ forth ]
: tare time - d# 1000 for next time + ;
: tare+ time - push d# 1000 for dup next c pop time + ;
: test tare time + - d# 1000 for out next time + ; ( next 3 loop 5.7 /next
   2 /swap 25 swap 7.2 ) [ macro ]
: c! h# C88B 2, < drop > here ;
: loop h# 49 1, h# 75 1, ( e2 ) here - + 1, ; [ forth ]
: try time - d# 1000 c! loop time + ; }block

  165 shadow{  }block

  166 code{  }block

  167 shadow{  }block

  168 code{  ( png empty )
:# w 1024
:# hh 768
:# d 1
: frame { 3A0001F } [ aper @ d# 4 / ] ; [ d# 172 load d# 174 load ]
: -crc ( a ) here over negate + crc .. ;
: here/4 ( -a ) here d# 3 and drop if d# 0 1, here/4 ; then here d# 2
   2/s ;
: bys ( nn-b ) .. here swap , ; { cr }
 ( pallettes ) [ d# 170 load ] { br }
: !png ( awh-an ) [ d ] @ / [ hh ] ! [ d ] @ / [ w ] ! here/4 swap H# 474E5089
   , H# A1A0A0D , ( ihdr ) H# 52444849 d# 13 bys [ w ] @ .. [ hh ] @ ..
   h# 304 , h# 0 1, -crc ( plte ) pallette ( idat ) H# 54414449 d# 0 bys
   swap deflate -crc ( iend ) H# 444E4549 d# 0 bys -crc here/4 over negate
   + ; { br }
: 'at ( xy-a ) d# 1024 * + [ frame ] + ;
: full d# 1 [ d ] ! d# 0 dup 'at d# 1024 d# 768 !png ;
: png full wgds ; }block

  169 shadow{ 
: d ( is reduction factor ) }block

  170 code{  ( pallettes )
: paper H# 45544C50 d# 48 bys { cr }
 h# FFFFFF 3, h# C00000 3, h# C000 3, h# C0C000 3, { cr }
 h# C0 3, h# C000C0 3, h# C0C0 3, h# 404040 3, { cr }
 h# C0C0C0 3, h# FF0000 3, h# FF00 3, h# FFFF00 3, { cr }
 h# FF 3, h# FF00FF 3, h# FFFF 3, h# 0 3, -crc ; { br }
: crt H# 45544C50 d# 48 bys { cr }
 h# 0 3, h# C00000 3, h# C000 3, h# C0C000 3, { cr }
 h# C0 3, h# C000C0 3, h# C0C0 3, h# 404040 3, { cr }
 h# C0C0C0 3, h# FF0000 3, h# FF00 3, h# FFFF00 3, { cr }
 h# FF 3, h# FF00FF 3, h# FFFF 3, h# FFFFFF 3, -crc ; { br }
: pallette ( paper ) crt ; }block

  171 shadow{  }block

  172 code{  ( crc )
:# ad1 23534
:# ad2 64494 [ macro ] { br }
: 2/s ?lit h# E8C1 2, 1, ; { -cr }
: 1@ h# 8A 2, ; [ forth ]
: bit ( n-n ) d# 1 ? if d# 1 2/s H# EDB88320 or ; { indent }
 then d# 1 2/s ;
: ,crc ( nn ) for dup d# 8 for bit next , { indent }
 d# 1 + next drop ;
: table ( -a ) align array [ d# 0 d# 256 ,crc ]
: crc ( bn-n ) d# -1 swap for over 1@ over or h# FF and table swap d# 8
   2/s or d# 1 u+ next - nip ; { br }
: +adl ( n ) h# FF and [ ad1 ] @ + dup [ ad2 ] @ +
: adl! [ ad2 ] ! [ ad1 ] ! ;
: +mod [ ad1 ] @ d# 65521 mod [ ad2 ] @ d# 65521 mod adl! ; }block

  173 shadow{ 
: 2/s ( shift right by literal )
: 1@ ( fetch byte, address in eax )
: array ( return word address in dictionary )
: bit ( process 1 bit with standard 32-bit crc )
: fill ( construct crc table for bytes )
: table ( said table )
: crc ( compute crc for a byte string )
: ad1/ad2 ( adler checksums )
: +adl ( add a byte to both checksums )
: adl! ( store checksums )
: +mod ( truncate checksums ) }block

  174 code{  ( lz77 ) [ macro ] { -cr }
: *byte h# C486 2, ;
: !bx < a! > h# 289 2, < drop > ; [ forth ] { br }
: *bys dup d# 16 2/s *byte swap h# FFFF and *byte h# 10000 * + ; { -cr }
: .. *bys , ;
: 0/1 h# 80 ? if h# 7E and h# 7E or drop if d# 7 ; then h# F ; then d# 0
   and ; { -cr }
: +or over - and or ;
: 4b dup 0/1 h# 9 and over d# 8 2/s 0/1 h# A and +or swap d# 16 2/s 0/1
   h# C and +or ;
: pix dup @ [ d ] @ u+ 4b ;
: row 1, dup [ w ] @ 2/ dup d# 1 + dup 2, - 2, d# 0 dup 1, +adl for pix
   d# 16 * push pix pop or dup 1, +adl next drop +mod [ d ] @ d# 1024
   * + ; { br }
: deflate h# 178 2, d# 1 d# 0 adl! [ hh ] @ d# -1 + for d# 0 row next
   d# 1 row drop [ ad2 ] @ *byte 2, [ ad1 ] @ *byte 2, here over d# 4
   + negate + *bys over d# -4 + !bx ; }block

  175 shadow{ 
: 0/1 ( 0, f or 7 for dark, bright or dim ) }block

  176 code{  ( cf-html ) [ empty d# 74 load ] { cr }
:# pad 271638528 [ d# 3000 block d# 4 * pad ! ] { cr }
:# hld 271672321 [ pad @ hld ! d# 178 d# 6 loads ]
: estyle ,link ,t1cr ( cfhtml.css '? ) ;
: .hdr [ pad ] @ [ hld ] ! ,t1cr ( @html? @head? ) istyle { cr }
 ( estyle ) ,t1cr ( @/head? @body? @table? ) ;
: .blk ( n ) d# 0 [ pos ] ! crlf ,t1 ( @td? ) { cr }
 dup even? if dup .dec ,t1cr ( *list ) then { cr }
 .cr block ,t1 ( @code ) d# 0 [ class ] ! d# 0 [ --cr ] ! { cr }
 begin @+ dup and while .token end then { cr }
 [ class ] @ eq? if ,t1 ( ? ) then drop drop { cr }
 begin -eol? while .nb end then .cr { cr }
 ,t1 ( @/code? ) .cr ,t1cr ( @/td? ) ;
: .sep ,t1 ( @td? ) .nb .nb ,t1 ( @/td? ) ;
: .blks ( first last+2 ) over negate + 2/ for { cr }
 ,t1 ( @tr? ) dup d# 1 or .blk .sep dup .blk { cr }
 ,t1cr ( @/tr? ) [ d# 2 ] + next drop ;
: .tlr ,t1cr ( @/table? @/body? @/html? ) sav ;
: .html ( first last+2 ) .hdr .blks .tlr ; { cr }
 [ named ] ( cf.html ) }block

  177 shadow{  ( colorforth to html utility ) { br }
 ( the html is created between ) [ pad ] ( and ) [ hld ] { cr }
 ( by ) .html ( and its factors ) .hdr .blks ( and ) .tlr ( , then written
   to the file last ) [ named ] ( . ) { br }
 ( uncomment ) estyle ( in ) .hdr ( to use an external ) { cr }
 ( stylesheet, maybe for printing. ) { br }
 ( pairs of blocks are formatted 2-up using html tables, with the odd/even
   blocks used to invoke ) [ .html ] ( or ) [ .blks ] ( displayed on the
   right. 'n list' is shown above the even block. ) { br }
 [ d# 176 d# 188 .html ] ( puts shadows on left, while ) { cr }
 [ d# 177 d# 189 .html ] ( puts them on the right. ) { br }
 [ seeb ] ( toggles blue-word visibility. ) { br }
 ( the last line of each block is filled ) { cr }
 ( with ) nbsp ( for column alignment. the ) [ class ] @ { cr }
 ( line closes the ) < code > ( tag of an empty block. ) }block

  178 code{  ( generate html details ) { cr }
: eq? ( nn-n ) over or if drop d# -1 then - ( nz? ; )
: nz? ( n ) dup and drop ;
: even? ( n ) h# 1 or h# 1 and drop ; { br }
: @+ ( a-an ) dup d# 1 + swap @ ;
: @tag ( a-at ) dup @ h# F and ; { br }
: sc h# 3B ( semicolon )
: ch, ( c ) [ hld ] @ 1! d# 1 [ hld ] +! ;
: lb h# 7B ( left-brace ) ch, ;
: rb sc h# 7D ( right-brace ) ch,
: crlf d# 13 ch, d# 10 ch, ; { br }
: ,token ( n ) ch if ch, ,token ; then drop drop ;
: ,word ( a-a ) begin @+ ,token @tag drop until ; { cr }
 ( loop ) begin ,word
: ,comments ( a ) @tag d# 9 or drop until drop ; [ macro ] { cr }
: ,t ( words ) 7push pop < ,lit > call ,comments nop ;
: ,trb ( words ) < ,t > call rb nop ;
: ,t1 ( words ) call set1 < ,t > call set0 nop ;
: ,t1cr ( words ) < ,t1 > call crlf nop [ forth ] }block

  179 shadow{ 
: eq? { -cr }
: nz? { -cr }
: diff? { -cr }
: even? ( leave only flags ) { cr }
: @+ { -cr }
: @tag ( are common factors ) { br }
 ( the following words generate ascii text only for html tags and source
   formatting; it will not be visible in the html display. ) { br }
: sc { -cr }
: ch, { -cr }
: lb { -cr }
: rb { -cr }
: crlf ( punctuation output ) { br }
 ( the macros enable in-line output from the ) { cr }
 ( standard cf-ascii table using ) [ set0 ] ( default or the extended
   table using ) [ set1 ] { br }
: ,token ( output ascii characters for one token )
: ,word ( output a token and any extension tokens )
: ,comments ( output contiguous comment words ) { br }
: ,t ( output from current set, don't change set. )
: ,trb ,t ( output followed by ) rb
: ,t1 ( output from ) set1 ( , return to ) set0 ( at end )
: ,t1cr ,t1 ( output followed by ) crlf }block

  180 code{  ( translate text and numbers )
:# pos 0
: -bol? [ pos ] @ nz? ;
: -eol? [ pos ] @ d# 46 or drop ;
: .cr ,t1 ( @br? ) d# 0 [ pos ] ! ; { cr }
 ( loop ) begin .cr { -cr }
: emit ( c ) ch, d# 1 [ pos ] +! ;
: .ch ( c ) -eol? until emit ;
: .sp -eol? if -bol? if h# 20 emit ; then then ;
: .2sp .sp ( .nb ; )
: .nb h# 26 ( ampersand ) .ch ,t ( nbsp ) sc ; { br }
: .sp.tn ( n ) .sp ( .tn ; )
: .tn ( n ) ch if .ch .tn ; then drop drop ; { br }
: .hd ( n ) [ d# -10 ] + -if [ h# 3A ] + .ch ; then [ h# 41 ] + .ch ;
: .dec ( n ) .sp [ d# 0 ] + -if h# 2D .ch negate then [ d# -1 ] swap begin
   [ d# 10 ] /mod dup and while end then drop
: spit ( -1 ... ) begin .hd [ d# 0 ] + -until drop ; { br }
: hd ( n-nn ) dup [ h# F ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n ) .sp [ d# -1 ] swap begin hd H# FFFFFFF and while end then
   drop spit ;
: .3hex ( n ) hd hd hd drop .sp .hd .hd .hd ; }block

  181 shadow{ 
:# pos 0 ( character display ) [ pos ] ( ition in line )
: -bol? { -cr }
: -eol? ( test position )
: .cr ( visible crlf )
: emit ( visible character )
: .ch { -cr }
: .sp { -cr }
: .2sp { -cr }
: .nb ( quirky characteristics ) { cr }
 < note > [ .sp ] ( does nothing at left margin ) { cr }
 < note > [ .ch ] ( does ) [ .cr ] ( after 46th character ) { cr }
 < note > [ .2sp ] ( takes only one space at left margin ) { cr }
 < note > [ .nb ] ( takes only one character position. ) { br }
: .tn { -cr }
: .sp.tn ( display a token. ) { br }
: .hd { -cr }
: hd { -cr }
: spit ( are number-output factors )
: .dec { -cr }
: .hex { -cr }
: .3hex ( display numbers ) }block

  182 code{  ( translate cf token details ) { cr }
:# class 763363337
:# --cr 0
: ,class ( a ) @ [ class ] @ over or drop ( diff? ) if { cr }
 [ class ] @ nz? if ,t1 ( @/code? @code ) then { cr }
 ,t1 ( *class+ ) dup [ class ] ! ,token ,t1 ( ? ) ; { cr }
 then drop ; [ macro ]
: ,c 7push pop < ,lit > call ,class nop ; [ forth ] { br }
: .quirks ( n ) [ --cr ] @ nz? if .2sp drop d# 0 [ --cr ] ! ; { cr }
 then ( class ) nz? if -bol? if .cr then then ;
: .space -eol? if .nb then ;
: .indent .cr d# 4 for .nb next ; { br }
: .blue ( n ) H# 9080000E ( cr ) eq? if .cr drop ; { cr }
 then H# E721000E ( -cr ) eq? if d# 1 [ --cr ] ! drop ; { cr }
 then H# 8625920E ( space ) eq? if .space drop ; { cr }
 then H# 76C08C4E ( indent ) eq? if .indent drop ; { cr }
 then H# C620000E ( br ) eq? if .cr .cr then drop ; }block

  183 shadow{ 
:# class 0 ( current class ) { cr }
:# --cr 0 ( true suppresses ) [ cr ] ( before next red word ) { cr }
: ,class { -cr }
: ,c ( class defining words, cf style ) { br }
: .quirks ( handle the spacing before red words ) { br }
: .space ( blue spaces are ignored at eol! )
: .indent { 8F } ( + html leading space ) { br }
: .blue ( generate most of the blue-word effects ) }block

  184 code{  ( translate cf tokens )
: sh? ( n-n ) 2/ 2/ 2/ 2/ dup 2/ swap d# 1 and drop ;
: lh? ( an-an ) push @+ pop h# 10 and drop ; { br }
: .t1 ( n ) ,c ( t1 ) .sp.tn ;
: .t2 ( an-a ) lh? if ,c ( h2 ) .hex ; then ,c ( d2 ) .dec ;
: .t3 ( n ) [ class ] @ ,c ( t3 ) .quirks ( .sp.tn ) .tn ;
: .t4 ( n ) ,c ( t4 ) .sp.tn ;
: .t5 ( an-a ) lh? if ,c ( h5 ) .hex ; then ,c ( d5 ) .dec ;
: .t6 ( n ) sh? if ,c ( h6 ) .hex ; then ,c ( d6 ) .dec ;
: .t7 ( n ) ,c ( t7 ) .sp.tn ;
: .t8 ( n ) sh? if ,c ( h8 ) .hex ; then ,c ( d8 ) .dec ;
: .t9 ( n ) ,c ( t9 ) .sp.tn ;
: .ta ( n ) ,c ( ta ) .sp.tn ;
: .tb ( n ) ,c ( tb ) .sp.tn ;
: .tc ( an-a ) ,c ( tc ) .sp.tn ,c ( dc ) @+ .dec ;
: .td ( n ) sh? ,c ( hd ) .3hex ;
: .te ( n ) ,c ( te ) ?seeb if dup .sp.tn then .blue ;
: .tf ( n ) sh? if ,c ( hf ) .hex ; then ,c ( df ) .dec ; { br }
: .token ( an-a ) dup h# F and jump { cr }
 .tn .t1 .t2 .t3 .t4 .t5 .t6 .t7 { cr }
 .t8 .t9 .ta .tb .tc .td .te .tf }block

  185 shadow{ 
: sh? ( extract short number, true flag if hex )
: lh? ( extract long number, true flag if hex ) { br }
 ( tag ------- cf class ------- html class ) { cr }
 < .t0 > ( extension token ........ ) < same as last >
: .t1 ( execute word ........... ) [ t1 ]
: .t2 ( execute long number .... ) [ h2, d2 ]
: .t3 ( define word ........... ) { -cr }
: t3
: .t4 ( compile word ........... ) t4
: .t5 ( compile long number .... ) h5, d5
: .t6 ( compile short number ... ) h6, d6
: .t7 ( compile macro .......... ) < t7 >
: .t8 ( execute short number ... ) [ h8, d8 ]
: .t9 ( lowercase text comment . t9 )
: .ta ( capitalized text comment ta ) < deprecated >
: .tb ( uppercase text comment . tb ) < deprecated >
: .tc ( variable ............... )
:# tc 0 dc
: .td ( target address ......... hd )
: .te ( editor command ......... ) < te >
: .tf ( short number comment ... hf, df ) { br }
: .token ( translate tag-by-tag ) { indent }
 < note > ( address may be incremented ) }block

  186 code{  ( stylesheet details and file output )
: vat ,t ( *vertical-align; top ) sc ;
: bcw crlf ,t ( *background-color; white ) sc ;
: wsn crlf ,t ( *white-space; nowrap ) sc ;
: fo ,t ( *font- ) ;
: ffm crlf fo { indent }
 ,t ( family; lucida*console,monospace ) sc ;
: fwb crlf fo ,t ( weight; bold ) sc ;
: fz fo ,t ( size; ) ;
: fc lb ,t ( *color; ) h# 23 ( sharp ) ch, ;
: fsi sc fo ,t ( style; italic ) rb ;
: tt sc ,t ( *text-transform; ) ; { br }
: ,link ,t1 ( @link *rel+stylesheet ) { indent }
 ,t1 ( *type+'text/css' *href+' ) ; { br }
: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 2 d# 0 d# 0 { indent }
 pop pop swap fcreate ;
: sav [ d# 0 fnam ] w/o fopen dup push { indent }
 [ pad ] @ dup negate [ hld ] @ + pop { indent }
 fwr drop fclose ; }block

  187 shadow{ 
: vat { -cr }
: bcw { -cr }
: wsn { -cr }
: fo { -cr }
: ffm { -cr }
: fwb { -cr }
: fz { -cr }
: fc { -cr }
: fsi { -cr }
: tt { cr }
 ( space-saving factors of internal stylesheet ) { br }
: ,link ( most of the external stylesheet link ) { br }
: fopen { -cr }
: sav ( open, write, close html file ) { cr }
 < note > ( byte addresses throughout ) }block

  188 code{  ( internal stylesheet )
: istyle ,t1cr ( @style*type+'text/css'? ) set1 { cr }
 ,t ( td ) lb vat bcw wsn ffm fwb fz ,trb ( x-large ) ,t ( code ) lb fz
   ,t ( large ) tt ,trb ( lowercase ) { cr }
 ,t ( .t1 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .h2 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d2 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t3 ) fc ,trb ( ff0000 ) { cr }
 ,t ( .t4 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h5 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d5 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h6 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d6 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .t7 ) fc ,trb ( 00cccc ) { cr }
 ,t ( .h8 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d8 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t9 ) fc ,trb ( 444444 ) { cr }
 ,t ( .ta ) fc ,t ( 000000 ) tt ,trb ( capitalize ) { cr }
 ,t ( .tb ) fc ,t ( 000000 ) tt ,trb ( uppercase ) { cr }
 ,t ( .tc ) fc ,trb ( ff00ff ) { cr }
 ,t ( .dc ) fc ,trb ( 00ff00 ) { cr }
 ,t ( .hd ) fc ,t ( bbbbbb ) fsi { cr }
 ,t ( .te ) fc ,trb ( 0000ff ) { cr }
 ,t ( .hf ) fc ,t ( 777777 ) fsi { cr }
 ,t ( .df ) fc ,trb ( 444444 ) ,t1cr ( @/style? ) ; }block

  189 shadow{ 
: istyle ( internal styles are aimed toward ) { cr }
 ( providing code examples for stand-alone use in other documents. although
   it's black-on-white, it faithfully displays the colorforth screen. )
   { br }
 ( some cf-html rendering tests ) { br }
 [ load D# 2147483647 H# 80000000 ]
: t1 ; D# 2147483646 H# 80000001 d# 87 h# 57 < ?lit > [ d# 87 h# 57 ]
   ( rtoeani rtos ascii )
:# var 123 { cr -cr }
: quirky { BD } { indent { AEF } { AFF } }
 [ d# -87 ] ( end ) [ h# 0 ] h# 0 { 1F } }block

  190 code{  }block

  191 shadow{  }block

  192 code{  }block

  193 shadow{  }block

  194 code{  }block

  195 shadow{  }block

  196 code{  }block

  197 shadow{  }block

  198 code{  }block

  199 shadow{  }block

  200 code{  }block

  201 shadow{  }block

  202 code{  }block

  203 shadow{  }block

  204 code{  }block

  205 shadow{  }block

  206 code{  }block

  207 shadow{  }block

  208 code{  }block

  209 shadow{  }block

  210 code{  }block

  211 shadow{  }block

  212 code{  }block

  213 shadow{  }block

  214 code{  }block

  215 shadow{  }block

  216 code{  }block

  217 shadow{  }block

  218 code{  }block

  219 shadow{  }block

  220 code{  }block

  221 shadow{  }block

  222 code{  }block

  223 shadow{  }block

  224 code{  }block

  225 shadow{  }block

  226 code{  }block

  227 shadow{  }block

  228 code{  }block

  229 shadow{  }block

  230 code{  }block

  231 shadow{  }block

  232 code{  }block

  233 shadow{  }block

  234 code{  }block

  235 shadow{  }block

  236 code{  }block

  237 shadow{  }block

  238 code{  }block

  239 shadow{  }block

  240 code{  }block

  241 shadow{  }block

  242 code{  }block

  243 shadow{  }block

  244 code{  }block

  245 shadow{  }block

  246 code{  }block

  247 shadow{  }block

  248 code{  }block

  249 shadow{  }block

  250 code{  }block

  251 shadow{  }block

  252 code{  }block

  253 shadow{  }block

  254 code{  }block

  255 shadow{  }block

  256 code{  }block

  257 shadow{  }block

  258 code{  }block

  259 shadow{  }block

  260 code{  }block

  261 shadow{  }block

  262 code{  }block

  263 shadow{  }block

  264 code{  }block

  265 shadow{  }block

  266 code{  }block

  267 shadow{  }block

  268 code{  }block

  269 shadow{  }block

  270 code{  }block

  271 shadow{  }block

  272 code{  }block

  273 shadow{  }block

  274 code{  }block

  275 shadow{  }block

  276 code{  }block

  277 shadow{  }block

  278 code{  }block

  279 shadow{  }block

  280 code{  }block

  281 shadow{  }block

  282 code{  }block

  283 shadow{  }block

  284 code{  }block

  285 shadow{  }block

  286 code{  }block

  287 shadow{  }block

  288 code{  }block

  289 shadow{  }block

  290 code{  }block

  291 shadow{  }block

  292 code{  }block

  293 shadow{  }block

  294 code{  }block

  295 shadow{  }block

  296 code{  }block

  297 shadow{  }block

  298 code{  }block

  299 shadow{  }block

  300 code{  }block

  301 shadow{  }block

  302 code{  }block

  303 shadow{  }block

  304 code{  }block

  305 shadow{  }block

  306 code{  }block

  307 shadow{  }block

  308 code{  }block

  309 shadow{  }block

  310 code{  }block

  311 shadow{  }block

  312 code{  }block

  313 shadow{  }block

  314 code{  }block

  315 shadow{  }block

  316 code{  }block

  317 shadow{  }block

  318 code{  }block

  319 shadow{  }block

  320 code{  }block

  321 shadow{  }block

  322 code{  }block

  323 shadow{  }block

  324 code{  }block

  325 shadow{  }block

  326 code{  }block

  327 shadow{  }block

  328 code{  }block

  329 shadow{  }block

  330 code{  }block

  331 shadow{  }block

  332 code{  }block

  333 shadow{  }block

  334 code{  }block

  335 shadow{  }block

  336 code{  }block

  337 shadow{  }block

  338 code{  }block

  339 shadow{  }block

  340 code{  }block

  341 shadow{  }block

  342 code{  }block

  343 shadow{  }block

  344 code{  }block

  345 shadow{  }block

  346 code{  }block

  347 shadow{  }block

  348 code{  }block

  349 shadow{  }block

  350 code{  }block

  351 shadow{  }block

  352 code{  }block

  353 shadow{  }block

  354 code{  }block

  355 shadow{  }block

  356 code{  }block

  357 shadow{  }block

  358 code{  }block

  359 shadow{  }block

  360 code{  }block

  361 shadow{  }block

  362 code{  }block

  363 shadow{  }block

  364 code{  }block

  365 shadow{  }block

  366 code{  }block

  367 shadow{  }block

  368 code{  }block

  369 shadow{  }block

  370 code{  }block

  371 shadow{  }block

  372 code{  }block

  373 shadow{  }block

  374 code{  }block

  375 shadow{  }block

  376 code{  }block

  377 shadow{  }block

  378 code{  }block

  379 shadow{  }block

  380 code{  }block

  381 shadow{  }block

  382 code{  }block

  383 shadow{  }block

  384 code{  }block

  385 shadow{  }block

  386 code{  }block

  387 shadow{  }block

  388 code{  }block

  389 shadow{  }block

  390 code{  }block

  391 shadow{  }block

  392 code{  }block

  393 shadow{  }block

  394 code{  }block

  395 shadow{  }block

  396 code{  }block

  397 shadow{  }block

  398 code{  }block

  399 shadow{  }block

  400 code{  }block

  401 shadow{  }block

  402 code{  }block

  403 shadow{  }block

  404 code{  }block

  405 shadow{  }block

  406 code{  }block

  407 shadow{  }block

  408 code{  }block

  409 shadow{  }block

  410 code{  }block

  411 shadow{  }block

  412 code{  }block

  413 shadow{  }block

  414 code{  }block

  415 shadow{  }block

  416 code{  }block

  417 shadow{  }block

  418 code{  }block

  419 shadow{  }block

  420 code{  }block

  421 shadow{  }block

  422 code{  }block

  423 shadow{  }block

  424 code{  }block

  425 shadow{  }block

  426 code{  }block

  427 shadow{  }block

  428 code{  }block

  429 shadow{  }block

  430 code{  }block

  431 shadow{  }block

  432 code{  }block

  433 shadow{  }block

  434 code{  }block

  435 shadow{  }block

  436 code{  }block

  437 shadow{  }block

  438 code{  }block

  439 shadow{  }block

  440 code{  }block

  441 shadow{  }block

  442 code{  }block

  443 shadow{  }block

  444 code{  }block

  445 shadow{  }block

  446 code{  }block

  447 shadow{  }block

  448 code{  }block

  449 shadow{  }block

  450 code{  }block

  451 shadow{  }block

  452 code{  }block

  453 shadow{  }block

  454 code{  }block

  455 shadow{  }block

  456 code{  }block

  457 shadow{  }block

  458 code{  }block

  459 shadow{  }block

  460 code{  }block

  461 shadow{  }block

  462 code{  }block

  463 shadow{  }block

  464 code{  }block

  465 shadow{  }block

  466 code{  }block

  467 shadow{  }block

  468 code{  }block

  469 shadow{  }block

  470 code{  }block

  471 shadow{  }block

  472 code{  }block

  473 shadow{  }block

  474 code{  }block

  475 shadow{  }block

  476 code{  }block

  477 shadow{  }block

  478 code{  }block

  479 shadow{  }block

  480 code{  }block

  481 shadow{  }block

  482 code{  }block

  483 shadow{  }block

  484 code{  }block

  485 shadow{  }block

  486 code{  }block

  487 shadow{  }block

  488 code{  }block

  489 shadow{  }block

  490 code{  }block

  491 shadow{  }block

  492 code{  }block

  493 shadow{  }block

  494 code{  }block

  495 shadow{  }block

  496 code{  }block

  497 shadow{  }block

  498 code{  }block

  499 shadow{  }block

  500 code{  }block

  501 shadow{  }block

  502 code{  }block

  503 shadow{  }block

  504 code{  }block

  505 shadow{  }block

  506 code{  }block

  507 shadow{  }block

  508 code{  }block

  509 shadow{  }block

  510 code{  }block

  511 shadow{  }block

  512 code{  }block

  513 shadow{  }block

  514 code{  }block

  515 shadow{  }block

  516 code{  }block

  517 shadow{  }block

  518 code{  }block

  519 shadow{  }block

  520 code{  }block

  521 shadow{  }block

  522 code{  }block

  523 shadow{  }block

  524 code{  }block

  525 shadow{  }block

  526 code{  }block

  527 shadow{  }block

  528 code{  }block

  529 shadow{  }block

  530 code{  }block

  531 shadow{  }block

  532 code{  }block

  533 shadow{  }block

  534 code{  }block

  535 shadow{  }block

  536 code{  }block

  537 shadow{  }block

  538 code{  }block

  539 shadow{  }block

  540 code{  }block

  541 shadow{  }block

  542 code{  }block

  543 shadow{  }block

  544 code{  }block

  545 shadow{  }block

  546 code{  }block

  547 shadow{  }block

  548 code{  }block

  549 shadow{  }block

  550 code{  }block

  551 shadow{  }block

  552 code{  }block

  553 shadow{  }block

  554 code{  }block

  555 shadow{  }block

  556 code{  }block

  557 shadow{  }block

  558 code{  }block

  559 shadow{  }block

  560 code{  }block

  561 shadow{  }block

  562 code{  }block

  563 shadow{  }block

  564 code{  }block

  565 shadow{  }block

  566 code{  }block

  567 shadow{  }block

  568 code{  }block

  569 shadow{  }block

  570 code{  }block

  571 shadow{  }block

  572 code{  }block

  573 shadow{  }block

  574 code{  }block

  575 shadow{  }block

  576 code{  }block

  577 shadow{  }block

  578 code{  }block

  579 shadow{  }block

  580 code{  }block

  581 shadow{  }block

  582 code{  }block

  583 shadow{  }block

  584 code{  }block

  585 shadow{  }block

  586 code{  }block

  587 shadow{  }block

  588 code{  }block

  589 shadow{  }block

  590 code{  }block

  591 shadow{  }block

  592 code{  }block

  593 shadow{  }block

  594 code{  }block

  595 shadow{  }block

  596 code{  }block

  597 shadow{  }block

  598 code{  }block

  599 shadow{  }block

  600 code{  }block

  601 shadow{  }block

  602 code{  }block

  603 shadow{  }block

  604 code{  }block

  605 shadow{  }block

  606 code{  }block

  607 shadow{  }block

  608 code{  }block

  609 shadow{  }block

  610 code{  }block

  611 shadow{  }block

  612 code{  }block

  613 shadow{  }block

  614 code{  }block

  615 shadow{  }block

  616 code{  }block

  617 shadow{  }block

  618 code{  }block

  619 shadow{  }block

  620 code{  }block

  621 shadow{  }block

  622 code{  }block

  623 shadow{  }block

  624 code{  }block

  625 shadow{  }block

  626 code{  }block

  627 shadow{  }block

  628 code{  }block

  629 shadow{  }block

  630 code{  }block

  631 shadow{  }block

  632 code{  }block

  633 shadow{  }block

  634 code{  }block

  635 shadow{  }block

  636 code{  }block

  637 shadow{  }block

  638 code{  }block

  639 shadow{  }block

  640 code{  }block

  641 shadow{  }block

  642 code{  }block

  643 shadow{  }block

  644 code{  }block

  645 shadow{  }block

  646 code{  }block

  647 shadow{  }block

  648 code{  ( active config global )
:# fov 2
:# cuco 700
:# testb 0
:# ps/ 4 [ d# 4 ps/ ! ]
:# sim 1 [ d# 1 sim ! ]
:# dh 0 [ d# 0 dh ! ] { br }
: compile [ d# 940 ] load ;
: tether { -cr }
: te [ d# 944 ] load ;
: simrec ; ( default nop )
: logger winver drop if [ d# 554 ] d# 3 loads then ;
: -tape [ d# 1 ] d# 1 and ; [ qwerty seeb ] }block

  649 shadow{  ( these parameters are globally resident and should not
   be overloaded. use ) [ warm ] ( after changing any but variables marked
   hot. )
: sim ( is ) 0 ( for full hi lvl integrator, ) 1 ( for faster hand coded, )
   2 ( for fastest partial sim, ) 3 ( no sim for tare. )
: fov ( abstract display scale )
: ps/ ( picosec per display step in hardsim )
: dh ( holds drive handle we are responsible for. )
: testb ( nonzero to enable testbeds. )
: compile ( compiles rom for layout and ram for optional initialization
   via ) [ pram ] ( in hardsim. )
: simrec ( defined here as nop in case not loaded )
: logger ( compiles log file generator in windows systems )
: -tape ( the ) [ yellow ] ( literal must be 0 for tapeout, 1 for testing. )
: saying [ qwerty ] ( at the end of the block enables the qwerty keyboard
   mode till next boot. ) }block

  650 code{  ( cfchip definition active )
: 6row 600n 601n 602n 603n 604n 605n 606n 607n 608n 609n 610n 611n 612n
   613n 614n 615n 616n 617n ;
: 5row 500n 501n 502n 503n 504n 505n 506n 507n 508n 509n 510n 511n 512n
   513n 514n 515n 516n 517n ;
: 4row 400n 401n 402n 403n 404n 405n 406n 407n 408n 409n 410n 411n 412n
   413n 414n 415n 416n 417n ;
: 3row 300n 301n 302n 303n 304n 305n 306n 307n 308n 309n 310n 311n 312n
   313n 314n 315n 316n 317n ;
: 2row 200n 201n 202n 203n 204n 205n 206n 207n 208n 209n 210n 211n 212n
   213n 214n 215n 216n 217n ;
: 1row 100n 101n 102n 103n 104n 105n 106n 107n 108n 109n 110n 111n 112n
   113n 114n 115n 116n 117n ; }block

  651 shadow{  ( define chip to lay out, loaded from 998 )
: 3..0row ( lay out all the nodes. comment those you do not wish to work
   with; make active nodes green. make sure cuco numbers a valid node
   that you are laying out before doing extract )
: chip ( top-level gds cell )
: chip0 ( octagon before global - well before wc )
: warnings ( nodes 3 or 5 require 4. ) { cr }
 ( change ) offset ( to reflect offset ) }block

  652 code{  ( cfchip definition { 4F } active )
: 7row 700n 701n 702n 703n 704n 705n 706n 707n 708n 709n 710n 711n 712n
   713n 714n 715n 716n 717n ;
: 0row 000n 001n 002n 003n 004n 005n 006n 007n 008n 009n 010n 011n 012n
   013n 014n 015n 016n 017n ;
: logo poly cpr m1 cpr m2 cpr m3 cpr m4 cpr ;
: chip0 power octagon dummy global pcps 0row 1row 2row 3row 4row 5row
   6row 7row ;
: chip seal origin v chip0 d# 120 [ gy d# -169 + ] v logo ; }block

  653 shadow{  ( define chip to lay out, loaded from 998 )
: 3..0row ( lay out all the nodes. comment those you do not wish to work
   with; make active nodes green. make sure cuco numbers a valid node
   that you are laying out before doing extract )
: chip ( top-level gds cell )
: chip0 ( octagon before global - well before wc )
: warnings ( nodes 3 or 5 require 4. ) { cr }
 ( change ) offset ( to reflect offset ) }block

  654 code{  }block

  655 shadow{  }block

  656 code{  }block

  657 shadow{  }block

  658 code{  }block

  659 shadow{  }block

  660 code{  }block

  661 shadow{  }block

  662 code{  }block

  663 shadow{  }block

  664 code{  }block

  665 shadow{  }block

  666 code{  }block

  667 shadow{  }block

  668 code{  }block

  669 shadow{  }block

  670 code{  }block

  671 shadow{  }block

  672 code{  }block

  673 shadow{  }block

  674 code{  }block

  675 shadow{  }block

  676 code{  }block

  677 shadow{  }block

  678 code{  }block

  679 shadow{  }block

  680 code{  }block

  681 shadow{  }block

  682 code{  }block

  683 shadow{  }block

  684 code{  }block

  685 shadow{  }block

  686 code{  }block

  687 shadow{  }block

  688 code{  }block

  689 shadow{  }block

  690 code{  }block

  691 shadow{  }block

  692 code{  }block

  693 shadow{  }block

  694 code{  }block

  695 shadow{  }block

  696 code{  }block

  697 shadow{  }block

  698 code{  }block

  699 shadow{  }block

  700 code{  }block

  701 shadow{  }block

  702 code{  }block

  703 shadow{  }block

  704 code{  }block

  705 shadow{  }block

  706 code{  }block

  707 shadow{  }block

  708 code{  }block

  709 shadow{  }block

  710 code{  }block

  711 shadow{  }block

  712 code{  }block

  713 shadow{  }block

  714 code{  }block

  715 shadow{  }block

  716 code{  }block

  717 shadow{  }block

  718 code{  }block

  719 shadow{  }block

  720 code{  }block

  721 shadow{  }block

  722 code{  }block

  723 shadow{  }block

  724 code{  }block

  725 shadow{  }block

  726 code{  }block

  727 shadow{  }block

  728 code{  }block

  729 shadow{  }block

  730 code{  }block

  731 shadow{  }block

  732 code{  }block

  733 shadow{  }block

  734 code{  }block

  735 shadow{  }block

  736 code{  }block

  737 shadow{  }block

  738 code{  }block

  739 shadow{  }block

  740 code{  }block

  741 shadow{  }block

  742 code{  }block

  743 shadow{  }block

  744 code{  }block

  745 shadow{  }block

  746 code{  }block

  747 shadow{  }block

  748 code{  }block

  749 shadow{  }block

  750 code{  }block

  751 shadow{  }block

  752 code{  }block

  753 shadow{  }block

  754 code{  }block

  755 shadow{  }block

  756 code{  }block

  757 shadow{  }block

  758 code{  }block

  759 shadow{  }block

  760 code{  }block

  761 shadow{  }block

  762 code{  }block

  763 shadow{  }block

  764 code{  }block

  765 shadow{  }block

  766 code{  }block

  767 shadow{  }block

  768 code{  }block

  769 shadow{  }block

  770 code{  }block

  771 shadow{  }block

  772 code{  }block

  773 shadow{  }block

  774 code{  }block

  775 shadow{  }block

  776 code{  }block

  777 shadow{  }block

  778 code{  }block

  779 shadow{  }block

  780 code{  }block

  781 shadow{  }block

  782 code{  }block

  783 shadow{  }block

  784 code{  }block

  785 shadow{  }block

  786 code{  }block

  787 shadow{  }block

  788 code{  }block

  789 shadow{  }block

  790 code{  }block

  791 shadow{  }block

  792 code{  }block

  793 shadow{  }block

  794 code{  }block

  795 shadow{  }block

  796 code{  }block

  797 shadow{  }block

  798 code{  }block

  799 shadow{  }block

  800 code{  }block

  801 shadow{  }block

  802 code{  }block

  803 shadow{  }block

  804 code{  }block

  805 shadow{  }block

  806 code{  }block

  807 shadow{  }block

  808 code{  }block

  809 shadow{  }block

  810 code{  }block

  811 shadow{  }block

  812 code{  }block

  813 shadow{  }block

  814 code{  }block

  815 shadow{  }block

  816 code{  }block

  817 shadow{  }block

  818 code{  }block

  819 shadow{  }block

  820 code{  }block

  821 shadow{  }block

  822 code{  }block

  823 shadow{  }block

  824 code{  }block

  825 shadow{  }block

  826 code{  }block

  827 shadow{  }block

  828 code{  }block

  829 shadow{  }block

  830 code{  }block

  831 shadow{  }block

  832 code{  }block

  833 shadow{  }block

  834 code{  }block

  835 shadow{  }block

  836 code{  }block

  837 shadow{  }block

  838 code{  }block

  839 shadow{  }block

  840 code{  }block

  841 shadow{  }block

  842 code{  }block

  843 shadow{  }block

  844 code{  }block

  845 shadow{  }block

  846 code{  }block

  847 shadow{  }block

  848 code{  }block

  849 shadow{  }block

  850 code{  }block

  851 shadow{  }block

  852 code{  }block

  853 shadow{  }block

  854 code{  }block

  855 shadow{  }block

  856 code{  }block

  857 shadow{  }block

  858 code{  }block

  859 shadow{  }block

  860 code{  }block

  861 shadow{  }block

  862 code{  }block

  863 shadow{  }block

  864 code{  }block

  865 shadow{  }block

  866 code{  }block

  867 shadow{  }block

  868 code{  }block

  869 shadow{  }block

  870 code{  }block

  871 shadow{  }block

  872 code{  }block

  873 shadow{  }block

  874 code{  }block

  875 shadow{  }block

  876 code{  }block

  877 shadow{  }block

  878 code{  }block

  879 shadow{  }block

  880 code{  }block

  881 shadow{  }block

  882 code{  }block

  883 shadow{  }block

  884 code{  }block

  885 shadow{  }block

  886 code{  }block

  887 shadow{  }block

  888 code{  }block

  889 shadow{  }block

  890 code{  ( ga144 chrt .18 design specific )
: gdsnos [ d# 440 ] ;
: nnx { 10F } [ d# 18 ] ; { -cr }
: nny { 8F } [ d# 8 ] ; { -cr }
: nns [ nnx nny * ] ;
: nnc ( nns ) [ nns d# 1 + ] ;
: nn-n ( n-n { 14F } ) [ d# 100 ] /mod [ nnx ] * + ;
: n-nn ( n-n ) [ nnx ] /mod { 14F } [ d# 100 ] * + ; { br }
: gapl [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d# 20
   d# 2 * + ] ;
: gapr [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d# 24
   d# 2 * + ] ;
: gapb [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d# 28
   d# 2 * + ] ;
: gapt [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d# 18
   d# 2 * + ] ;
: ray0 ( -xy ) gapl [ d# 199 ] + gapb [ d# 199 ] + ;
: rayn ( -xy ) nnx [ d# 350 ] * nny [ d# 759 ] * d# -1 + ray0 v+ ; { br }
: gx [ rayn drop gapr + d# 199 + ] ;
: gy [ rayn nip gapt + d# 199 + ] ; { br }
: origin { 148F } { B2F } d# 26 d# 26 ;
: cx [ origin drop d# 2 * gx + d# 2 + ] ;
: cy [ origin nip d# 2 * gy + d# 2 + ] ;
: -cx [ cx negate ] ; { -cr }
: cx*y [ cx cy * ] ; { br }
: gfx [ d# 8 ] ; { -cr }
: gfy [ d# 16 ] ; }block

  891 shadow{ 
: gdsnos ( block for gds layer numbers )
: nnx ( and nny number of nodes/row and /column )
: nnc ( number of nodes compiled )
: nn-n ( and ) n-nn ( convert yx notation to and from linear node numbers )
: gapl, r, b, t ( distance in tiles between inner edge of padring bus
   and outer edge of core pwr )
: ray0 ( and ) rayn ( are gxy relative phys origin and upper right corner
   of node array. source of constants is ) [ xtab ] ( and ) [ ytab. ]
: gx ( and ) gy ( bounds of pad ring. ) [ always remember to check ] global
   [ reset wiring when size or placement of node array or pad ring are
   changed! ]
: cx ( and ) cy ( bounds of seal ring. )
: -cx ( negative tiles/row )
: origin ( origin of 'die' i.e. pad ring within seal ring. c coords rel
   to seal; g rel to 'die' )
: gfx ( and ) gfy ( fill cell grid ) }block

  892 code{  ( ga144 pads, ports and resets ) { br }
: port ( i-pa ) align tbl [ h# 1D5 , h# 115 , h# 175 , h# 145 , h# 195
   , h# 185 , h# 1B5 , h# 1A5 , ]
: idle ( n-p ) [ nnx ] /mod [ nny d# -1 + ] mod [ d# 1 ] min [ d# 4 ]
   + swap [ nnx d# -1 + ] mod [ d# 1 ] min 2* + port ;
: rstadr align tbl [ h# AA , h# 195 , h# 185 , h# 1B5 , h# 1A5 , ]
: rstdef strings ( p0aa p13f p12f p11f p10f )
: ?rst ( pa-i ) [ d# 4 ] for dup i rstadr or while drop -next abort then
   drop drop pop ; }block

  893 shadow{ 
: port ( returns port for 0-3 rdlu then edges )
: idle ( is idle p value for given node. )
: rstadr ( and ) rstdef ( number values and white names of p straps rom,
   corn, side, top/bot, mid. )
: ?rst ( returns index of valid reset or aborts. ) }block

  894 code{  ( ga144 node types ) { br }
: laid [ nns aray ] { -cr }
: resets [ nns aray ]
: kinds [ nns aray ] { br }
: 0's ( n ) for d# 0 , next ;
: +roms ( -ia ) align ray [ nns 0's ]
: iz ( nn i ) swap nn-n +roms ! ; { cr }
 [ d# 701 d# 2 iz d# 705 d# 10 iz d# 708 d# 6 iz ] { indent }
 [ d# 709 d# 14 iz d# 713 d# 14 iz d# 717 d# 14 iz ] { cr }
 [ d# 117 d# 14 iz d# 617 d# 14 iz ] { cr }
 [ d# 1 d# 2 iz d# 200 d# 18 iz d# 300 d# 4 iz ] { cr }
 ( eforth ) [ d# 105 d# 20 iz d# 106 d# 20 iz ] ( sdram... ) { cr }
 [ d# 7 d# 20 iz d# 8 d# 20 iz d# 9 d# 20 iz d# 107 d# 20 iz d# 108 d# 20
   iz ]
: @rom ( nn-n ) nn-n +roms @ [ d# 22 ] less if drop [ d# 1418 ] + ; then
   drop [ d# 100 ] mod [ d# 1301 ] + ; { br }
: bedtab ( -serbed ) [ cuco ] @ nn-n kinds @ ;
: ?serbed [ testb ] @ d# 0 or drop if bedtab ; then d# 0 ; }block

  895 shadow{ 
: laid ( nz if node laid out )
: resets ( index of reset address )
: kinds ( kind for testbeds )
: +roms ( and ) @rom ( are here only as temporary kludges. we will eventually
   load a table from the node defns for default kind and prom source. )
: +roms ( array indexed by linear node number returning code number for
   rom load block. )
: iz ( sets node ) [ nn ] ( to use rom load block ) [ n ] ( codes- 0-arith
   2-serdes 4-syncboot 6-async 10-spi 14-analog 18-1wire )
: @rom ( returns block number for production rom code applicable to the
   given node. )
: ?serbed ( 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers
   for ) [ cuco ] ( if ) [ testb ] ( nz. ) }block

  896 code{  }block

  897 shadow{  }block

  898 code{  }block

  899 shadow{  }block

  900 code{  ( okad tools compile is in cfuse )
: softsim { -cr }
: so d# 942 load ;
: tile d# 910 load ; ( layout tiles ) [ d# 146 load ]
: place { -cr }
: pl tile ( layout and display )
: flat { -cr }
: fl d# 912 load ; ( 2d display )
: cover d# 914 load ;
: gds d# 916 load ; ( construct gds file )
: @gds d# 918 load ; ( display gds )
: ?gds d# 920 load ; ( examine gds )
: extract { -cr }
: ex d# 922 load ; ( build tables )
: hardsim { -cr }
: ha d# 924 load ; ( integrate i and v )
: hilo d# 926 load ; ( mark nets above vdd/2 )
: lite d# 928 load ;
: lit d# 908 load ;
: pram d# 934 load ;
: calc d# 930 load ; ( tsmc calculation app )
: prism d# 932 load ; ( tsmc spectrum ) [ d# 890 d# 3 loads ] ( design
   specific ) [ mark empty ] }block

  901 shadow{  ( design load block for okad2 applications )
: ex
: extract ( netlist for simulation and go into )
: flat ( view of layout - keys )
: .
: .... [ ludr ] ( big left up down right )
: .432 [ ludr ] ( toggle metal 2-4 , move ludr )
: .... [ +g1- ] ( zoom in, toggle gates, toggle metal1, zoom out )
: . ( exit flat view or simulator with ) [ space e space ] ( to enter
   block editor and get new key menu on bottum right )
: ha
: hardsim ( virtual scope ) [ g ] n ( go till number ) [ h ] ( go till
   key ) [ b ] ( go 1000 counts , exit with ) [ e ]
: gds ( consruct gds file image and display )
: @gds ( view file records )
: ?gds
: lite ( brighten the net pointed to - metal-1 )
: lit ( brighten an additional net ) }block

  902 code{  }block

  903 shadow{  }block

  904 code{  }block

  905 shadow{  }block

  906 code{  }block

  907 shadow{  }block

  908 code{  }block

  909 shadow{  }block

  910 code{  }block

  911 shadow{  }block

  912 code{  }block

  913 shadow{  }block

  914 code{  }block

  915 shadow{  }block

  916 code{  }block

  917 shadow{  }block

  918 code{  }block

  919 shadow{  }block

  920 code{  }block

  921 shadow{  }block

  922 code{  }block

  923 shadow{  }block

  924 code{  }block

  925 shadow{  }block

  926 code{  }block

  927 shadow{  }block

  928 code{  }block

  929 shadow{  }block

  930 code{  }block

  931 shadow{  }block

  932 code{  }block

  933 shadow{  }block

  934 code{  }block

  935 shadow{  }block

  936 code{  }block

  937 shadow{  }block

  938 code{  }block

  939 shadow{  }block

  940 code{  ( g18 compiler ) [ empty c ] { cr }
 [ d# 0 d# 0 laid nns fill d# 0 d# 0 kinds nns fill ] { br }
 [ d# 1400 load ] { br }
: reset ( a ) ?rst [ com ] @ resets ! ;
: kind ( n ) [ com ] @ kinds ! ;
: node ( nn ) nn-n nns mod dup [ com ] ! { cr }
 n-nn @rom load ;
: bin ( nn ) d# 0 memory swap nn-n [ com ] ! d# 0 memory d# 512 move ;
   { br }
: program d# 1380 load [ nns d# -1 + ] for i [ com ] ! { cr }
 i idle reset i n-nn @rom load -next { cr }
 ( special rom's ) [ d# 1304 ] load { cr }
 -tape drop if [ d# 1300 ] load then ; { br }
 [ d# 1402 d# 6 loads target program empty ] }block

  941 shadow{  ( compiles all relevant g18 code. ) { br }
: laid ( is cleared for setting as nodes laid out )
: resets ( is set to default multiport executes for all nodes and may
   be overridden in source code using ) reset
: kinds ( is set to default testbed none and may be overridden with )
   kind ( to 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers )
: program ( compile code for multicomputers. always compiles standard
   rom; if not tapeout, the load block at { A28F } defines test environment
   which may be in rom, ram, or both. ) { br }
: node ( starts random compilation for node ) [ nn ] ( by compiling node )
   [ nn's ] ( rom )
: bin ( saves the binary just generated in the bin for node ) [ nn, ]
   ( which must be outside chip { F } { F } . ) }block

  942 code{  ( g18 simulator ) [ compile empty ] { cr }
 [ d# 1272 d# 11 loads ] { cr }
 [ d# 1256 d# 2 loads ] ( testbed ) { cr }
 [ d# 1260 d# 4 loads ] ( memory instructions ) { cr }
 [ d# 1270 load ] ( show pins ) { cr }
 [ d# 1250 load ] ( 4x8 window on 8x18 ) { cr }
 [ d# 1294 d# 3 loads ] ( display keyboard initialization ) { cr }
 [ reset lefts rights downs ups ] ( /asynch ) { cr { 155F } { 582F } }
 ( boots { 155F } { 588F } boots { F } { 190F } boots ) { cr { F } { 258F } }
 ( boots { F } { 25CF } boots { F } { 25EF } boots ) [ d# 0 d# 0 boots ]
   { cr }
 [ ok h ] }block

  943 shadow{  }block

  944 code{  }block

  945 shadow{  }block

  946 code{  }block

  947 shadow{  }block

  948 code{  }block

  949 shadow{  }block

  950 code{  }block

  951 shadow{  }block

  952 code{  }block

  953 shadow{  }block

  954 code{  }block

  955 shadow{  }block

  956 code{  }block

  957 shadow{  }block

  958 code{  }block

  959 shadow{  }block

  960 code{  }block

  961 shadow{  }block

  962 code{  }block

  963 shadow{  }block

  964 code{  }block

  965 shadow{  }block

  966 code{  }block

  967 shadow{  }block

  968 code{  }block

  969 shadow{  }block

  970 code{  }block

  971 shadow{  }block

  972 code{  }block

  973 shadow{  }block

  974 code{  }block

  975 shadow{  }block

  976 code{  }block

  977 shadow{  }block

  978 code{  }block

  979 shadow{  }block

  980 code{  }block

  981 shadow{  }block

  982 code{  }block

  983 shadow{  }block

  984 code{  }block

  985 shadow{  }block

  986 code{  }block

  987 shadow{  }block

  988 code{  }block

  989 shadow{  }block

  990 code{  }block

  991 shadow{  }block

  992 code{  }block

  993 shadow{  }block

  994 code{  }block

  995 shadow{  }block

  996 code{  }block

  997 shadow{  }block

  998 code{  }block

  999 shadow{  }block

 1000 code{  }block

 1001 shadow{  }block

 1002 code{  }block

 1003 shadow{  }block

 1004 code{  }block

 1005 shadow{  }block

 1006 code{  }block

 1007 shadow{  }block

 1008 code{  }block

 1009 shadow{  }block

 1010 code{  }block

 1011 shadow{  }block

 1012 code{  }block

 1013 shadow{  }block

 1014 code{  }block

 1015 shadow{  }block

 1016 code{  }block

 1017 shadow{  }block

 1018 code{  }block

 1019 shadow{  }block

 1020 code{  }block

 1021 shadow{  }block

 1022 code{  }block

 1023 shadow{  }block

 1024 code{  }block

 1025 shadow{  }block

 1026 code{  }block

 1027 shadow{  }block

 1028 code{  }block

 1029 shadow{  }block

 1030 code{  }block

 1031 shadow{  }block

 1032 code{  }block

 1033 shadow{  }block

 1034 code{  }block

 1035 shadow{  }block

 1036 code{  }block

 1037 shadow{  }block

 1038 code{  }block

 1039 shadow{  }block

 1040 code{  }block

 1041 shadow{  }block

 1042 code{  }block

 1043 shadow{  }block

 1044 code{  }block

 1045 shadow{  }block

 1046 code{  }block

 1047 shadow{  }block

 1048 code{  }block

 1049 shadow{  }block

 1050 code{  }block

 1051 shadow{  }block

 1052 code{  }block

 1053 shadow{  }block

 1054 code{  }block

 1055 shadow{  }block

 1056 code{  }block

 1057 shadow{  }block

 1058 code{  }block

 1059 shadow{  }block

 1060 code{  }block

 1061 shadow{  }block

 1062 code{  }block

 1063 shadow{  }block

 1064 code{  }block

 1065 shadow{  }block

 1066 code{  }block

 1067 shadow{  }block

 1068 code{  }block

 1069 shadow{  }block

 1070 code{  }block

 1071 shadow{  }block

 1072 code{  }block

 1073 shadow{  }block

 1074 code{  }block

 1075 shadow{  }block

 1076 code{  }block

 1077 shadow{  }block

 1078 code{  }block

 1079 shadow{  }block

 1080 code{  }block

 1081 shadow{  }block

 1082 code{  }block

 1083 shadow{  }block

 1084 code{  }block

 1085 shadow{  }block

 1086 code{  }block

 1087 shadow{  }block

 1088 code{  }block

 1089 shadow{  }block

 1090 code{  }block

 1091 shadow{  }block

 1092 code{  }block

 1093 shadow{  }block

 1094 code{  }block

 1095 shadow{  }block

 1096 code{  }block

 1097 shadow{  }block

 1098 code{  }block

 1099 shadow{  }block

 1100 code{  }block

 1101 shadow{  }block

 1102 code{  }block

 1103 shadow{  }block

 1104 code{  }block

 1105 shadow{  }block

 1106 code{  }block

 1107 shadow{  }block

 1108 code{  }block

 1109 shadow{  }block

 1110 code{  }block

 1111 shadow{  }block

 1112 code{  }block

 1113 shadow{  }block

 1114 code{  }block

 1115 shadow{  }block

 1116 code{  }block

 1117 shadow{  }block

 1118 code{  }block

 1119 shadow{  }block

 1120 code{  }block

 1121 shadow{  }block

 1122 code{  }block

 1123 shadow{  }block

 1124 code{  }block

 1125 shadow{  }block

 1126 code{  }block

 1127 shadow{  }block

 1128 code{  }block

 1129 shadow{  }block

 1130 code{  }block

 1131 shadow{  }block

 1132 code{  }block

 1133 shadow{  }block

 1134 code{  }block

 1135 shadow{  }block

 1136 code{  }block

 1137 shadow{  }block

 1138 code{  }block

 1139 shadow{  }block

 1140 code{  }block

 1141 shadow{  }block

 1142 code{  }block

 1143 shadow{  }block

 1144 code{  }block

 1145 shadow{  }block

 1146 code{  }block

 1147 shadow{  }block

 1148 code{  }block

 1149 shadow{  }block

 1150 code{  }block

 1151 shadow{  }block

 1152 code{  }block

 1153 shadow{  }block

 1154 code{  }block

 1155 shadow{  }block

 1156 code{  }block

 1157 shadow{  }block

 1158 code{  }block

 1159 shadow{  }block

 1160 code{  }block

 1161 shadow{  }block

 1162 code{  }block

 1163 shadow{  }block

 1164 code{  }block

 1165 shadow{  }block

 1166 code{  }block

 1167 shadow{  }block

 1168 code{  }block

 1169 shadow{  }block

 1170 code{  }block

 1171 shadow{  }block

 1172 code{  }block

 1173 shadow{  }block

 1174 code{  }block

 1175 shadow{  }block

 1176 code{  }block

 1177 shadow{  }block

 1178 code{  }block

 1179 shadow{  }block

 1180 code{  }block

 1181 shadow{  }block

 1182 code{  }block

 1183 shadow{  }block

 1184 code{  }block

 1185 shadow{  }block

 1186 code{  }block

 1187 shadow{  }block

 1188 code{  }block

 1189 shadow{  }block

 1190 code{  }block

 1191 shadow{  }block

 1192 code{  }block

 1193 shadow{  }block

 1194 code{  }block

 1195 shadow{  }block

 1196 code{  }block

 1197 shadow{  }block

 1198 code{  }block

 1199 shadow{  }block

 1200 code{  }block

 1201 shadow{  }block

 1202 code{  }block

 1203 shadow{  }block

 1204 code{  }block

 1205 shadow{  }block

 1206 code{  }block

 1207 shadow{  }block

 1208 code{  }block

 1209 shadow{  }block

 1210 code{  }block

 1211 shadow{  }block

 1212 code{  }block

 1213 shadow{  }block

 1214 code{  }block

 1215 shadow{  }block

 1216 code{  }block

 1217 shadow{  }block

 1218 code{  }block

 1219 shadow{  }block

 1220 code{  }block

 1221 shadow{  }block

 1222 code{  }block

 1223 shadow{  }block

 1224 code{  }block

 1225 shadow{  }block

 1226 code{  }block

 1227 shadow{  }block

 1228 code{  }block

 1229 shadow{  }block

 1230 code{  }block

 1231 shadow{  }block

 1232 code{  }block

 1233 shadow{  }block

 1234 code{  }block

 1235 shadow{  }block

 1236 code{  }block

 1237 shadow{  }block

 1238 code{  }block

 1239 shadow{  }block

 1240 code{  }block

 1241 shadow{  }block

 1242 code{  }block

 1243 shadow{  }block

 1244 code{  }block

 1245 shadow{  }block

 1246 code{  }block

 1247 shadow{  }block

 1248 code{  ( smtm test ) [ h# 32 org ]
: go a! h# 1557F !b h# 1556A !b . pop @p+ { indent }
 ( ' ) @p+ dup 2/ . ( ' ) a ! ! h# 43 for { indent }
 h# 3F !+ . unext { indent }
 ( ' ) 2* a! push . ( ' ' ) begin @p+ !+ . unext ( ' ) { indent }
 ( ' ) @p+ push ; ( ' ) ! warm ; { cr { 25F } }
 [ h# 2A org ]
: r @p+ go ; r---
: d @p+ go ; -d--
: l @p+ go ; --l-
: u @p+ go ; ---u { cr }
 [ d# 0 org ]
: path d u d u d u d r d u d u d u d l path ; }block

 1249 shadow{  }block

 1250 code{  ( show all nodes in miniature )
: window [ xorg ] @ d# 22 * d# 608 + [ yorg ] @ negate d# 4 + { indent }
 d# 30 * d# 28 + over over at push [ d# 8 d# 22 * ] + { indent }
 pop [ d# 4 d# 30 * ] + blue box ;
: .node ( n ) nn-n [ com ] ! ?red d# 48 emit ;
: line ( n ) cr d# 17 for dup .node d# 1 + -next drop ;
: .all window d# 610 d# 0 tab d# 7 for i d# 100 * line { indent }
 -next ; { br }
 [ exit ] ( help debugging multiport read/write )
: .pt ( a ) [ pt ] ! port @ h. cr pend @ h. cr ;
: .nd nn-n [ com ] ! { indent }
 red right .pt green down .pt { indent }
 red left .pt green up .pt cr { indent }
 white es @ h. cr clu @ h. ;
: .all d# 610 d# 0 tab d# 705 .nd d# 800 d# 0 tab d# 708 .nd ; }block

 1251 shadow{ 
: window ( paint a blue box behind the visible ) { indent }
 ( part of the array )
: .node ( pacman char for each node, ) { indent }
 ( red if active and silver if asleep )
: line ( draw one line of { 24F } nodes )
: .all ( move to upper right corner ) { indent }
 ( and draw all { 10F } lines of the array ) { br }
: .pt ( show port and pend for one direction )
: .nd ( show ports and pends for all four )
: .all ( alternate display for debugging ports ) }block

 1252 code{  [ html named ] ( softsim.html ) [ .hdr ] { cr }
 [ d# 1252 d# 1254 .blks ] ( this print screen ) { cr }
 [ d# 942 d# 944 .blks ] ( load block ) { cr }
 [ d# 1272 d# 1294 .blks ] { cr }
 [ d# 1256 d# 1260 .blks ] ( testbed ) { cr }
 [ d# 1260 d# 1268 .blks ] ( memory instructions ) { cr }
 [ d# 1270 d# 1272 .blks ] ( show pins ) { cr }
 [ d# 1250 d# 1252 .blks ] ( 4x8 window on 8x18 ) { cr }
 [ d# 1294 d# 1300 .blks ] ( screen/kbd initialization ) { cr }
 [ .tlr ] ( blocks from softsim load screen in { 75CF } ) }block

 1253 shadow{  [ d# 1252 load ] ( makes an html listing of ) { cr }
 ( the softsim application ) }block

 1254 code{  ( testbed bootstream ) { br }
 [ nns n-nn node d# 0 org ] ( test boot stream ) { cr { 3C07DF } }
 [ h# B56B , { 3C07DF } h# B56B , { 5F } h# 15557 , ] { cr { 2407FF } }
 [ h# 756A , { 2407DF } h# 756B , ] ( comma uses pattern ) }block

 1255 shadow{  }block

 1256 code{  ( spi serial testbed ) { cr }
:# clk 0
:# spbit 1359544320
:# btcnt 33 [ d# 33 btcnt ! ] { cr }
 [ nns com ! d# 0 me d# 18 * spbit ! d# 0 clk ! ] { cr }
: ?bit [ btcnt ] @ d# -1 + d# 0 max dup [ btcnt ] ! { indent }
 dup and drop if pop drop ; then ;
: bitn ( n-nn ) dup @ swap over d# 1 + swap ! { indent }
 d# 18 /mod @n swap ;
: bit17 [ spbit ] bitn for 2* -next
: io! ( n ) 2/ h# 20000 and ios @n { indent }
 h# 1FFFF and or ios !n ;
: spi [ d# 705 nn-n ] nop [ com ] ! [ clk ] @ ioc @ { indent }
 d# 1 and dup [ clk ] ! or drop { indent }
 if [ clk ] @ dup and drop if ; then { indent }
 ?bit bit17 then ; }block

 1257 shadow{  ( spi testbed )
: clk ( state of clock pin last time )
: spbit ( 'bit' address of incoming data ) { cr }
 ( note stream code is at node { F } )
: btcnt ( count output bits at beginning )
: ?bit ( count down to zero but no further ) { cr }
 ( and pop out of calling word until zero reached )
: bitn ( change 'bit' address to word address and bit count ... increment
   bit address ... ) { cr }
 ( @ from word address leaving bit count on top )
: bit17 ( shift current bit into ) [ almost ] ( bit 17 and )
: io! ( insert bit into ios )
: spi ( execute during each step for spi testbed ) }block

 1258 code{  ( async serial testbed )
: asport [ d# 708 nn-n ] nop [ com ] ! up [ pt ] ! ;
: table pop 2/ 2/ ;
: up708 align table [ d# 0 , ] { cr }
 [ d# 708 nn-n com ! up pt ! pend , ]
: /asynch asport [ up708 ] dest ! ;
: ?wake ios @ 2* h# 40000 and { indent }
 ioc @ d# 7 2*s h# 40000 and or { indent }
 asport dest @ ! ;
: sta h# 40000 io! ;
: sto d# 0 io! ; { cr }
:# sbit 1360871424
:# ss -1
:# baud 200 { cr }
 [ d# 200 baud ! d# -1 ss ! nns com ! d# 0 me d# 18 * sbit ! ]
: timing h# 2D000 [ ss ] @ d# 30 mod for 2* next io! ; { cr }
: data [ sbit ] bitn d# -18 + - for 2* -next io! ;
: dat [ ss ] @ d# 30 mod d# -7 + drop { indent }
 -if timing ; then data ;
: bit17 d# 1 [ ss ] +! [ ss ] @ d# 10 mod jump { indent }
 sta dat dat dat dat dat dat dat dat sto
: asynch [ time ] @ [ baud ] @ or drop if ( clear wrq ) { indent }
 asport d# 0 dest @ ! ; then { indent }
 d# 4000 [ baud ] +! [ d# 708 nn-n ] nop [ com ] ! { indent }
 bit17 ?wake ; }block

 1259 shadow{  ( async serial testbed )
: table ( help to )
: up708 ( create an up port for node { 588F } )
: /asynch ( init up dest register for { 588F } )
: ?wake ( wake on pin )
: sta ( rt bit )
: sto ( p bit ) { cr }
 sbit ( stream pointer node { F } ) { cr }
 ss ( stream counter ) { cr }
 baud ( bit timer )
: timing ( six bit preamble )
: data ( lsb first )
: dat ( time for data, not start or stop )
: bit17 ( insert next bit into io register )
: asynch ( execute during each step for testbed ) }block

 1260 code{  ( softsim memory access )
: rwb ( nai-n ) mem @ [ rrq wrq or ] and swap / or ;
: mkios ios @ h# 201FF and h# 8 right rwb { indent }
 h# 20 down rwb h# 80 left rwb h# 200 up rwb { indent }
 ios ! ;
: /ios ios @ h# 1FE00 and ioc @ { indent }
 dup 2* and h# 2002A and or ios ! ;
: ?ios dup h# 15D or drop if ; then { indent }
 drop ios @ +t set pop drop ;
: ?ioc dup h# 15D or drop if ; then { indent }
 drop -t ioc ! set /ios pop drop ; }block

 1261 shadow{  ( softsim memory access )
: rwb ( read write bits shifted from port to ios )
: mkios ( make ios using rwb )
: /ios ( set pins in ios to low unless ioc says ) { cr }
 ( output high. testbed can override this. )
: ?ios ( reads ios register as a special case, ) { cr }
 ( testbed should put appropriate pin data ) { cr }
 ( into ios. )
: ?ioc ( reads ioc then initializes ios with ) { cr }
 ( reasonable default values. testbed can plug ) { cr }
 ( in more appropriate values. ) }block

 1262 code{  ( softsim ports )
: rpt ( -m ) right [ pt ] ! h# 80 ;
: dpt ( -m ) down [ pt ] ! h# 40 ;
: lpt ( -m ) left [ pt ] ! h# 20 ;
: upt ( -m ) up [ pt ] ! h# 10 ;
: active ( m ) [ ad ] @ h# 50 or and drop ;
: @part ( pm-p ) active if port @ +or then ;
: get ( -p ) h# 0 rpt @part dpt @part lpt @part { indent }
 upt @part h# 3 slp ! ;
: !part ( pm-p ) active if dup pend ! then ;
: put ( p ) rpt !part dpt !part lpt !part upt !part { indent }
 drop ;
: -both ( p-p ) dup es ! [ ad ] @ clu ! { indent }
 [ rrq wrq or ] over over and or drop ;
: -slot d# -1 slot +! d# 0 slp ! ; { br }
: @comm get -both if drop -slot [ rrq ] put ; then { indent }
 h# 3FFFF and +t h# 0 put ;
: !comm get -both if drop -slot t @ [ wrq ] or put { indent }
 ; then drop -t drop h# 0 put ;
: @inst get -both if drop h# 0 slp ! [ rrq ] put ; { indent }
 then h# 3FFFF and ir ! h# 0 slot ! h# 0 put ; }block

 1263 shadow{  ( softsim ports )
: rpt { -cr }
: dpt { -cr }
: lpt { -cr }
: upt { cr }
 ( set ) [ pt ] ( and leave mask )
: active ( mask off ) [ ad ] ( to see if port is active )
: @part
: get ( accumulate values of active ports )
: !part
: put ( store accumulated value into pend ) { cr }
 ( for each active port )
: -both ( save ) [ pt ] ( and ) [ ad ] ( for later display and ) { cr }
 ( set flag if not both read and write requested )
: -slot ( node is sleeping so arrange for ) { cr }
 ( instruction to be executed again next time ) { br }
: @comm ( multiport fetch )
: !comm ( multiport store )
: @inst ( multiport instruction fetch ) { cr }
 }block

 1264 code{  ( softsim memory )
: bus? ( a ) dup [ ad ] ! h# 100 and drop { indent }
 if [ ad ] @ h# F0 and h# 50 or drop then ;
: !p pc @3 bus? if !comm ; then { indent }
 d# 2 cnt [ ad ] @ p+
: !x ( a ) -t swap mem ! set ;
: @a ar @n ?ios
: @ab bus? if @comm ; then d# 2 cnt [ ad ] @
: @x ( a ) mem @ +t set ;
: @b b @3 ?ios @ab ;
: @+ ar @n ?ios bus? if @comm ; { indent }
 then d# 2 cnt [ ad ] @ a+ @x ;
: !a ar @n ?ioc
: !ab bus? if !comm ; then d# 2 cnt [ ad ] @ !x ;
: !b b @3 ?ioc !ab ;
: !+ ar @n ?ioc bus? if !comm ; { indent }
 then d# 2 cnt [ ad ] @ a+ !x ;
: @p pc @3 bus? if @comm ; then { indent }
 d# 2 cnt [ ad ] @ p+ @x ; { br }
: +pc pc @3 bus? if @inst ; then { indent }
 [ ad ] @ p+ mem @ ir ! d# 0 slot ! set ; { cr }
 }block

 1265 shadow{  ( softsim memory )
: bus? ( is address a bus register ? )
: @x/!x a ( common to fetch/store ) { cr }
 ?ios ( in the fetches reads the ios register ) { cr }
 ( as a special case when appropriate ) { cr }
 ?ioc ( in the stores writes the ioc register ) { cr }
 ( as a special case when appropriate ) { br }
: @p ( fetching or storing memory or ports )
: @a
: @+
: !a
: !b
: !+
: @p { br }
: +pc ( fetch the next instruction word from ) { cr }
 ( memory or a port ) }block

 1266 code{  ( softsim execute )
:# fast 1000
:# gap 1000 [ d# 1 gap ! ] { cr }
 ( instruction jump table )
: inst ( n ) d# 1 slot +! h# 1F and jump ret ex jmp call ur+ jr+ jz jns
   @p @+ @b @a !p !+ !b !a +* 2*x 2/x -x +x andx orx t! t@ r@ s@ a@ nul
   r! b! a!x
: s0 ir @ d# 13 2/s inst ;
: s1 ir @ d# 8 2/s inst ;
: s2 ir @ d# 3 2/s inst ;
: s3 ir @ 2* 2* inst ;
: s4 cl @ dup and drop -if +pc ; then ;
: tick [ com ] ! d# -1 cl +! slot @ jump s0 s1 s2 s3 s4
: bus mem dup d# 1 or @ over h# F or @ @ +or swap ! ;
: buses right bus down bus left bus up bus ; { br }
: step d# 1 [ time ] +! [ nns d# -1 + ] for i tick -next { indent }
 [ nns d# -1 + ] for i [ com ] ! buses mkios -next { indent }
 ( spi asynch ) ;
: quick [ gap ] @ for step next ;
: go quick pause key? go ;
: faster [ fast ] @ [ gap ] @ d# 1 or drop if { indent }
 drop d# 1 then [ gap ] ! ; }block

 1267 shadow{ 
: fast ( number of quick steps in fast mode )
: gap ( number of steps in current mode )
: inst ( increment slot jump to 1 of ) { cr { 40F } }
 ( instructions )
: s0-s3 ( execute instruction from slot 0-3 )
: s4 ( fetch next instruction word )
: tick ( execute 1 clock cycle )
: bus ( merge pending and dest to bus register )
: buses ( bus on each of four ports )
: step tick ( for each computer )
: quick gap ( steps before stopping to display )
: go ( quick display until keypress )
: faster ( toggle fast and slow modes for go ) }block

 1268 code{  }block

 1269 shadow{  }block

 1270 code{  ( softsim pins )
: out silver ioc
: pn. @n swap / h# 1 and digit ;
: in blue ios pn. ;
: p17. ( n ) [ com ] ! d# -14 [ xy ] +! h# 20000
: pin. ioc @ over and drop if 2/ out ; then in ;
: p5. h# 20 pin. ;
: p3. h# 8 pin. ;
: p1. h# 2 pin. ; { br }
: 1pin ( n ) nn-n loc p17. ;
: 2pins ( n ) nn-n loc p17. p1. ;
: 4pins ( n ) nn-n loc p17. p5. p3. p1. ;
: pins. [ d# 1 ] 2pins [ d# 701 ] 2pins [ d# 705 ] 4pins { indent }
 [ d# 708 ] 2pins [ d# 715 ] 1pin [ d# 517 ] 1pin { indent }
 [ d# 417 ] 1pin [ d# 317 ] 1pin [ d# 217 ] 1pin { indent }
 [ d# 8 ] 4pins [ d# 100 ] 1pin [ d# 200 ] 1pin { indent }
 [ d# 300 ] 2pins [ d# 500 ] 1pin [ d# 600 ] 1pin ; }block

 1271 shadow{  ( softsim pins )
: out ( outputs are silver )
: pn. ( factored behavior )
: in ( inputs are blue )
: p17. ( sets com, moves cursor, always first )
: pin. ( factored behavior of each pin )
: p5. ( p17. has already set com )
: p3.
: p1. { br }
: 1pin ( some nodes have one pin )
: 2pins ( some have two )
: 4pins ( spi at least has four )
: pins. ( display io pins on all nodes ) { cr }
 ( used in ok ) { br }
 ( testbed must set ios ) }block

 1272 code{  ( softsim registers and memory ) { cr }
:# ad 405
:# com 54
:# pt 325
:# time 87000 [ d# 0 time ! macro ]
: 2/s ?lit h# F8C1 2, 1, ;
: 2*s ?lit h# E0C1 2, 1, ; [ forth ]
: +or ( nn ) over - and or ;
: me [ com ] @ 2* h# 8000 + block + ;
: mem h# 1FF and h# 100 ? if dup h# 15D or drop { indent }
 if h# 155 or h# 10 / ( 8,4,2,1 ) h# 120 or { indent }
 then then h# 1BF and me ; ( 120-12e used )
: port [ pt ] @ mem ;
: pend port d# 1 or ;
: dest port h# F or ; { br }
: right h# 1D5 ;
: down h# 115 ;
: left h# 175 ;
: up h# 145 ;
: rrq h# 80000 ;
: wrq h# 40000 ; }block

 1273 shadow{  ad ( dress ) com ( puter ) pt ( port ) time
: 2/s n ( shift right n bits )
: 2*s n ( shift left n bits )
: +or ( inclusive or )
: me ( convert memory offset to pentium address )
: mem ( convert register address ) { br }
: port ( return port address for current ) [ pt ]
: pend ( convert port to 'pending' address )
: dest ( convert port to 'destination' which ) { cr }
 ( points to neighbor with shared port ) { br }
: right ( unconverted port addresses )
: down
: left
: up { br }
: rrq ( read request bit )
: wrq ( write request bit ) }block

 1274 code{  ( softsim registers and memory )
: r h# 100 me ;
: ar h# 101 me ; ( a register )
: b h# 102 me ;
: pc h# 103 me ;
: ir h# 104 me ;
: t h# 105 me ;
: s h# 106 me ;
: ss d# 7 and h# 107 me + ;
: rs d# 7 and h# 10F me + ;
: slot h# 117 me ;
: rp h# 118 me ;
: sp h# 119 me ;
: cl h# 11A me ;
: ph h# 11B me ;
: es h# 11C me ;
: clu h# 11D me ;
: slp h# 11E me ;
: ioc h# 130 me ; ( write only )
: ios h# 131 me ; ( read only ) }block

 1275 shadow{  ( registers and 'node variables' )
: ar ( a register. cannot be named a because ) { cr }
 ( pentium macro takes precedence )
: slot ( current instruction slot 0-4 )
: rp,sp ( stack pointers )
: ss ( 8 stack registers )
: rs ( 8 stack registers )
: cl ( clock counted down to time memory access )
: ph ( clock counted up to time instruction )
: es ( used in debugging )
: clu ( used in debugging )
: slp ( mark a node as asleep )
: ioc ( write only, use with testbed )
: ios ( read only, also used with testbed ) }block

 1276 code{  ( softsim display )
:# 'e/2 270075789
: cr/2 cr d# -14 [ xy ] +! ;
: emit/2 ( c ) [ 'e/2 ] xqt ;
: +e/2 [ 'e/2 ] assign [ d# 48 ] + [ xy ] @ swap emit { indent }
 h# B0000 + [ xy ] ! ; [ +e/2 ]
: -e/2 [ 'e/2 ] assign drop ;
: ?adr ( a ) [ d# -8 ] + -if -e/2 then { indent }
 [ d# 4 ] + drop if ; then +e/2 ;
: 'ops align strings ( ; ex jmp cal unx nxt if -if @p @+ @b @ !p !+ !b
   ! +* 2* 2/ - + and or drp dup pop ovr a . psh b! a! fet )
: op@ ( i ) 'ops @ [ d# -16 ] and { indent }
 begin dup and while unpack emit/2 { indent }
 end then drop sp/2 ;
: opc. ( i ) slot @ [ d# 4 ] and drop if drop d# 32 then op@ ;
: ops. ( n ) [ d# 4 ] * [ d# 3 ] for [ d# 32 ] /mod next { indent }
 [ d# 4 ] for dup op@ ?adr next +e/2 ; }block

 1277 shadow{  ( softsim display )
: cr/2 ( half carriage return )
: emit/2 ( half space emit )
: +e/2 ( set emit/2 to perform half emit )
: -e/2 ( set emit/2 to drop the character )
: ?adr ( used to avoid displaying an address ) { cr }
 ( field as random opcodes )
: 'ops ( a string of opcode names for decompiler )
: op@ ( lookup and type an opcode string )
: opc. ( when slot is 4 display 'fet' )
: ops. ( given an instruction word, display the ) { cr }
 ( opcodes ) }block

 1278 code{  ( softsim display )
:# base 16
: digits ( i-n ) align tbl [ d# 24 , d# 25 , d# 26 , d# 27 , d# 28 , d# 29
   , d# 30 , d# 31 , d# 32 , d# 33 , ] { cr }
 [ d# 5 , d# 19 , d# 10 , d# 16 , d# 4 , d# 14 , ]
: digit ( i ) digits emit/2 ;
: .n ( nc ) dup push d# -1 + { indent }
 for [ base ] @ /mod next pop for digit next ;
: hex d# 16 [ base ] ! ;
: dec d# 10 [ base ] ! ; { br }
:# nod 56
:# nod2 57
: switch [ nod ] @ [ nod2 ] @ [ nod ] ! [ nod2 ] ! ;
: wake? silver slp @ d# 3 and drop ;
: blue h# 4040FF color ;
: ?white wake? if white then ;
: ?green wake? if green then ;
: ?blue wake? if blue then ;
: ?red wake? if red then ;
: me? [ com ] @ [ nod ] @ or drop { indent }
 if [ h# 808080 ] color ; then ?red ; }block

 1279 shadow{  ( softsim display )
: base ( radix for small character number display )
: digits ( table of character values )
: digit ( display digit as small character )
: .n ( display ) c ( digits of ) n ( in the current ) [ base ]
: hex ( change ) [ base ] ( to hex )
: dec ( change ) [ base ] ( to decimal )
: nod nod2 ( focus on two nodes )
: switch ( swap focus nodes )
: wake? ( a node is awake if ) slp ( is { 6F } )
: ?white
: ?green
: ?blue
: ?red ( change to named color if awake )
: me? ( red if this node number has focus ) }block

 1280 code{  ( softsim display )
:# xorg 3
:# yorg 4 { cr }
: out? ( xy ) over over +or push over d# -8 + { indent }
 over d# -4 + and - pop +or drop ;
: loc ( n-n ) dup [ nnx ] /mod [ xorg ] @ negate { indent }
 [ yorg ] @ negate v+ out? { indent }
 -if drop drop drop pop drop ; then { indent }
 - d# 4 + d# 176 * swap d# 72 * swap { indent }
 d# 22 dup v+ over lm at ;
: tab ( xy ) over lm at ; { br }
: @n @ h# 15555 or ;
: !n swap h# 15555 or swap ! ;
: @3 @ h# 3FF and h# 155 or ;
: !3 swap h# 155 or swap ! ;
: 10bit [ h# 3FF ] and ;
: 8bit [ h# FF ] and ;
: 3bit [ d# 7 ] and pc ( @ ) @3 [ d# 7 - ] and or ;
: adr slot @ jump 10bit 10bit 8bit 3bit nul }block

 1281 shadow{  ( softsim display )
: xorg { -cr }
: yorg ( upper left corner of display ) { br }
: out? ( decide whether node is off screen )
: loc [ n ] ( calculate screen position of node )
: tab [ xy ] ( move cursor and set left margin ) { br }
: @n { -cr }
: !n { -cr }
: @3 { -cr }
: !3 { cr }
 ( fetch and store from memory, changing ) { cr }
 ( from pattern to number ) { br }
: 10bit { -cr }
: 8bit { -cr }
: 3bit
: adr ( isolate the address field in an inst ) }block

 1282 code{  ( softsim display )
:# off 64
: u d# 16
: ud [ off ] @ + h# FF and [ off ] ! ;
: d d# -16 ud ;
: the [ nod ] @ [ com ] ! ; { br }
: array pop 2/ 2/ + @ ;
: div align array [ h# 100000 , h# 8000 , h# 400 , h# 20 , d# 1 , ]
: cin ir @ h# 80 * d# 1 + slot @ div / h# 1F and ; { br }
: ar. ar @n d# 5 .n cr/2 ;
: br. b @3 d# 3 .n ;
: rqs. ios @ d# 9 2/s h# FF and h# 2 .n ;
: ioc. ioc @n d# 5 .n cr/2 ;
: ios. ios @n d# 5 .n cr/2 ;
: ir. ir @n d# 5 .n cr/2 ;
: tr. t @n d# 5 .n cr/2 ;
: sr. s @n d# 5 .n cr/2 ;
: rr. r @n d# 5 .n cr/2 ;
: pc. pc @3 hex d# 3 .n cr/2 ;
: sl. slot @ digit ;
: op. cin opc. cr/2 ;
: cl. cl @ d# 0 max d# 3 min digit ; }block

 1283 shadow{  ( softsim display )
: u
: ud
: d ( manipulate the memory dump offset )
: the ( make focus node the current node ) { br }
: array { -cr }
: div { -cr }
: cin { cr }
 ( isolate current opcode from inst word ) { br }
: ar. { -cr }
: br. { -cr }
: ioc. { -cr }
: ios.
: ir. { -cr }
: tr. { -cr }
: sr. { -cr }
: rr.
: pc. { -cr }
: sl. { -cr }
: op. { -cr }
: cl. { cr }
 ( building blocks for the 2d display, com. ) }block

 1284 code{  ( softsim display )
: -sp/2 [ h# B0000 negate ] nop [ xy ] +! ;
: place dup [ com ] ! n-nn me? dec -sp/2 d# 3 .n ; { br }
: com. ( n ) loc place ?white pc. ?blue cl. { indent }
 ?white sl. ?green op. ?white ir. { indent }
 ?blue ioc. ios. ?red rr. ?green { indent }
 tr. sr. ?white ar. blue rqs. ?white br. ; { br }
: mem. ( xy ) tab hex d# 15 for i [ off ] @ h# BF and + { indent }
 dup white d# 2 .n sp/2 mem @ dup { indent }
 h# 15555 or green d# 5 .n sp/2 { indent }
 white ops. cr/2 -next ; { br }
: stack sp @ d# 8 for dup ss @n d# 5 .n cr/2 { indent }
 d# -1 + next drop ;
: return rp @ d# 8 for d# 1 + dup rs @n d# 5 .n { indent }
 cr/2 next drop ;
: stacks ( xy ) tab hex white return { indent }
 red rr. green tr. sr. white stack ; }block

 1285 shadow{  ( softsim display )
: -sp/2 ( half backspace )
: place ( identify current computer on 2d display )
: com. [ n ] ( display computer n )
: mem. [ xy ] ( memory dump of focus ) [ nod ] ( at xy )
: stack
: return
: stacks ( full stack dump of focus ) [ nod ] ( at xy ) }block

 1286 code{  ( softsim execute ) { cr }
: cnt ( n ) ph @ or drop if d# 1 ph +! { indent }
 d# -1 slot +! pop drop ; then d# 0 ph ! ;
: set4 h# 4 slot !
: set d# 2 cl ! ; { br }
: /+/ ( nim-n ) push over + over or pop and or ;
: inc ( n-n ) [ ad ] @ h# 100 and drop if ; then d# 1 h# 3F /+/ ;
: a+ ar @n inc ar !n ;
: p+ pc @3 inc pc !3 ; }block

 1287 shadow{  ( softsim execute )
: cnt ( count down for memory access )
: set4 ( go to slot { 8F } and )
: set ( set ) [ cl ] ( to time memory prefetch ) { br }
: /+/ [ nim-n ] ( add ) i ( to ) n ( affecting only bits ) { cr }
 ( within ) m
: inc ( increment current address if not ) { cr }
 ( a port address )
: a+ ( increment the a register )
: p+ ( increment the p register ) }block

 1288 code{  ( softsim execute )
: +t ( n ) t @ s @ sp @ d# 1 + dup sp ! ss ! s ! t ! ;
: -t ( -n ) t @ s @ t ! sp @ dup ss @ s ! { indent }
 d# -1 + sp ! ;
: +r ( n ) r @ rp @ d# 1 + dup rp ! rs ! r ! ;
: -r ( -n ) r @ rp @ dup rs @ r ! d# -1 + rp ! ;
: t@ t @n ;
: t! t !n ;
: bin -t h# 15555 or t@ ; { br }
: -x t @ h# 3FFFF or t ! ;
: 2*x t@ 2* h# 3FFFF and t! ;
: sx dup h# 20000 and 2* or ;
: +* t@ sx ar @n { indent }
 d# 1 ? if push s @n + pop { indent }
 then 2/ over d# 1 and drop { indent }
 if h# 20000 or then ar !n 2/ t! ; }block

 1289 shadow{  ( softsim execute )
: +t n ( push onto data stack )
: -t -n ( pop from data stack )
: +r n ( push onto return stack )
: -r -n ( pop from return stack )
: t! ( write t as number )
: t@ ( read t as number )
: bin ( prepare for a binary operation ) { br }
 ( some instructions named with terminal ) { cr }
 ( x to avoid pentium conflict ) { br }
: -x ( - )
: 2*x ( 2* )
: sx ( sign extend )
: +* ( multiply step ) }block

 1290 code{  ( softsim execute )
:# cy 8192
: 2/x t@ sx 2/ t! ;
: orx bin or t! ;
: andx bin and t! ;
: +x bin + pc @ h# 200 and drop { indent }
 if d# 0 [ cy ] @ h# 40000 and drop { indent }
 if d# 1 or then + dup [ cy ] ! then { indent }
 h# 3FFFF and t! ;
: t! -t drop ;
: r@ -r +t ;
: a@ ar @ +t ;
: t@ t @ +t ;
: s@ s @ +t ;
: b! -t h# 3FF and b ! ;
: r! -t +r ;
: a!x d# 0 cnt -t ar ! ; }block

 1291 shadow{  ( softsim execute )
: 2/x ( 2/ )
: orx ( or )
: andx ( and )
: +x ( + )
: t! ( drop )
: r@ ( pop )
: a@ ( a )
: t@ ( dup )
: s@ ( over )
: b!
: r! ( push )
: a!x ( a! ) }block

 1292 code{  ( softsim execute )
: call pc @ +r
: jmp ir @n adr dup pc !3 set4 h# 100 and { indent }
 drop if d# 0 cl ! then ;
: jz h# 3FFFF
: jc t @n and drop if set4 ; then jmp ;
: jns h# 20000 jc ;
: ret -r h# 3FF and pc ! set4 ;
: jr+ r @n d# -1 + dup r !n dup and drop { indent }
 -if -r drop set4 ; then jmp ;
: ur+ r @n d# -1 + dup r !n dup and drop { indent }
 -if -r drop ; then d# 0 slot ! ;
: ex pc @ -r pc ! +r set4 ; }block

 1293 shadow{  ( softsim execute )
: call ( call through i )
: jmp ( jump through i )
: jz ( if )
: jc
: jns ( -if )
: ret ( ; jump through r )
: jr+ ( next )
: ur+ ( unext )
: ex ( call through r ) }block

 1294 code{  ( softsim display )
:# wind? -1
: nod. ( xy ) tab dec [ nod ] @ n-nn red d# 3 .n ;
: ofst d# 320 ;
: .wind [ wind? ] @ dup and drop if .all ; then { indent }
 switch d# 610 d# 22 the stacks { indent }
 d# 690 d# 22 nod. d# 690 d# 52 the mem. { indent }
 switch ; { br }
: ok show black screen text { indent }
 [ nns d# -1 + ] for i com. -next .wind { indent }
 d# 610 [ d# 22 ofst + ] the stacks { indent }
 d# 690 [ d# 22 ofst + ] nod. { indent }
 d# 690 [ d# 52 ofst + ] the mem. { indent }
 d# 610 d# 680 tab [ time ] @ . cr [ gap ] @ . { indent }
 pins. ( debug ) keyboard ; { br }
: lw d# -1
: +xorg ( n ) [ xorg ] @ + d# 0 max [ nnx d# -8 + ] min [ xorg ] ! ;
: rw d# 1 +xorg ;
: uw d# 1
: +yorg ( n ) [ yorg ] @ + d# 0 max [ nny d# -4 + ] min [ yorg ] ! ;
: dw d# -1 +yorg ;
: wtog [ wind? ] @ dup and if dup or [ wind? ] ! ; then { indent }
 - [ wind? ] ! ; }block

 1295 shadow{  ( softsim display )
: nod. ( show current node in red at ) [ xy ]
: ofst ( offset to second focus node )
: .wind ( show 4*8 window in 8*18 ) { cr }
 ( or extra focus node ) { br }
: ok ( the default 2d display ) { br }
: lw ( move display window left )
: +xorg ( factored move in x axis )
: rw ( move display window right )
: uw ( move display window up )
: +yorg ( factored move in y axis )
: dw ( move display window down )
: wtog ( toggle window display ) }block

 1296 code{  ( softsim keyboard handler )
: n! ( n ) nn-n d# 0 max [ nns { FFFFFFEF } ] ( + ) min [ nod ] ! ;
: fr d# 1
: +nod [ nod ] @ + n-nn n! ;
: fl d# -1 +nod ;
: fu [ nnx ] nop
: ++nod [ nod ] @ over +nod swap over + { indent }
 [ nod ] @ or drop if [ nod ] ! ; then drop ;
: fd [ nnx negate ] ++nod ;
: +gap d# 1
: +g ( n ) [ fast ] @ + d# 0 max dup [ fast ] ! [ gap ] ! ;
: ++gap d# 100 +g ;
: -gap d# -1 +g ;
: --gap d# -100 +g ; { br }
: h pad nul nul accept nul { cr }
 lw uw dw rw fl fu fd fr switch u d wtog { cr }
 ++gap +gap nul nul nul faster go quick { cr }
 --gap -gap nul nul { indent }
 [ h# 2500 , h# 110160C , h# 110160C , ] { indent }
 [ H# F101603 , h# 2B2B , H# 80D0E00 , h# 2323 , ] }block

 1297 shadow{  ( softsim display )
: n! ( change focus node ) [ nod ]
: fr ( focus right )
: +nod ( factored horizontal move )
: fl ( focus left )
: fu ( focus up )
: ++nod ( factored vertical move )
: fd ( focus down )
: +gap ( add { 2F } to gap and fast )
: +g ( factored add to gap and fast )
: ++gap ( add { C8F } to gap and fast )
: -gap ( add { FFFFFFEF } to gap and fast )
: --gap ( add { FFFFF38F } to gap and fast )
: h ( keyboard handler ) { indent }
 [ ++ ] ( fastest faster ) { indent }
 [ fgs ] ( fast go step ) { indent }
 [ -- ] ( slowest slower ) { cr indent }
 [ ludr ] ( left up down right ) [ window ] { indent }
 [ ludr ] ( left up down right ) [ focus ] { indent }
 [ oudw ] ( other up down window ) [ memory dump ] { cr indent }
 [ . ] ( quit ) }block

 1298 code{  ( softsim reset )
:# limbo 0 [ h# 0 limbo ! ]
: unp ( n-a ) d# 10 /mod nn-n [ com ] ! { indent }
 h# 10 * h# 10 or h# 155 or mem ;
: , unp swap unp over over h# E or ! swap h# E or ! ;
: row ( n ) [ nnx ] for dup dup [ d# 100 d# 10 * ] + , d# 10 + { indent }
 next drop ;
: ups d# 1001 row d# 3001 row d# 5001 row ;
: downs d# 4 row d# 2004 row d# 4004 row d# 6004 row ;
: col ( n ) [ nny ] for dup dup d# 10 + , [ d# 100 d# 10 * ] + { indent }
 next drop ;
: lefts d# 12 col d# 32 col d# 52 col d# 72 col { indent }
 d# 92 col d# 112 col d# 132 col d# 152 col ;
: rights d# 8 col d# 28 col d# 48 col d# 68 col { indent }
 d# 88 col d# 108 col d# 128 col d# 148 col d# 168 col ;
: boots ( an ) nn-n [ com ] ! h# 155 or pc ! ;
: un! for d# 0 over ! d# 1 + next drop ;
: /dest ( a { FFFFFFEF } ) [ limbo ] swap [ pt ] ! dest ! { indent }
 d# 0 dup port ! pend ! ;
: rese r h# 31 un! [ h# A9 h# 155 or ] pc ! d# 4 slot ! { indent }
 0 dup cl ! ph ! d# -1 es ! { indent }
 d# 0 dup ioc ! ios ! h# 3 slp ! { indent }
 left /dest up /dest right /dest { indent }
 down /dest [ h# 15D h# 155 or ] b ! ;
: reset drop d# 0 [ nns d# -1 + ] for i [ com ] ! rese -next ; }block

 1299 shadow{  ( co-ordinate shared register ports )
: unp ( unpacks a number with computer in hundreds digits and bus in units
   digit. returns address of pending bus content, which becomes bus content
   on next clock tick. )
: , ( given a pair of numbers describing endpoints of a bus. stores address
   of each in memory of other computer. writing to bus register updates
   register at other end. )
: 127 ( f or' destination )
: 12b
: 12d
: 12e
: 129 ( 1 or' pending )
: 125
: 123
: 120
: 128 ( bus 8 right )
: 124 ( bus 4 down )
: 122 ( bus 2 left )
: 121 ( bus 1 up )
: boots ( change execution address )
: reset ( initialize some registers , ) { cr }
 ( execute from idle ) }block

 1300 code{  ( test code for chip ) { br }
 ( custom code ) [ d# 1302 load ] ( exit ) { br }
 ( ide serial ) [ d# 708 node d# 1372 load ] { indent }
 ( sync ) [ d# 300 node d# 1374 load ] { indent }
 ( wire ) [ d# 17 node d# 1376 load ] { indent }
 ( end ) [ d# 16 node d# 1378 load ] { br }
 ( smtm test ) [ d# 0 node d# 1248 load exit ] { br }
 ( */ exerciser ) [ d# 402 node d# 1354 load ] { indent }
 [ d# 401 node d# 1356 load d# 400 node d# 1358 load ] { cr }
 ( serdes ) [ d# 1 node d# 1360 load d# 701 node d# 1362 load ] { cr }
 ( spi flash write ) [ d# 702 node d# 1364 load ] { cr }
 ( ana ) [ d# 715 node d# 1366 load d# 717 node d# 1368 load ] { cr }
 }block

 1301 shadow{  ( this block is loaded to compile test code for any desired
   nodes. write *nnn node* either here before loading a node's source,
   or in the source itself. the *node* phrase compiles the appropriate
   rom for the given node so that test code may reference the rom. ) {
   br }
 ( things like ide and common tests are loaded here, and this base code
   is presently assigned up at the top of this area just below 1380. to
   simplify base maintenance, please use { A2CF } for your own testing
   and load it from here. when we begin using personal space above { B40F }
   your own tests can go there. ) }block

 1302 code{  ( custom test code ) }block

 1303 shadow{  ( this load block, and the following { 32F } source/shadow
   pairs, are yours to do with as you please! ) }block

 1304 code{  ( eforth rom code ) { br }
 ( sdram addr ) [ d# 9 node d# 1320 load ] { indent }
 ( ctrl ) [ d# 8 node d# 1322 load ] ( ram ) { indent }
 ( data ) [ d# 7 node d# 1324 load ] { indent }
 ( idle ) [ d# 108 node d# 1326 load ] { indent }
 ( user ) [ d# 107 node d# 1328 load ] { br }
 ( eforth stack ) [ d# 106 node d# 1310 d# 2 loads ] { indent }
 ( bitsy ) [ d# 105 node d# 1306 d# 2 loads ] { br }
 }block

 1305 shadow{  ( load block for rom resident sdram and eforth in the ga144.
   loaded by { 758F } even for tapeout. ) }block

 1306 code{  ( e4 bitsy 1of2 ) { cr }
 [ h# AA org ]
: rp-- ( a-a' ) { 155D } d# -1 . + ;
: bs@ { -cr }
: 'else ( a-w ) { 159D } { indent }
 @p+ !b !b . ( ' ) @p+ x@ ( ' ) { indent }
 @p+ !b @b ; ( ' ) . . . !p+ ( ' )
: rp@ ( ri-ri ) { 161D } over rp--
: pshbs ( w- ) { 163D } @p+ !b !b ; ( ' ) @p+ pshw ( ' )
: 'r@ ( ri-ri ) { 167D } over rp--
: @w ( a- ) { 169D } bs@ pshbs ;
: rfrom ( ri-r'i ) { 16DD } over rp-- over over @w ;
: popbs ( -w ) { 173D } @p+ !b @b ; ( ' ) !p+ pops ( ' )
: pshr ( aw-a ) { 177D } { indent }
 @p+ !b !b dup ( ' ) @p+ . . @p+ ( ' ) { indent }
 !b @p+ !b . ( ' ) x! ( ' )
: rp++ { -cr }
: ip++ ( a-a' ) { 17FD } d# 1 . + ;
: tor ( ri-r'i ) { 183D } push popbs pshr pop ;
: rp! ( i-ri ) { 189D } push popbs rp++ pop ; { br }
: 'con ( ra-r'i ) { 18FD } bs@
: 'var ( ra-r'i ) { 191D } dup pshbs
: 'exit ( rx-r'i ) { 193D } drop rp-- dup bs@ ; }block

 1307 shadow{  ( e4 bitsy shadow 1of2 )
: rp-- ( internal )
: x@ ( internal ) { -cr }
: 'else ( eforth microcode )
: rp@ ( eforth microcode )
: pshw ( internal )
: 'r@ ( eforth microcode )
: @w ( internal )
: rfrom ( eforth microcode )
: popw ( internal )
: pshr ( internal )
: rp++ ( internal ) { -cr }
: ip++ ( internal )
: tor ( eforth microcode )
: rp! ( internal )
: 'con ( eforth microcode )
: 'var ( eforth microcode )
: 'exit ( eforth microcode ) }block

 1308 code{  ( e4 bitsy 2of2 ) { br }
 { 197D } begin dup 2* -if { indent }
 ( code.s-xt ) drop !b ahead [ swap ] then { indent }
 ( code.r-xt ) drop push ;' { cr }
: bitsy { 19DD } then dup bs@ push ip++
: xxt { 1A1D } pop -until { indent }
 ( list-xt ) push pshr pop bitsy ; { br }
 ( execute )
: 'ex { 1A7D } ( xt-- ) popbs push xxt ;
: 'lit { 1ABD } ( --w ) dup bs@ push ip++ pop pshbs ;
: 'if { 1B1D } ( f-- ) popbs if { indent }
 drop ip++ ; then drop 'else ; { br }
 { 1B9D } [ exit ] ( start is run in ide )
: start right a! ( terminal ) left b! ( stack ) { indent }
 d# -32 d# 0 ( rp.ip ) bitsy ; }block

 1309 shadow{  ( e4 bitsy 2of2 shadow )
: 'con ( runtime constant )
: 'var ( runtime variable )
: 'exit ( runtime end call ) { br }
: btc ( label e4 interpreter ) { cr }
 ( bitsy main interpreter entry )
: xxt ( internal ) { br }
: 'ex ( runtime execute )
: 'lit ( runtime literal )
: 'if ( runtime conditional branch ) { cr }
: @io ( return the serial bit delay )
: !io ( init serial 0-autobps n-fixedbps )
: t!io ( internal )
: tx! ( transmit one character )
: ttx! ( internal )
: trx? ( internal )
: rx? ( test recieved char - 0 if no char else 18bit inverted char ) }block

 1310 code{  ( e4 stack 1of2 ) { cr }
 [ h# 3C org ]
: xa@ ( a- ) { 79D } @p+ !b !b ; ( ' ) @p+ sd@ ( ' )
: xa! ( a- ) { 7DD } @p+ !b !b ; ( ' ) @p+ sd! ( ' ) { cr }
 { 81D } [ h# AA org ]
: 'c@ { -cr }
: '@ { -cr }
: x@ ( a-w ) { 155D } xa@ @b ;
: sp++ { -cr }
: char+ { -cr }
: cell+
: 1+ ( w-w' ) { 159D } d# 1 . + ;
: popt ( p-xp't ) { 15DD } dup sp++ over x@ ;
: sp-- { -cr }
: char- { -cr }
: cell-
: 1- ( w-w' ) { 161D } d# -1 . + ;
: psht ( pt-p' ) { 165D } push sp-- pop over
: x! ( wa- ) { 169D } xa! !b ;
: 'c! { -cr }
: '! ( pwa-p'st ) { 16DD } x!
: popts ( p-p'st ) { 16FD } popt
: pops ( pt-p'st ) { 171D } push popt pop ;
: pshs ( pst-p't ) { 175D } push psht pop ;
: page@ ( pst-p'tw ) { 179D } @p+ !b @b . ( ' ) dup !p+ ; ( ' )
: pshw ( pstw-p'tw ) { 17DD } push pshs pop ;
: page! ( ptw-p'st ) { 181D } @p+ !b !b . ( ' ) drop @p+ ; ( ' ) pops
   ;
: sp@ { 187D } ( -a ) pshs psht dup pops ;
: sp! { 18DD } ( a- ) pshs popts ; }block

 1311 shadow{  ( e4 stack 1of2 shadow )
: 'c@ ( runtime c@ )
: '@ ( runtime @ )
: x@ ( inline external ram )
: sp++ ( increment data stack pointer )
: char+ ( increment address by char size )
: cell+ ( increment address by cell size )
: 1+ ( increment by one )
: popt ( internal )
: sp-- ( decrement data stack pointer )
: char- ( decrement address by char size )
: cell- ( decrement address by cell size )
: 1- ( decrement by one )
: psht ( internal )
: x!
: 'c! ( runtime c! )
: '! ( runtime ! )
: popts ( internal )
: pops ( internal )
: pshs ( internal )
: page@ ( inline external ram )
: pshw ( inline external ram )
: page! ( inline external ram ) }block

 1312 code{  ( e4 stack 2of2 )
: 'drop { 191D } ( w- ) drop pops ;
: 'over { 193D } ( ww-www ) over pshw ;
: 'dup { 195D } ( w-ww ) dup pshw ;
: 'swap { 197D } ( ab-ba ) over push push drop pop pop ;
: '2/ { 19BD } ( w-w ) 2/ ; { -cr }
: '2* { 19DD } ( w-w ) 2* ;
: um+ { 19FD } ( uu-uc ) over or -if { indent }
 { 1A1D } over or . + -if
: 'nc { 1A5D } ( -0 ) dup dup or ;
: 'cy { 1A7D } ( -1 ) then d# 1 ; { indent }
 { 1ABD } then over or -if + 'cy ; then + 'nc ;
: zless { 1B1D } ( n-f ) -if dup or - ; then dup or ;
: 'or { 1B7D } ( ww-w ) over - and
: 'xor { 1B9D } ( ww-w ) or pops ;
: 'and { 1BBD } ( ww-w ) and pops ;
: negate { 1BDD } ( w-w ) 1-
: invert ( w-w' ) { 1BFD } begin ( . ) - ;
: zeq ( w-f ) { 1C1D } until dup or ;
: '+ ( pww-p'sw' ) { 1C5D } + pops ; { 1C7D } ( exit )
: swap- { 1C7D } ( ww-w ) - . + - pops ; { 1CBD } { br }
 { 1CBD } [ exit ] ( start is run in ide )
: start right b! ( sdram ) { cr }
 d# 0 dup dup ( sp.s.t ) --l- ; ( bitsy ) }block

 1313 shadow{  ( e4 stack 2of2 shadow )
: pshw ( internal )
: sp@ ( get data stack pointer )
: sp! ( set data stack pointer )
: 'drop ( runtime drop )
: 'over ( runtime over )
: 'dup ( runtime dup )
: 'swap ( runtime swap )
: zless ( runtime zero less )
: um+ ( add with carry )
: 'nc ( no carry is 0 )
: 'cy ( carry set is 1 )
: 'xor ( runtime exclusive or )
: 'and ( runtime and )
: 'or ( runtime inclusive or )
: negate ( runtime negate )
: invert ( runtime invert )
: zeq ( runtime zero equals )
: '+ ( runtime + )
: '2/ ( runtime 2/ )
: '2* ( runtime 2* ) }block

 1314 code{  ( e4th bitsy ) { br }
: @io { 63D } ( --u ) @p+ ! @ . ( ' ) push t'@io ( ' ) pshw ; { cr }
 ( init io device 0-autobps n-fixedbps )
: !io { 69D } ( u-- ) popw
: t!io { 6BD } ( u- ) @p+ ! ! ; ( ' ) @p+ t'!io ; ( ' )
: tx! { 6FD } ( c-- ) popw
: ttx! { 71D } ( c- ) @p+ ! ! ; ( ' ) @p+ - ; ( ' )
: trx? { 75D } ( -c'0 ) @p+ ! @ ; ( ' ) !p+ t'rx? ; ( ' )
: rx? { 79D } ( --c'0 ) trx? pshw ; }block

 1315 shadow{  }block

 1316 code{  ( e4 terminal 1of2 - serial i/o ) { br }
: getchar { 1D } ( delay in'0 f - delay -char f ) push over 2/ for . unext
   .. ( middle of start-bit ) { cr }
 d# 7 for ( 8-data bits ) { indent }
 over for . unext .. { indent }
 h# 1FFFF @b ( middle +/- ) { indent }
 over - and push and pop or { cr }
 2/ next { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .. h# FF and - dup { cr }
 begin drop @b -until drop pop ; { br }
: putchar { 27D } ( delay in'0 c - delay in'0 ) { cr }
 push over pop { cr }
 2* h# 3FE00 dup push - and pop or { cr }
 d# 10 for ( 1-start, 8-data, 2-stop bits ) { indent }
 d# 2 over over 2/ and or !b { indent }
 over for . unext .. { cr }
 2/ next drop drop ; { 43D } }block

 1317 shadow{  ( note. both tx and rx are completely in stock rs232 polarity,
   i.e. mark lo space hi, data low start low. ultimately we need to invert
   the whole thing for compatibility with s40 boot node conventions but
   for testing purposes we will leave it as is and invert the rs232 board. )
   { br }
: getchar ( called after seeing leading edge of start bit. returns clean
   inverted character. ) { br }
: putchar ( takes a dirty octet of data and transmits it as startbit,
   eight data bits no parity one stop bit. ) }block

 1318 code{  ( e4 terminal 2of2 - bitsy commands ) { br }
: baud { 43D } ( 0-d ) - push ( space is 0'0000.0100'1 ) { cr }
 { 45D } begin @b - -until ( at start-bit ) { cr }
 { 47D } begin @b -until ( at 1-bit ) { cr }
 { 49D } begin @b zif then - . -until ( at 0-bits ) { cr }
 { 4DD } begin @b zif then . -until ( at stop-bit ) { cr }
 pop - ( n ) dup 2/ . + ( 1.5n ) ; { br }
: @io { 55D } ( delay - delay in'0 0 ) { indent }
 pop a! push dup or baud ! { indent }
 pop pop dup dup or ; { indent }
 begin baud
: !io { 5FD } ( delay in'0 u - delay 0 0 ) { indent }
 until ( abandon old values )
: rx? { 61D } ( delay - delay 0 0 ) d# 0 dup ; { br }
: terminal { 65D } ( delay in'0 x ) { cr }
 begin drop @b - -if getchar then { indent }
 - 2* 2* -if drop .. r--- ( bitsy ) then { cr }
 -until ( delay in'0 -c ) - putchar dup terminal ; { 79D } }block

 1319 shadow{ 
: @io ( return the serial bit delay ) { br }
: !io ( sets nonzero baud rate delay over garbage. if zero, waits for
   a space character to autobaud with. ) { br }
: rx? ( test for received char ) { br }
: tx! ( send one character ) { br }
: terminal ( polling loop for character receive or send ) }block

 1320 code{  ( sdram address-bus ) { cr }
 ( copy command to address bus ) { br }
 [ h# AA org ]
: cmd ( c- ) { 155D } h# 3D555 ( nop.xxx ) !b .. { indent }
 @ ( sleeps ) !b cmd ; { br }
 { 15BD } [ exit ] ( start is run in ide )
: start right a! data b! cmd ; }block

 1321 shadow{  }block

 1322 code{  ( sdram control-pins ) { cr }
 ( each word runs the requested rise..fall cycle 12+11 ticks per cycle
   is a 42ns period ) { cr }
 [ h# 0 org ]
: nooop ( rfr-rfr ) { 1D } ( 'nooop' ) . .. !b { indent }
 .. over over .. . . !b ;
: rcol1 ( rf-rfrf ) { 9D } . . !b { indent }
 .. h# 2B .. !b ( transfer ) { indent }
 . h# 22E .. . . !b ; { cr }
 { 15D } [ h# 10 org ] ( 8-word page accessible to down port )
: cmmd ( rfr-rfr ) { 21D } ( '@p+ ! cmmd' ) !b { indent }
 .. over over .. . . !b ;
: rcol ( rfr-rfr ) { 27D } ( '@p+ ! rcol' ) !b { indent }
 over over .. rcol1 ;
: wcol ( rfr-rfr ) { 2BD } ( '@p+ ! wcol' ) !b { indent }
 h# 2003E h# 2002E .. !b { indent }
 .. h# 3022B .. !b ( transfer ) { indent }
 h# 3023B !b .. . . !b { indent }
 h# 2002E .. !b h# 2B !b ( recover ) { indent }
 .. over over .. . . !b ; { br }
 { 47D } [ exit ] ( start is run in ide )
: start right a! io b! h# 2E ( cmd-fall ) -d-- ; }block

 1323 shadow{  }block

 1324 code{  ( sdram data-bus ) { br }
 ( db@ isn't used with 7j chip! ) { cr }
 [ h# AA org ] ( called with 'db@' '...!p+' )
: db@ ( -w ) { 155D } @ ; ( wakeup when data ready ) { br }
 ( db! called with '@p+ db!' )
: db! ( w- ) { 157D } h# 15555 !b ( .. set output state ) { indent }
 ! ( wakeup when data taken )
: inpt { 15BD } h# 14555 !b ; ( restore input state ) { br }
 { 15FD } [ exit ] ( start is run in ide )
: start up a! io b! down push inpt ; }block

 1325 shadow{  }block

 1326 code{  ( sdram idle-loop ) { cr }
 [ h# AA org ]
: noop ( - ) { 155D } @p+ ! ; ( ' ) nooop ( ' )
: cmd ( c- ) { 159D } h# 5A48 ! ! ; ( '@p+ ! cmmd' ) { cr }
: idle ( m-m ) { 15DD } @p+ ! .. ( ' ) nooop ( ' ) h# 8003 cmd noop d# 120
   for ( 7.8us 42ns/ 5- is 181 ) { indent }
 @p+ ! .. ( ' ) nooop ( ' ) { indent }
 begin { 16FD } @b and if { indent }
 ( ... ) @ .. @ ! ! ( user to ctrl ) { indent }
 ( ... ) *next idle ; { 179D } { indent }
 then drop { cr }
 next @p+ ! .. ( ' ) nooop ( ' ) idle ; { cr }
: init ( m-m ) { 181D } ( run only at power-up/reset ) { indent }
 d# 4761 for ( 200us 42ns/ 1- ) noop next { indent }
 noop h# 10400 ( pre.all ) cmd noop { indent }
 h# 8001 ( rfr.123 ) cmd noop noop { indent }
 h# 8002 ( rfr.123 ) cmd noop noop { indent }
 h# 21 ( std.mode ) cmd noop noop { indent }
 h# 4000 ( ext.mode ) cmd noop idle ; { br }
 { 1B1D } [ exit ] ( start is run in ide )
: start h# 135 ( '-dl- ) a! io b! { cr }
 h# 800 ( n13w? ) dup dup dup dup dup dup { cr }
 dup dup dup init ; }block

 1327 shadow{  }block

 1328 code{  ( sdram user interface ) { cr }
 [ h# AA org ] ( user cmds+data from/to up or right )
: a2rc ( pa-pbc ) { 155D } dup ( 2* 16mw ) push 2/ ( 32mw ) { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ -if
: row! ( pr-pbc ) { 15FD } h# 7FFF ( row.mask ) and dup .. { cr }
 h# 18000 ( activate ) or .. ! h# 5A48 ! .. ( '@p+ ! cmmd' ) h# 6000 (
   bank.mask ) and pop .. h# 3FF ( col.mask ) and ; then over + row! ;
: sd@ ( pa-p ) { 177D } a2rc h# 28400 ( read+pre ) or or { cr }
 ! h# 5A4B ! .. ( '@p+ ! rcol' ) down b! .. { cr }
 @p+ !b @b ( ' ) @ !p+ .. ( ' ) pop b! !b ;
: sd! ( pa-p ) { 18BD } a2rc h# 20400 ( write+pre ) or or { cr }
 ! h# 5A4D ! .. ( '@p+ ! wcol' ) pop b! @b .. { cr }
 down b! .. @p+ !b !b ; ( ' ) @p+ db! ( ' )
: poll ( ru-ru ) { 19FD } io b! @b { cr }
 2* 2* -if push over .. r--- over pop then { cr }
 h# 800 and . if push .. ---u pop then { cr }
 drop poll ; { br }
 { 1B9D } [ exit ] ( start is run in ide )
: start left ! d# 0 d# 0 ( r.u ) poll ; }block

 1329 shadow{  ( configure for sdram wiring as follows ) { cr }
 2* ( 16mw ) push ( 2/ 32mw ) [ for d# 16 mw wiring ] { cr }
 ( 2* 16mw push ) 2/ ( 32mw ) [ for 32. ] }block

 1330 code{  }block

 1331 shadow{  }block

 1332 code{  }block

 1333 shadow{  }block

 1334 code{  }block

 1335 shadow{  }block

 1336 code{  }block

 1337 shadow{  }block

 1338 code{  }block

 1339 shadow{  }block

 1340 code{  }block

 1341 shadow{  }block

 1342 code{  }block

 1343 shadow{  }block

 1344 code{  }block

 1345 shadow{  }block

 1346 code{  }block

 1347 shadow{  }block

 1348 code{  }block

 1349 shadow{  }block

 1350 code{  }block

 1351 shadow{  }block

 1352 code{  }block

 1353 shadow{  }block

 1354 code{  ( hardware multiply test ) [ d# 0 org +cy ]
: clc { 401D } dup dup or dup . + drop ;
: d2* ( hl-hl ) { 405D } dup . + push dup . + pop ;
: um+ ( hln-hl ) { 40BD } . + push dup dup or . + pop ; { 411D } [ -cy ]
: h* ( nu-hl ) { 11D } dup a! dup or d# 17 for +* unext a ;
: abs ( n-n ) { 19D } -if
: neg ( n-n ) { 1BD } - d# 1 . + then ; { 21D } [ +cy ]
: u/mod ( hld-rq ) { 421D } clc neg
: -u/mod { 425D } a! d# 17 push begin begin dup . + push dup . + dup a
   . + -if drop pop *next dup . + ; then over or or pop next dup . + ;
   { 43DD } [ -cy ]
: try { 43DD } right b! ( ba ) @b @b h* ( r ) @b um+ ( a ) @b u/mod (
   b ) !b ( r ) !b try ; { 44DD } }block

 1355 shadow{ 
: h* ( is simplest multiply; first arg is a signed number and second,
   the multiplier, is a full { 24F } bit unsigned number. )
: try ( slaves this node to another by the port given. it expects to receive
   numbers b a r and calculates b*a+r then receives a and returns b and
   r. the multiply is done using the h* here which is why b is signed
   and a is unsigned. ) }block

 1356 code{  ( soft multiply test ) [ d# 0 org +cy ]
: clc { 401D } dup dup or dup . + drop ;
: d2* ( hl-hl ) { 405D } dup . + push dup . + pop ;
: um+ ( hln-hl ) { 40BD } . + push dup dup or . + pop ;
: u* ( nn-hl ) { 411D } a! clc dup push dup or dup pop d# 17 for begin
   push d2* a -if 2* a! pop dup push . + push d# 0 . + pop pop *next drop
   ; then 2* a! pop next drop ; { 433D } [ -cy ]
: abs ( n-n ) { 33D } -if
: neg ( n-n ) { 35D } - d# 1 . + then ;
: *. ( ff-f ) { 3BD } over over or push abs swap abs u* d2* d2* drop pop
   -if drop neg ; then drop ; { 4DD } [ +cy ]
: u/mod ( hld-rq ) { 44DD } clc neg
: -u/mod { 451D } a! d# 17 push begin begin dup . + push dup . + dup a
   . + -if drop pop *next dup . + ; then over or or pop next dup . + ;
   { 467D } ( -cy )
: try { 467D } right b! @b @b u* @b um+ @b u/mod !b !b try ; { 475D } }block

 1357 shadow{  }block

 1358 code{  ( multiply exerciser ) [ h# 0 org ]
: dec ( n-n ) d# -1 . + ;
: +or ( nn-n ) over - and or ;
: try ( abr-ab bad ) { 9D } right a! ( 12033 ! ) push dup ! over ! pop
   dup ! push over ! dup @ or @ pop or +or ;
: test ( abr-abr ) dup push try if pop ; then drop pop
: poll @b h# 200 and if up b! @b push ;' io b! then drop
: run ( abr-abr ) { 35D } if dec test ; then drop if dec over dec test
   ; then drop dec if ( -1 ) h# 1FFFF over dec test ; then drop h# 600D
   ; { 53D }
: go { 53D } io b! ( 20000 ) h# 1FFFF ( -1 ) h# 1FFFF over dec run ; {
   br }
: -u/mod ( old ) { 5FD } a! d# 17 push dup . begin begin { cr }
 + push dup . + dup a . + -if drop pop dup *next + ; then over or or pop
   dup next + ; { 79D } }block

 1359 shadow{ 
: try ( exercises slave node given a test vector. for the hardware version
   a is unsigned and b is signed. but the divide is unsigned so b is limited
   to the largest positive number. ) }block

 1360 code{  ( serdes test ) [ h# AA org ] data a! h# 3FFFE dup ! up a!
   begin @ drop unext ( rdlu ) [ d# 0 org ]
: try io b! h# 20000 !b h# 147 a! d# 0 d# 10000 for d# 1 + dup a! next
   ;
: start @ io b!
: test h# 2AAAA @b or ! test . . . . down a! . . start }block

 1361 shadow{  }block

 1362 code{  ( serdes test { 4F } ) [ h# AA org ] data a! h# 33333 dup
   ! up a! h# 20000 !b begin dup . . . . . . . . . . . . . . . . . . .
   . . ! unext . . . . . . . }block

 1363 shadow{  }block

 1364 code{  ( spi flash writer michael + greg 2.1 ) [ d# 0 org ]
: 2o ( dw-dw' ) { 1D } obit 2* obit ;
: wait ( dw-dw ) { 5D } select dup begin drop @b -until drop select ;
: 2cmd ( dw-d ) { DD } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 17D } io b! ( fast ) d# 5 ;
: fet ( ah al-d ) { 1DD } push push set ( read ) h# C00 cmd pop !8 pop
   8obits !8 ;
: +wr ( -d ) { 29D } set ( wren+wrsr ) h# 1804 2cmd { indent }
 ( hi8 zero ) dup !8 ( ebsy ) h# 1C000 cmd ;
: aaip ( d-d ) { 35D } h# 2B400 wait !8 ;
: x8p ( hln-d asrc ) { 3BD } +wr ( wren+aaip ) h# 1AB4 2cmd { cr }
 drop push push push set pop !8 pop 8obits { cr }
 !8 ahead begin aaip [ swap ] then d# 7 for { indent }
 pop dup push push @+ { indent }
 begin 2o 2* next push aaip pop { indent }
 d# 7 pop dup push or push { indent }
 begin 2o 2* next drop next next { cr }
 ( wrdi+dbsy ) h# 1200 wait 2cmd rdl- ; { 73D }
: ers { 73D } +wr ( wren+eras ) h# 1980 2cmd dup select ; { 7BD } }block

 1365 shadow{  }block

 1366 code{  ( take adc data ) [ d# 0 org ]
: sam+ ( -n ) { 1D { 2ABF } } h# 2155 { C2ABF }
: s+- ( k-n ) io b! !b up b! !b @b ;
: sam- ( -n ) { DD { 12ABF } } h# 2955 { D2ABF } s+- ; { br }
: sam { 11D } h# 20 a! sam+ sam- d# 11 2* for { cr }
 push sam+ dup - pop . + ( !+ ) push { cr }
 push sam- dup - pop . + pop + !+ next ; { 2DD } { br }
 [ exit ] sam+ drop }block

 1367 shadow{  ( this block supports taking of data manually for a/d transfer
   function. to use it, put a/d in the desired mode by editing the constants
   in sam+ and - then set desired voltage and execute sam. you will find
   a sequence of samples stored in ram at { 40F } ) { br }
 ( original version sampled each half cycle of the incoming clock. ) }block

 1368 code{  ( generate dac waves ) [ d# 0 org ]
: dly { 1D } d# 100 for unext ;
: sano ( n-n ) h# 3FFDF and ; h# 10 or ;
: tri ( n ) { FD } push h# 155 d# 0 begin { cr }
 d# 510 for over or dup sano !b { indent }
 dly over or d# 1 . + next { cr }
 d# 510 for over or dup sano !b { indent }
 dly over or d# -1 . + next next drop drop ;
: try { 39D } io b!
: sing { 3DD } d# 1000 tri
: poll { 41D } @b h# 2000 and if down b! @b push ;' io b! then drop sing
   ;
: haul { 53D } io b! d# -1 dup push dup push dup push dup push dup push
   dup push dup push dup push push h# 155 h# AA over over over over over
   over ( / ) dup dup
: spin { 6DD } begin !b ( . . ) unext ( !b !b !b !b !b !b !b !b ) spin
   ; { 6FD } [ exit ] { cr }
 h# 155 h# 1D5 h# 55 h# D5 h# AA h# D5 h# 55 h# 1D5 ( / ) }block

 1369 shadow{  }block

 1370 code{  }block

 1371 shadow{  }block

 1372 code{  ( ide via async boot ) [ d# 0 org ]
: obit ( dwn-dw ) { 1D } !b over push delay ;
: word ( dw-d ) { 5D } leap drop leap drop leap drop drop ;
: obyt ( dw-dwx ) { DD } then then then d# 3 obit drop d# 7 for dup d# 1
   and d# 3 or obit drop 2/ next d# 2 obit ;
: -out { 23D } ser-exec ( rdl- ) ; { 25D } { br }
: ok { 25D } h# 31416 word -out ;
: fet { 2BD } d# 0
: pump ( n ) for @+ word next -out ;
: stat { 37D } d# 9 pump ;
: bstk { 3BD } @ push .. @ word pop dup push word .. ( @p+.push ) h# 49BA
   ! d# 7 .. dup push ! .. @p+ ! .. ( /+ ) begin !p+ . . unext .. begin
   @ word .. next .. @p+ ! pop .. ( /+ ) pop @p+ ; .. ! -out ; { 59D } }block

 1373 shadow{  }block

 1374 code{  ( ide via sync boot ) [ d# 0 org ]
: 1bit ( wx-w'x ) drop -if d# 3 ahead [ swap ] then d# 2 { cr }
 then !b 2* dup ;
: word ( w ) { DD } d# 8 dup for begin drop @b -until 1bit begin drop
   @b - -until 1bit next drop drop ;
: +out ( x ) { 1FD } begin drop @b - -until drop d# 3 !b ;
: -out ( x ) { 27D } begin drop @b -until { cr }
 drop d# 2 !b d# 1 !b ser-exec ; { br }
: ok { 31D } dup +out h# 31416 word dup -out ;
: fet { 39D } d# 0
: pump ( n ) dup +out for @+ word next dup -out ;
: stat { 47D } d# 9 pump ;
: bstk { 4BD } +out @ dup push . @ word word ( / @p+.push ) h# 49BA !
   d# 7 . ( / ) dup push ! . ( / ) @p+ ! . . ( /+ ) begin !p+ . . unext
   ( / ) begin @ word ( / ) next ( / ) @p+ ! pop . ( /+ ) pop @p+ ; (
   / ) ! -out ; { 69D } }block

 1375 shadow{  }block

 1376 code{  ( ide wire node ) [ d# 0 org ]
: fet { 1D } @p+ !b @ . fet !b @b ! ; { 7D } [ d# 5 org ]
: sto { BD } @p+ !b @ . sto !b @ !b ; { 11D } [ h# A org ]
: ins { 15D } @p+ !b @ . ins !b ; { 1BD } [ h# D org ]
: psh { 1BD } @p+ !b @ . psh !b ; { 21D } [ h# 10 org ]
: stk { 21D } @p+ !b . . stk d# 9 for @b ! unext ; { cr }
 { 2BD } }block

 1377 shadow{  }block

 1378 code{  ( ide last guy ) [ h# 1E org ]
: focus ( i0 ) { 3DD } @p+ !b !b ; ( / ) focus ; [ d# 0 org ]
: fet { 1D } @p+ focus ( /+ ) @p+ a! @ !p+ ( / ) @ !b @b @p+ ( /+ ) ;
   ( / ) !b ! ;
: sto { BD } @p+ focus ( /+ ) @p+ a! . @p+ ( / ) @ !b @ . ( / ) !b @p+
   !b ; ( /+ ) ! ;
: ins { 15D } @ focus ; ( / ) ins ins
: psh { 1BD } @p+ focus ( /+ ) @p+ ; ( / ) @ !b ;
: stk { 21D } @p+ focus ( /+ ) !p+ dup push !p+ ( / ) @b @b ! dup ( / )
   ! ( @p+.push ) h# 49BA !b d# 7 ( / ) dup push !b . ( / ) @p+ !b ( /+ )
   begin !p+ . . unext ( / ) begin @b ! unext . ( / ) @p+ !b !b ; ( /+ )
   pop @p+ ; { cr }
 ( if past size-2 not ok- ) { 39D } }block

 1379 shadow{  }block

 1380 code{  ( common ) { cr }
 [ h# 1D5 org ] { -cr }
: r--- { cr }
 [ h# 115 org ] { -cr }
: -d-- { cr }
 [ h# 175 org ] { -cr }
: --l- { cr }
 [ h# 145 org ] { -cr }
: ---u { cr }
 [ h# 1A5 org ] { -cr }
: rdlu ( right down left up ) { cr }
 [ h# 1B5 org ] { -cr }
: rdl- ( right down left ) { cr }
 [ h# 185 org ] { -cr }
: rd-u ( right down up ) { cr }
 [ h# 195 org ] { -cr }
: rd-- ( right down ) }block

 1381 shadow{  }block

 1382 code{  ( polynomial approximation )
: poly ( xn-xy ) pop a! push @+ a begin { indent }
 push *. pop a! @+ + a next push ; }block

 1383 shadow{ 
: poly ( xn-xy ) { cr }
 ( evaluation of chebyshev polynomials using ) { cr }
 ( the horner scheme. ) { br }
 ( x is the input value. n is the length of ) { cr }
 ( the coefficient table minus 2. coefficient ) { cr }
 ( table follows inline, and execution ) { cr }
 ( continues after the final table entry. x is ) { cr }
 ( left on the stack under the result, y. ) { br }
 ( for example... )
: cos ( f-f' ) { cr }
 ( hart 3300 ) { cr }
 ( -0.0043 0.0794 -0.6459 0.5708 ) { indent }
 2* 2* . triangle dup *. d# 2 poly { indent }
 [ d# -281 , d# 5203 , d# -42329 , d# 37407 , ] { indent }
 push drop pop *. + ; }block

 1384 code{  ( interpolate )
: interp ( ims-v ) dup push push over { indent }
 begin 2/ unext a! { indent }
 and push @+ dup @+ - . + - { indent }
 pop a! dup dup or { indent }
 begin +* unext push drop pop . + ; }block

 1385 shadow{ 
: interp ( ims-v ) { cr }
 ( to determine values for m and s ... ) { cr }
 ( let l be number of meaningful input bits. ) { cr }
 ( let n be power of 2 where 2**n + 1 is the ) { cr }
 ( number of table entries. ) { br }
 ( s equals l-n-1 ) { cr }
 ( m equals 2** l-n - 1 ) { br }
 ( so for example if you have an 8 bit adc, ) { cr }
 ( l equals 8. let n equal 2 for a 5 entry table. the table is expected
   to be at address 0, ) { cr }
 ( so to represent 0 to 1800 millivolts... ) { br }
 [ 0 org 0 , 450 , 900 , 1350 , 1800 , ] { cr }
: mv ( i-n ) h# 3F 5 interp ; { br }
 [ d# 0 mv ] ( gives ) [ d# 0 ] { cr }
 [ d# 128 mv ] ( gives ) [ d# 900 ] { cr }
 [ d# 256 mv ] ( gives ) [ d# 1800 ] { cr }
 ( and intermediate values are interpolated. ) }block

 1386 code{  ( fir or iir filter )
: taps ( yxc-y'x' ) pop a! push begin { indent }
 @+ @ push a push *.17 pop a! { indent }
 push !+ pop . + pop next @ a! ; }block

 1387 shadow{ 
: taps ( yxc-y'x' ) { cr }
 ( for example... ) { br }
: fir ( yx-y'x' ) d# 15 taps [ d# -53 , d# 0 , d# 2276 , d# 0 , d# 382
   , d# 0 , d# -1706 , d# 0 , d# -1158 , d# 0 , d# 2014 , d# 0 , d# 2406
   , d# 0 , d# -1977 , d# 0 , d# -4206 , d# 0 , d# 1289 , d# 0 , d# 6801
   , d# 0 , d# 678 , d# 0 , d# -11109 , d# 0 , d# -6250 , d# 0 , d# 23531
   , d# 0 , d# 54145 , d# 0 , ] { br }
 ( 16 taps, 16 coefficients with intermediate ) { cr }
 ( storage interleaved. ) }block

 1388 code{  ( routing; called with 'a relay' )
: relay ( a ) pop a! @+ push @+ zif { indent }
 drop ahead ( done ) [ swap ] then { indent }
 pop over push @p+ ( ' ) a relay ( ' ) { indent }
 !b !b !b begin @+ !b unext
: done then a push a! ; }block

 1389 shadow{  ( relay moves a port executable packet down ) { cr }
 ( a sequence of nodes linked by their b ) { cr }
 ( registers. the packet consists of a 1-cell ) { cr }
 ( index, a 1-cell count ) [ less one ] ( of body ) { cr }
 ( size, and the body cells. ) { br }
 ( a packet ) [ may ] ( be started from memory within ) { cr }
 ( a node, or it may simply be fed to a port. ) { br }
 ( relay assumes that b points to the next ) { cr }
 ( node in the chain. uses one return stack ) { cr }
 ( location and four data stack locations. ) { cr }
 ( it must be at the same location in every ) { cr }
 ( node. ) }block

 1390 code{  ( multiply )
: *.17 ( a b - a a*b ) a! d# 16 push dup dup or { indent }
 begin +* unext - +* a -if { indent }
 drop - 2* ; then drop 2* - ; }block

 1391 shadow{ 
: *.17 ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. note that the definition of ) *. { cr }
 ( contains a call to this word. ) { br }
 ( 17 bit fractions --- s.i ffff ffff ffff ffff ) }block

 1392 code{  ( lshift rshift )
: lsh push begin 2* unext ;
: rsh push begin 2/ unext ; }block

 1393 shadow{  }block

 1394 code{  ( triangle )
: triangle ( x-y call with; 2* 2* triangle ) { indent }
 h# 10000 over -if drop . + ; then { indent }
 drop - . + - ; }block

 1395 shadow{ 
: triangle ( assuming an angle expressed as a ) { cr }
 ( 16 bit fraction of a revolution, ) { cr }
 [ 2* 2* triangle ] ( produces a triangle wave ) { cr }
 ( approximation to the cosine of that angle. ) }block

 1396 code{  ( fractional multiply )
: *. { 16FD } ( f1 f2 - f1 f1*f2 ) *.17 { indent }
 a 2* -if drop - 2* - ; then { indent }
 drop 2* ; }block

 1397 shadow{ 
: *. ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. ) { br }
 ( 16 bit fractions --- si. ffff ffff ffff ffff ) }block

 1398 code{  ( divide ) { cr }
 [ +cy ] { 5A7D } ( enter ea mode )
: clc dup dup or dup . + drop ;
: --u/mod clc
: -u/mod ( hld-rq ) a! d# 17 push begin begin { indent }
 dup . + . push dup . + { indent }
 dup a . + -if { indent }
 drop pop *next dup . + ; then { indent }
 over or or . pop next dup . + ; { cr }
 [ -cy ] { 1C3D } ( exit ea mode ) }block

 1399 shadow{ 
: clc ( clears the carry bit for addition in ) { cr }
 ( ea mode. ) { br }
 ( the following defines u/mod in ram ... ) { cr }
: u/mod ( hld-rq ) - d# 1 . + --u/mod ; { br }
 ( if the divisor is a constant, just negate ) { cr }
 ( it at edit or compile time. ) }block

 1400 code{  ( g18 compiler )
:# h 28
:# ip 27
:# slot 4
:# call? 0
:# cal 270080062
:# com 16 [ macro ]
: !7 h# BD0489 3, h# FFFFFFFC , < drop > ;
: 2*s ?lit h# E0C1 2, 1, ;
: call ( nn ) < ?dup > h# B8 1, , h# E9 1, [ cal ] @ here d# 3 + - + ,
   ; [ forth ]
: swap swap ;
: eras ( an ) push h# 61FC ( call a9 ) swap block pop blks fill ;
: memory ( n-a ) [ h# 240 - ] and [ com ] @ 2* h# 8000 + block + ; [ h# 8000
   nnc d# 2 * eras ]
: org ( n ) dup [ h ] ! [ ip ] !
: break d# 4 [ slot ] ! ;
: o ( n ) d# 6 for d# 10 /mod next d# 6 for d# 8 * + next
: p, ( n ) [ h ] @ memory ! [ h ] @ d# 1 over + over or h# 7F and or [
   h ] ! ;
: s4 [ h ] @ [ ip ] ! d# 13 2*s dup [ call? ] ! p, d# 1 [ slot ] ! ;
: s0 d# 13 2*s
: sn dup [ call? ] ! [ ip ] @ memory +! d# 1 [ slot ] +! ;
: s1 d# 8 2*s sn ;
: s2 d# 3 2*s sn ;
: s3 dup d# 3 and drop if d# 7 sn s4 ; then d# 4 / sn ;
: i, [ slot ] @ jump s0 s1 s2 s3 s4 }block

 1401 shadow{  ( g18 target compiler ) [ includes support for g18 addressing
   see d# 1404 ]
: h ( address of next available word in target memory here )
: ip ( address of current instruction word )
: slot ( next available instruction slot )
: call? ( was last instruction a call ? )
: call a ( compile a call )
: eras ( fills g18 memory with call 155 number )
: 2*s n ( shift left n bits )
: memory n-a ( host address for target memory )
: org n ( set current target memory location )
: break ( break in emulator only )
: p, n ( compile pattern into target memory )
: s0-s4 ( assemble opcode into slot 0-3 )
: i, ( assemble opcode into next slot *note** simple code jump table using )
   [ jump ] }block

 1402 code{  ( target )
: cnt 2/ d# -1 + ;
: defer ( -b ) pop ;
: execute ( b ) push ;
: f! ( bn ) [ sp ] + ! ;
: f@ ( n-b ) [ sp ] + @ ;
: class ( b ) [ last d# 1 + ] ! ;
: empty empt
: host d# 0 class [ d# 6 f@ ] nop [ d# 4 f@ ] nop [ d# 13 f@ ] nop
: functions ( bbb ) d# 13 f! d# 4 f! d# 6 f! ;
: . h# 1C i, ; ( nop )
: hhere here ;
: .. [ slot ] @ d# 4 or drop if . .. ; then d# 0 [ call? ] ! ;
: here .. [ h ] @ h# 3FF and ; [ hhere ]
: report here d# 32 * [ d# 13 d# 16 + ] + !7 ;
: c18 ( b ) d# 1 f@ [ d# 0 + ] functions ;
: +cy here h# 200 over - and or org ;
: -cy here [ h# 200 - ] and org ;
: await [ com ] @ idle [ cal ] @ execute ; }block

 1403 shadow{ 
: defer -a ( byte address of the compiled code that follows -- used for
   forward referencing )
: execute a ( code at this address )
: f! an ( store address of code executed when a word with this function
   is interpreted )
: f@ n-a ( fetch address of function code )
: class a ( store address of code to be executed for each word subsequently
   defined )
: empty ( redefine empty to restore altered functions )
: host ( change context back to colorforth )
: functions aa ( store functions in kernel specific way )
: c18 ( save green word and number functions. set green short-number to
   n, compile to call. target words are executed to assemble instructions )
: . ( nop used to fill instruction words )
: nops ( fills rest of word with nops )
: here -a ( starts new instruction word. leaves target address as number )
: await ( generates call to node's idle ports. ) }block

 1404 code{  ( g18 jump instructions )
: 9same ( axa-ax ) push over pop - or [ h# 200 ] and drop ;
: j3 .
: j0 i, [ ip ] @ memory +! break ;
: j1 [ h ] @ 9same if over h# 100 and drop if swap h# FF and swap j0 ;
   then then . . j3 ;
: j2 over h# 155 or [ h ] @ or h# 3F8 and drop if . j3 ; then swap d# 7
   and swap j0 ;
: -adr ( an ) swap h# 155 or swap [ slot ] @ jump j0 j1 j2 j3 j0
: adr ( n-n ) [ slot ] @ d# 3 or drop if i, [ ip ] @ d# 8 * [ h ] @ [
   ip ] @ negate + + d# 8 * [ slot ] @ + break ; then . adr ;
: @h ( n-a ) d# 8 /mod + ;
: f3 ( an ) over h# 155 or over @h or h# 2F8 and drop if abort ; then
   swap d# 7 and swap d# 8 / memory +! ;
: f2 dup @h 9same if over h# 100 and drop if swap h# FF and swap
: f1 d# 8 / memory +! ; then then abort ;
: then ( n ) here h# 155 or swap d# 8 /mod swap jump f1 f1 f2 f3 }block

 1405 shadow{  [ the g18 uses adr bit d# 9 for mode; d# 8 for i/o; d# 7
   for rom. incrementer maintains bits 0-6, rest are left alone except
   for return and slot d# 0 jumps. ] { br }
: 9same ( is true if the two addresses match in bit 9 - the extended arithmetic
   mode bit. )
: -adr an ( assembles jump to known address )
: adr n-a ( assembles forward jump in slot 0,1,2. value left on stack
   is instr addr * 64 + here-ip + slot. )
: @h ( given that vlue value / 8 returns p at time the jump executes. )
: then a ( insert address for forward jump ) }block

 1406 code{  ( complex instructions )
: def defer here < call > ;
: call defer ( a ) d# 3 -adr ; [ call cal ! ]
: ; [ call? ] @ dup h# 6000 or drop if dup h# 300 or drop if dup h# 18
   or drop if d# 0 and i, break ; then then then dup 2/ and negate [ ip ]
   @ memory +! ;
: -if ( -a ) d# 7 adr ;
: if ( -a ) d# 6 adr ;
: -until ( a ) d# 7 -adr ;
: until ( a ) d# 6 -adr ;
: -while ( a-aa ) d# 7 adr swap ;
: while ( a-aa ) d# 6 adr swap ;
: zif ( -a ) d# 5 adr ;
: *next ( aa-a ) swap
: next ( a ) d# 5 -adr ;
: unext ( a ) d# 4 i, drop ;
: n defer d# 8 f@ execute
: lit d# 8 i, h# 3FFFF and ( ok in slot 3 )
: , ( n ) h# 15555 or p, ;
: for h# 1D i,
: begin here ;
: ahead ( -a ) d# 2 adr ;
: end ( a ) d# 2 -adr ;
: leap ( -a ) d# 3 adr ; }block

 1407 shadow{ 
: def -a ( deferred to class. executed for every target definition to
   compile host code that compiles target call )
: call a ( compile target call )
: ; ( will be executed as a target word. the pentium macro has precedence
   while compiling )
: if/-if ( leaves address of jump on stack )
: -until a ( jump if positive to ) begin
: zif ( forward ) next ( decrements r and jumps if r! else pops and falls
   thru )
: next/for
: n ( executed for green short-numbers. all 18-bit target numbers are
   short. executes white short-number to put interpreted number on stack.
   then assembles literal instruction with number in next location. inverted
   for rom )
: , n ( compile number into target memory )
: ?lit -n ( retrieve previously compiled number )
: begin -a ( starts new instruction word. leaves properly formatted target
   address )
: ahead ( compiles fwd ref jump resolve w/then )
: leap ( like ahead but compiles a call ) }block

 1408 code{  ( instructions )
: target n c18 def class ;
: ex { -cr }
: ;' d# 1 i, break ;
: rx
: @p { -cr }
: @p+ d# 8 i, ;
: @+ d# 9 i, ;
: @b h# A i, ;
: @ h# B i, ;
: !p { -cr }
: !p+ h# C i, ;
: !+ h# D i, ;
: !b h# E i, ;
: ! h# F i, ; }block

 1409 shadow{  ( words being redefined for the target computer. these
   host words can no longer be executed. although pentium macros take
   precedence during compilation, they will no longer be used. )
: g18 ( instructions )
: 0 ( ; ) ....8 ( n ) ..10 ( +* ) ..18 ( dup )
: 1 ( ;' ) ...9 ( @+ ) .11 ( 2* ) ..19 ( pop )
: 2 ( j ) ....a ( @b ) .12 ( 2/ ) ..1a ( over )
: 3 ( call ) .b ( @ ) ..13 ( - ) ...1b ( a )
: 4 ( unext ) c ( !p+ ) 14 ( + ) ...1c ( . )
: 5 ( next ) .d ( !+ ) .15 ( and ) .1d ( push )
: 6 ( if ) ...e ( !b ) .16 ( or ) ..1e ( b! )
: 7 ( -if ) ..f ( ! ) ..17 ( drop ) 1f ( a! ) }block

 1410 code{  ( port literals and constants )
: right [ h# 1D5 ] lit ; ( 0101111111 register bits )
: down [ h# 115 ] lit ; ( 0110111111 )
: left [ h# 175 ] lit ; ( 0111011111 )
: up [ h# 145 ] lit ; ( 0111101111 )
: warp [ h# 157 ] lit ; ( 0101010111 )
: io h# 15D lit ; ( 0111110111 )
: data h# 141 lit ; ( 0111101011 port calls )
: center h# 1A5 lit ;
: top h# 1B5 lit ;
: side h# 185 lit ;
: corner h# 195 lit ;
: /mod /mod ;
: spispeed d# 497 ( 0 ) lit ; [ h# 0 ] ( 24-bit adrs ) [ d# 4 * d# 262144
   /mod ] ( al ah ) [ h# 3 ] ( read cmd ) [ d# 256 * + d# 4 * ]
: spicmd ( c.ah ) [ d# 0 + ] lit ;
: spiadr ( al ) [ d# 0 + ] lit ; }block

 1411 shadow{  }block

 1412 code{  ( more instructions )
: +* h# 10 i, ; ( slot 3 ok )
: 2* h# 11 i, ;
: 2/ h# 12 i, ;
: - h# 13 i, ;
: + h# 14 i, ; ( slot 3 ok )
: and h# 15 i, ;
: or h# 16 i, ; ( exclusive-or )
: drop h# 17 i, ;
: dup h# 18 i, ; ( slot 3 ok )
: pop h# 19 i, ;
: over h# 1A i, ;
: a h# 1B i, ;
: push h# 1D i, ;
: b! h# 1E i, ;
: a! h# 1F i, ; }block

 1413 shadow{ 
: o ( replaces top-of-stack with 0. g18 instructions can't be used in
   macros - forth macros take precedence ) }block

 1414 code{  }block

 1415 shadow{  }block

 1416 code{  }block

 1417 shadow{  }block

 1418 code{  ( math rom anywhere ) [ d# 0 kind ] { br }
 [ h# A1 org ] { cr }
 { 143D } [ d# 1388 load ] ( relay ) { cr }
 { 153D } { -cr }
: warm await ; { br }
 [ h# B0 org ] { cr }
 { 161D } [ d# 1390 load ] ( multiply ) { cr }
 { 16FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 179D } [ d# 1386 load ] ( taps ) { cr }
 { 189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 19DD } [ d# 1394 load ] ( triangle ) { cr }
 { 1A7D } [ d# 1398 load ] ( -u/mod ) { br }
 [ h# AA org ] { cr }
 { 155D } [ d# 1382 load ] ( polynomial approximation ) { cr }
 { 161D } }block

 1419 shadow{  }block

 1420 code{  ( serdes boot top/bot ) [ d# 6 kind h# AA reset ] { br }
 [ h# A1 org ] { cr }
 { 143D } [ d# 1388 load ] ( relay ) { cr }
 { 153D } { -cr }
: warm await ; { cr }
: cold { 155D } h# 3141 a! h# 3FFFE dup ! rdlu cold ; { br }
 { 161D } [ d# 1390 load ] ( multiply ) { cr }
 { 16FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 179D } [ d# 1386 load ] ( taps ) { cr }
 { 189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 19DD } [ d# 1394 load ] ( triangle ) { cr }
 { 1A7D } [ d# 1398 load ] ( -u/mod ) { cr }
 { 1C3D } }block

 1421 shadow{  }block

 1422 code{  ( sync serial boot side ) [ d# 2 kind h# AA reset ] { cr
   { 17FF } }
 [ h# BE org ] { -cr }
: sget { cr }
 [ h# A1 org ] { cr }
 { 143D } [ d# 1388 load ] ( relay ) { cr }
 { 153D } { -cr }
: warm await ; { cr }
: cold { 155D } h# 31A5 a! @ @b . . -if ( 0pin ) { cr }
 h# 3FD85 ( 'rd-u 3fc00 + ) dup push dup begin { cr }
 drop @b . -if ( /pin ) *next [ swap ] then { cr }
 h# 185 ( 'rd-u ) push drop push ; then
: ser-exec { 16DD } ( x-x ) sget push sget a! sget
: ser-copy { 173D } push zif ; then { cr }
 begin sget ( push sget pop !+ ) !+ next ;
: sget { 17DD } ( -w ) dup leap leap
: 6in { 181D } then then leap leap
: 2in { 185D } then then 2* 2* dup begin { cr }
 . drop @b . - -until - d# 2 and dup begin { cr }
 . drop @b . . -until d# 2 and 2/ or or ; { br }
 { 199D } [ d# 1390 load ] ( multiply ) { cr }
 { 1A7D } [ d# 1386 load ] ( taps ) { cr }
 { 1B7D } [ d# 1394 load ] ( triangle ) { cr }
 { 1C1D } }block

 1423 shadow{  ( sync serial boot side ) { br }
 ( ser-copy reads one word per loop and the loop counter is the actual
   number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

 1424 code{  ( async serial boot top/bot ) [ d# 1 kind h# AA reset ] {
   cr { 19FF } }
 [ h# CB org ] { -cr }
: 18ibits { cr }
 [ h# A1 org ] { cr }
 { 143D } [ d# 1388 load ] ( relay ) { cr }
 { 153D } { -cr }
: warm await ;
: cold { 155D } h# 31A5 ( 'rdlu ) a! @ @b .. -if
: ser-exec { 15DD } ( x-d ) 18ibits drop push . { cr }
 18ibits drop a! . 18ibits
: ser-copy { 167D } ( xnx-d ) drop push zif ; then begin { cr }
 18ibits drop ( push . 18ibits drop pop . !+ ) !+ ( . ) next ; then drop
   h# 1B5 ( 'rdl- ) push push ;
: wait { 177D } ( x ) begin . drop @b -until . drop ;
: sync { 17DD } ( x-delay ) dup dup wait or - push begin @b . -if . drop
   *next rdl- ; then . drop pop - 2/ ;
: start { 18BD } ( delay word - delay word b ) { cr }
 dup wait over dup 2/ . + push
: delay { 191D } ( nw-nwb ) { cr }
 begin @b . -if then . drop next @b ; { br }
 { 197D } [ d# 1426 load ] ( 18ibits ) { cr }
 { 1B3D } [ d# 1392 load ] ( lsh rsh ) { cr }
 { 1BBD } }block

 1425 shadow{  ( async serial boot top/bot ) { br }
 ( ser-copy reads one word per loop and the loop counter is the actual
   number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

 1426 code{  ( more async serial )
: 18ibits { 197D } ( x - delay word x ) { indent }
 sync sync dup start leap ( 2bits ) leap
: byte { 1A1D } then drop start leap
: 4bits { 1A5D } then leap
: 2bits { 1A7D } then then leap
: 1bit { 1A9D } ( nwb-nwb ) then { indent }
 push 2/ pop over or { indent }
 h# 20000 and or over push delay ; { cr }
 { 1B3D } }block

 1427 shadow{  }block

 1428 code{  ( spi boot top/bot ) [ d# 4 kind h# AA reset host ]
: --- [ h# 2A ] lit ;
: --+ [ h# 2B ] lit ;
: +-- [ h# 3A ] lit ;
: +-+ [ h# 3B ] lit ;
: -++ [ h# 2F ] lit ; [ target ] { cr }
 [ h# A1 org d# 1388 load ] ( relay ) { br }
 [ h# C2 org ]
: 8obits ( dw-dw' ) d# 7 for leap ( obit ) 2* *next ;
: ibit { 18FD } ( dw-dw' ) { indent }
 @b . -if drop - 2* ; then drop 2* - ;
: half { 195D } ( dwc-dw ) !b over for . . unext ;
: select { 199D } ( dw-dw ) -++ half --+ half ;
: obit { 1A1D } ( dw-dw ) then { indent }
 -if +-- half +-+ half ; then
: rbit { 1ABD } ( dw-dw ) --- half --+ half ;
: 18ibits { 1B3D } ( d-dw ) dup d# 17 for rbit ibit - next ; { cr }
: u2/ 2/ h# 1FFFF and ; { cr }
 [ h# A9 org ] { cr }
 { 153D } { -cr }
: warm await ; { cr }
 { 155D } [ d# 1430 load ] ( the rest ) { cr }
 { 183D } }block

 1429 shadow{  }block

 1430 code{  ( more spi )
: cold { 155D } @b - .. [ h# 1B5 ] ( 'rdl- ) -until { indent }
 spispeed spiadr push spicmd
: spi-boot { 161D } ( dly adrh . adrl - dly x ) { indent }
 select 8obits 8obits { indent }
 drop pop . 8obits 8obits
: spi-exec { 16DD } ( dx-dx ) drop 18ibits { indent }
 h# 1E000 . + [ h# 1B5 ] ( 'rdl- ) -until { indent }
 push 18ibits a! 18ibits
: spi-copy { 179D } ( dn-dx ) push zif ; then begin { indent }
 18ibits ( push 18ibits pop !+ ) !+ next dup ; { 183D } ( was { 185F } ) }block

 1431 shadow{  ( more spi ) { br }
 ( spi-copy reads one word per loop and the loop counter is the actual
   number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

 1432 code{  ( analog ) [ d# 0 kind ] { br }
 [ h# A1 org ] { cr }
 { 143D } [ d# 1388 load ] ( relay ) { cr }
 { 153D } { -cr }
: warm await ; { br }
 [ h# B0 org ] { cr }
 { 161D } [ d# 1390 load ] ( multiply ) { cr }
 { 16FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 179D } [ d# 1434 load ] ( -dac ) { cr }
 { 189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 19DD } [ d# 1394 load ] ( triangle ) { cr }
 { 1A7D } [ d# 1398 load ] ( -u/mod ) { br }
 [ h# AA org ] { cr }
 { 155D } [ d# 1382 load ] ( polynomial approximation ) { cr }
 { 161D } }block

 1433 shadow{  }block

 1434 code{  ( dac )
: -dac ( legacy entry name below )
: dac27 { 179D } ( mcpaw-mcp ) dup push push { indent }
 over pop - . + push push h# 155 { indent }
 pop over or a { indent }
 begin unext !b . { indent }
 begin unext !b !b ; }block

 1435 shadow{  }block

 1436 code{  ( 1-wire ) [ d# 3 kind h# AA org ] { br }
 [ h# 9E org ]
: rcv ( s-sn ) { 13DD } a push dup dup a! d# 17 for begin
: bit { 143D } @ drop @b -if { indent }
 drop - 2* - *next pop a! ; then { indent }
 drop 2* next pop a! ; { 151D } { br }
 [ h# A9 org ]
: warm { 153D } await ;
: cold { 155D } left center a! . io b! { indent }
 dup dup h# B7 ( rest ) dup push push d# 16 push { indent }
 @ drop @b [ h# 185 ] ( side ) -until { indent }
 drop a! . bit ; { 16FD } ( rest ) { indent }
 push rcv a! rcv push zif ; then { indent }
 begin rcv !+ next ; { 17DD } { br }
 { 17DD } [ d# 1394 load ] ( triangle { AF } ) { cr }
 { 187D } [ d# 1390 load ] ( multiply *.17 { EF } ) { cr }
 { 195D } [ d# 1396 load ] ( fractional multiply *. { AF } ) { cr }
 { 19FD { AD0F } } ( load interpolate interp { 14F } ) { cr }
 { 19FD } [ d# 1398 load ] ( -u/mod { 1CF } ) { cr }
 { 1BDD } ( equals { 13DF } ) }block

 1437 shadow{  }block

 1438 code{  ( null rom anywhere ) [ d# 0 kind ] { br }
 [ h# A9 org ] { cr }
 ( warm ) { 153D } await ; }block

 1439 shadow{  ( default code for null rom, or for special rom to be loaded
   out of sequence. ) { br }
: warm ( is assumed by crawlers, and is also the destination of the call
   instruction that rom is initialized with. ) [ avoid clobbering this
   word since steven's test code will not work in its absence. ] }block

 1440 code{  }block

 1441 shadow{  }block

 1442 code{  }block

 1443 shadow{  }block

 1444 code{  }block

 1445 shadow{  }block

 1446 code{  }block

 1447 shadow{  }block

 1448 code{  }block

 1449 shadow{  }block

 1450 code{  }block

 1451 shadow{  }block

 1452 code{  }block

 1453 shadow{  }block

 1454 code{  }block

 1455 shadow{  }block

 1456 code{  }block

 1457 shadow{  }block
