#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass literate-article
\begin_preamble
\@ifundefined{definecolor}
 {\usepackage{color}}{}
\usepackage[dvips]{graphics}\usepackage{longtable}\usepackage{times}
\usepackage{comment}\usepackage{lastpage}
\usepackage{microtype}\DisableLigatures[-]{}

\usepackage[normalem]{ulem}\newcommand{\suppress}[1]{}\newcommand{\deleted}[1]{\xout{#1}}\newcommand{\revised}[1]{\uline{#1}}\newlength\wvtextpercent\setlength{\wvtextpercent}{0.009\textwidth}

\newbox\strikebox\def\strike#1{\setbox\strikebox \hbox{<#1>}\hbox{\raise0.5ex\hbox to 0pt{\vrule height 0.4pt width \wd\strikebox\hss}\copy\strikebox}}

\cfoot{Page \thepage\ of \pageref{LastPage}}
\end_preamble
\use_default_options true
\begin_modules
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics dvips
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\rightmargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
ColorForth Assembler/Disassembler
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Version
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Date
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout
0.0.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22 May 2012
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section

\series bold
\shape italic
Purpose
\series default
\shape default
 
\end_layout

\begin_layout Standard
I took over this program originally from John Rible as an initial contract
 with IntellaSys in Oct.
 2006, with the purpose to convert colorForth (
\family typewriter
\series bold
cf
\family default
\series default
) source into ASCII text and then added Albert van der Horst's 
\family typewriter
\series bold
ciasdis
\family default
\series default
 to illuminate the 
\family typewriter
\series bold
cf
\family default
\series default
 kernel.
 The goal is to produce a complete round trip, reproducing the 
\family typewriter
\series bold
cf
\family default
\series default
 file with an ASCII disassembly (
\family typewriter
\series bold
dsm
\family default
\series default
) file that can be used in its own Literate Programming document.
 At this stage, the round trip is produced with the following script:
\end_layout

\begin_layout Scrap

<<OkadWork>>=
\begin_inset Newline newline
\end_inset

gforth cfasdis.frt -e "cfdis OkadWork bye" > OkadWork.dsm
\begin_inset Newline newline
\end_inset

gforth cfasdis.frt -e "cfas OkadWork bye" 
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The cfasdis source is an extension of Albert's ciasdis as can be seen here:
\end_layout

\begin_layout Scrap

<<cfasdis.frt>>=
\begin_inset Newline newline
\end_inset

<<load-ciasdis>>
\begin_inset Newline newline
\end_inset

<<cfdis.f>>
\begin_inset Newline newline
\end_inset

<<cfas.f>>
\begin_inset Newline newline
\end_inset

<<run-ciasdis>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Section
Color Blindness
\end_layout

\begin_layout Standard
Before I start diving much deeper, I should explain that I am red/green
 color blind.
 This means that I do not see, or react to color like most people do.
 7% of males have this condition, as well as other people who do not perceive
 color the same way as others do.
 I have used a program called eyePilot (Version 1.0.12 from Tenebraex) so
 I can figure out what colors ColorForth is using, but it has been withdrawn
 from the market.
 So, most recently, I found WhatColor 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.hikarun.com/e/
\end_layout

\end_inset

, which appears to be supported, at least.
 I don't always need it, but frequently, 
\family typewriter
\series bold
\color yellow
yellow
\family default
\series default
\color inherit
 and 
\family typewriter
\series bold
\color green
green
\family default
\series default
\color inherit
 look far to much alike and on the block I will be using in a few moments,
 I see that the green component can have an RGB value of 192 or 255.
 I see that the User's manual explains that these are HEX numbers, but this
 does not make using colorForth any easier for me.
\end_layout

\begin_layout Standard
Additionally, tools that I tend to rely on in my programming, have not caught
 up with the use of color in source code.
 HTML editors are getting closer, and colorForth even has an HTML listing
 utility, but I have not found them good enough yet.
 Most explicitly, the use of Literate Programming that I will be using in
 this documentation can not be done with color attributes yet.
 Some day, the rest of us might catch up with where Chuck wants us to be,
 but at the moment, I am not there yet.
\end_layout

\begin_layout Standard
Therefore, for the rest of this document, I will be using an ASCII translation
 of the syntax used by colorForth.
 This makes the code look very similar to ANS Forth, but do not be mistaken,
 it will not run in any other version of Forth that I know about.
 Here is the translation matrix:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
colorForth
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASCII translation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color red
red
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
: red
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color white
white
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
( white )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color green
green
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
: ...
 green ...
 ;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color yellow
yellow
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
[ yellow ]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color magenta
magenta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
:# magenta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color blue
blue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
{ blue }
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color cyan
cyan
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
< cyan >
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\color black
grey
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
^ grey ^
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Numbers will be preceded by the base operator that they are in (e.g.
 
\family typewriter
\series bold
D#
\family default
\series default
 or 
\family typewriter
\series bold
H#
\family default
\series default
, but 
\family typewriter
\series bold
B#
\family default
\series default
 and 
\family typewriter
\series bold
O#
\family default
\series default
 can not be translated back).
\end_layout

\begin_layout Standard
Notice that cyan and grey doesn't show up properly under the colors that
 LyX uses and I pity the person who is reading this with a black and white
 ebook reader.
 The purpose of this exercise is to automate this process.
\end_layout

\begin_layout Subsection
License
\end_layout

\begin_layout Standard
Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation
 the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software
 is furnished to do so, subject to the following conditions:
\end_layout

\begin_layout Standard
The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.
\end_layout

\begin_layout Standard
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE
, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
\end_layout

\begin_layout Subsection
ColoForth disassembler
\end_layout

\begin_layout Standard
Disassembler support for OkadWork.cf the arrayForth for GA144-1.10.
\end_layout

\begin_layout Scrap

<<cfdis.f>>=
\begin_inset Newline newline
\end_inset


\backslash
 Copyright (c) 2012 Dennis Ruffer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<Restore.f>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<endians>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ?? ( "name" -- flag )  BL WORD FIND SWAP DROP 0= 0= ;
\begin_inset Newline newline
\end_inset

: uses ( flag -- )  0= IF POSTPONE 
\backslash
 THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

?? CTRL 0= uses : CTRL CHAR 31 AND ;
\begin_inset Newline newline
\end_inset

?? [CTRL] 0= uses : [CTRL] CTRL POSTPONE LITERAL ; IMMEDIATE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

?? ForGForth uses ALSO
\begin_inset Newline newline
\end_inset

ASSEMBLER
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<icons>>
\begin_inset Newline newline
\end_inset

<<unpack-words>>
\begin_inset Newline newline
\end_inset

<<word-adjustments>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DUMP-NAMES ( a2 a1 -- )   DO  I DUP S" names " CR+$
\begin_inset Newline newline
\end_inset

        @NAME TYPE SPACE  0 CELL+ +LOOP  CR ;
\begin_inset Newline newline
\end_inset

: DIS-NAMES ( a1 a2 -- )   TARGET>HOST SWAP TARGET>HOST
\begin_inset Newline newline
\end_inset

    DUP NEXT-CUT !  DUMP-NAMES ;
\begin_inset Newline newline
\end_inset

: -names ( a n -- )   2>R ['] DIS-NAMES  2R> RANGE ;
\begin_inset Newline newline
\end_inset

' -names RANGE: -names: ( -name- )
\begin_inset Newline newline
\end_inset

: -names- ( a n -- )   -warning >R  NONAME$ -names  R> +warning ;
\begin_inset Newline newline
\end_inset

' DIS-NAMES  ' -names:  ARE-COUPLED
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<transitions>>
\begin_inset Newline newline
\end_inset

<<token-output>>
\begin_inset Newline newline
\end_inset

<<dump-blocks>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

PREVIOUS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Endian handlers
\end_layout

\begin_layout Standard
The following are used to fetch data that is in known Endian format.
  E.g.
 in file system structures or network packets.
  These words work on un-aligned entities.
\end_layout

\begin_layout Scrap

<<endians>>=
\begin_inset Newline newline
\end_inset

: SIGN-EXTEND ( x n -- x' )  32 SWAP - DUP >R
\begin_inset Newline newline
\end_inset

    LSHIFT  R> 0 DO  2/  LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: @-LE ( a -- x )   4 1C@-LE ;
\begin_inset Newline newline
\end_inset

: !-LE ( x a -- )   4 1C!-LE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: W@-BE ( a -- x )   2 1C@-BE ;
\begin_inset Newline newline
\end_inset

: W!-BE ( x a -- )   2 1C!-BE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Icon decompiler
\end_layout

\begin_layout Scrap

<<icons>>=
\begin_inset Newline newline
\end_inset

: .ICON-ROW ( x -- )   BASE @ >R  2 BASE !  S>D
\begin_inset Newline newline
\end_inset

    <#  16 0 DO  #  LOOP  #>  TYPE  R> BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

16 CONSTANT ICON-COLUMNS
\begin_inset Newline newline
\end_inset

24 CONSTANT ICON-ROWS
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: |ICON| ( -- n )   ICON-COLUMNS 8 / ICON-ROWS * ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: IH.
 ( n -- a n )   0 1 (DH.) TYPE SPACE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DUMP-ICONS ( a2 a1 -- )   DUP S" icons{ " CR+GENERIC  2DUP - |ICON| /
\begin_inset Newline newline
\end_inset

    0 DO  I  ICON-ROWS 0 DO  CR  4 0 DO  DUP I +
\begin_inset Newline newline
\end_inset

                J 0= IF  16 / IH.
  ELSE
\begin_inset Newline newline
\end_inset

                    J 1 = IF  16 MOD IH.
  ELSE
\begin_inset Newline newline
\end_inset

                        DROP 2 SPACES  THEN  THEN
\begin_inset Newline newline
\end_inset

                OVER |ICON| I * + J 2* + W@-BE .ICON-ROW  SPACE
\begin_inset Newline newline
\end_inset

        LOOP  LOOP  CR  DROP  4 |ICON| * +  4 +LOOP
\begin_inset Newline newline
\end_inset

    2DUP - IF  (DUMP-B)  ELSE  2DROP
\begin_inset Newline newline
\end_inset

    THEN  S" }icons" TYPE CR ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DIS-ICONS ( a1 a2 -- )   TARGET>HOST SWAP TARGET>HOST
\begin_inset Newline newline
\end_inset

    DUP NEXT-CUT ! DUMP-ICONS ;
\begin_inset Newline newline
\end_inset

: -icons ( a n -- )   2>R ['] DIS-ICONS 2R> RANGE ;
\begin_inset Newline newline
\end_inset

' -icons RANGE: -icons: ( -name- )
\begin_inset Newline newline
\end_inset

: -icons- ( a n -- )   -warning >R  NONAME$ -icons  R> +warning ;
\begin_inset Newline newline
\end_inset

' DIS-ICONS  ' -icons:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Unpack words
\end_layout

\begin_layout Standard
Unpack cf word to ascii text
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
prefix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
range
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.xxx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0-7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.xxx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8-15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11xx.xxx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16-47
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Scrap

<<unpack-words>>=
\begin_inset Newline newline
\end_inset

: UNPACK ( n -- n' chr )   DUP  DUP 0<
\begin_inset Newline newline
\end_inset

    IF       1 LSHIFT DUP 0<
\begin_inset Newline newline
\end_inset

        IF   6 LSHIFT SWAP 25 RSHIFT 63 AND  16 -    
\backslash
 11xxxxx..
 16-47
\begin_inset Newline newline
\end_inset

        ELSE 4 LSHIFT SWAP 27 RSHIFT  7 AND  8 XOR   
\backslash
 10xxx..
    8-15
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    ELSE     4 LSHIFT SWAP 28 RSHIFT  7 AND          
\backslash
 0xxx..
     0-7
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: PRESHIFT ( n -- n' )   32 0 DO  [ HEX ]
\begin_inset Newline newline
\end_inset

        DUP F0000000 AND IF
\begin_inset Newline newline
\end_inset

            UNLOOP EXIT
\begin_inset Newline newline
\end_inset

        THEN  2*
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: s, ( a n -- )   DUP C,  0 ?DO  COUNT C,  LOOP  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

S"  rtoeanismcylgfwdvpbhxuq0123456789j-k.z/;'!+@*,?"
\begin_inset Newline newline
\end_inset

CREATE cf-ii ( -- adr)   s,  0 cf-ii 1+ C!
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CH ( n -- n' chr )   0FFFFFFF0 AND UNPACK DUP cf-ii COUNT
\begin_inset Newline newline
\end_inset

    ROT < ABORT" invalid character" + C@ ;
\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

VARIABLE PHERE
\begin_inset Newline newline
\end_inset

: PAD| ( -- )   0 PAD C! ;
\begin_inset Newline newline
\end_inset

: PAD+ ( a n -- )   PAD APPEND ;
\begin_inset Newline newline
\end_inset

: PAD+BL ( -- )   S"  " PAD+ ;
\begin_inset Newline newline
\end_inset

: PADTYPE ( -- )   PAD COUNT TYPE  PAD| ;
\begin_inset Newline newline
\end_inset

: PAD, ( chr -- )   PHERE @ C!  1 PHERE +! ;
\begin_inset Newline newline
\end_inset

: PADDECODE ( n -- )   BEGIN  CH DUP WHILE PAD,  REPEAT  2DROP ;
\begin_inset Newline newline
\end_inset

: PADCOUNT ( n -- adr len )   PAD COUNT + DUP >R PHERE !
\begin_inset Newline newline
\end_inset

    PADDECODE  R> PHERE @ OVER -  DUP PAD C@ + PAD C! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: @NAME ( a -- a' n )   @-LE PRESHIFT PAD| PADCOUNT
\begin_inset Newline newline
\end_inset

    ?DUP 0= IF  DROP S" _"  THEN  PAD| ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Word adjustments
\end_layout

\begin_layout Scrap

<<word-adjustments>>=
\begin_inset Newline newline
\end_inset

Files  FILE Words.dbf  FILE= Words.dbf
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

( Bytes  records   origin             name )
\begin_inset Newline newline
\end_inset

      8      256        0 BLOCK-DATA (WORD-NAMES)
\begin_inset Newline newline
\end_inset

     18      256  +ORIGIN BLOCK-DATA  WORD-NAMES
\begin_inset Newline newline
\end_inset

     10      256  +ORIGIN BLOCK-DATA  ADJUSTMENTS
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: /Words ( -- )   Words.dbf  FILE-HANDLE @ 0= IF
\begin_inset Newline newline
\end_inset

        S" Words.dbf" >FILE  THEN
\begin_inset Newline newline
\end_inset

    (WORD-NAMES) INITIALIZE  WORD-NAMES INITIALIZE ;
\begin_inset Newline newline
\end_inset

: /Adjust ( -- )   ADJUSTMENTS INITIALIZE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

4 ( LINK)
\begin_inset Newline newline
\end_inset

    LONG WORD-ADDR ( Address, used as the key)
\begin_inset Newline newline
\end_inset

 NUMERIC ADJUST    ( Difference from old)
\begin_inset Newline newline
\end_inset

 8 BYTES NAME-STR  ( Name, word name)
\begin_inset Newline newline
\end_inset

CONSTANT |Words|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .WORD-ADDR ( -- )   BASE @ HEX  WORD-ADDR L@ 8 H.R SPACE  BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .Word ( n -- )   WORD-NAMES READ  .WORD-ADDR  ADJUST N?
\begin_inset Newline newline
\end_inset

    NAME-STR OVER >R B@  FILE-PAD R> xTYPE  SPACE ;
\begin_inset Newline newline
\end_inset

: .Words ( -- )   CR  (WORD-NAMES) RECORDS ?DO
\begin_inset Newline newline
\end_inset

        I (WORD-NAMES) READ  LINK L@ .Word
\begin_inset Newline newline
\end_inset

        I 4 MOD 0= IF  CR  THEN
\begin_inset Newline newline
\end_inset

    LOOP  CR ;
\begin_inset Newline newline
\end_inset

: .Adjusts ( -- )   ADJUSTMENTS RECORDS ?DO
\begin_inset Newline newline
\end_inset

        CR  I READ  .WORD-ADDR  ADJUST N?
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: FIND-ADDRESS ( a1 -- flag )   FILE-PAD #TB BLANK
\begin_inset Newline newline
\end_inset

    WORD-ADDR 4 nC!  4 WORD-ADDR -BINARY ;
\begin_inset Newline newline
\end_inset

: add-word ( a1 a2 n -- )   ROT (WORD-NAMES) FIND-ADDRESS IF
\begin_inset Newline newline
\end_inset

        SAVE  WORD-NAMES SLOT DUP READ  WORD-ADDR 4 nC@ WORD-ADDR L!
\begin_inset Newline newline
\end_inset

        RESTORE  DUP LINK 4 nC!  +ORDERED  WORD-NAMES READ
\begin_inset Newline newline
\end_inset

        FILE-PAD DUP #TB BLANK  SWAP MOVE  NAME-STR B!  0 ADJUST N!
\begin_inset Newline newline
\end_inset

    ELSE  ORDERED RELEASE  2DROP 
\backslash
 TYPE 1 ABORT" at duplicate address "
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

: add-adjust ( a n -- )   SWAP ADJUSTMENTS FIND-ADDRESS IF
\begin_inset Newline newline
\end_inset

        ADJUST 2 nC!  +ORDERED  ELSE  ORDERED RELEASE
\begin_inset Newline newline
\end_inset

        1 ABORT" Duplicate adjustment "
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: adjust-address ( a -- n )   ADJUSTMENTS FIND-ADDRESS IF
\begin_inset Newline newline
\end_inset

    -1 R# +!  THEN  ORDERED RELEASE  ADJUST N@ ;
\begin_inset Newline newline
\end_inset

Assem
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: MAKE-NAME-LABELS ( code names -- )
\begin_inset Newline newline
\end_inset

    2DUP - 0 DO  OVER TARGET>HOST I + @ ?DUP IF
\begin_inset Newline newline
\end_inset

            OVER TARGET>HOST I + @NAME
\begin_inset Newline newline
\end_inset

            Files add-word Assem
\begin_inset Newline newline
\end_inset

    THEN  0 CELL+ +LOOP  2DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ADJUST-DELTA ( delta anew aold -- new-delta )
\begin_inset Newline newline
\end_inset

    ROT >R 2DUP - DUP R@ - ?DUP IF
\begin_inset Newline newline
\end_inset

        
\backslash
 CR  PAD COUNT TYPE  ."  moved " DUP .
 ." bytes "
\begin_inset Newline newline
\end_inset

        R> 2DROP ROT DROP SWAP OVER
\begin_inset Newline newline
\end_inset

        Files add-adjust Assem
\begin_inset Newline newline
\end_inset

    ELSE  DROP 2DROP R>  THEN ;
\begin_inset Newline newline
\end_inset

: FIND-ADJUSTMENTS ( -- n )   TARGET-START  Files
\begin_inset Newline newline
\end_inset

    /Adjust 0 add-adjust  0 (WORD-NAMES) RECORDS ?DO
\begin_inset Newline newline
\end_inset

        I (WORD-NAMES) READ  LINK L@ WORD-NAMES READ
\begin_inset Newline newline
\end_inset

        WORD-ADDR L@  NAME-STR OVER >R B@  FILE-PAD R> -TRAILING  Assem
\begin_inset Newline newline
\end_inset

        S" X_" PAD PLACE  PAD APPEND  PAD FIND IF
\begin_inset Newline newline
\end_inset

            EXECUTE ADJUST-DELTA
\begin_inset Newline newline
\end_inset

        ELSE  2DROP  Files -1 ADJUST N! Assem  THEN
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ADJUST-RANGES   LAB-UPB 1+ 1 ?DO  I MAKE-CURRENT
\begin_inset Newline newline
\end_inset

        'RANGE-START @ Files adjust-address Assem 'RANGE-START +!
\begin_inset Newline newline
\end_inset

        'RANGE-END @ Files adjust-address Assem 'RANGE-END +!
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset

: ADJUST-DIRECTIVES   LAB-UPB 1+ 1 ?DO  I LABELS[]
\begin_inset Newline newline
\end_inset

        DUP @ Files adjust-address Assem SWAP +!
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset

: ADJUST-COMMENTS   LAB-UPB 1+ 1 ?DO  I LABELS[]
\begin_inset Newline newline
\end_inset

        DUP @ Files adjust-address Assem SWAP +!
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset

: ADJUST-EQUS   LAB-UPB 1+ 1 ?DO
\begin_inset Newline newline
\end_inset

        I LABELS[] DUP @ DUP Files adjust-address Assem ?DUP IF
\begin_inset Newline newline
\end_inset

            ROT 2DUP +!  >R SWAP R> CELL+ @ >NFA @
\begin_inset Newline newline
\end_inset

            2DUP $@ INVENTED-NAME? IF
\begin_inset Newline newline
\end_inset

                >R + INVENT-NAME R> PLACE
\begin_inset Newline newline
\end_inset

            ELSE  2DROP DROP  THEN
\begin_inset Newline newline
\end_inset

        ELSE  2DROP  THEN
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ADD-LABELS ( -- )   Files  WORD-NAMES RECORDS ?DO
\begin_inset Newline newline
\end_inset

        I READ  ADJUST N@ -1 = IF
\begin_inset Newline newline
\end_inset

            WORD-ADDR L@  NAME-STR OVER >R B@  FILE-PAD R> -TRAILING
\begin_inset Newline newline
\end_inset

            Assem  S" LABEL X_" PAD PLACE  PAD APPEND
\begin_inset Newline newline
\end_inset

            PAD COUNT EVALUATE
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Transitions
\end_layout

\begin_layout Scrap

<<transitions>>=
\begin_inset Newline newline
\end_inset

65 CONSTANT TRIM#
\begin_inset Newline newline
\end_inset

VARIABLE #OUT  0 #OUT !
\begin_inset Newline newline
\end_inset

VARIABLE #CRS  1 #CRS !
\begin_inset Newline newline
\end_inset

VARIABLE capext   0 capext !
\begin_inset Newline newline
\end_inset

VARIABLE curcolor   0 curcolor ! 
\backslash
 color of current token
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CRS ( -- )   PADTYPE  #CRS @ ?DUP IF
\begin_inset Newline newline
\end_inset

        ABS 0 DO  CR  LOOP
\begin_inset Newline newline
\end_inset

        #CRS @ 0< IF
\begin_inset Newline newline
\end_inset

            S"      " PAD+
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    ELSE  PAD+BL  THEN ;
\begin_inset Newline newline
\end_inset

: |CR ( -- )   #CRS @ IF  #OUT @ IF  CR  THEN  THEN  1 #CRS ! ;
\begin_inset Newline newline
\end_inset

: PAD?TYPE ( -- )   PAD C@ #OUT @ + TRIM# > IF  PADTYPE |CR  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TRANSITION ( new -- x )   
\backslash
 check against multiple transitions
\begin_inset Newline newline
\end_inset

    ( new    <-- )  curcolor @
\begin_inset Newline newline
\end_inset

    OVER 14 <>  OVER 14 =  AND IF  S"  }" PAD+ CRS THEN   
\backslash
  b -> ~b
\begin_inset Newline newline
\end_inset

    OVER 13 <>  OVER 13 =  AND IF  S"  ^" PAD+     THEN   
\backslash
  g -> ~g
\begin_inset Newline newline
\end_inset

    OVER  9 <>  OVER  9 =  AND IF  S"  )" PAD+     THEN   
\backslash
  w -> ~w
\begin_inset Newline newline
\end_inset

    OVER  1 <>  OVER  1 =  AND IF  S"  ]" PAD+     THEN   
\backslash
  y -> ~y
\begin_inset Newline newline
\end_inset

    OVER  7 <>  OVER  7 =  AND IF  S"  >" PAD+     THEN   
\backslash
  c -> ~c
\begin_inset Newline newline
\end_inset

    PAD?TYPE
\begin_inset Newline newline
\end_inset

    OVER  7 =   OVER  7 <> AND IF  S"  <" PAD+     THEN   
\backslash
 ~c ->  c
\begin_inset Newline newline
\end_inset

    OVER  1 =   OVER  1 <> AND IF  S"  [" PAD+     THEN   
\backslash
 ~y ->  y
\begin_inset Newline newline
\end_inset

    OVER  9 =   OVER  9 <> AND IF  S"  (" PAD+     THEN   
\backslash
 ~w ->  w
\begin_inset Newline newline
\end_inset

    OVER 13 =   OVER 13 <> AND IF  S"  ^" PAD+     THEN   
\backslash
 ~g ->  g
\begin_inset Newline newline
\end_inset

    OVER 14 =   OVER 14 <> AND IF  S"  {" PAD+     THEN   
\backslash
 ~b ->  b
\begin_inset Newline newline
\end_inset

    SWAP curcolor ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: NEWC ( new -- )  ( DUP curcolor @ XOR IF ) TRANSITION ( THEN ) DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Token output
\end_layout

\begin_layout Scrap

<<token-output>>=
\begin_inset Newline newline
\end_inset

: gnn ( a -- a' n )   DUP >R  CELL+  R> @-LE ;
\begin_inset Newline newline
\end_inset

: n32 ( a x -- a' n )   DROP gnn ;
\begin_inset Newline newline
\end_inset

: n27 ( n -- n' )   2/ 2/ 2/ 2/ 2/ ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset

: .NUMBER ( n -- )   DUP 1F AND
\begin_inset Newline newline
\end_inset

    DUP 02 = IF DROP PAD?TYPE S"  D# " PAD+ n32 (.)  PAD+ EXIT THEN 
\backslash
  y: execute 32-bit dec
\begin_inset Newline newline
\end_inset

    DUP 12 = IF DROP PAD?TYPE S"  H# " PAD+ n32 (H.) PAD+ EXIT THEN 
\backslash
 dy: execute 32-bit hex
\begin_inset Newline newline
\end_inset

    DUP 05 = IF DROP PAD?TYPE S"  D# " PAD+ n32 (.)  PAD+ EXIT THEN 
\backslash
  g: compile 32-bit dec
\begin_inset Newline newline
\end_inset

    DUP 15 = IF DROP PAD?TYPE S"  H# " PAD+ n32 (H.) PAD+ EXIT THEN 
\backslash
 dg: compile 32-bit hex
\begin_inset Newline newline
\end_inset

    DUP 06 = IF DROP PAD?TYPE S"  d# " PAD+ n27 (.)  PAD+ EXIT THEN 
\backslash
  g: compile 27-bit dec
\begin_inset Newline newline
\end_inset

    DUP 16 = IF DROP PAD?TYPE S"  h# " PAD+ n27 (H.) PAD+ EXIT THEN 
\backslash
 dg: compile 27-bit hex
\begin_inset Newline newline
\end_inset

    DUP 08 = IF DROP PAD?TYPE S"  d# " PAD+ n27 (.)  PAD+ EXIT THEN 
\backslash
  y: execute 27-bit dec
\begin_inset Newline newline
\end_inset

    DUP 18 = IF DROP PAD?TYPE S"  h# " PAD+ n27 (H.) PAD+ EXIT THEN 
\backslash
 dy: execute 27-bit hex
\begin_inset Newline newline
\end_inset

    DROP ;
\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: 1CAP ( addr -- )   DUP C@ [CHAR] a [CHAR] z 1+ WITHIN
\begin_inset Newline newline
\end_inset

    IF  DUP C@ 32 - SWAP C!  ELSE  DROP  THEN ;
\begin_inset Newline newline
\end_inset

: CAPS ( addr len -- )   0 ?DO  DUP 1CAP 1+  LOOP  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

FALSE CONSTANT SHOW-UNKNOWN
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .WORD ( n -- )   0 capext !  PAD+BL  PADCOUNT 2DROP ;
\begin_inset Newline newline
\end_inset

: .BLUE ( n -- )   0 capext !  PAD+BL  PADCOUNT
\begin_inset Newline newline
\end_inset

    2DUP S" cr" COMPARE 0= IF  1  ELSE
\begin_inset Newline newline
\end_inset

    2DUP S" br" COMPARE 0= IF  2  ELSE
\begin_inset Newline newline
\end_inset

    2DUP S" -cr" COMPARE 0= IF  1  ELSE
\begin_inset Newline newline
\end_inset

    2DUP S" indent" COMPARE 0= IF  -1  ELSE
\begin_inset Newline newline
\end_inset

    2DUP S" ," COMPARE 0= IF  1  ELSE
\begin_inset Newline newline
\end_inset

    2DUP S" *" COMPARE 0= IF  1  ELSE
\begin_inset Newline newline
\end_inset

    OVER C@ [CHAR] .
 = IF  -1  ELSE
\begin_inset Newline newline
\end_inset

        SHOW-UNKNOWN IF  S"  ^" TYPE 2DUP DUMP  THEN  1
\begin_inset Newline newline
\end_inset

    THEN THEN THEN THEN THEN THEN THEN
\begin_inset Newline newline
\end_inset

    #CRS !  2DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .CAPWORD ( n -- )   0 capext !  PADCOUNT DROP 1CAP ;
\begin_inset Newline newline
\end_inset

: .ALLCAPS ( n -- )   -1 capext !  PADCOUNT CAPS ;
\begin_inset Newline newline
\end_inset

: .EXTENSION ( n -- )   PADCOUNT capext @ IF  CAPS  ELSE  2DROP  THEN ;
\begin_inset Newline newline
\end_inset

: .COLONDEF ( -- )   PADTYPE  |CR S" :" PAD+ .WORD ;
\begin_inset Newline newline
\end_inset

: .VARIABLE ( -- )   S"  :#" PAD+ .WORD gnn  PAD+BL  (.) PAD+ ;
\begin_inset Newline newline
\end_inset

: .COMMENT# ( n -- )   S"  { " PAD+  (H.) PAD+  S"  }" PAD+ ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset

: .GREY ( n -- )   PAD+BL  DUP 1F AND
\begin_inset Newline newline
\end_inset

    DUP 1D = IF  DROP  5 RSHIFT 2 (H.R) PAD+  ELSE
\begin_inset Newline newline
\end_inset

    DUP 0D = IF  2DROP  S" c01/1" PAD+  ELSE
\begin_inset Newline newline
\end_inset

        DROP 1 <?> 2 (H.R) PAD+
\begin_inset Newline newline
\end_inset

    THEN THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .TOKEN ( n -- )   DUP 0F AND
\begin_inset Newline newline
\end_inset

    DUP  0 = IF DROP         .EXTENSION EXIT THEN 
\backslash
 --- extension word
\begin_inset Newline newline
\end_inset

    DUP  1 = IF DROP  1 NEWC .WORD      EXIT THEN 
\backslash
 yel execute word
\begin_inset Newline newline
\end_inset

    DUP  2 = IF DROP  1 NEWC .NUMBER    EXIT THEN 
\backslash
 yel execute 32-bit
\begin_inset Newline newline
\end_inset

    DUP  3 = IF DROP  3 NEWC .COLONDEF  EXIT THEN 
\backslash
 red define word
\begin_inset Newline newline
\end_inset

    DUP  4 = IF DROP  4 NEWC .WORD      EXIT THEN 
\backslash
 gre compile word
\begin_inset Newline newline
\end_inset

    DUP  5 = IF DROP  4 NEWC .NUMBER    EXIT THEN 
\backslash
 gre compile 32-bit
\begin_inset Newline newline
\end_inset

    DUP  6 = IF DROP  4 NEWC .NUMBER    EXIT THEN 
\backslash
 gre compile 27-bit
\begin_inset Newline newline
\end_inset

    DUP  7 = IF DROP  7 NEWC .WORD      EXIT THEN 
\backslash
 cya compile a macro
\begin_inset Newline newline
\end_inset

    DUP  8 = IF DROP  1 NEWC .NUMBER    EXIT THEN 
\backslash
 yel execute 27-bit
\begin_inset Newline newline
\end_inset

    DUP  9 = IF DROP  9 NEWC .WORD      EXIT THEN 
\backslash
 whi comment word
\begin_inset Newline newline
\end_inset

    DUP 0A = IF DROP  9 NEWC .CAPWORD   EXIT THEN 
\backslash
 whi Capitalized Word
\begin_inset Newline newline
\end_inset

    DUP 0B = IF DROP  9 NEWC .ALLCAPS   EXIT THEN 
\backslash
 whi ALL CAPS WORD
\begin_inset Newline newline
\end_inset

    DUP 0C = IF DROP 0C NEWC .VARIABLE  EXIT THEN 
\backslash
 mag variable + number
\begin_inset Newline newline
\end_inset

    DUP 0D = IF DROP 0D NEWC .GREY      EXIT THEN 
\backslash
 gre compiler feedback
\begin_inset Newline newline
\end_inset

    DUP 0E = IF DROP 0E NEWC .BLUE      EXIT THEN 
\backslash
 blu display word
\begin_inset Newline newline
\end_inset

    DROP         .COMMENT# ;          
\backslash
 $F commented number
\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Dump blocks
\end_layout

\begin_layout Scrap

<<dump-blocks>>=
\begin_inset Newline newline
\end_inset

: ABLOCK ( a -- )   DUP 1020 + SWAP  0 curcolor !
\begin_inset Newline newline
\end_inset

    BEGIN  2DUP >  OVER @ 0= 0=  AND WHILE  gnn .TOKEN
\begin_inset Newline newline
\end_inset

    REPEAT  6 NEWC  2DROP ;   
\backslash
 dummy color to mark end of block
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DUMP-BLOCKS ( a2 a1 -- )   
\backslash
 display blocks ready to be translated back
\begin_inset Newline newline
\end_inset

    CUT-SIZE @ >R  1024 CUT-SIZE !  BASE @ >R  DECIMAL
\begin_inset Newline newline
\end_inset

    DO  I CODE-SPACE - 1024 /  S" D# " PAD $!  DUP S>D <# #S #> PAD $+!
\begin_inset Newline newline
\end_inset

        1 AND IF  S"  shadow{ "  ELSE  S"  code{ "  THEN  PAD $+!
\begin_inset Newline newline
\end_inset

        I PAD $@ CR+$  CR  PAD|  I ABLOCK  PADTYPE  S"  }block" TYPE  CR
\begin_inset Newline newline
\end_inset

    1024 +LOOP  R> BASE !  R> CUT-SIZE !  CR ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

?? ForGForth uses : GET-TYPE   'TYPE @ ;
\begin_inset Newline newline
\end_inset

?? ForGForth uses : SET-TYPE   'TYPE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

?? ForGForth 0= uses : GET-TYPE   'TYPE >DFA @ ;
\begin_inset Newline newline
\end_inset

?? ForGForth 0= uses : SET-TYPE   'TYPE >DFA ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TRIM-EMIT ( c -- )   GET-TYPE  'TYPE RESTORED  SWAP
\begin_inset Newline newline
\end_inset

    DUP BL = IF 
\backslash
 #OUT @ TRIM# > IF
\begin_inset Newline newline
\end_inset

            
\backslash
    CR  SPACE  1 #OUT !
\begin_inset Newline newline
\end_inset

        (    THEN ) BL EMIT  1 #OUT +!  ELSE
\begin_inset Newline newline
\end_inset

        DUP 10 = IF  10 EMIT  0 #OUT !  ELSE
\begin_inset Newline newline
\end_inset

            DUP EMIT  1 #OUT +!
\begin_inset Newline newline
\end_inset

    THEN THEN  DROP  SET-TYPE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TRIM-TYPE ( a n -- )   0 ?DO  COUNT TRIM-EMIT  LOOP  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

?? ForGForth uses : GET-TRIM   ['] TRIM-TYPE ;
\begin_inset Newline newline
\end_inset

?? ForGForth 0= uses : GET-TRIM   'TRIM-TYPE >DFA @ ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DUMP-TRIM-BLOCKS   GET-TRIM SET-TYPE  DUMP-BLOCKS  'TYPE RESTORED ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DIS-BLOCKS ( a1 a2 -- )   TARGET>HOST SWAP TARGET>HOST
\begin_inset Newline newline
\end_inset

    DUP NEXT-CUT !  DUMP-TRIM-BLOCKS ;
\begin_inset Newline newline
\end_inset

: -blocks ( a n -- )   2>R ['] DIS-BLOCKS  2R> RANGE ;
\begin_inset Newline newline
\end_inset

' -blocks RANGE: -blocks: ( -name- )
\begin_inset Newline newline
\end_inset

: -blocks- ( a n -- )   -warning >R  NONAME$ -blocks  R> +warning ;
\begin_inset Newline newline
\end_inset

' DIS-BLOCKS  ' -blocks:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Restore uncompressed version
\end_layout

\begin_layout Standard
Pulled out of OkadWork.cf blocks
\end_layout

\begin_layout Scrap

<<Restore.f>>=
\begin_inset Newline newline
\end_inset


\backslash
 Copyright (c) 2010 Dennis Ruffer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

CREATE cfca 0 , 
\backslash
 address of compressed allocation
\begin_inset Newline newline
\end_inset

CREATE ebx 0 ,
\begin_inset Newline newline
\end_inset

CREATE ecx 0 ,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: 2*d ( n -- n )   DUP 32 ecx @ - RSHIFT  ebx @ ecx @ LSHIFT  + ebx ! ;
\begin_inset Newline newline
\end_inset

: 2*c ( n -- n' )   ecx @ LSHIFT ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

CREATE [na] 26 , 
\backslash
 bits remaining in source word
\begin_inset Newline newline
\end_inset

CREATE [nb] -6 , 
\backslash
 bits remaining in ebx
\begin_inset Newline newline
\end_inset

CREATE [h] 67510272 , 
\backslash
 destination address
\begin_inset Newline newline
\end_inset

CREATE [an] 0 ,
\begin_inset Newline newline
\end_inset

CREATE [aa] 67977026 ,
\begin_inset Newline newline
\end_inset

CREATE [nz] 4 ,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: NEW ( 32-bits in current word )   [aa] @ @ [an] !
\begin_inset Newline newline
\end_inset

    1 CELLS [aa] +!  32 [na] ! ;
\begin_inset Newline newline
\end_inset

: ?NEW ( fetch new word if necessary )   [na] @ 0= IF  NEW  THEN ;
\begin_inset Newline newline
\end_inset

: SHIFT ( n -- n ) ( into ebx, decrement nb )
\begin_inset Newline newline
\end_inset

    DUP NEGATE DUP [nb] +!  [na] +!  ecx !
\begin_inset Newline newline
\end_inset

    [an] @ 2*d 2*c [an] ! ;
\begin_inset Newline newline
\end_inset

: BITS ( n -- ) ( shift bits into ebx.
 overflow into next word )
\begin_inset Newline newline
\end_inset

    ?NEW DUP NEGATE [na] @ +  DUP 0< IF
\begin_inset Newline newline
\end_inset

        DUP >R + SHIFT NEW R> NEGATE SHIFT
\begin_inset Newline newline
\end_inset

    ELSE  DROP SHIFT  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: h, ( n -- ) ( store at destination )   [h] @ !  1 CELLS [h] +! ;
\begin_inset Newline newline
\end_inset

: TBITS ( n n -- ) ( fill ebx with tag )   [nb] @ 8 + ecx !  2*c OR h, ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TZ ( n n -- n ? )   OVER [nz] !  DUP NEGATE >R + ebx @
\begin_inset Newline newline
\end_inset

    R> 0 DO  DUP 1 AND IF
\begin_inset Newline newline
\end_inset

            2DROP  UNLOOP  [nz] @ 0 EXIT
\begin_inset Newline newline
\end_inset

        THEN  2/
\begin_inset Newline newline
\end_inset

    LOOP  ebx ! DUP [nz] @ INVERT + INVERT [nb] +!  1 ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ?FULL ( n -- n ) ( is there room in ebx? )
\begin_inset Newline newline
\end_inset

    [nb] @ DUP AND DUP 0< IF
\begin_inset Newline newline
\end_inset

        TZ IF  EXIT  THEN
\begin_inset Newline newline
\end_inset

        DUP >R  4 - [nb] +!  TBITS
\begin_inset Newline newline
\end_inset

        0 DUP R> DUP INVERT 29 + [nb] !
\begin_inset Newline newline
\end_inset

    ELSE  DROP  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CHR ( -- n 1 | 0 ) 
\backslash
 examine high bits; shift 4, 5 or 7 bits
\begin_inset Newline newline
\end_inset

    0 ebx ! ( ?NEW )  4 BITS ebx @ 8 AND IF
\begin_inset Newline newline
\end_inset

        ebx @ 4 AND IF
\begin_inset Newline newline
\end_inset

            3 BITS 7 1 EXIT
\begin_inset Newline newline
\end_inset

        THEN  1 BITS 5 1 EXIT
\begin_inset Newline newline
\end_inset

    THEN  4 ebx @ 15 AND IF  1 EXIT
\begin_inset Newline newline
\end_inset

    THEN  DROP 0 ;
\begin_inset Newline newline
\end_inset

: CHRS ( n -- n ) 
\backslash
 shift characters until 0
\begin_inset Newline newline
\end_inset

    CHR IF  ?FULL ecx !  2*c ebx @ OR RECURSE  THEN ;
\begin_inset Newline newline
\end_inset

: WRD ( n -- ) 
\backslash
 shift characters, then tag
\begin_inset Newline newline
\end_inset

    28 [nb] !  DUP CHRS TBITS ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: t, ( -- )   -4 [nb] !  ebx @ TBITS ;
\begin_inset Newline newline
\end_inset

: SHORT ( n -- ) ( 28-bit value+tag )   28 BITS t, ;
\begin_inset Newline newline
\end_inset

: 32BITS ( -- ) ( for values )   16 BITS  16 BITS  ebx @ h, ;
\begin_inset Newline newline
\end_inset

: LITRAL ( n -- ) 
\backslash
  1-bit base base, tag.
 value in next word
\begin_inset Newline newline
\end_inset

    0 ebx !  1 BITS t,  32BITS ;
\begin_inset Newline newline
\end_inset

: VAR ( n -- ) ( word, value )   WRD 32BITS ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TAG ( -- n 1 | 0 ) 
\backslash
 vector
\begin_inset Newline newline
\end_inset

    ebx @ 15 AND DUP
\begin_inset Newline newline
\end_inset

    DUP  0 = IF  2DROP          0 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  1 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  2 = IF   DROP  LITRAL  1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  3 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  4 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  5 = IF   DROP  LITRAL  1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  6 = IF   DROP  SHORT   1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  7 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  8 = IF   DROP  SHORT   1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP  9 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP 10 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP 11 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP 12 = IF   DROP  VAR     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP 13 = IF   DROP  SHORT   1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP 14 = IF   DROP  WRD     1 EXIT  THEN
\begin_inset Newline newline
\end_inset

    DUP 15 = IF   DROP  SHORT   1 EXIT  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: WRDS ( ?new -- ) 
\backslash
 examine tags
\begin_inset Newline newline
\end_inset

    4 BITS TAG IF  RECURSE  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: BLOCKS ( blks -- bytes)   1024 * ;
\begin_inset Newline newline
\end_inset

: CFBLOCK ( blk -- addr)   BLOCKS CODE-SPACE + ;
\begin_inset Newline newline
\end_inset

: ERASEBLKS ( b n -- )   >R CFBLOCK R> BLOCKS ERASE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: BLOCK-RANGE ( a n n -- ) 
\backslash
 process each block
\begin_inset Newline newline
\end_inset

    OVER CFBLOCK [h] !  DUP >R ERASEBLKS  [aa] !  0 [na] !
\begin_inset Newline newline
\end_inset

    R> 0 DO  WRDS
\begin_inset Newline newline
\end_inset

        [h] @ CODE-SPACE - 1024 + -1024 AND
\begin_inset Newline newline
\end_inset

        CODE-SPACE + [h] !
\begin_inset Newline newline
\end_inset

    LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ns ( -- n )   18 CFBLOCK 1 CELLS + ;    
\backslash
 compressed if negative
\begin_inset Newline newline
\end_inset

: cfc ( -- n )   CP @ CODE-SPACE - ;      
\backslash
 size of compressed file
\begin_inset Newline newline
\end_inset

: nblk ( -- n )   18 CFBLOCK 3 CELLS + ;  
\backslash
 size of uncompressed file
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: RESTORE ( -- ) 
\backslash
 restore compressed blocks
\begin_inset Newline newline
\end_inset

    ns @ 0< IF  nblk @ BLOCKS CODE-LENGTH @ > ABORT" Too big!"
\begin_inset Newline newline
\end_inset

        36 CFBLOCK  HERE DUP cfca !  cfc 36 BLOCKS - DUP ALLOT
\begin_inset Newline newline
\end_inset

        MOVE  cfca @ 36 nblk @ OVER - BLOCK-RANGE
\begin_inset Newline newline
\end_inset

        nblk @ BLOCKS CODE-SPACE + CP !
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
ColorForth assembler
\end_layout

\begin_layout Standard
Assembler support for OkadWork.cf the arrayForth for GA144-1.10
\end_layout

\begin_layout Scrap

<<cfas.f>>=
\begin_inset Newline newline
\end_inset


\backslash
 Copyright (c) 2010 Dennis Ruffer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<stacks>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

?? ForGForth uses ALSO ASSEMBLER
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<icon-assem>>
\begin_inset Newline newline
\end_inset

<<af2cf-support>>
\begin_inset Newline newline
\end_inset

<<get-words+numbers>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SETCOLOR ( n _ -- )   CREATE , DOES> @ curcolor ! ;   
\backslash
 define format words
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<cfcharacters>>
\begin_inset Newline newline
\end_inset

<<cfwords>>
\begin_inset Newline newline
\end_inset

<<a2cf>>
\begin_inset Newline newline
\end_inset

<<cfblocks>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: D# ( -n- n )   BASE @ DECIMAL  0 0 BL WORD COUNT
\begin_inset Newline newline
\end_inset

    >NUMBER ABORT" Invalid number" 2DROP  SWAP BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

PREVIOUS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Stack support
\end_layout

\begin_layout Standard
Stack administration * originally from gforth's grey.fs * with GNU v2 license.
 This implementation does not check overflow.
\end_layout

\begin_layout Standard
Creates a stack called word with n cells.
 The first cell is the stackpointer.
\end_layout

\begin_layout Scrap

<<stacks>>=
\begin_inset Newline newline
\end_inset

FALSE CONSTANT STACK-DEBUG
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK ( n -- )   
\backslash
 use: n stack word
\begin_inset Newline newline
\end_inset

    CREATE HERE CELL+ , HERE 0 ,
\begin_inset Newline newline
\end_inset

    SWAP CELLS ALLOT
\begin_inset Newline newline
\end_inset

    HERE SWAP ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-CLEAR? ( stack -- f )   DUP @ [ 1 CELLS ] LITERAL - = ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-DUMP ( stack -- )   DUP STACK-CLEAR? 0= IF
\begin_inset Newline newline
\end_inset

        ." > " DUP @ SWAP CELL+
\begin_inset Newline newline
\end_inset

        BEGIN  2DUP - WHILE  CELL+ DUP ?
\begin_inset Newline newline
\end_inset

        REPEAT  2DROP ." < "
\begin_inset Newline newline
\end_inset

    ELSE  DROP  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-PUSH ( n stack -- )   CELL OVER +!
\begin_inset Newline newline
\end_inset

    DUP 2@ < ABORT" stack full"
\begin_inset Newline newline
\end_inset

    DUP -ROT @ !  STACK-DEBUG IF
\begin_inset Newline newline
\end_inset

        CR ." PUSH " DUP STACK-DUMP
\begin_inset Newline newline
\end_inset

    THEN  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-TOP ( stack -- n )   
\backslash
 returns top of stack
\begin_inset Newline newline
\end_inset

    DUP STACK-CLEAR? ABORT" no items on stack"
\begin_inset Newline newline
\end_inset

    DUP @ @  SWAP STACK-DEBUG IF
\begin_inset Newline newline
\end_inset

        CR ." TOP  " DUP STACK-DUMP
\begin_inset Newline newline
\end_inset

    THEN  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-TOP? ( stack -- n|0 )   
\backslash
 returns top or 0
\begin_inset Newline newline
\end_inset

    DUP STACK-CLEAR? IF  DROP 0
\begin_inset Newline newline
\end_inset

    ELSE  STACK-TOP  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-POP ( stack -- )   
\backslash
 discards top stack item
\begin_inset Newline newline
\end_inset

    DUP STACK-CLEAR? ABORT" no items on stack"
\begin_inset Newline newline
\end_inset

    -1 CELLS OVER +!  STACK-DEBUG IF
\begin_inset Newline newline
\end_inset

        CR ." POP  " DUP STACK-DUMP
\begin_inset Newline newline
\end_inset

    THEN  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-PULL ( stack -- n )   DUP STACK-TOP SWAP STACK-POP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-PULL? ( stack -- n|0 )   
\backslash
 pull top if available
\begin_inset Newline newline
\end_inset

    DUP STACK-CLEAR? IF  DROP 0
\begin_inset Newline newline
\end_inset

    ELSE  STACK-PULL  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: STACK-CLEAR ( stack -- )   DUP CELL+ SWAP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Icon assembler support
\end_layout

\begin_layout Scrap

<<icon-assem>>=
\begin_inset Newline newline
\end_inset

VARIABLE #ICONS      
\backslash
 Number of icons in the array
\begin_inset Newline newline
\end_inset

VARIABLE #ICON-COL   
\backslash
 Index into array of icons at HERE
\begin_inset Newline newline
\end_inset

VARIABLE #ICON-ROW   
\backslash
 Scan row within the icons we are assembling
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

ICON-COLUMNS 8 / CONSTANT |ICON-ROW|
\begin_inset Newline newline
\end_inset

ICON-ROWS 1+ |ICON-ROW| * CONSTANT |ICON-BUFFER|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: >ICON ( i -- a )   |ICON-BUFFER| * HERE 32 + + ;
\begin_inset Newline newline
\end_inset

: >ICON-ROW ( i r -- a )   1+ |ICON-ROW| * SWAP >ICON + ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SAVE-ROW ( str len -- )   2 BASE !
\begin_inset Newline newline
\end_inset

    0 0 2SWAP >NUMBER 2DROP DROP
\begin_inset Newline newline
\end_inset

    #ICON-COL @  #ICON-ROW @
\begin_inset Newline newline
\end_inset

    >ICON-ROW W!-BE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SAVE-ICON ( str len -- )   HEX
\begin_inset Newline newline
\end_inset

    0 0 2SWAP >NUMBER 2DROP DROP
\begin_inset Newline newline
\end_inset

    #ICON-COL @ >ICON >R  #ICON-ROW @ IF
\begin_inset Newline newline
\end_inset

        R@ W@-BE  4 LSHIFT +  R> W!-BE  ELSE
\begin_inset Newline newline
\end_inset

        R@ |ICON-BUFFER| ERASE  R> W!-BE  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SAVE-ICONS ( -- )   HEX  #ICONS @ 0 ?DO
\begin_inset Newline newline
\end_inset

        I >ICON DUP W@-BE >R  |ICON-ROW| +
\begin_inset Newline newline
\end_inset

        |ICON-BUFFER| |ICON-ROW| - DUP R> *
\begin_inset Newline newline
\end_inset

        AS-HERE + SWAP MOVE
\begin_inset Newline newline
\end_inset

    LOOP  0 #ICONS ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: NEXT-ICON-ROW ( -- )
\begin_inset Newline newline
\end_inset

    REFILL 0= ABORT" End of input before icons finished"
\begin_inset Newline newline
\end_inset

    #ICON-COL @ IF  #ICON-COL @ #ICONS !  0 #ICON-COL !  1 #ICON-ROW +!
\begin_inset Newline newline
\end_inset

    ELSE  SAVE-ICONS  0 #ICON-COL !  0 #ICON-ROW !
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: icons{ ( -- )   BASE @ >R
\begin_inset Newline newline
\end_inset

    0 #ICONS !  0 #ICON-COL !  0 #ICON-ROW !
\begin_inset Newline newline
\end_inset

    BEGIN
\begin_inset Newline newline
\end_inset

        BEGIN
\begin_inset Newline newline
\end_inset

            BEGIN  #ICON-ROW @ 2 <
\begin_inset Newline newline
\end_inset

            WHILE  BL WORD COUNT  DUP 0=
\begin_inset Newline newline
\end_inset

                WHILE  2DROP  NEXT-ICON-ROW
\begin_inset Newline newline
\end_inset

                REPEAT
\begin_inset Newline newline
\end_inset

                2DUP S" }icons" COMPARE
\begin_inset Newline newline
\end_inset

                IF  SAVE-ICON
\begin_inset Newline newline
\end_inset

                ELSE  2DROP  SAVE-ICONS  R> BASE !  EXIT
\begin_inset Newline newline
\end_inset

                THEN
\begin_inset Newline newline
\end_inset

            THEN
\begin_inset Newline newline
\end_inset

            BL WORD COUNT  DUP 0=
\begin_inset Newline newline
\end_inset

        WHILE  2DROP  NEXT-ICON-ROW
\begin_inset Newline newline
\end_inset

        REPEAT
\begin_inset Newline newline
\end_inset

        2DUP S" }icons" COMPARE
\begin_inset Newline newline
\end_inset

        IF  SAVE-ROW  1 #ICON-COL +!
\begin_inset Newline newline
\end_inset

        ELSE  2DROP  SAVE-ICONS  R> BASE !  EXIT
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    AGAIN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
ASCII to colorForth support
\end_layout

\begin_layout Scrap

<<af2cf-support>>=
\begin_inset Newline newline
\end_inset

VARIABLE CFEND                    
\backslash
 address of last colorForth token in block
\begin_inset Newline newline
\end_inset

VARIABLE NBITS                    
\backslash
 number of bits left in token
\begin_inset Newline newline
\end_inset

VARIABLE WORDLEN  0 WORDLEN !    
\backslash
 size of current ASCII word name
\begin_inset Newline newline
\end_inset

VARIABLE 1STCAP  TRUE 1STCAP !    
\backslash
 1st letter that can be capitalized
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

20 STACK SAVECOLOR    
\backslash
 remember colors around extensions and comments
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: /BITS ( -- )        
\backslash
 reset token specific flags
\begin_inset Newline newline
\end_inset

    28 NBITS !  TRUE 1STCAP !
\begin_inset Newline newline
\end_inset

    curcolor CASE
\begin_inset Newline newline
\end_inset

         0 OF  SAVECOLOR STACK-TOP? ?DUP
\begin_inset Newline newline
\end_inset

            IF  curcolor !  THEN  ENDOF
\begin_inset Newline newline
\end_inset

         3 OF  4 curcolor !  ENDOF
\begin_inset Newline newline
\end_inset

        10 OF  9 curcolor !  ENDOF
\begin_inset Newline newline
\end_inset

        11 OF  9 curcolor !  ENDOF
\begin_inset Newline newline
\end_inset

        12 OF  1 curcolor !  ENDOF
\begin_inset Newline newline
\end_inset

    ENDCASE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .CFPTR ( -- )   BASE @ >R  DECIMAL  CR            
\backslash
 display block location
\begin_inset Newline newline
\end_inset

    CP @ CODE-SPACE -  1024 /MOD 3 .R  4 / 4 .R  SPACE
\begin_inset Newline newline
\end_inset

    R> BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: .AFPTR ( -- )   SOURCE DUP >R TYPE                
\backslash
 display text location
\begin_inset Newline newline
\end_inset

    CR 27 SPACES  >IN @ DUP R@ - IF  DUP WORDLEN @ + R@ - 1-
\begin_inset Newline newline
\end_inset

        IF  1-  THEN  THEN  R> DROP  WORDLEN @ - SPACES
\begin_inset Newline newline
\end_inset

    WORDLEN @ 0 DO  S" ^" TYPE  LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Input words and numbers
\end_layout

\begin_layout Scrap

<<get-words+numbers>>=
\begin_inset Newline newline
\end_inset

FALSE CONSTANT TESTING
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ADDN ( n -- )   TESTING IF  DUP CP @ @-LE -    
\backslash
 add a fully formed token
\begin_inset Newline newline
\end_inset

        IF  .CFPTR  DUP 8 H.R S" <>" TYPE CP @ @-LE 8 H.R SPACE .AFPTR
\begin_inset Newline newline
\end_inset

    THEN  THEN  CP @ !-LE  4 CP +!  /BITS ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ADDC ( n -- )   NBITS @ 4 + LSHIFT  curcolor @ ( DUP >R ) +    
\backslash
 add text token
\begin_inset Newline newline
\end_inset

    ADDN ( ??? R> 0= IF  SAVECOLOR STACK-POP  THEN ) ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

FALSE CONSTANT GETWORD-DEBUG
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: GETWORD ( -- str len )    
\backslash
 get next ASCII word or abort if none left
\begin_inset Newline newline
\end_inset

    BEGIN  BL WORD COUNT  GETWORD-DEBUG IF
\begin_inset Newline newline
\end_inset

            2DUP TYPE SPACE  STACK-DEBUG IF
\begin_inset Newline newline
\end_inset

                SAVECOLOR STACK-DUMP
\begin_inset Newline newline
\end_inset

            THEN
\begin_inset Newline newline
\end_inset

        THEN  DUP WORDLEN !  DUP 0=
\begin_inset Newline newline
\end_inset

    WHILE  2DROP REFILL 0= ABORT" end of input before block finished"
\begin_inset Newline newline
\end_inset

    REPEAT ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: GETN ( hex -- n )   BASE @ SWAP IF  HEX  ELSE  DECIMAL  THEN
\begin_inset Newline newline
\end_inset

    0 0 GETWORD OVER C@ [CHAR] - = DUP >R   
\backslash
 get an ASCII number
\begin_inset Newline newline
\end_inset

    IF  1 /STRING  THEN  >NUMBER ROT OR
\begin_inset Newline newline
\end_inset

        IF  .CFPTR  S" Invalid number     " TYPE  .AFPTR
\begin_inset Newline newline
\end_inset

        THEN  DROP R>
\begin_inset Newline newline
\end_inset

    IF  NEGATE  THEN  SWAP BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: LARGEN ( -- color )   curcolor @ 1 = IF  2 EXIT  THEN  5 ;
\begin_inset Newline newline
\end_inset

: SMALLN ( -- color )   curcolor @ 1 = IF  8 EXIT  THEN  6 ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: L/S ( hex -- n )   
\backslash
 format a numeric token, adding prefix token if large
\begin_inset Newline newline
\end_inset

    DUP >R GETN DUP 80000000 = OVER ABS 2* F8000000 AND OR
\begin_inset Newline newline
\end_inset

    IF  LARGEN R> + ADDN EXIT  THEN
\begin_inset Newline newline
\end_inset

    5 LSHIFT SMALLN R> + + ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
ColorForth character encoding
\end_layout

\begin_layout Scrap

<<cfcharacters>>=
\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

CREATE II-CF   HERE 60 DUP ALLOT  ERASE   
\backslash
 ASCII to cf translation table
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: /II-CF ( -- )   cf-ii COUNT 1
\begin_inset Newline newline
\end_inset

    DO  I 2DUP + C@  DUP [CHAR] a [CHAR] z 1+ WITHIN
\begin_inset Newline newline
\end_inset

        IF  SWAP 40 +  SWAP 20 -  2DUP II-CF + C!        
\backslash
 lower case alpha
\begin_inset Newline newline
\end_inset

            SWAP 40 +  SWAP 20 -       II-CF + C!        
\backslash
 upper case alpha
\begin_inset Newline newline
\end_inset

        ELSE                20 -       II-CF + C!        
\backslash
 non-alpha chars
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    LOOP  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/II-CF   
\backslash
 fill programatically to reduce maintenance
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CHC ( ascii -- cf )   
\backslash
 convert ASCII to cf character
\begin_inset Newline newline
\end_inset

    DUP 80 20 WITHIN IF  .CFPTR S" invalid character  " TYPE  .AFPTR  0=
\begin_inset Newline newline
\end_inset

    ELSE  -20 + II-CF + C@  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: HUF ( cf -- cf huf len )   
\backslash
 convert cf char to huffman, #-bits
\begin_inset Newline newline
\end_inset

    DUP 63 AND
\begin_inset Newline newline
\end_inset

    DUP 16 < IF
\begin_inset Newline newline
\end_inset

        DUP 8 < IF
\begin_inset Newline newline
\end_inset

            4 ( 0xxx 0-7 )
\begin_inset Newline newline
\end_inset

        ELSE  24 XOR 5 ( 10xxx 8-15 )
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    ELSE  80 + 7 ( 11xxxxx 16-47 )
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
ColorForth words
\end_layout

\begin_layout Standard
Chuck's 'trick': since he is shifting the bits left, which fills with zeros,
 he allows the packed encoded characters to be larger than 28 bits if the
 trailing bits are zeros.
\end_layout

\begin_layout Standard
The capitalization support is no longer used.
\end_layout

\begin_layout Scrap

<<cfwords>>=
\begin_inset Newline newline
\end_inset

: SHORTPACK ( n cf huf len -- cf huf' n' len' )   >R ROT R@ NBITS @ >
\begin_inset Newline newline
\end_inset

    IF  OVER DUP  R@ NBITS @ -  DUP >R RSHIFT  R@ LSHIFT XOR ( ??? ) drop
 0
\begin_inset Newline newline
\end_inset

        IF  R> DROP  ADDC  0  curcolor @ SAVECOLOR STACK-PUSH  0 curcolor
 !
\begin_inset Newline newline
\end_inset

        ELSE  SWAP R> R> OVER - >R RSHIFT SWAP  THEN
\begin_inset Newline newline
\end_inset

    THEN  R> ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: FIRSTCAP ( -- )   
\backslash
 process 1st capital character
\begin_inset Newline newline
\end_inset

    curcolor @ 9 =  curcolor @ 0= OR NOT
\begin_inset Newline newline
\end_inset

    IF  .CFPTR  S" Cap not in comment " TYPE  .AFPTR  THEN
\begin_inset Newline newline
\end_inset

    curcolor @ IF  10 curcolor !  FALSE 1STCAP !  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ALLCAPS ( -- )   
\backslash
 process folllowing capital characters
\begin_inset Newline newline
\end_inset

    curcolor @ 10 =  curcolor @ 11 = OR NOT
\begin_inset Newline newline
\end_inset

    IF  .CFPTR  S" Not 1st/all caps   " TYPE  .AFPTR  THEN
\begin_inset Newline newline
\end_inset

    curcolor @ IF  11 curcolor !  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: NOTCAP ( -- )   
\backslash
 process lower case characters
\begin_inset Newline newline
\end_inset

    curcolor @ 11 = IF  .CFPTR  S" Must be all caps   " TYPE  .AFPTR  THEN
\begin_inset Newline newline
\end_inset

    FALSE 1STCAP ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: PACK ( n cf huf len -- n' )   SHORTPACK   
\backslash
 pack huffman characters
\begin_inset Newline newline
\end_inset

    DUP >R ( len )  LSHIFT + >R ( n )  DUP 128 AND
\begin_inset Newline newline
\end_inset

    IF  1STCAP @ IF  FIRSTCAP  ELSE  ALLCAPS  THEN
\begin_inset Newline newline
\end_inset

    ELSE  DUP 64 AND IF  NOTCAP  THEN
\begin_inset Newline newline
\end_inset

    THEN  DROP R> ( n )  R> ( len ) NEGATE NBITS +! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ADDWORD ( str len -- )   
\backslash
 add ASCII word to image
\begin_inset Newline newline
\end_inset

    0 -ROT  OVER + SWAP ?DO
\begin_inset Newline newline
\end_inset

        I C@ CHC HUF PACK
\begin_inset Newline newline
\end_inset

    LOOP  ADDC ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: names ( -- )   0 curcolor !  SAVECOLOR STACK-CLEAR  /BITS
\begin_inset Newline newline
\end_inset

    BEGIN  BL WORD COUNT  DUP WORDLEN !  ?DUP WHILE
\begin_inset Newline newline
\end_inset

            S" _" 2OVER COMPARE 0= IF
\begin_inset Newline newline
\end_inset

                2DROP 0 ADDN  ELSE  ADDWORD  THEN
\begin_inset Newline newline
\end_inset

    REPEAT  DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Translate ASCII to colorForth
\end_layout

\begin_layout Scrap

<<a2cf>>=
\begin_inset Newline newline
\end_inset

FALSE CONSTANT SHOW-#TOKENS
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ENDBLOCK ( -- )   
\backslash
 finish up the block by filling it with null tokens
\begin_inset Newline newline
\end_inset

    CFEND @ CP @ - 4 /MOD DUP >R 0< OR ABORT" bad pointers"
\begin_inset Newline newline
\end_inset

    SHOW-#TOKENS IF  .CFPTR S" tokens processed ok" TYPE
\begin_inset Newline newline
\end_inset

    THEN  0 curcolor !  R> 1+ 0 DO  0 ADDN  LOOP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

GET-CURRENT ( * )   WORDLIST DUP CONSTANT AF-VOC   SET-CURRENT
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: D# ( _ -- )   BASE @ DECIMAL 0 L/S ADDN BASE ! ;
\begin_inset Newline newline
\end_inset

: H# ( _ -- )   BASE @ HEX    16 L/S ADDN BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: :# ( _name _value -- )   curcolor @ SAVECOLOR STACK-PUSH 
\backslash
 compile a variable
\begin_inset Newline newline
\end_inset

    CP @  12 curcolor !  GETWORD ADDWORD  CP @ SWAP - 4 -
\begin_inset Newline newline
\end_inset

    IF  .CFPTR  S" Var name too long  " TYPE  .AFPTR  THEN
\begin_inset Newline newline
\end_inset

    0 GETN ADDN  SAVECOLOR STACK-PULL curcolor ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: }blocks ( -- ) ;  
\backslash
 terminate blocks
\begin_inset Newline newline
\end_inset

: }block ( -- )   
\backslash
 terminate block
\begin_inset Newline newline
\end_inset

    ENDBLOCK  -1 curcolor ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: }   SAVECOLOR STACK-PULL curcolor ! ; 
\backslash
 restore color
\begin_inset Newline newline
\end_inset

: { ( _value -- )   
\backslash
 compile an error or comment
\begin_inset Newline newline
\end_inset

    curcolor @ SAVECOLOR STACK-PUSH  BASE @  HEX
\begin_inset Newline newline
\end_inset

    0 0 GETWORD 2DUP >R >R  OVER C@ [CHAR] - =
\begin_inset Newline newline
\end_inset

    DUP >R IF  1 /STRING  THEN  >NUMBER ROT OR
\begin_inset Newline newline
\end_inset

    IF  2DROP R> DROP  14 curcolor !  R> R> ADDWORD
\begin_inset Newline newline
\end_inset

    ELSE  DROP R> IF  NEGATE  THEN  ADDN  R> R> 2DROP
\begin_inset Newline newline
\end_inset

    THEN  BASE ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ^ ( _value -- )   
\backslash
 compile a display token
\begin_inset Newline newline
\end_inset

    curcolor @ 13 = IF  SAVECOLOR STACK-PULL curcolor ! 
\backslash
 restore color
\begin_inset Newline newline
\end_inset

    ELSE  curcolor @ SAVECOLOR STACK-PUSH  BASE @  HEX
\begin_inset Newline newline
\end_inset

        GETWORD  2DUP S" c01/1" COMPARE 0= IF  2DROP 13  ELSE
\begin_inset Newline newline
\end_inset

            0 0 2SWAP >NUMBER NIP OR ABORT" Invalid display number"
\begin_inset Newline newline
\end_inset

        THEN  13 CURCOLOR !  5 LSHIFT 29 + ADDN  BASE !
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

3 SETCOLOR :        
\backslash
 define
\begin_inset Newline newline
\end_inset

1 SETCOLOR [        
\backslash
 execute
\begin_inset Newline newline
\end_inset

4 SETCOLOR ]        
\backslash
 compile
\begin_inset Newline newline
\end_inset

7 SETCOLOR <        
\backslash
 compile macro
\begin_inset Newline newline
\end_inset

4 SETCOLOR >        
\backslash
 compile
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: )   SAVECOLOR STACK-PULL curcolor ! ;                
\backslash
 restore color
\begin_inset Newline newline
\end_inset

: (   curcolor @ SAVECOLOR STACK-PUSH  9 curcolor ! ;    
\backslash
 comment
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

( * ) SET-CURRENT
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
ColorForth blocks
\end_layout

\begin_layout Scrap

<<cfblocks>>=
\begin_inset Newline newline
\end_inset

: +TOKEN ( str len -- )   
\backslash
 process ASCII word
\begin_inset Newline newline
\end_inset

    2DUP AF-VOC SEARCH-WORDLIST
\begin_inset Newline newline
\end_inset

    IF  EXECUTE  2DROP  EXIT  THEN
\begin_inset Newline newline
\end_inset

    ADDWORD ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CBLOCK ( blk# -- )   
\backslash
 process ASCII into a block
\begin_inset Newline newline
\end_inset

    CFBLOCK DUP CP !  1020 + CFEND !
\begin_inset Newline newline
\end_inset

    4 curcolor !  SAVECOLOR STACK-CLEAR  /BITS
\begin_inset Newline newline
\end_inset

    BEGIN  curcolor @ 0< NOT  WHILE
\begin_inset Newline newline
\end_inset

        CFEND CP @ > NOT
\begin_inset Newline newline
\end_inset

        IF  .CFPTR  S" Block too long     " TYPE  .AFPTR
\begin_inset Newline newline
\end_inset

            BEGIN  GETWORD S" }block" COMPARE 0=
\begin_inset Newline newline
\end_inset

            UNTIL  -1 curcolor !
\begin_inset Newline newline
\end_inset

        ELSE  GETWORD +TOKEN  THEN
\begin_inset Newline newline
\end_inset

    REPEAT ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: code{ ( n -- )   DUP 1 AND   
\backslash
 start code block
\begin_inset Newline newline
\end_inset

    IF  CR  8 SPACES S" Odd code block     " TYPE
\begin_inset Newline newline
\end_inset

        5 WORDLEN !  .AFPTR  THEN
\begin_inset Newline newline
\end_inset

    CBLOCK ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: shadow{ ( n -- )   DUP 1 AND 0=   
\backslash
 start shadow block
\begin_inset Newline newline
\end_inset

    IF  CR  8 SPACES S" Even shadow block  " TYPE
\begin_inset Newline newline
\end_inset

        7 WORDLEN !  .AFPTR  THEN
\begin_inset Newline newline
\end_inset

    CBLOCK ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Section

\series bold
Computer Intelligence Assembler/Disassembler
\end_layout

\begin_layout Standard
Albert van der Horst, of the HCC FIG Holland, wrote 
\family typewriter
\series bold
ciasdis
\family default
\series default
 between 2000-2008 and released it with a GNU Public License.
 He wrote it based on 
\family typewriter
\series bold
lina
\family default
\series default
 4.0.6 and I extended it to work with 
\family typewriter
\series bold
gforth
\family default
\series default
 0.7.9.
 My documentation will be included here as Literate Programming, but Albert's
 overview was:
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

From day one the reverse engineering assembler had the property that disassembly
 was based on the same tables as assembly, and that disassembled binaries,
 could be reassembled to the exact same binary.
 This is now complemented by consult files that supply the disassembler
 with information to generate a readable and documented source with label
 names.
 Consult files can be built up incrementally.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
License
\end_layout

\begin_layout Quote
This program is free software; you can redistribute it and/or modify it
 under the terms of version 2 of the GNU General Public License as published
 by the Free Software Foundation.
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details.
 You should have received a copy of the GNU General Public License along
 with this program; if not, write to the Free Software Foundation, Inc.,
 59 Temple Place, Suite 330, Boston, MA 02111, USA.
\end_layout

\begin_layout Subsection
Main Build
\end_layout

\begin_layout Subsubsection
Main Load
\end_layout

\begin_layout Standard
Albert wrote this to be used as Linux executables (
\family typewriter
\series bold
cias
\family default
\series default
 and 
\family typewriter
\series bold
cidis
\family default
\series default
), but I use it in Windows 7 in source form with 
\family typewriter
\series bold
gforth
\family default
\series default
 running under 
\family typewriter
\series bold
cygwin
\family default
\series default
.
 In reality, the two executbles are identical, but the 'd' in the name triggers
 the disassembler behavior.
 For ColorForth, I split this into 2 parts so I could load the ColorForth
 portions in the middle.
\end_layout

\begin_layout Scrap

<<ciasdis.frt>>=
\begin_inset Newline newline
\end_inset

<<load-ciasdis>>
\begin_inset Newline newline
\end_inset

<<run-ciasdis>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Load the ciasdis support files:
\end_layout

\begin_layout Scrap

<<load-ciasdis>>=
\begin_inset Newline newline
\end_inset

( $Id: ciasdis.frt,v 1.26 2009/03/26 19:40:39 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

CR 
\backslash
 Start compile time output on a new line
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<compat.f>>
\begin_inset Newline newline
\end_inset

<<noname>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    <<GET-FILE>>
\begin_inset Newline newline
\end_inset

    <<PUT-FILE>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE OLD:    REQUIRE $=    REQUIRE class    REQUIRE W/O
\begin_inset Newline newline
\end_inset

    <<NEW-PRESENT>>
\begin_inset Newline newline
\end_inset

    <<FAR-at>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 --------------------------------------------------------------
\begin_inset Newline newline
\end_inset

<<tools.frt>>
\begin_inset Newline newline
\end_inset

include File/pFDatabase/pFDatabase.fth
\begin_inset Newline newline
\end_inset

Files FALSE REVERSE !  BIG-ENDIAN  ONLY FORTH DEFINITIONS
\begin_inset Newline newline
\end_inset

<<asgen.frt>>
\begin_inset Newline newline
\end_inset

<<aswrap.frt>>
\begin_inset Newline newline
\end_inset

<<asi386.frt>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 Tools
\begin_inset Newline newline
\end_inset

<<access.frt>>
\begin_inset Newline newline
\end_inset

<<labelas.frt>>
\begin_inset Newline newline
\end_inset

<<labeldis.frt>>
\begin_inset Newline newline
\end_inset

<<crawl.frt>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This second part defines the run time behavior of ciasdis:
\end_layout

\begin_layout Scrap

<<run-ciasdis>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE #-PREFIX    
\backslash
 In behalf of user.
\begin_inset Newline newline
\end_inset

    REQUIRE ARGC    
\backslash
 In behalf of building an executable.
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<WRITE-ONE-SECTION>>
\begin_inset Newline newline
\end_inset

<<WRITE-SECTIONS>>
\begin_inset Newline newline
\end_inset

<<OPEN-IT>>
\begin_inset Newline newline
\end_inset

<<CLOSE-IT>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    <<cf-SOURCE-AS>>
\begin_inset Newline newline
\end_inset

    <<cf-TARGET-AS>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    <<ci-SOURCE-AS>>
\begin_inset Newline newline
\end_inset

    <<ci-TARGET-AS>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<WRITE-IT>>
\begin_inset Newline newline
\end_inset

<<filenames>>
\begin_inset Newline newline
\end_inset

<<PARSE-ASM>>
\begin_inset Newline newline
\end_inset

<<[ASM>>
\begin_inset Newline newline
\end_inset

<<cias>>
\begin_inset Newline newline
\end_inset

<<FETCHED>>
\begin_inset Newline newline
\end_inset

<<FETCH>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    <<cf-TARGET-DIS>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    <<ci-TARGET-DIS>>
\begin_inset Newline newline
\end_inset

    REQUIRE DUMP
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<CONSULTED>>
\begin_inset Newline newline
\end_inset

<<CONSULT>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    <<cfdis>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    <<cidis>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<RESTORE-ALL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    <<INTERACTIVE>>
\begin_inset Newline newline
\end_inset

    <<HANDLE-ARG>>
\begin_inset Newline newline
\end_inset

    <<CONTAINS-D?>>
\begin_inset Newline newline
\end_inset

    <<BLOCK-FILE>>
\begin_inset Newline newline
\end_inset

    <<SIGNON>>
\begin_inset Newline newline
\end_inset

    <<MAIN>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Write current section to FILEHANDLE.
 Leave FILEHANDLE.
\end_layout

\begin_layout Scrap

<<WRITE-ONE-SECTION>>=
\begin_inset Newline newline
\end_inset

: WRITE-ONE-SECTION ( handle -- handle )
\begin_inset Newline newline
\end_inset

    >R  FILE-OFFSET 0 R@ REPOSITION-FILE THROW
\begin_inset Newline newline
\end_inset

    CODE-SPACE CP @ OVER - R@ WRITE-FILE THROW  R> ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Write all sections to FILEHANDLE.
 Leave FILEHANDLE.
\end_layout

\begin_layout Scrap

<<WRITE-SECTIONS>>=
\begin_inset Newline newline
\end_inset

: WRITE-SECTIONS ( handle -- handle )   SECTION-REGISTRY DO-BAG
\begin_inset Newline newline
\end_inset

        I @ TO CURRENT-SECTION  WRITE-ONE-SECTION
\begin_inset Newline newline
\end_inset

    LOOP-BAG ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Open NAME, return FILEHANDLE.
\end_layout

\begin_layout Scrap

<<OPEN-IT>>=
\begin_inset Newline newline
\end_inset

: OPEN-IT ( a n -- handle )   R/W CREATE-FILE THROW ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Close FILEHANDLE.
\end_layout

\begin_layout Scrap

<<CLOSE-IT>>=
\begin_inset Newline newline
\end_inset

: CLOSE-IT ( handle -- )   CLOSE-FILE THROW ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Write all sections to file NAME.
\end_layout

\begin_layout Scrap

<<WRITE-IT>>=
\begin_inset Newline newline
\end_inset

: WRITE-IT ( a n -- )   OPEN-IT  WRITE-SECTIONS  CLOSE-IT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Handle all the filename extensions.
\end_layout

\begin_layout Scrap

<<filenames>>=
\begin_inset Newline newline
\end_inset

VARIABLE file.cf    
\backslash
 colorForth source
\begin_inset Newline newline
\end_inset

VARIABLE file.cfo   
\backslash
 colorForth source reproduced
\begin_inset Newline newline
\end_inset

VARIABLE file.cul   
\backslash
 consultant file
\begin_inset Newline newline
\end_inset

VARIABLE file.dsm   
\backslash
 disassembled output
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: make-filename ( aext next a n ahere -- )
\begin_inset Newline newline
\end_inset

    >R  DUP 5 + ALLOT  R@ PLACE  R> APPEND ;
\begin_inset Newline newline
\end_inset

: make-filenames ( a n -- )   HERE DUP >R file.cf !
\begin_inset Newline newline
\end_inset

    DUP 4 + ALLOT  R@ PLACE  R@ COUNT  S" .cf" R> APPEND
\begin_inset Newline newline
\end_inset

    S" .cfo" 2OVER  HERE DUP file.cfo ! make-filename
\begin_inset Newline newline
\end_inset

    S" .cul" 2OVER  HERE DUP file.cul ! make-filename
\begin_inset Newline newline
\end_inset

    S" .dsm" 2SWAP  HERE DUP file.dsm ! make-filename ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Assembler parser.
\end_layout

\begin_layout Scrap

<<PARSE-ASM>>=
\begin_inset Newline newline
\end_inset

: PARSE-ASM ( -- )
\begin_inset Newline newline
\end_inset

    BEGIN BEGIN  BL WORD DUP C@
\begin_inset Newline newline
\end_inset

            WHILE  FIND IF  EXECUTE
\begin_inset Newline newline
\end_inset

                ELSE  COUNT 2DUP S" ASM]" $= IF  2DROP EXIT
\begin_inset Newline newline
\end_inset

                    THEN  OVER C@ [CHAR] : = IF  1 /STRING
\begin_inset Newline newline
\end_inset

                        KNOWN-LABEL? IF  2DROP
\begin_inset Newline newline
\end_inset

                        ELSE  _AP_ -ROT LABELED
\begin_inset Newline newline
\end_inset

                        THEN
\begin_inset Newline newline
\end_inset

                    ELSE  OVER C@ [CHAR] - = DUP >R IF  1 /STRING
\begin_inset Newline newline
\end_inset

                        THEN  0 0 2SWAP >NUMBER 2DROP DROP  R> IF  NEGATE
\begin_inset Newline newline
\end_inset

                        THEN
\begin_inset Newline newline
\end_inset

                    THEN
\begin_inset Newline newline
\end_inset

                THEN
\begin_inset Newline newline
\end_inset

            REPEAT
\begin_inset Newline newline
\end_inset

        DROP REFILL 0= UNTIL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Parse assembler until 
\family typewriter
\series bold
ASM]
\family default
\series default
.
\end_layout

\begin_layout Scrap

<<[ASM>>=
\begin_inset Newline newline
\end_inset

: [ASM ( -- )   BASE @ >R  GET-ORDER
\begin_inset Newline newline
\end_inset

    POSTPONE ONLY POSTPONE FORTH POSTPONE ALSO POSTPONE ASSEMBLER
\begin_inset Newline newline
\end_inset

    SAVE-INPUT  FIRSTPASS  2 0 DO  DEPTH >R  PARSE-ASM  CR  DEPTH R> -
\begin_inset Newline newline
\end_inset

        IF  .S  TRUE ABORT" Stack depth error"  THEN
\begin_inset Newline newline
\end_inset

        I 0= IF  SECONDPASS  RESTORE-INPUT THROW  THEN
\begin_inset Newline newline
\end_inset

    LOOP  SET-ORDER  R> BASE ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Perform the action of the program as per the spec's of '
\family typewriter
\series bold
cias
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<cias>>=
\begin_inset Newline newline
\end_inset

: cias ( -- )   SOURCE-AS INCLUDED  TARGET-AS WRITE-IT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fetch file NAME to the code buffer.
\end_layout

\begin_layout Scrap

<<FETCHED>>=
\begin_inset Newline newline
\end_inset

: FETCHED ( a n -- )   GET-FILE DUP CODE-LENGTH @ > ABORT" Too big!"
\begin_inset Newline newline
\end_inset

    CODE-SPACE SWAP  2DUP + CP !  MOVE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fetch file "name" to the code buffer.
\end_layout

\begin_layout Scrap

<<FETCH>>=
\begin_inset Newline newline
\end_inset

: FETCH ( -- )   BL WORD COUNT FETCHED ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Using (only) information from file with NAME, disassemble the current program
 as stored in the '
\family typewriter
\series bold
CODE-BUFFER
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<CONSULTED>>=
\begin_inset Newline newline
\end_inset

: CONSULTED ( a n -- )   INIT-ALL  HEX  INCLUDED ( file)  SORT-ALL
\begin_inset Newline newline
\end_inset

    PLUG-HOLES  ALL-L-LABELS  DISASSEMBLE-TARGET  DECIMAL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Consult "file" as per '
\family typewriter
\series bold
CONSULT
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<CONSULT>>=
\begin_inset Newline newline
\end_inset

: CONSULT ( -- )   BL WORD COUNT CONSULTED ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Restore all revectoring done while compiling to stand alone.
\end_layout

\begin_layout Scrap

<<RESTORE-ALL>>=
\begin_inset Newline newline
\end_inset

: RESTORE-ALL ( -- )   '?ERROR RESTORED  'SECTION RESTORED
\begin_inset Newline newline
\end_inset

    'TYPE RESTORED ;
\begin_inset Newline newline
\end_inset

RESTORE-ALL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ANS Forth specific
\end_layout

\begin_layout Standard
Return the NAME of the source file.
\end_layout

\begin_layout Scrap

<<cf-SOURCE-AS>>=
\begin_inset Newline newline
\end_inset

: SOURCE-AS ( -- a n )   BL WORD COUNT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return the NAME of the target file.
\end_layout

\begin_layout Scrap

<<cf-TARGET-AS>>=
\begin_inset Newline newline
\end_inset

: TARGET-AS ( -- a n )   BL WORD COUNT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return the NAME of the target file.
\end_layout

\begin_layout Scrap

<<cf-TARGET-DIS>>=
\begin_inset Newline newline
\end_inset

: TARGET-DIS ( -- a n )   BL WORD COUNT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Perform the action of the program as per the spec's of '
\family typewriter
\series bold
cidis
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<cfdis>>=
\begin_inset Newline newline
\end_inset

: cidis ( -- )   BL WORD COUNT FETCHED TARGET-DIS CONSULTED ;
\begin_inset Newline newline
\end_inset

: cfdis ( -- )   BL WORD COUNT make-filenames
\begin_inset Newline newline
\end_inset

    file.cf @ COUNT FETCHED  file.cul @ COUNT CONSULTED ;
\begin_inset Newline newline
\end_inset

: cfas ( -- )   BL WORD COUNT make-filenames
\begin_inset Newline newline
\end_inset

    TESTING IF  file.cf @ COUNT FETCHED  THEN
\begin_inset Newline newline
\end_inset

    file.dsm @ COUNT INCLUDED  file.cfo @ COUNT WRITE-IT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ciForth specific
\end_layout

\begin_layout Standard
Return the NAME of the source file.
\end_layout

\begin_layout Scrap

<<ci-SOURCE-AS>>=
\begin_inset Newline newline
\end_inset

: SOURCE-AS ( -- a n )   1 ARG[] ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return the NAME of the target file.
\end_layout

\begin_layout Scrap

<<ci-TARGET-AS>>=
\begin_inset Newline newline
\end_inset

: TARGET-AS ( -- a n )   2 ARG[] ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return the NAME of the target file.
\end_layout

\begin_layout Scrap

<<ci-TARGET-DIS>>=
\begin_inset Newline newline
\end_inset

: TARGET-DIS ( -- a n )   2 ARG[] ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Perform the action of the program as per the spec's of '
\family typewriter
\series bold
cidis
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<cidis>>=
\begin_inset Newline newline
\end_inset

: cidis ( -- )   1 ARG[] FETCHED TARGET-DIS CONSULTED ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Start an interactive session or a filter.
 The startup code has changed '
\family typewriter
\series bold
OK
\family default
\series default
' for a filter.
 In that case suppress the splat screen.
 Note that '
\family typewriter
\series bold
QUIT
\family default
\series default
' is the command interpreter.
\end_layout

\begin_layout Scrap

<<INTERACTIVE>>=
\begin_inset Newline newline
\end_inset

: INTERACTIVE    'OK DUP >DFA @ SWAP >PHA = IF 0 LIST OK THEN
\begin_inset Newline newline
\end_inset

    ASSEMBLER   0 ORG   QUIT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Handle arguments, start interactive system if no arguments.
 The second argument is still obligatory for the moment.
\end_layout

\begin_layout Scrap

<<HANDLE-ARG>>=
\begin_inset Newline newline
\end_inset

: HANDLE-ARG   ARGC 1 = IF INTERACTIVE THEN
\begin_inset Newline newline
\end_inset

    ARGC ( 2) 3 4 WITHIN 0= 13 ?ERROR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For 
\family typewriter
\series bold
STRING:
\family default
\series default
 "It CONTAINS a 'd' or a 'D' "
\end_layout

\begin_layout Scrap

<<CONTAINS-D?>>=
\begin_inset Newline newline
\end_inset

: CONTAINS-D?    2DUP &D $I >R  &d $I R>  OR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fetch the library file from the current directory.
 We can't assume 
\family typewriter
\series bold
lina
\family default
\series default
 has been installed so 
\family typewriter
\series bold
forth.lab
\family default
\series default
 is supplied with the 
\family typewriter
\series bold
ciasdis
\family default
\series default
 program.
\end_layout

\begin_layout Scrap

<<BLOCK-FILE>>=
\begin_inset Newline newline
\end_inset

"forth.lab" BLOCK-FILE $!
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make a cold start silent.
\end_layout

\begin_layout Scrap

<<SIGNON>>=
\begin_inset Newline newline
\end_inset

'TASK >DFA @   '.SIGNON >DFA !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The name determines what to do.
\end_layout

\begin_layout Scrap

<<MAIN>>=
\begin_inset Newline newline
\end_inset

: MAIN   RESTORE-ALL  DEFAULT-SEGMENT HANDLE-ARG
\begin_inset Newline newline
\end_inset

    0 ARG[] CONTAINS-D? IF cidis ELSE cias THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Disgraceful adaptations
\end_layout

\begin_layout Standard
Put here to draw attention.
\end_layout

\begin_layout Standard
This name might later be changed.
\end_layout

\begin_layout Scrap

<<noname>>=
\begin_inset Newline newline
\end_inset

: NONAME$ ( -- a n )   s" NONAME" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ANS Forth specific
\end_layout

\begin_layout Scrap

<<GET-FILE>>=
\begin_inset Newline newline
\end_inset

: GET-FILE ( a1 n1 -- a2 n2 )
\begin_inset Newline newline
\end_inset

    r/o open-file throw
\begin_inset Newline newline
\end_inset

    dup >r file-size throw
\begin_inset Newline newline
\end_inset

    abort" file too large"
\begin_inset Newline newline
\end_inset

    dup allocate throw
\begin_inset Newline newline
\end_inset

    swap 2dup r@ read-file throw
\begin_inset Newline newline
\end_inset

    over <> abort" could not read whole file"
\begin_inset Newline newline
\end_inset

    r> close-file throw ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<PUT-FILE>>=
\begin_inset Newline newline
\end_inset

: PUT-FILE ( a1 n1 a2 n2 -- )
\begin_inset Newline newline
\end_inset

    r/w create-file throw
\begin_inset Newline newline
\end_inset

    dup >r write-file throw
\begin_inset Newline newline
\end_inset

    r> close-file throw ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ciForth specific
\end_layout

\begin_layout Standard
Patch the word '
\family typewriter
\series bold
PRESENT
\family default
\series default
' such that no name words are no longer considered present.
 This prevents a zillion error messages.
\end_layout

\begin_layout Scrap

<<NEW-PRESENT>>=
\begin_inset Newline newline
\end_inset

: NEW-PRESENT   OLD: PRESENT DUP IF DUP >NFA @ $@ NONAME$ $= 0= AND THEN
 ;
\begin_inset Newline newline
\end_inset

' NEW-PRESENT ' PRESENT 3 CELLS MOVE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Patch the word '
\family typewriter
\series bold
L@
\family default
\series default
' with the name '
\family typewriter
\series bold
FAR@
\family default
\series default
'.
 Such that it no longer conflicts with the '
\family typewriter
\series bold
L@
\family default
\series default
' we have.
\end_layout

\begin_layout Scrap

<<FAR-at>>=
\begin_inset Newline newline
\end_inset

: FAR@ L@ ;    HIDE L@
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Compatibility
\end_layout

\begin_layout Standard
I have created similar compatibility test systems before, but Josh Grams
 (
\family typewriter
\series bold
josh@qualdan.com
\family default
\series default
) created this one, which is smaller and covers more systems than I had
 even envisioned earlier.
 He wrote this code to detect forth system and use appropriate prelude,
 between 2009 and 2010-03-09.
 He gifted it to the public domain.
  Specifically, you may use, modify, and redistribute it without limitation,
 but it comes with ABSOLUTELY NO WARRANTY.
\end_layout

\begin_layout Standard
Currently, it detects the following systems, but he had not tested 
\family typewriter
\series bold
iForth
\family default
\series default
 or 
\family typewriter
\series bold
VFX Forth
\family default
\series default
 and I have only tested 
\family typewriter
\series bold
gforth
\family default
\series default
 and 
\family typewriter
\series bold
ciforth
\family default
\series default
:
\end_layout

\begin_layout Description
bigForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.jwdt.com/~paysan/bigforth.html
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForBigForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 bigforth compat.f -e bye
\begin_inset Newline newline
\end_inset

S" BIGFORTH" ENVIRONMENT? env-str?
\begin_inset Newline newline
\end_inset

    uses CREATE ForBigForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
ciforth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://home.hccnet.nl/a.w.m.van.der.horst/ciforth.html
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForCiForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 lina -s compat.f
\begin_inset Newline newline
\end_inset

S" NAME" ENVIRONMENT? S" ciforth" env-str=
\begin_inset Newline newline
\end_inset

    uses CREATE ForCiForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
FICL 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ficl.sourceforge.net
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForFicl>>=
\begin_inset Newline newline
\end_inset


\backslash
 ficl compat.f
\begin_inset Newline newline
\end_inset


\backslash
 Grrr.
  FICL has no way to quit automatically after running a script.
\begin_inset Newline newline
\end_inset

S" ficl-version" ENVIRONMENT? env-str?
\begin_inset Newline newline
\end_inset

    uses CREATE ForFicl
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
gforth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.jwdt.com/~paysan/gforth.html
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForGForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 gforth compat.f -e bye
\begin_inset Newline newline
\end_inset

S" gforth" ENVIRONMENT? env-str?
\begin_inset Newline newline
\end_inset

    uses CREATE ForGForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
iForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://home.iae.nl/users/mhx/i4faq.html
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForIForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 ???
\begin_inset Newline newline
\end_inset

S" IFORTH" ENVIRONMENT? env-flag?
\begin_inset Newline newline
\end_inset

     uses CREATE ForIForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
kForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ccreweb.org/software/kforth/kforth.html
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForKForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 kforth compat.f -e bye
\begin_inset Newline newline
\end_inset

?? NONDEFERRED
\begin_inset Newline newline
\end_inset

    uses CREATE ForKForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
PFE 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://pfe.sourceforge.net
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForPfe>>=
\begin_inset Newline newline
\end_inset


\backslash
 pfe -q -y compat.f
\begin_inset Newline newline
\end_inset

S" FORTH-NAME" ENVIRONMENT? S" pfe" env-str=
\begin_inset Newline newline
\end_inset

    uses CREATE ForPfe
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
pForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.softsynth.com/pforth
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForPForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 pforth compat.f
\begin_inset Newline newline
\end_inset

?? ::::loadp4th.fth
\begin_inset Newline newline
\end_inset

    uses CREATE ForPForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SP-Forth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://spf.sourceforge.net
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForSpf4>>=
\begin_inset Newline newline
\end_inset


\backslash
 spf4 compat.f BYE
\begin_inset Newline newline
\end_inset

S" FORTH-SYS" ENVIRONMENT? S" SP-FORTH" env-str=
\begin_inset Newline newline
\end_inset

    uses CREATE ForSpf4
\begin_inset Newline newline
\end_inset

        
\backslash
 REQUIRE CASE-INS lib/ext/caseins.f
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
VFX
\begin_inset space ~
\end_inset

Forth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.mpeforth.com
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForVfx>>=
\begin_inset Newline newline
\end_inset


\backslash
 ??? vfx include compat.f bye ???
\begin_inset Newline newline
\end_inset

?? VFXFORTH
\begin_inset Newline newline
\end_inset

    uses CREATE ForVfx
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
Win32Forth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://win32forth.sourceforge.net
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForWin32Forth>>=
\begin_inset Newline newline
\end_inset


\backslash
 win32forth include compat.f bye
\begin_inset Newline newline
\end_inset

S" WIN32FORTH" ENVIRONMENT? env-str?
\begin_inset Newline newline
\end_inset

    uses CREATE ForWin32Forth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SwiftForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://forth.com/swiftforth
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

<<ForSwiftForth>>=
\begin_inset Newline newline
\end_inset


\backslash
 sf include compat.f bye
\begin_inset Newline newline
\end_inset

?? VERSION DUP uses S" SwiftForth" version over compare 0= AND
\begin_inset Newline newline
\end_inset

    uses CREATE ForSwiftForth
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Other systems to consider, but most are not standard:
\end_layout

\begin_layout Description
4p 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://maschenwerk.de
\end_layout

\end_inset


\end_layout

\begin_layout Description
dsForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.delosoft.com
\end_layout

\end_inset


\end_layout

\begin_layout Description
FINA 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://code.google.com/p/fina-forth
\end_layout

\end_inset


\end_layout

\begin_layout Description
hForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.taygeta.com/hforth.html
\end_layout

\end_inset


\end_layout

\begin_layout Description
IsForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://isforth.com
\end_layout

\end_inset


\end_layout

\begin_layout Description
NTF/LXF 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://falth.homelinux.net/readme2.html
\end_layout

\end_inset


\end_layout

\begin_layout Description
MinForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://falth.homelinux.net/readme2.html
\end_layout

\end_inset


\end_layout

\begin_layout Description
RetroForth 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://retroforth.org
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rationale
\end_layout

\begin_layout Standard
This eventually came to be fairly simple, but it took him several iterations
 to get it "right", so he published it in case it may save someone else
 some work.
\end_layout

\begin_layout Standard
A good test must:
\end_layout

\begin_layout Itemize
Reliably detect the current system: some free systems don't provide a way
 to test for this, so we have to get creative.
\end_layout

\begin_layout Itemize
Run out of the box on all other systems.
  Many useful words aren't in the CORE wordset and hence aren't provided
 by even all standard systems.
 Also, most so-called standard systems have words which are implemented
 in a sub-standard fashion.
\end_layout

\begin_layout Subsubsection
Helper Words
\end_layout

\begin_layout Standard
Process the rest of line only if 
\family typewriter
\series bold
flag
\family default
\series default
 is true.
 
\family typewriter
\series bold
[IF] ..
 [THEN]
\family default
\series default
 don't exist everywhere, so we use this conditional comment word instead.
\end_layout

\begin_layout Scrap

<<uses>>=
\begin_inset Newline newline
\end_inset

: uses ( flag -- )  0= IF POSTPONE 
\backslash
 THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard

\family typewriter
\series bold
[DEFINED]
\family default
\series default
 doesn't exist everywhere, and on some systems the interpreter uses 
\family typewriter
\series bold
WORD
\family default
\series default
, so 
\family typewriter
\series bold
BL WORD FIND
\family default
\series default
 doesn't work in the interpreter.
\end_layout

\begin_layout Scrap

<<??>>=
\begin_inset Newline newline
\end_inset

: ?? ( "name" -- flag )  BL WORD FIND SWAP DROP 0= 0= ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
We need a string comparison word, but on ciforth, 
\family typewriter
\series bold
COMPARE
\family default
\series default
 is not loaded by default.
\end_layout

\begin_layout Scrap

<<STR=>>=
\begin_inset Newline newline
\end_inset

?? STR= 0= uses : MATCH? >R COUNT ROT COUNT ROT = R> AND ;
\begin_inset Newline newline
\end_inset

?? STR= 0= uses : (STR=) BEGIN DUP 0 > WHILE MATCH? 1- REPEAT 0= ;
\begin_inset Newline newline
\end_inset

?? STR= 0= uses : STR= ROT 2DUP = >R MIN (STR=) >R 2DROP R> R> AND ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dummy 
\family typewriter
\series bold
ENVIRONMENT?
\family default
\series default
 (since kForth doesn't have it)
\end_layout

\begin_layout Scrap

<<ENVIRONMENT?>>=
\begin_inset Newline newline
\end_inset

?? ENVIRONMENT? 0= uses : ENVIRONMENT? 2DROP 0 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The return from 
\family typewriter
\series bold
ENVIRONMENT?
\family default
\series default
 is a bit of a nuisance, so we have words to deal with various possibilities
 and return a single flag.
\end_layout

\begin_layout Scrap

<<env-words>>=
\begin_inset Newline newline
\end_inset

: env-flag?  DUP IF DROP THEN ;              
\backslash
 flag true?
\begin_inset Newline newline
\end_inset

: env-str?  DUP IF >R 2DROP R> THEN ;        
\backslash
 string present?
\begin_inset Newline newline
\end_inset

: env-str=  ROT IF STR= ELSE 2DROP 0 THEN ;  
\backslash
 string matches?
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
System Tests
\end_layout

\begin_layout Standard
Originally Josh defined a word to check for the presence of each system.
 But Win32Forth doesn't like it if you compile 
\family typewriter
\series bold
ENVIRONMENT?
\family default
\series default
 into a word (apparently it isn't available in turnkey applications).
  He could have gotten around that by precomputing the values and defining
 constants.
 But then he realized that there was no sense in cluttering up the dictionary
 with all those words.
  So this version just uses interpreted tests.
  He recommend that your system-specific preludes define a no-op word named
 after the Forth system.
  Then you can later do something like this:
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[defined] ciforth [if] ...
 [then]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One reason *for* defining a test word for each system was that ANS CORE
 doesn't require 
\family typewriter
\series bold
S"
\family default
\series default
 to work in interpretation state.
  But the 
\family typewriter
\series bold
FILE
\family default
\series default
 wordset does, and since this is in a file...
  At any rate, all systems which I have tested have an interpreted 
\family typewriter
\series bold
S"
\family default
\series default
.
  If you add a system which doesn't, you could replace 
\family typewriter
\series bold
S"
\family default
\series default
 with something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Scrap

: PAD" ( -- c-addr u )  [CHAR] " WORD  COUNT PAD PLACE  PAD COUNT ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each system has a comment describing how to invoke the system for testing
 purposes, the test itself, and the `
\family typewriter
\series bold
uses
\family default
\series default
` line which gives an example of how to include another source file (some
 systems are case-sensitive, some only define 
\family typewriter
\series bold
INCLUDED
\family default
\series default
, and so on).
\end_layout

\begin_layout Scrap

<<compat.f>>=
\begin_inset Newline newline
\end_inset

<<uses>>
\begin_inset Newline newline
\end_inset

<<??>>
\begin_inset Newline newline
\end_inset

<<STR=>>
\begin_inset Newline newline
\end_inset

<<ENVIRONMENT?>>
\begin_inset Newline newline
\end_inset

<<env-words>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<ForBigForth>>
\begin_inset Newline newline
\end_inset

<<ForCiForth>>
\begin_inset Newline newline
\end_inset

<<ForFicl>>
\begin_inset Newline newline
\end_inset

<<ForGForth>>
\begin_inset Newline newline
\end_inset

<<ForIForth>>
\begin_inset Newline newline
\end_inset

<<ForKForth>>
\begin_inset Newline newline
\end_inset

<<ForPfe>>
\begin_inset Newline newline
\end_inset

<<ForPForth>>
\begin_inset Newline newline
\end_inset

<<ForSpf4>>
\begin_inset Newline newline
\end_inset

<<ForVfx>>
\begin_inset Newline newline
\end_inset

<<ForWin32Forth>>
\begin_inset Newline newline
\end_inset

<<ForSwiftForth>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Standard
Those auxiliary thingies that are not appropriate elsewhere.
\end_layout

\begin_layout Scrap

<<tools.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: tools.frt,v 1.2 2005/01/04 23:23:48 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: <?> ( n -- )   .S DROP S" <?>" TYPE CR ;    
\backslash
 a fence post to isolate issues
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<warnings>>
\begin_inset Newline newline
\end_inset

<<display>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

     : NOT ( flag -- flag' )   0= ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

    <<string-primitives>>
\begin_inset Newline newline
\end_inset

    <<H.>>
\begin_inset Newline newline
\end_inset

    <<num-out>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

     : CORA swap over compare ;
\begin_inset Newline newline
\end_inset

     : ETYPE TYPE ;
\begin_inset Newline newline
\end_inset

     : TOGGLE ( a b -- ) over @ xor swap ! ;
\begin_inset Newline newline
\end_inset

     variable exit-code
\begin_inset Newline newline
\end_inset

     0 value _  ' _ to _
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

    <<BAGS>>
\begin_inset Newline newline
\end_inset

    <<BIN-SEARCH>>
\begin_inset Newline newline
\end_inset

    <<EXCHANGE>>
\begin_inset Newline newline
\end_inset

    <<QSORT>>
\begin_inset Newline newline
\end_inset

[ELSE]
\begin_inset Newline newline
\end_inset

    REQUIRE H.
    REQUIRE RESTORED
\begin_inset Newline newline
\end_inset

    <<.NFA>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<debug>>
\begin_inset Newline newline
\end_inset

<<QSORT-SAFE>>
\begin_inset Newline newline
\end_inset

<<INVENTED-NAMES>>
\begin_inset Newline newline
\end_inset

<<=<>=>>
\begin_inset Newline newline
\end_inset

<<?ABORT>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE $=    REQUIRE ."$"
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Hide known redefinition warnings
\end_layout

\begin_layout Standard
Note that 
\family typewriter
\series bold
-warning
\family default
\series default
 leaves a value that is consumed by 
\family typewriter
\series bold
+warning
\family default
\series default
, so this must be accounted for and all systems must define something here.
\end_layout

\begin_layout Scrap

<<warnings>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth [IF]
\begin_inset Newline newline
\end_inset

: -warning ( - x)   warnings @  0 warnings ! ;
\begin_inset Newline newline
\end_inset

: +warning ( x)   warnings ! ; 
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth [IF]
\begin_inset Newline newline
\end_inset

: -warning ( -- x)   warning @  0 warning ! ;
\begin_inset Newline newline
\end_inset

: +warning ( x)   warning ! ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

: -warning 0 ; : +warning drop ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Vectored display
\end_layout

\begin_layout Standard
To enable output to be turned off, or sent to a file.
\end_layout

\begin_layout Scrap

<<display>>=
\begin_inset Newline newline
\end_inset

CREATE 'TYPE   ' TYPE DUP , ,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: TYPE ( a n -- )   'TYPE @ EXECUTE ;
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: RESTORED ( a -- )   DUP CELL+ @  SWAP ! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<SHUTUP>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth [IF]  true constant ForDOS  [THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth [IF] 
\backslash
 Add missing GForth definitions
\begin_inset Newline newline
\end_inset

s" PWD" getenv drop c@ char 
\backslash
 = [IF]    
\backslash
 using DOS path separators
\begin_inset Newline newline
\end_inset

     true constant ForDOS [THEN] [THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForDOS [IF]
\begin_inset Newline newline
\end_inset

     CREATE <EOL>   2 C, 13 C, 10 C, 
\backslash
 We are assuming DOS line terminators
\begin_inset Newline newline
\end_inset

[ELSE]
\begin_inset Newline newline
\end_inset

     CREATE <EOL>   1 C, 10 C,       
\backslash
 We are assuming UNIX line terminators
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

CREATE CHAR-BUF   0 C,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: CR ( -- )         'TYPE 2@ = IF  CR  ELSE  <EOL> COUNT TYPE  THEN ;
\begin_inset Newline newline
\end_inset

: EMIT ( c -- )     'TYPE 2@ = IF  EMIT  ELSE
\begin_inset Newline newline
\end_inset

         CHAR-BUF C!  CHAR-BUF 1 TYPE  THEN ;
\begin_inset Newline newline
\end_inset

: SPACE ( -- )      'TYPE 2@ = IF  SPACE  ELSE  BL EMIT  THEN ;
\begin_inset Newline newline
\end_inset

: SPACES ( n -- )   'TYPE 2@ = IF  SPACES  ELSE  0 ?DO  SPACE  LOOP  THEN
 ;
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make the output disappear till the end of the calling word.
\end_layout

\begin_layout Scrap

<<SHUTUP>>=
\begin_inset Newline newline
\end_inset

: 2DROP'  2DROP ;      
\backslash
 Need a high level word here.
\begin_inset Newline newline
\end_inset

: (SHUTUP) ( xt -- )   ['] 2DROP' 'TYPE !  EXECUTE  'TYPE RESTORED ;
\begin_inset Newline newline
\end_inset

: SHUTUP ( -name- )   ' POSTPONE LITERAL  POSTPONE (SHUTUP) ; IMMEDIATE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Paragraph
ANS Forth specific
\end_layout

\begin_layout Scrap

<<num-out>>=
\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: C.
   S>D <# # #S #> TYPE SPACE ; ( print byte )
\begin_inset Newline newline
\end_inset

: (.)   S>D TUCK DABS <# #S ROT SIGN #> ;
\begin_inset Newline newline
\end_inset

: .
   (.) TYPE SPACE ;
\begin_inset Newline newline
\end_inset

: .R   >R (.) R> OVER - 0 MAX SPACES TYPE ;
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
String handling
\end_layout

\begin_layout Paragraph
ANS Forth specific
\end_layout

\begin_layout Scrap

<<string-primitives>>=
\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: cappend ( char to -- )   DUP >R COUNT + C! R@ C@ 1+ R> C! ;
\begin_inset Newline newline
\end_inset

: append ( from len to -- )   2DUP >R >R  COUNT + SWAP MOVE
\begin_inset Newline newline
\end_inset

    R> R@ C@ + R> C! ;
\begin_inset Newline newline
\end_inset

: place ( from len to -- )   0 OVER C! SWAP 255 MIN SWAP APPEND ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: @+ ( a -- a' n )   DUP >R CELL+ R> @ ;
\begin_inset Newline newline
\end_inset

: $= ( a1 n1 a2 n2 -- f )   COMPARE 0= ;
\begin_inset Newline newline
\end_inset

: $@ ( a -- a' n )   COUNT ;
\begin_inset Newline newline
\end_inset

: $, ( a n -- a' )   HERE >R  DUP C,  0 ?DO  $@ C,  LOOP  DROP R> ;
\begin_inset Newline newline
\end_inset

: $! ( a n a' -- )   PLACE ;
\begin_inset Newline newline
\end_inset

: $+! ( a n a' -- )   APPEND ;
\begin_inset Newline newline
\end_inset

: $C+ ( c a -- )   CAPPEND ;
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Hex output
\end_layout

\begin_layout Paragraph
ANS Forth specific
\end_layout

\begin_layout Standard
Print SINGLE in hex.
\end_layout

\begin_layout Scrap

<<H.>>=
\begin_inset Newline newline
\end_inset

VARIABLE BASE'
\begin_inset Newline newline
\end_inset

: <HEX   BASE @ BASE' ! HEX ;       ( 0/1  SWITCH TO HEX)
\begin_inset Newline newline
\end_inset

: HEX>   BASE' @ BASE !     ;       ( 1/0  AND BACK)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

<<4?>>
\begin_inset Newline newline
\end_inset

    : (DH.)   <HEX  <#  1- 0 ?DO  #  I 4?  LOOP  #  #>  HEX> ;
\begin_inset Newline newline
\end_inset

[ELSE]
\begin_inset Newline newline
\end_inset

    : (DH.)   <HEX  <#  1- 0 ?DO  #  LOOP  #  #>  HEX> ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

: (H.R) ( n digits -- a len )   >R S>D R> (DH.) ;
\begin_inset Newline newline
\end_inset

: H.R ( n digits -- )   (H.R) TYPE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: (H.) ( n -- a len )   DUP ABS 0  <HEX  <# #S ROT SIGN #>  HEX> ;
\begin_inset Newline newline
\end_inset

: H.
   (H.) TYPE SPACE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ciForth specific
\end_layout

\begin_layout Standard
In lina, Albert adds a , after 4 digits.
\end_layout

\begin_layout Scrap

<<4?>>=
\begin_inset Newline newline
\end_inset

: 4? ( n -- )   1+ 4 MOD 0= IF  [CHAR] , HOLD THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Bags of stacks
\end_layout

\begin_layout Scrap

<<BAGS>>=
\begin_inset Newline newline
\end_inset

<<BUILD-BAG>>
\begin_inset Newline newline
\end_inset

<<BAG>>
\begin_inset Newline newline
\end_inset

<<!BAG>>
\begin_inset Newline newline
\end_inset

<<BAG?>>
\begin_inset Newline newline
\end_inset

<<BAG+!>>
\begin_inset Newline newline
\end_inset

<<BAG@->>
\begin_inset Newline newline
\end_inset

<<BAG-REMOVE>>
\begin_inset Newline newline
\end_inset

<<BAG-HOLE>>
\begin_inset Newline newline
\end_inset

<<BAG-INSERT>>
\begin_inset Newline newline
\end_inset

<<|BAG|>>
\begin_inset Newline newline
\end_inset

<<BAG-LOOP>>
\begin_inset Newline newline
\end_inset

<<.BAG>>
\begin_inset Newline newline
\end_inset

<<BAG-WHERE>>
\begin_inset Newline newline
\end_inset

<<IN-BAG?>>
\begin_inset Newline newline
\end_inset

<<BAG->>
\begin_inset Newline newline
\end_inset

<<SET>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Build a bag (i.e.
 stack) with X items.
\end_layout

\begin_layout Scrap

<<BUILD-BAG>>=
\begin_inset Newline newline
\end_inset

: BUILD-BAG ( n -- )   HERE CELL+ , CELLS ALLOT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Create a bag "x" with X items.
\end_layout

\begin_layout Scrap

<<BAG>>=
\begin_inset Newline newline
\end_inset

: BAG ( n -name- )   CREATE BUILD-BAG DOES> ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make the BAG empty.
\end_layout

\begin_layout Scrap

<<!BAG>>=
\begin_inset Newline newline
\end_inset

: !BAG ( bag -- )   DUP CELL+ SWAP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For the BAG : it IS non-empty.
\end_layout

\begin_layout Scrap

<<BAG?>>=
\begin_inset Newline newline
\end_inset

: BAG? ( bag -- )   @+ = 0= ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Push ITEM to the BAG
\end_layout

\begin_layout Scrap

<<BAG+!>>=
\begin_inset Newline newline
\end_inset

: BAG+! ( x bag -- )   DUP >R @ ! 0 CELL+ R> +! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
From BAG: pop ITEM
\end_layout

\begin_layout Scrap

<<BAG@->>=
\begin_inset Newline newline
\end_inset

: BAG@- ( bag -- x )   0 CELL+ NEGATE OVER +! @ @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Remove entry at ADDRESS from BAG.
\end_layout

\begin_layout Scrap

<<BAG-REMOVE>>=
\begin_inset Newline newline
\end_inset

: BAG-REMOVE ( a bag -- )
\begin_inset Newline newline
\end_inset

    >R  DUP CELL+ SWAP  OVER R@ @ SWAP - MOVE  -1 CELLS R> +! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make hole at ADDRESS in BAG.
\end_layout

\begin_layout Scrap

<<BAG-HOLE>>=
\begin_inset Newline newline
\end_inset

: BAG-HOLE ( a bag -- )
\begin_inset Newline newline
\end_inset

    >R  DUP CELL+   OVER R@ @ SWAP - MOVE   0 CELL+ R> +! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Insert VALUE at ADDRESS in BAG.
\end_layout

\begin_layout Scrap

<<BAG-INSERT>>=
\begin_inset Newline newline
\end_inset

: BAG-INSERT ( x a bag -- )   OVER SWAP BAG-HOLE ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For BAG : NUMBER of items.
\end_layout

\begin_layout Scrap

<<|BAG|>>=
\begin_inset Newline newline
\end_inset

: |BAG| ( bag -- n )   @+ SWAP - 0 CELL+ / ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Loop over a bag, see '
\family typewriter
\series bold
.BAG
\family default
\series default
' for an example.
\end_layout

\begin_layout Scrap

<<BAG-LOOP>>=
\begin_inset Newline newline
\end_inset

: DO-BAG  POSTPONE @+ POSTPONE SWAP POSTPONE ?DO ; IMMEDIATE
\begin_inset Newline newline
\end_inset

: LOOP-BAG 0 CELL+ POSTPONE LITERAL POSTPONE +LOOP ; IMMEDIATE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print BAG.
\end_layout

\begin_layout Scrap

<<.BAG>>=
\begin_inset Newline newline
\end_inset

: .BAG ( bag -- )   DO-BAG  I ?  LOOP-BAG ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For VALUE and BAG : ADDRESS of value in bag/nill.
\end_layout

\begin_layout Scrap

<<BAG-WHERE>>=
\begin_inset Newline newline
\end_inset

: BAG-WHERE ( x bag -- a )   DO-BAG  DUP I @ = IF
\begin_inset Newline newline
\end_inset

        DROP I UNLOOP EXIT  THEN
\begin_inset Newline newline
\end_inset

    LOOP-BAG  DROP 0 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For VALUE and BAG : value IS present in bag.
\end_layout

\begin_layout Scrap

<<IN-BAG?>>=
\begin_inset Newline newline
\end_inset

: IN-BAG? ( x bag -- )   BAG-WHERE 0= 0= ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Remove VALUE from BAG.
\end_layout

\begin_layout Scrap

<<BAG->>=
\begin_inset Newline newline
\end_inset

: BAG- ( x bag -- )   DUP >R   BAG-WHERE   R> BAG-REMOVE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add/remove VALUE to bag, used as a SET, i.e.
 no duplicates.
\end_layout

\begin_layout Scrap

<<SET>>=
\begin_inset Newline newline
\end_inset

: SET+ ( x bag -- )   2DUP IN-BAG? IF 2DROP ELSE BAG+! THEN ;
\begin_inset Newline newline
\end_inset

: SET- ( x bag -- )   2DUP IN-BAG? IF BAG- ELSE 2DROP THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Bin search
\end_layout

\begin_layout Standard
Uses a comparison routine with execution token 'COMP'.
 'COMP' must have the stack diagram ( IT -- flag) , where flag typically
 means that IT compares lower or equal to some fixed value.
 It may be  TRUE , FALSE or undefined for `IMIN' , but it must be monotonic
 down in the range [IMIN,IMAX), i.e.
 if IMIN<=IX<=IY<IMAX then if IX COMP gives false, IY COMP cannot give true.
\end_layout

\begin_layout Standard

\family typewriter
\series bold
BIN-SEARCH
\family default
\series default
 finds the first index 'IT' between 'IMIN' and 'IMAX' (exclusive) for which
 'COMP' returns false or else 'IMAX'.
 An empty range is possible, (e.g.
 'IMIN' and 'IMAX' are equal).
\end_layout

\begin_layout Scrap

<<BIN-SEARCH>>=
\begin_inset Newline newline
\end_inset

: BIN-SEARCH ( n IMIN, n IMAX, xt COMP -- n IRES )   >R
\begin_inset Newline newline
\end_inset

    BEGIN       
\backslash
 Loop variant IMAX - IMIN
\begin_inset Newline newline
\end_inset

        2DUP  <> WHILE
\begin_inset Newline newline
\end_inset

            2DUP + 2/  ( -- ihalf )
\begin_inset Newline newline
\end_inset

            DUP R@ EXECUTE IF
\begin_inset Newline newline
\end_inset

                1+  SWAP ROT DROP 
\backslash
 Replace IMIN
\begin_inset Newline newline
\end_inset

            ELSE
\begin_inset Newline newline
\end_inset

                SWAP DROP 
\backslash
 Replace IMAX
\begin_inset Newline newline
\end_inset

            THEN
\begin_inset Newline newline
\end_inset

    REPEAT
\begin_inset Newline newline
\end_inset

    R> 2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Quick sort
\end_layout

\begin_layout Standard
Make QSORT safe by allowing an empty range.
 Not tested and maybe not necessary.
\end_layout

\begin_layout Scrap

<<QSORT-SAFE>>=
\begin_inset Newline newline
\end_inset


\backslash
 : QSORT-SAFE 2>R 2DUP < IF 2R> QSORT ELSE 2DROP 2R> 2DROP THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ANS Forth specific
\end_layout

\begin_layout Standard
The 
\family typewriter
\series bold
QSORT
\family default
\series default
 facility is part of 
\family typewriter
\series bold
lina
\family default
\series default
, so it must be added to ANS Forths.
\end_layout

\begin_layout Standard
Sort the range FIRST to LAST (inclusive) of item compared by the xt COMPARING
 and exchanged by the xt EXHANGING.
 All indices in this range must be proper to pass to the xt's.
 The xt's are filled in into 
\family typewriter
\series bold
*<
\family default
\series default
 and 
\family typewriter
\series bold
*<-->
\family default
\series default
 and must observe the interface.
 After the call we have that : For FIRST<=I<J<=LAST      I J *<--> EXECUTE
 leaves TRUE.
\end_layout

\begin_layout Scrap

<<QSORT>>=
\begin_inset Newline newline
\end_inset

( QSORT ) 
\backslash
 AvdH A2apr22
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 Compare item N1 and N2.
 Return 'N1' IS lower and not equal.
\begin_inset Newline newline
\end_inset

VARIABLE *<
\begin_inset Newline newline
\end_inset


\backslash
 Exchange item N1 and N2.
\begin_inset Newline newline
\end_inset

VARIABLE *<-->
\begin_inset Newline newline
\end_inset

<<PARTITION>>
\begin_inset Newline newline
\end_inset

<<(QSORT)>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: QSORT ( xt1 xt2 -- )   *<--> !  *< !  (QSORT) ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Partition inclusive range LO HI leaving LO_1 HI_1 LO_2 HI_2.
\end_layout

\begin_layout Scrap

<<PARTITION>>=
\begin_inset Newline newline
\end_inset

: PARTITION   2DUP + 2/   >R  ( R: median)
\begin_inset Newline newline
\end_inset

    2DUP BEGIN      ( lo_1 hi_2 lo_2 hi_1)
\begin_inset Newline newline
\end_inset

        SWAP BEGIN  DUP R@ *< @ EXECUTE WHILE  1+  REPEAT
\begin_inset Newline newline
\end_inset

        SWAP BEGIN  R@ OVER *< @ EXECUTE WHILE  1-  REPEAT
\begin_inset Newline newline
\end_inset

        2DUP > 0= IF
\begin_inset Newline newline
\end_inset

            
\backslash
 Do we have a new position for our pivot?
\begin_inset Newline newline
\end_inset

            OVER R@ = IF R> DROP DUP >R ELSE
\begin_inset Newline newline
\end_inset

                DUP  R@ = IF R> DROP OVER >R THEN THEN
\begin_inset Newline newline
\end_inset

            2DUP *<--> @ EXECUTE
\begin_inset Newline newline
\end_inset

            >R 1+ R> 1-
\begin_inset Newline newline
\end_inset

        THEN
\begin_inset Newline newline
\end_inset

    2DUP > UNTIL    ( lo_1 hi_2 lo_2 hi_1)
\begin_inset Newline newline
\end_inset

    R> DROP                            ( R: )
\begin_inset Newline newline
\end_inset

    SWAP ROT ;      ( lo_1 hi_1 lo_2 hi_2)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Sort the range LOW to HIGH inclusive observing 'LOW' and 'HIGH' must be
 indices compatible with the current values of 
\family typewriter
\series bold
*<
\family default
\series default
 and 
\family typewriter
\series bold
*<-->
\family default
\series default
.
\end_layout

\begin_layout Scrap

<<(QSORT)>>=
\begin_inset Newline newline
\end_inset

: (QSORT)             ( lo hi -- )
\begin_inset Newline newline
\end_inset

    PARTITION         ( lo_1 hi_1 lo_2 hi_2)
\begin_inset Newline newline
\end_inset

    2DUP < IF  RECURSE  ELSE  2DROP  THEN
\begin_inset Newline newline
\end_inset

    2DUP < IF  RECURSE  ELSE  2DROP  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Invented names
\end_layout

\begin_layout Standard
Make ADDRESS return some label NAME, static memory so use immediately.
\end_layout

\begin_layout Scrap

<<INVENT-NAME>>=
\begin_inset Newline newline
\end_inset

: INVENT-NAME   s" L" NAME-BUF $!   0 8 (DH.) NAME-BUF $+! NAME-BUF $@ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS and NAME: "that name WAS invented".
\end_layout

\begin_layout Scrap

<<INVENTED-NAME?>>=
\begin_inset Newline newline
\end_inset

: INVENTED-NAME? ( a1 a2 n -- flag )  9 <> IF  2DROP 0
\begin_inset Newline newline
\end_inset

    ELSE  SWAP INVENT-NAME CORA 0=  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<INVENTED-NAMES>>=
\begin_inset Newline newline
\end_inset

CREATE NAME-BUF   256 ALLOT
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<INVENT-NAME>>
\begin_inset Newline newline
\end_inset

<<INVENTED-NAME?>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-INVENT-NAME
\begin_inset Newline newline
\end_inset

    assert( 42 INVENT-NAME S" L00000042" COMPARE 0= )
\begin_inset Newline newline
\end_inset

    assert( 42 S" L00000043" INVENTED-NAME? 0= )
\begin_inset Newline newline
\end_inset

    assert( 42 S" L00000042" INVENTED-NAME? -1 = )
\begin_inset Newline newline
\end_inset

; TEST-INVENT-NAME
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Miscellaneous
\end_layout

\begin_layout Standard
Debug comments.
\end_layout

\begin_layout Scrap

<<debug>>=
\begin_inset Newline newline
\end_inset

: 
\backslash
D POSTPONE 
\backslash
 ;
\begin_inset Newline newline
\end_inset


\backslash
 : 
\backslash
D ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Missing conditionals.
\end_layout

\begin_layout Scrap

<<=<>=>>=
\begin_inset Newline newline
\end_inset

[DEFINED] >= 0= [IF] : >= < 0= ; [THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] <= 0= [IF] : <= > 0= ; [THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If FLAG is not zero, output STRING on the error channel and exit with an
 error code of 2.
\end_layout

\begin_layout Scrap

<<?ABORT>>=
\begin_inset Newline newline
\end_inset

: ?ABORT ROT IF ETYPE 2 EXIT-CODE ! BYE ELSE 2DROP THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ANS Forth specific
\end_layout

\begin_layout Standard
Exchange the content at ADDR1 and ADDR2 over a fixed LENGTH.
\end_layout

\begin_layout Scrap

<<EXCHANGE>>=
\begin_inset Newline newline
\end_inset

: EXCHANGE ( a1 a2 n -- )   0 ?DO  OVER I +  OVER I +  OVER C@  OVER C@
\begin_inset Newline newline
\end_inset

        >R SWAP C!  R> SWAP C!  LOOP  2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ciForth specific
\end_layout

\begin_layout Standard
Print name of following definition.
\end_layout

\begin_layout Scrap

<<.NFA>>=
\begin_inset Newline newline
\end_inset

: .^   .S R@ @ >NFA @ $@ TYPE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Reverse Engineering Assembler
\end_layout

\begin_layout Standard
This file '
\family typewriter
\series bold
asgen.frt
\family default
\series default
' contains generic tools and has been used to make assemblers for 8080 8086
 80386 Alpha 6809 and should be usable for Pentium 68000 6502 8051.
 It should run on ISO Forth's provided some ciforth facilities are present
 or emulated.
 The assemblers -- with some care -- have the property that the disassembled
 code can be assembled to the exact same code.
\end_layout

\begin_layout Standard
Most instruction sets follow this basic idea that they contain three distinct
 parts:
\end_layout

\begin_layout Enumerate
the opcode that identifies the operation
\end_layout

\begin_layout Enumerate
modifiers such as the register working on
\end_layout

\begin_layout Enumerate
data, as a bit field in the instruction.
\end_layout

\begin_layout Enumerate
data, including addresses or offsets.
\end_layout

\begin_layout Standard
This assembler goes through three stages for each instruction:
\end_layout

\begin_layout Enumerate
postit: assembles the opcode with holes for the modifiers.
 This has a fixed length.
 Also posts requirements for commaers.
\end_layout

\begin_layout Enumerate
fixup: fill up the holes, either from the beginning or the end of the post.
 These can also post required commaers.
\end_layout

\begin_layout Enumerate
fixup's with data.
 It has user supplied data in addition to opcode bits.
 Both together fill up bits left by a postit.
\end_layout

\begin_layout Enumerate
The commaers.
 Any user supplied data in addition to opcode, that can be added as separate
 bytes.
 Each has a separate command, where checks are built in.
\end_layout

\begin_layout Standard
Keeping track of this is done by bit arrays, similar to the a.i.
 blackboard concept.
 This is ONLY to notify the user of mistakes, they are NOT needed for the
 assembler proper.
 This setup allows a complete check of validity of code and complete control
 over what code is generated.
 Even so all checks can be defeated if need be.
\end_layout

\begin_layout Standard
The generic tools include:
\end_layout

\begin_layout Itemize
the defining words:
\begin_inset Newline newline
\end_inset

for 1 2 3 4 byte postits,
\begin_inset Newline newline
\end_inset

for fixups from front and behind
\begin_inset Newline newline
\end_inset

for comma-ers.
\end_layout

\begin_layout Itemize
showing a list of possible instructions, for all opcodes or for a single
 one.
\end_layout

\begin_layout Itemize
disassembly of a single instruction or a range.
\end_layout

\begin_layout Itemize
hooks for more tools, e.g.
 print the opcode map as postscript.
\end_layout

\begin_layout Itemize
hooks for prefix instructions
\end_layout

\begin_layout Itemize
hooks for classes of instructions, to be turned off as a whole.
\end_layout

\begin_layout Standard
To write an assembler, make the tables, generate the complete list of instructio
ns, assemble it and disassemble it again.
 If equal, you have a starting point for confidence in your work.
\end_layout

\begin_layout Standard
This code was at some time big-endian dependant and assumed a 32 bit machine!
 It is not sure that all traces of this have vanished.
 You cannot use this program as a cross-assembler if there are instructions
 that don't fit in a hosts cell (i.e.
 its postit) IT USES THE VOCABULARY AS A LINKED LIST OF STRUCTS (ciforth)!
 IT USED KNOWLEDGE OF THE INTERPRETER AND THE HEADERS! Now if you think
 that this makes this code non-portable, think again.
 You have to change about 8 lines to adapt.
 Now if you only have to adapt 8 lines in a 40k lines c-program with the
 same functionality, it would smack portable.
 Wouldn't it?
\end_layout

\begin_layout Standard
The blackboard consist of three bit arrays.
 At the start of an instruction they are all zero.
 '
\family typewriter
\series bold
TALLY-BI
\family default
\series default
' '
\family typewriter
\series bold
TALLY-BY
\family default
\series default
' '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' keep track of instruction bits, instruction byte and bad things respectively.
\end_layout

\begin_layout Standard
An instructions generally has a single postit that defines the opcode.
 It assembles the opcode, advancing '
\family typewriter
\series bold
HERE
\family default
\series default
' leaving zero bits that needs still filling in by fixups.
 It sets these bits in '
\family typewriter
\series bold
TALLY-BI
\family default
\series default
'.
 It may also post that commaers are required by setting a bit in '
\family typewriter
\series bold
TALLY-BY
\family default
\series default
'.
\end_layout

\begin_layout Standard
Then comes the fixups.
 They fill up the holes left in the instruction -- before '
\family typewriter
\series bold
HERE
\family default
\series default
' -- by or-ing and maintain '
\family typewriter
\series bold
TALLY-BI
\family default
\series default
', resetting bits.
 They end in '
\family typewriter
\series bold
|
\family default
\series default
' where the other assembly actions end in '
\family typewriter
\series bold
,
\family default
\series default
'.
 They may require more commaers, posting to '
\family typewriter
\series bold
TALLY-BY
\family default
\series default
'.
 The commaers advance '
\family typewriter
\series bold
HERE
\family default
\series default
' by a whole number of bytes assembling user supplied information and reset
 the corresponding bits in '
\family typewriter
\series bold
TALLY-BY
\family default
\series default
'.
\end_layout

\begin_layout Standard
All parts of an instruction can add bits to '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
'.
 If any two consecutive bits are up this is bad.
 Its bits can never be reset but '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' is reset as a whole at the start of an instruction.
\end_layout

\begin_layout Standard
An example: load an index register with a 16 bit value, 8080.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TALLY-BI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TALLY-BY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TALLY-BA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HERE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A43 4 DUMP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0801
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A43
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
..
 ..
 ..
 ..
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
LXI,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0030
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0002
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0002
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A44
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
01 ..
 ..
 ..
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
SP|
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0002
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0002
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A44
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
31 ..
 ..
 ..
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
SP0 @ X,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0002
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A46
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
31 00 FE ..
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
HLT,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
31 00 FE 76
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The bit in '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' means a 16 bit operation.
 Now if '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' contains 3 it would mean that it is at the same time an 8 bit and 16 bit
 operation.
 Bad!                                                  )
\end_layout

\begin_layout Standard
The following problems can be detected:
\end_layout

\begin_layout Itemize
postit when '
\family typewriter
\series bold
TALLY-BI
\family default
\series default
' or '
\family typewriter
\series bold
TALLY-BY
\family default
\series default
' contains bits up
\end_layout

\begin_layout Itemize
setting or resetting bits for the second time in '
\family typewriter
\series bold
TALLY-BI
\family default
\series default
' or '
\family typewriter
\series bold
TALLY-BY
\family default
\series default
'
\end_layout

\begin_layout Itemize
commaing when '
\family typewriter
\series bold
TALLY-BI
\family default
\series default
' still contains bits up
\end_layout

\begin_layout Itemize
setting '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' bad
\end_layout

\begin_layout Standard
A prefix PostIt has its prefix field filled in with an execution token.
 This token represents the action performed on the 
\family typewriter
\series bold
TALLY-BA
\family default
\series default
 flags, that is used instead of resetting it.
 This can be used for example for the OS -- operand size -- prefix in the
 Pentium.
 Instead of putting the information that we are in a 16 bit operand segment
 in 
\family typewriter
\series bold
TALLY-BA
\family default
\series default
, it transforms that information to 32 bit.
\end_layout

\begin_layout Scrap

<<asgen.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: asgen.frt,v 4.31 2005/03/07 11:54:58 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<prelude>>
\begin_inset Newline newline
\end_inset

( ############### PART I ASSEMBLER ####################################
 )
\begin_inset Newline newline
\end_inset

<<assembler-utilities>>
\begin_inset Newline newline
\end_inset

<<dependant-utilities>>
\begin_inset Newline newline
\end_inset

<<independant-utilities>>
\begin_inset Newline newline
\end_inset

<<assembler-bookkeeping>>
\begin_inset Newline newline
\end_inset

<<assembler-defining-words>>
\begin_inset Newline newline
\end_inset

<<obsolescent>>
\begin_inset Newline newline
\end_inset

<<preferred>>
\begin_inset Newline newline
\end_inset

<<end-preferred>>
\begin_inset Newline newline
\end_inset

<<super-defining-words>>
\begin_inset Newline newline
\end_inset

( ############### PART II DISASSEMBLER ################################
 )
\begin_inset Newline newline
\end_inset

<<structures>>
\begin_inset Newline newline
\end_inset

<<tryers>>
\begin_inset Newline newline
\end_inset

<<disassemblers>>
\begin_inset Newline newline
\end_inset

<<defining-words>>
\begin_inset Newline newline
\end_inset

<<conveniences>>
\begin_inset Newline newline
\end_inset

PREVIOUS 
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Prelude
\end_layout

\begin_layout Standard
Wrapper for asgen, when we want to test without label mechanisms.
 These are hot patched for reverse engineering.
\end_layout

\begin_layout Scrap

<<prelude>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    : (?ERROR) ( f n -- )   swap if throw else drop then ;
\begin_inset Newline newline
\end_inset

    CREATE '?ERROR   ' (?ERROR) DUP , ,   : ?ERROR '?ERROR @ EXECUTE ;
\begin_inset Newline newline
\end_inset

    
\begin_inset Newline newline
\end_inset

    -warning
\begin_inset Newline newline
\end_inset

    : ?CSP ( -- ) ; 
\backslash
 check stack
\begin_inset Newline newline
\end_inset

    : !CSP ( -- ) ; 
\backslash
 set stack check
\begin_inset Newline newline
\end_inset

    +warning
\begin_inset Newline newline
\end_inset

    : ?EXEC ( -- ) ;
\begin_inset Newline newline
\end_inset

    : asm-create ( -- )   create ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    : asm-create ( -- )   (WORD) (CREATE) ;
\begin_inset Newline newline
\end_inset

    REQUIRE ALIAS
\begin_inset Newline newline
\end_inset

    REQUIRE @+ ( Fetch from ADDRES.
 Leave incremented ADDRESS and DATA )
\begin_inset Newline newline
\end_inset

    REQUIRE BAG
\begin_inset Newline newline
\end_inset

    REQUIRE POSTFIX
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 Vectors that are hot-patched in aswrap.frt
\begin_inset Newline newline
\end_inset

CREATE 'AS-ALLOT   ' ALLOT DUP , ,   : AS-ALLOT 'AS-ALLOT @ EXECUTE ;
\begin_inset Newline newline
\end_inset

CREATE 'AS-HERE    ' HERE DUP , ,    : AS-HERE 'AS-HERE @ EXECUTE ;
\begin_inset Newline newline
\end_inset

CREATE 'AS-C,      ' C, DUP , ,      : AS-C, 'AS-C, @ EXECUTE ;
\begin_inset Newline newline
\end_inset

CREATE '_AP_       ' HERE DUP , ,    : _AP_ '_AP_ @ EXECUTE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: (-ADORN-ADDRESS) DROP CR ;   ( Action between two disassembled instr.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

CREATE 'ADORN-ADDRESS   ' (-ADORN-ADDRESS) DUP , ,
\begin_inset Newline newline
\end_inset

: ADORN-ADDRESS ( a -- )   'ADORN-ADDRESS @ EXECUTE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Maybe not present utilities
\end_layout

\begin_layout Scrap

<<assembler-utilities>>=
\begin_inset Newline newline
\end_inset

<<!+>>
\begin_inset Newline newline
\end_inset

<<@->>
\begin_inset Newline newline
\end_inset

<<CTRL>>
\begin_inset Newline newline
\end_inset

<<TABLE1>>
\begin_inset Newline newline
\end_inset

<<ROTLEFT>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    'TABLE1 HIDDEN
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Store DATA to ADDRES.
 Leave incremented ADDRESS
\end_layout

\begin_layout Scrap

<<!+>>=
\begin_inset Newline newline
\end_inset

: !+ ( x a -- a' )   >R R@ ! R> CELL+ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fetch from decremented ADDRES.
 Leave DATA and ADDRESS
\end_layout

\begin_layout Scrap

<<@->>=
\begin_inset Newline newline
\end_inset

: @- ( a -- x a' )   0 CELL+ - >R R@ @ R>  ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<CTRL>>=
\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: CTRL CHAR 31 AND ;
\begin_inset Newline newline
\end_inset

: [CTRL] CTRL POSTPONE LITERAL ; IMMEDIATE
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard

\family typewriter
\series bold
x TABLE1 + @
\family default
\series default
 yields $100^[-x mod 4]
\end_layout

\begin_layout Scrap

<<TABLE1>>=
\begin_inset Newline newline
\end_inset

CREATE TABLE1   1 , 1 ,
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Rotate X by I bytes left leaving X' Left i.e.
 such as it appears in memory! Not as printed on a big endian machine! aqa
 "
\family typewriter
\series bold
8 * LSHIFT
\family default
\series default
" on bigendian.
\end_layout

\begin_layout Scrap

<<ROTLEFT>>=
\begin_inset Newline newline
\end_inset

: ROTLEFT ( x n -- x' )   TABLE1 + @ UM* OR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
System dependant utilities
\end_layout

\begin_layout Standard
Common fields in the defining words for posits fixups and commaers.
 All leave a single ADDRESS.
 The first data field for a postit/fixup contains instruction bits, for
 a commaer it contains the xt of the comma action for a data fixup it contains
 the position of the bits.
\end_layout

\begin_layout Scrap

<<dependant-utilities>>=
\begin_inset Newline newline
\end_inset

: %>BODY ; ( From DEA to the DATA field of a created word, now the same
 )
\begin_inset Newline newline
\end_inset

: %BODY> ; ( Reverse of above)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: DEA-FIELD ( u size -- u' )   CREATE  OVER , +
\begin_inset Newline newline
\end_inset

    DOES> ( dea -- a )   @ SWAP %>BODY + ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

0
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >LFA    ( link to previous word for compatibility  
 )
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >NFA    ( variable length name field is at the end 
 )
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >DATA
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

( Work on TALLY-BI etc.
        Effects  for posits fixups and commaers.
 )
\begin_inset Newline newline
\end_inset

(                                            |||    |||       |||      
 )
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >BI                    ( OR!    AND!      --       
 )
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >BY                    ( OR!    OR!       AND!     
 )
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >BA                    ( OR!U   OR!U      OR!U     
 )
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >CNT    ( `HERE' advances with count )
\begin_inset Newline newline
\end_inset

  0 CELLS DEA-FIELD >DIS    ( disassembler only for COMMA , 0 -> default)
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >PRF    ( prefix flag, only for PI ,    0 -> default)
\begin_inset Newline newline
\end_inset

  1 CELLS DEA-FIELD >DFA    ( type of word, replacing the DOES> check  
 )
\begin_inset Newline newline
\end_inset

CONSTANT |DEA| ( the name is tacked onto the end when it is created    
 )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<ID.>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

VOCABULARY ASSEMBLER IMMEDIATE
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: Assem   ONLY FORTH ALSO POSTPONE ASSEMBLER ALSO DEFINITIONS ; IMMEDIATE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Assem HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    <<'alias>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<DOES>>
\begin_inset Newline newline
\end_inset

<<IGNORE?>>
\begin_inset Newline newline
\end_inset

<<VOCEND?>>
\begin_inset Newline newline
\end_inset

<<NEXT>>
\begin_inset Newline newline
\end_inset

<<STARTVOC>>
\begin_inset Newline newline
\end_inset

<<IS-A>>
\begin_inset Newline newline
\end_inset

<<MEMBER>>
\begin_inset Newline newline
\end_inset

<<?ERROR->>
\begin_inset Newline newline
\end_inset

<<CREATE-->>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a definition's name from its DEA.
\end_layout

\begin_layout Scrap

<<ID.>>=
\begin_inset Newline newline
\end_inset

: %ID.
 >NFA @ $@ TYPE SPACE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
From DEA to the 
\family typewriter
\series bold
DOES>
\family default
\series default
 pointer for a '
\family typewriter
\series bold
DOES>
\family default
\series default
' word
\end_layout

\begin_layout Scrap

<<DOES>>=
\begin_inset Newline newline
\end_inset

: %>DOES ( dea -- x ) >DFA ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Leave for DEA : it is to be ignored in disassemblies.
 This is used for supressing the bare bones of the sib mechanism in i586.
\end_layout

\begin_layout Scrap

<<IGNORE?>>=
\begin_inset Newline newline
\end_inset

: IGNORE? >NFA @ CHAR+ C@ [CHAR] ~ = ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Given a DEA, return the next DEA.
 For a DEA as returned from 
\family typewriter
\series bold
(>NEXT%)
\family default
\series default
 : it is the end, not a real DEA.
\end_layout

\begin_layout Scrap

<<VOCEND?>>=
\begin_inset Newline newline
\end_inset

: VOCEND? ( dea -- f )   >LFA @ 0= ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
As 
\family typewriter
\series bold
(>NEXT%)
\family default
\series default
 but skip holes, i.e.
 words with names starting in '
\family typewriter
\series bold
-
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<NEXT>>=
\begin_inset Newline newline
\end_inset

: (>NEXT%) ( dea -- dea )   >LFA @ ;
\begin_inset Newline newline
\end_inset

: >NEXT% ( dea -- dea' )   BEGIN  (>NEXT%) DUP >NFA @ CHAR+ C@
\begin_inset Newline newline
\end_inset

    [CHAR] - - UNTIL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Leave the first DEA of the assembler vocabulary.
\end_layout

\begin_layout Scrap

<<STARTVOC>>=
\begin_inset Newline newline
\end_inset

0 VALUE STARTVOC ( -- dea )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Build: allocate place to remember a 
\family typewriter
\series bold
DOES>
\family default
\series default
 address of a '
\family typewriter
\series bold
CREATE
\family default
\series default
'd word.
 Leave that ADDRESS to be filled in by '
\family typewriter
\series bold
REMEMBER
\family default
\series default
' Execution: Leave for DEA : it is of same type as the remembered 
\family typewriter
\series bold
DOES>
\family default
\series default
.
\end_layout

\begin_layout Scrap

<<IS-A>>=
\begin_inset Newline newline
\end_inset

VARIABLE 'IS-A   1 'IS-A !
\begin_inset Newline newline
\end_inset

: IS-A ( -- )   CREATE  'IS-A @ ,  DOES> ( dea -- f ) @ SWAP %>DOES @ =
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Patch up the data field of a preceeding word defined by '
\family typewriter
\series bold
IS-A
\family default
\series default
'.
 To be called when sitting at the 
\family typewriter
\series bold
DOES>
\family default
\series default
 address.
 The 
\family typewriter
\series bold
!CSP
\family default
\series default
 / 
\family typewriter
\series bold
?CSP
\family default
\series default
 detects stack changes.
 Now split it into 2 checks.
\end_layout

\begin_layout Scrap

<<MEMBER>>=
\begin_inset Newline newline
\end_inset

: MEMBER ( n -- )   STARTVOC >DFA ! ;
\begin_inset Newline newline
\end_inset

: REMEMBER ( -- )   ?CSP  'IS-A @ POSTPONE LITERAL  POSTPONE MEMBER
\begin_inset Newline newline
\end_inset

    1 'IS-A +!  !CSP ; IMMEDIATE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Also needed : ?ERROR that defeats all checks.
\end_layout

\begin_layout Scrap

<<?ERROR->>=
\begin_inset Newline newline
\end_inset


\backslash
 : ?ERROR DROP DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Behaves as 'CREATE' except, if the word to be created has name "--" it is
 ignored, by making the header unfindable.
 Not strictly needed.
\end_layout

\begin_layout Scrap

<<CREATE-->>=
\begin_inset Newline newline
\end_inset

: CREATE--   SAVE-INPUT  BL WORD $@ $, >R  RESTORE-INPUT THROW
\begin_inset Newline newline
\end_inset

    R> DUP $@ S" --" COMPARE 0= IF  -warning CREATE +warning
\begin_inset Newline newline
\end_inset

    ELSE  CREATE  THEN  HERE DUP >R  |DEA| DUP ALLOT  ERASE
\begin_inset Newline newline
\end_inset

    R@ >NFA !  STARTVOC R@ >LFA !  R> TO STARTVOC ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ciForth specific
\end_layout

\begin_layout Standard
Make an alias for "
\family typewriter
\series bold
'
\family default
\series default
" in the minimum search order called "
\family typewriter
\series bold
%
\family default
\series default
".
\end_layout

\begin_layout Scrap

<<'alias>>=
\begin_inset Newline newline
\end_inset

'ONLY >WID CURRENT !    
\backslash
 Making ONLY the CONTEXT is dangerous! This will do.
\begin_inset Newline newline
\end_inset

"'" 'ONLY >WID (FIND)   ALIAS %         ( "'" ) 2DROP
\begin_inset Newline newline
\end_inset

CONTEXT @ CURRENT !     
\backslash
 Restore current.
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
System independant utilities
\end_layout

\begin_layout Standard
Note that the assembler works with multi-character bigendian numbers.
\end_layout

\begin_layout Scrap

<<independant-utilities>>=
\begin_inset Newline newline
\end_inset

<<CONTAINED-IN>>
\begin_inset Newline newline
\end_inset

<<lsbyte,>>
\begin_inset Newline newline
\end_inset

<<lsbyte-at>>
\begin_inset Newline newline
\end_inset

<<lsbytes>>
\begin_inset Newline newline
\end_inset

<<MCat>>
\begin_inset Newline newline
\end_inset

<<MC<0>>
\begin_inset Newline newline
\end_inset

<<MC@-S>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The FIRST bitset is contained in the SECOND one, leaving it IS.
\end_layout

\begin_layout Scrap

<<CONTAINED-IN>>=
\begin_inset Newline newline
\end_inset

: CONTAINED-IN OVER AND = ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Compile the ls 8 bits of X at here, leaving the REMAINING bits.
\end_layout

\begin_layout Scrap

<<lsbyte,>>=
\begin_inset Newline newline
\end_inset

: lsbyte, DUP AS-C, 0008 RSHIFT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For X and ADDRESS , add the byte below address to x at l.s.
 place.
 Leave X and decremented ADDRESS.
\end_layout

\begin_layout Scrap

<<lsbyte-at>>=
\begin_inset Newline newline
\end_inset

: lsbyte@ 1- SWAP 8 LSHIFT OVER C@ OR SWAP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For X ADDRESS LENGTH , return the NUMBER that at address (bigendian).
 x provides a filler, -1 results in sign extension.
\end_layout

\begin_layout Scrap

<<lsbytes>>=
\begin_inset Newline newline
\end_inset

: lsbytes  >R R@ + BEGIN R> DUP WHILE 1- >R  lsbyte@ REPEAT 2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS LENGTH , return the NUMBER that is there (bigendian).
 "Multiple byte fetch".
\end_layout

\begin_layout Scrap

<<MCat>>=
\begin_inset Newline newline
\end_inset

: MC@ 0 ROT ROT lsbytes ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS LENGTH , return the "number there IS negative".
\end_layout

\begin_layout Scrap

<<MC<0>>=
\begin_inset Newline newline
\end_inset

: MC<0 + 1- C@ 80 AND 80 = ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS LENGTH , return the NUMBER that is there.
 bigendian and signextended.
 "Multiple byte fetch, signed".
\end_layout

\begin_layout Scrap

<<MC@-S>>=
\begin_inset Newline newline
\end_inset

: MC@-S 2DUP MC<0 ROT ROT lsbytes ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Assembler bookkeeping
\end_layout

\begin_layout Standard
The bookkeeping is needed for error detection and disassembly.
\end_layout

\begin_layout Scrap

<<assembler-bookkeeping>>=
\begin_inset Newline newline
\end_inset

<<TALLY-BI>>
\begin_inset Newline newline
\end_inset

<<TALLY-BY>>
\begin_inset Newline newline
\end_inset

<<TALLY-BA>>
\begin_inset Newline newline
\end_inset

<<BA-DEFAULT>>
\begin_inset Newline newline
\end_inset

<<OLDCOMMA>>
\begin_inset Newline newline
\end_inset

<<ISS>>
\begin_inset Newline newline
\end_inset

<<ISL>>
\begin_inset Newline newline
\end_inset

<<BA-XT>>
\begin_inset Newline newline
\end_inset

<<RESET-BAD>>
\begin_inset Newline newline
\end_inset

<<!TALLY>>
\begin_inset Newline newline
\end_inset

<<AT-REST?>>
\begin_inset Newline newline
\end_inset

<<BADPAIRS?>>
\begin_inset Newline newline
\end_inset

<<CONSISTENT?>>
\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

<<CHECK26>>
\begin_inset Newline newline
\end_inset

<<CHECK32>>
\begin_inset Newline newline
\end_inset

<<CHECK31>>
\begin_inset Newline newline
\end_inset

<<CHECK31A>>
\begin_inset Newline newline
\end_inset

<<CHECK32B>>
\begin_inset Newline newline
\end_inset

<<CHECK33>>
\begin_inset Newline newline
\end_inset

<<CHECK28>>
\begin_inset Newline newline
\end_inset

<<CHECK29>>
\begin_inset Newline newline
\end_inset

<<CHECK30>>
\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset

<<OR!>>
\begin_inset Newline newline
\end_inset

<<AND!>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bits that need to be fixed up.
\end_layout

\begin_layout Scrap

<<TALLY-BI>>=
\begin_inset Newline newline
\end_inset

VARIABLE TALLY-BI
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bits represent a commaer that is to be supplied.
\end_layout

\begin_layout Scrap

<<TALLY-BY>>=
\begin_inset Newline newline
\end_inset

VARIABLE TALLY-BY
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
State bits, bad if two consequitive bits are up.
\end_layout

\begin_layout Scrap

<<TALLY-BA>>=
\begin_inset Newline newline
\end_inset

VARIABLE TALLY-BA
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bits set in the default can be used to exclude certain classes of instructions,
 e.g.
 because they are not implemented.
\end_layout

\begin_layout Scrap

<<BA-DEFAULT>>=
\begin_inset Newline newline
\end_inset

VARIABLE BA-DEFAULT    0 BA-DEFAULT !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Previous comma, or zero.
\end_layout

\begin_layout Scrap

<<OLDCOMMA>>=
\begin_inset Newline newline
\end_inset

VARIABLE OLDCOMMA
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Start of current instruction.
\end_layout

\begin_layout Scrap

<<ISS>>=
\begin_inset Newline newline
\end_inset

VARIABLE ISS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Length of current instruction
\end_layout

\begin_layout Scrap

<<ISL>>=
\begin_inset Newline newline
\end_inset

VARIABLE ISL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
To be executed instead of reset BA between prefix and instruction.
\end_layout

\begin_layout Scrap

<<BA-XT>>=
\begin_inset Newline newline
\end_inset

VARIABLE BA-XT
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Reset '
\family typewriter
\series bold
BA
\family default
\series default
' to default for begin instruction, unless prefix.
\end_layout

\begin_layout Scrap

<<RESET-BAD>>=
\begin_inset Newline newline
\end_inset

: RESET-BAD ( -- )   BA-XT @ DUP IF EXECUTE ELSE
\begin_inset Newline newline
\end_inset

        DROP  BA-DEFAULT @ TALLY-BA ! THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Initialise '
\family typewriter
\series bold
TALLY
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<!TALLY>>=
\begin_inset Newline newline
\end_inset

: !TALLY ( -- )   0 TALLY-BI !   0 TALLY-BY !   RESET-BAD   0 OLDCOMMA !
 ;
\begin_inset Newline newline
\end_inset

    0 BA-XT !   !TALLY
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return: instruction IS complete, or not started.
\end_layout

\begin_layout Scrap

<<AT-REST?>>=
\begin_inset Newline newline
\end_inset

: AT-REST? TALLY-BI @ 0=   TALLY-BY @ 0=  AND ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For N : it CONTAINS bad pairs.
\end_layout

\begin_layout Scrap

<<BADPAIRS?>>=
\begin_inset Newline newline
\end_inset

: BADPAIRS? DUP 1 LSHIFT AND AAAAAAAAAAAAAAAA AND ;
\begin_inset Newline newline
\end_inset

: BAD? TALLY-BA @ BADPAIRS? ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The state of assembling is inconsistent.
 If STATUS were added to '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' would that create a bad situation?
\end_layout

\begin_layout Scrap

<<CONSISTENT?>>=
\begin_inset Newline newline
\end_inset

: CONSISTENT? TALLY-BA @ OR BADPAIRS? 0= ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate errors.
 None have net stack effects, such that they may be replaced by NULL definitions.
 Error at postit time.
\end_layout

\begin_layout Scrap

<<CHECK26>>=
\begin_inset Newline newline
\end_inset

: CHECK26 AT-REST? 0= ABORT" PREVIOUS INSTRUCTION INCOMPLETE" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Always an error.
\end_layout

\begin_layout Scrap

<<CHECK32>>=
\begin_inset Newline newline
\end_inset

: CHECK32 BAD? ABORT" PREVIOUS OPCODE PLUS FIXUPS INCONSISTENT" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate error for fixup, if for the BI, some of the BITS would stick out
 it.
 Leave MASK and BITS .
 Programming error!
\end_layout

\begin_layout Scrap

<<CHECK31>>=
\begin_inset Newline newline
\end_inset

: CHECK31 2DUP SWAP CONTAINED-IN 0=
\begin_inset Newline newline
\end_inset

    ABORT" DESIGN ERROR, INCOMPATIBLE MASK" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate error for ``FIXUP-DATA'' , if the BI and the LEN are not compatible.
 Leave BI and LEN .
 Programming error!
\end_layout

\begin_layout Scrap

<<CHECK31A>>=
\begin_inset Newline newline
\end_inset

: CHECK31A 2DUP OVER >R RSHIFT 1 OR OVER LSHIFT R> <>
\begin_inset Newline newline
\end_inset

    ABORT" DESIGN ERROR, INCOMPATIBLE MASK" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The part of BITS outside of BITFIELD must be either all ones or zeros.
 This checks for a shifted signed field.
\end_layout

\begin_layout Scrap

<<CHECK32B>>=
\begin_inset Newline newline
\end_inset

: CHECK32B  2DUP OR INVERT 0= ( all ones) >R
\begin_inset Newline newline
\end_inset

    INVERT AND 0= ( all zero's ) R> OR ( okay)
\begin_inset Newline newline
\end_inset

    0= ABORT" PREVIOUS OPCODE PLUS FIXUPS INCONSISTENT" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate error for postit, if for the inverted BI , some of the the BITS
 would stick out it.
 Leave MASK and BITS .
 Programming error!
\end_layout

\begin_layout Scrap

<<CHECK33>>=
\begin_inset Newline newline
\end_inset

: CHECK33 2DUP SWAP INVERT CONTAINED-IN 0=
\begin_inset Newline newline
\end_inset

    ABORT" DESIGN ERROR, INCOMPATIBLE MASK" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
BITS would stick out it.
 Leave MASK and BITS .
 Programming error! Generate error on data for postit/fixup, if some BITS
 to fill in are already in the MASK.
 Leave BITS and MASK.
\end_layout

\begin_layout Scrap

<<CHECK28>>=
\begin_inset Newline newline
\end_inset

: CHECK28 2DUP AND ABORT" UNEXPECTED FIXUP/COMMAER" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate error on data for commaer, if the BITS to reset are not present
 in the MASK.
 Leave BITS and MASK.
\end_layout

\begin_layout Scrap

<<CHECK29>>=
\begin_inset Newline newline
\end_inset

: CHECK29 2DUP OR -1 - ABORT" DUPLICATE FIXUP/UNEXPECTED COMMAER" ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate error if COMMAMASK is not in ascending order.
 Leave IT.
\end_layout

\begin_layout Scrap

<<CHECK30>>=
\begin_inset Newline newline
\end_inset

: CHECK30 DUP OLDCOMMA @ < ABORT" COMMAERS IN WRONG ORDER"
\begin_inset Newline newline
\end_inset

    DUP OLDCOMMA ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Or DATA into ADDRESS.
 If bits were already up its wrong.
\end_layout

\begin_layout Scrap

<<OR!>>=
\begin_inset Newline newline
\end_inset

: OR! >R R@ @  CHECK28 OR R> ! ;
\begin_inset Newline newline
\end_inset

: OR!U >R R@ @  OR R> ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Or DATA into ADDRESS.
 Unchecked.
 Reset bits of DATA into ADDRESS.
 If bits were already down it's wrong.
\end_layout

\begin_layout Scrap

<<AND!>>=
\begin_inset Newline newline
\end_inset

: AND! >R INVERT R@ @ CHECK29 AND R> ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Assembler defining words
\end_layout

\begin_layout Scrap

<<assembler-defining-words>>=
\begin_inset Newline newline
\end_inset

<<assemble,>>
\begin_inset Newline newline
\end_inset

<<!POSTIT>>
\begin_inset Newline newline
\end_inset

<<TALLY:,>>
\begin_inset Newline newline
\end_inset

<<POSTIT>>
\begin_inset Newline newline
\end_inset

<<BUILD-IP>>
\begin_inset Newline newline
\end_inset

<<PIS>>
\begin_inset Newline newline
\end_inset

<<IS-PI>>
\begin_inset Newline newline
\end_inset

<<TALLY:|>>
\begin_inset Newline newline
\end_inset

<<FIXUP>>
\begin_inset Newline newline
\end_inset

<<xFI>>
\begin_inset Newline newline
\end_inset

<<TRIM-SIGNED>>
\begin_inset Newline newline
\end_inset

<<FIXUP-DATA>>
\begin_inset Newline newline
\end_inset

<<FIXUP-SIGNED>>
\begin_inset Newline newline
\end_inset

<<DFI>>
\begin_inset Newline newline
\end_inset

<<DFIs>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Assemble INSTRUCTION for ``ISL'' bytes.
 ls byte first.
\end_layout

\begin_layout Scrap

<<assemble,>>=
\begin_inset Newline newline
\end_inset

: assemble, ( x -- )   ISL @ 0 DO  lsbyte,  LOOP  DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Initialise in behalf of postit.
\end_layout

\begin_layout Scrap

<<!POSTIT>>=
\begin_inset Newline newline
\end_inset

: !POSTIT ( -- )   AS-HERE ISS !  0 OLDCOMMA ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bookkeeping for a postit using a pointer to the BIBYBA information, can
 fake a postit in disassembling too.
\end_layout

\begin_layout Scrap

<<TALLY:,>>=
\begin_inset Newline newline
\end_inset

: TALLY:, ( a -- )   DUP >BI @ TALLY-BI !  DUP >BY @ TALLY-BY !
\begin_inset Newline newline
\end_inset

    DUP >BA @ TALLY-BA OR!U  DUP >CNT @ ISL !  >DIS @ BA-XT ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Post the instruction using DATA.
\end_layout

\begin_layout Scrap

<<POSTIT>>=
\begin_inset Newline newline
\end_inset

: POSTIT ( a -- )   CHECK26   !TALLY   !POSTIT
\begin_inset Newline newline
\end_inset

    DUP >DATA @ >R   TALLY:,   R> assemble, ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Build an instruction given by BA BY BI the OPCODE and COUNT.
\end_layout

\begin_layout Scrap

<<BUILD-IP>>=
\begin_inset Newline newline
\end_inset

: BUILD-IP ( ba by bi opc cnt -- )   STARTVOC >CNT !  STARTVOC >DATA !
\begin_inset Newline newline
\end_inset

    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !
\begin_inset Newline newline
\end_inset

    0 ( prefix) STARTVOC >PRF ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define an instruction by BA BY BI and the OPCODE.
 For 1 2 3 and 4 byte opcodes.
\end_layout

\begin_layout Scrap

<<PIS>>=
\begin_inset Newline newline
\end_inset

IS-A IS-1PI : 1PI  CHECK33 CREATE-- REMEMBER  1 BUILD-IP DOES>  POSTIT ;
\begin_inset Newline newline
\end_inset

IS-A IS-2PI : 2PI  CHECK33 CREATE-- REMEMBER  2 BUILD-IP DOES>  POSTIT ;
\begin_inset Newline newline
\end_inset

IS-A IS-3PI : 3PI  CHECK33 CREATE-- REMEMBER  3 BUILD-IP DOES>  POSTIT ;
\begin_inset Newline newline
\end_inset

IS-A IS-4PI : 4PI  CHECK33 CREATE-- REMEMBER  4 BUILD-IP DOES>  POSTIT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For DEA : it REPRESENTS some kind of opcode.
\end_layout

\begin_layout Scrap

<<IS-PI>>=
\begin_inset Newline newline
\end_inset

: IS-PI  >R 0
\begin_inset Newline newline
\end_inset

    R@ IS-1PI OR  R@ IS-2PI OR  R@ IS-3PI OR   R@ IS-4PI OR R> DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bookkeeping for a fixup using a pointer to the BIBYBA information, can fake
 a fixup in disassembling too.
\end_layout

\begin_layout Scrap

<<TALLY:|>>=
\begin_inset Newline newline
\end_inset

: TALLY:| ( a -- )   DUP >BI @ TALLY-BI AND!  DUP >BY @ TALLY-BY OR!
\begin_inset Newline newline
\end_inset

    >BA @ TALLY-BA OR!U ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fix up the instruction using a pointer to DATA.
\end_layout

\begin_layout Scrap

<<FIXUP>>=
\begin_inset Newline newline
\end_inset

: FIXUP>   DUP >DATA @ ISS @ OR!   TALLY:|   CHECK32 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define a fixup by BA BY BI and the FIXUP bits.
 One size fits all, because of the or character of the operations.
\end_layout

\begin_layout Scrap

<<xFI>>=
\begin_inset Newline newline
\end_inset

IS-A IS-xFI : xFI  CHECK31 CREATE-- REMEMBER STARTVOC >DATA !
\begin_inset Newline newline
\end_inset

    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA ! DOES>  FIXUP> ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For a signed DATA item a LENGTH and a BITFIELD.
 Shift the data item into the bit field and leave IT.
 Check if it doesn't fit.
\end_layout

\begin_layout Scrap

<<TRIM-SIGNED>>=
\begin_inset Newline newline
\end_inset

: TRIM-SIGNED >R   2DUP R@ SWAP RSHIFT CHECK32B   LSHIFT R> AND ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fix up the instruction using DATA and a pointer to the bit POSITION.
\end_layout

\begin_layout Scrap

<<FIXUP-DATA>>=
\begin_inset Newline newline
\end_inset

: FIXUP-DATA ( a -- )   DUP >DATA @  SWAP >R  LSHIFT ISS @ OR!
\begin_inset Newline newline
\end_inset

    R> TALLY:|  CHECK32 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fix up the instruction using DATA and a pointer to the bit POSITION.
\end_layout

\begin_layout Scrap

<<FIXUP-SIGNED>>=
\begin_inset Newline newline
\end_inset

: FIXUP-SIGNED ( a -- )   DUP >DATA @  SWAP >R
\begin_inset Newline newline
\end_inset

    R@ >BI @ TRIM-SIGNED ISS @ OR!
\begin_inset Newline newline
\end_inset

    R> TALLY:| CHECK32 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define a data fixup by BA BY BI, and LEN the bit position.
 At assembly time: expect DATA that is shifted before use.
 One size fits all, because of the or character of the operations.
\end_layout

\begin_layout Scrap

<<DFI>>=
\begin_inset Newline newline
\end_inset

IS-A IS-DFI : DFI  CHECK31A CREATE-- REMEMBER STARTVOC >DATA !
\begin_inset Newline newline
\end_inset

    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !  DOES>  FIXUP-DATA ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Same, but for signed data.
\end_layout

\begin_layout Scrap

<<DFIs>>=
\begin_inset Newline newline
\end_inset

IS-A IS-DFIs : DFIs  CHECK31A CREATE-- REMEMBER STARTVOC >DATA !
\begin_inset Newline newline
\end_inset

    STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !  DOES>  FIXUP-SIGNED
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Obsolescent
\end_layout

\begin_layout Scrap

<<obsolescent>>=
\begin_inset Newline newline
\end_inset

<<REVERSE-BYTES>>
\begin_inset Newline newline
\end_inset

<<CORRECT-R>>
\begin_inset Newline newline
\end_inset

<<TALLY:|R>>
\begin_inset Newline newline
\end_inset

<<FIXUP<>>
\begin_inset Newline newline
\end_inset

<<FIR>>
\begin_inset Newline newline
\end_inset

<<DFIR>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Reverses bytes in a WORD.
 Return IT.
\end_layout

\begin_layout Scrap

<<REVERSE-BYTES>>=
\begin_inset Newline newline
\end_inset

: REVERSE-BYTES
\begin_inset Newline newline
\end_inset

    1 CELLS 0 DO DUP  FF AND SWAP 8 RSHIFT   LOOP
\begin_inset Newline newline
\end_inset

    8 CELLS 0 DO SWAP I LSHIFT OR   8 +LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Rotate the MASK etc from a fixup-from-reverse into a NEW mask fit for using
 from the start of the instruction.
 We know the length!
\end_layout

\begin_layout Scrap

<<CORRECT-R>>=
\begin_inset Newline newline
\end_inset

: CORRECT-R 0 CELL+ ISL @ - ROTLEFT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bookkeeping for a fixup-from-reverse using a pointer to the BIBYBA information,
 can fake a fixup in disassembling too.
\end_layout

\begin_layout Scrap

<<TALLY:|R>>=
\begin_inset Newline newline
\end_inset

: TALLY:|R ( a -- )   DUP >BI @ CORRECT-R TALLY-BI AND!
\begin_inset Newline newline
\end_inset

    DUP >BY @ TALLY-BY OR!  >BA @ TALLY-BA OR!U ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fix up the instruction from reverse with DATA.
\end_layout

\begin_layout Scrap

<<FIXUP<>>=
\begin_inset Newline newline
\end_inset

: FIXUP<   CORRECT-R ISS @ OR! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define a fixup-from-reverse by BA BY BI and the FIXUP bits.
 One size fits all, because of the character of the or-operations.
 BI and fixup are specified that last byte is lsb, such as you read it.
\end_layout

\begin_layout Scrap

<<FIR>>=
\begin_inset Newline newline
\end_inset

IS-A IS-FIR : FIR  CHECK31 CREATE-- REMEMBER REVERSE-BYTES STARTVOC >DATA
 !
\begin_inset Newline newline
\end_inset

    REVERSE-BYTES STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !
\begin_inset Newline newline
\end_inset

    DOES>  DUP >DATA @  FIXUP< TALLY:|R  CHECK32 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define a fixup-from-reverse by BA BY BI and LEN to shift.
 One size fits all, because of the character of the or-operations.
 BI and fixup are specified that last byte is lsb, such as you read it.
\end_layout

\begin_layout Scrap

<<DFIR>>=
\begin_inset Newline newline
\end_inset

IS-A IS-DFIR : DFIR  CHECK31 CREATE-- REMEMBER STARTVOC >DATA !
\begin_inset Newline newline
\end_inset

    REVERSE-BYTES STARTVOC >BI !  STARTVOC >BY !  STARTVOC >BA !
\begin_inset Newline newline
\end_inset

    DOES>  DUP >DATA @  SWAP >R  LSHIFT REVERSE-BYTES FIXUP<
\begin_inset Newline newline
\end_inset

        R> TALLY:|R  CHECK32 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Preferred
\end_layout

\begin_layout Scrap

Not yet used???
\end_layout

\begin_layout Scrap

<<preferred>>=
\begin_inset Newline newline
\end_inset

<<(AND!BYTE)>>
\begin_inset Newline newline
\end_inset

<<AND!BYTE>>
\begin_inset Newline newline
\end_inset

<<(OR!BYTE)>>
\begin_inset Newline newline
\end_inset

<<OR!BYTE>>
\begin_inset Newline newline
\end_inset

<<TALLY:|R'>>
\begin_inset Newline newline
\end_inset

<<FIXUP<'>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If bits were already down it is wrong, for next two words.
 Reset bits of DATA into ADDRESS bytewise.
\end_layout

\begin_layout Scrap

<<(AND!BYTE)>>=
\begin_inset Newline newline
\end_inset

: (AND!BYTE) >R 0FF AND INVERT R@ C@ CHECK29 AND R> C! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Reset bits of DATA byte by byte into ADDRESS.
\end_layout

\begin_layout Scrap

<<AND!BYTE>>=
\begin_inset Newline newline
\end_inset

: AND!BYTE BEGIN 2DUP (AND!BYTE) SWAP 8 RSHIFT DUP WHILE SWAP 1+ REPEAT
 2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If bits were already up its wrong, for next two words.
 Or DATA into ADDRESS bytewise.
\end_layout

\begin_layout Scrap

<<(OR!BYTE)>>=
\begin_inset Newline newline
\end_inset

: (OR!BYTE) >R R@ C@  CHECK28 OR R> C! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Or DATA byte by byte from behind into ADDRESS.
\end_layout

\begin_layout Scrap

<<OR!BYTE>>=
\begin_inset Newline newline
\end_inset

: OR!BYTE BEGIN 1- 2DUP (OR!BYTE) SWAP 8 RSHIFT DUP WHILE SWAP REPEAT 2DROP
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bookkeeping for a fixup-from-reverse using a pointer to the BIBYBA information,
 can fake a fixup in disassembling too.
\end_layout

\begin_layout Scrap

<<TALLY:|R'>>=
\begin_inset Newline newline
\end_inset

: TALLY:|R'  DUP >BI @ TALLY-BI AND!BYTE  DUP >BY @ TALLY-BY OR!
\begin_inset Newline newline
\end_inset

    >BA @ TALLY-BA OR!U ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fix up the instruction from reverse using a pointer to DATA.
\end_layout

\begin_layout Scrap

<<FIXUP<'>>=
\begin_inset Newline newline
\end_inset

: FIXUP<'   DUP >DATA @ ISS @ ISL @ + OR!BYTE  TALLY:|R'  CHECK32 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
End preferred
\end_layout

\begin_layout Scrap

<<end-preferred>>=
\begin_inset Newline newline
\end_inset

<<TALLY:,,>>
\begin_inset Newline newline
\end_inset

<<COMMA>>
\begin_inset Newline newline
\end_inset

<<COMMAER>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Bookkeeping for a commaer using a pointer to the BIBYBA information.
 Not used by the disassembler.
\end_layout

\begin_layout Scrap

<<TALLY:,,>>=
\begin_inset Newline newline
\end_inset

: TALLY:,, ( a -- )   DUP >BY @ CHECK30 TALLY-BY AND!  >BA @ TALLY-BA OR!U
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<COMMA>>=
\begin_inset Newline newline
\end_inset

: COMMA ( a -- )   DUP >DATA @ >R  TALLY:,,  CHECK32  R> EXECUTE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Build with an disassembly ROUTINE, with the LENGTH to comma, the BA BY informati
on and the ADDRESS that is executing the commaer.
 A disassembly routine gets the ``DEA'' of the commaer on stack.
\end_layout

\begin_layout Scrap

<<COMMAER>>=
\begin_inset Newline newline
\end_inset

IS-A IS-COMMA : COMMAER CREATE-- REMEMBER STARTVOC >DATA !  0 STARTVOC >BI
 !
\begin_inset Newline newline
\end_inset

    STARTVOC >BY !  STARTVOC >BA !  STARTVOC >CNT !  STARTVOC >DIS !
\begin_inset Newline newline
\end_inset

    DOES>  COMMA ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Assembler super defining words
\end_layout

\begin_layout Scrap

<<super-defining-words>>=
\begin_inset Newline newline
\end_inset

<<PRO-TALLY>>
\begin_inset Newline newline
\end_inset

<<T!>>
\begin_inset Newline newline
\end_inset

<<T!R>>
\begin_inset Newline newline
\end_inset

<<Tat>>
\begin_inset Newline newline
\end_inset

<<FAMILIES>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Prototype for TALLY-BI BY BA.
\end_layout

\begin_layout Scrap

<<PRO-TALLY>>=
\begin_inset Newline newline
\end_inset

CREATE PRO-TALLY 3 CELLS ALLOT
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fill in the tally prototype with BA BY BI.
\end_layout

\begin_layout Scrap

<<T!>>=
\begin_inset Newline newline
\end_inset

: T! PRO-TALLY !+ !+ !+ DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Reversed BI information.
\end_layout

\begin_layout Scrap

<<T!R>>=
\begin_inset Newline newline
\end_inset

: T!R   REVERSE-BYTES T! ; 
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Get the data from the tally prototype back BA BY BI.
\end_layout

\begin_layout Scrap

<<Tat>>=
\begin_inset Newline newline
\end_inset

: T@ PRO-TALLY 3 CELLS +  @- @- @- DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add INCREMENT to the OPCODE a NUMBER of times, and generate as much instructions
, all with the same BI-BA-BY from '
\family typewriter
\series bold
PRO-TALLY
\family default
\series default
'.
 For each assembler defining word there is a corresponding family word.
 Words named "--" are mere placeholders.
\end_layout

\begin_layout Scrap

<<FAMILIES>>=
\begin_inset Newline newline
\end_inset

: 1FAMILY,    0 DO   DUP >R T@ R> 1PI   OVER + LOOP DROP DROP ;
\begin_inset Newline newline
\end_inset

: 2FAMILY,    0 DO   DUP >R T@ R> 2PI   OVER + LOOP DROP DROP ;
\begin_inset Newline newline
\end_inset

: 3FAMILY,    0 DO   DUP >R T@ R> 3PI   OVER + LOOP DROP DROP ;
\begin_inset Newline newline
\end_inset

: 4FAMILY,    0 DO   DUP >R T@ R> 4PI   OVER + LOOP DROP DROP ;
\begin_inset Newline newline
\end_inset

: xFAMILY|    0 DO   DUP >R T@ R> xFI   OVER + LOOP DROP DROP ;
\begin_inset Newline newline
\end_inset

: FAMILY|R    0 DO   DUP >R T@ REVERSE-BYTES R> FIR   OVER + LOOP DROP DROP
 ;
\begin_inset Newline newline
\end_inset

: xFAMILY|F   0 DO   DUP >R T@ R> DFI   OVER + LOOP DROP DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Disassembler data structures
\end_layout

\begin_layout Scrap

<<structures>>=
\begin_inset Newline newline
\end_inset

<<DISS>>
\begin_inset Newline newline
\end_inset

: !DISS DISS !BAG ;
\begin_inset Newline newline
\end_inset

: .DISS-AUX DISS @+ SWAP DO
\begin_inset Newline newline
\end_inset

        I @ DUP IS-COMMA OVER IS-DFI OR OVER IS-DFIs OR IF I DISS - .
 THEN
\begin_inset Newline newline
\end_inset

        [DEFINED] ForSwiftForth [IF]  .'  [THEN]
\begin_inset Newline newline
\end_inset

        [DEFINED] ForGForth [IF]  ID.
  [THEN]
\begin_inset Newline newline
\end_inset

    0 CELL+ +LOOP  CR ;
\begin_inset Newline newline
\end_inset

<<DISS-VECTOR>>
\begin_inset Newline newline
\end_inset

: +DISS DISS BAG+! ;
\begin_inset Newline newline
\end_inset

: DISS? DISS BAG? ;
\begin_inset Newline newline
\end_inset

<<DISS->>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
A row of dea's representing a disassembly.
\end_layout

\begin_layout Scrap

<<DISS>>=
\begin_inset Newline newline
\end_inset

12 BAG DISS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard

\family typewriter
\series bold
DISS-VECTOR
\family default
\series default
 can be redefined to generate testsets.
\end_layout

\begin_layout Scrap

<<DISS-VECTOR>>=
\begin_inset Newline newline
\end_inset

VARIABLE DISS-VECTOR    ' .DISS-AUX DISS-VECTOR !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Discard last item of '
\family typewriter
\series bold
DISS
\family default
\series default
'
\end_layout

\begin_layout Scrap

<<DISS->>=
\begin_inset Newline newline
\end_inset

: DISS- 0 CELL+ NEGATE DISS +! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Tryers
\end_layout

\begin_layout Standard
Tryers try to construct an instruction from current bookkeeping.
 They can backtrack to show all possibilities.
\end_layout

\begin_layout Scrap

<<tryers>>=
\begin_inset Newline newline
\end_inset

<<TRY-PI>>
\begin_inset Newline newline
\end_inset

<<TRY-xFI>>
\begin_inset Newline newline
\end_inset

<<TRY-DFI>>
\begin_inset Newline newline
\end_inset

<<TRY-FIR>>
\begin_inset Newline newline
\end_inset

<<TRY-COMMA>>
\begin_inset Newline newline
\end_inset

<<REBUILD>>
\begin_inset Newline newline
\end_inset

<<BACKTRACK>>
\begin_inset Newline newline
\end_inset

<<RESULT?>>
\begin_inset Newline newline
\end_inset

<<.RESULT>>
\begin_inset Newline newline
\end_inset


\backslash
     % RESULT +DISS Spurious? Remove after next total test.
\begin_inset Newline newline
\end_inset

<<SHOW-STEP>>
\begin_inset Newline newline
\end_inset

<<SHOW-ALL>>
\begin_inset Newline newline
\end_inset

<<SHOW-OPCODES>>
\begin_inset Newline newline
\end_inset

<<SHOW:>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
These tryers are quite similar: if the DEA on the stack is of the right
 type and if the precondition is fullfilled it does the reassuring actions
 toward the tally as with assembling and add the fixup/posti/commaer to
 the disassembly struct.
 as if this instruction were assembled.
 Leave the DEA.
\end_layout

\begin_layout Scrap

<<TRY-PI>>=
\begin_inset Newline newline
\end_inset

: TRY-PI
\begin_inset Newline newline
\end_inset

    DUP IS-PI IF
\begin_inset Newline newline
\end_inset

    AT-REST? IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:,
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<TRY-xFI>>=
\begin_inset Newline newline
\end_inset

: TRY-xFI
\begin_inset Newline newline
\end_inset

    DUP IS-xFI IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<TRY-DFI>>=
\begin_inset Newline newline
\end_inset

: TRY-DFI
\begin_inset Newline newline
\end_inset

    DUP IS-DFI OVER IS-DFIs OR IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<TRY-FIR>>=
\begin_inset Newline newline
\end_inset

: TRY-FIR
\begin_inset Newline newline
\end_inset

    DUP IS-FIR IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ CORRECT-R TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|R
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<TRY-COMMA>>=
\begin_inset Newline newline
\end_inset

: TRY-COMMA
\begin_inset Newline newline
\end_inset

    DUP IS-COMMA IF
\begin_inset Newline newline
\end_inset

    DUP >BY @ TALLY-BY @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:,,
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate bookkeeping such as to correspond with '
\family typewriter
\series bold
DISS
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<REBUILD>>=
\begin_inset Newline newline
\end_inset

: REBUILD
\begin_inset Newline newline
\end_inset

    !TALLY
\begin_inset Newline newline
\end_inset

    DISS? IF
\begin_inset Newline newline
\end_inset

        DISS @+ SWAP !DISS DO  ( Get bounds before clearing)
\begin_inset Newline newline
\end_inset

            I @ TRY-PI TRY-xFI TRY-DFI TRY-FIR TRY-COMMA DROP
\begin_inset Newline newline
\end_inset

        0 CELL+ +LOOP
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Discard the last item of the disassembly -- it is either used up or incorrect
 --.
 Replace DEA with the proper DEA to inspect from here.
\end_layout

\begin_layout Scrap

<<BACKTRACK>>=
\begin_inset Newline newline
\end_inset

: BACKTRACK
\begin_inset Newline newline
\end_inset

(   S" BACKTRACKING" TYPE                                              
 )
\begin_inset Newline newline
\end_inset

    DROP DISS @ @- DISS !
\begin_inset Newline newline
\end_inset

(   DROP DISS @ 0 CELL+ - @                                            
 )
\begin_inset Newline newline
\end_inset

(   S" Failed at :" TYPE DUP ID.
 CR                                     )
\begin_inset Newline newline
\end_inset

    >NEXT%
\begin_inset Newline newline
\end_inset

(   DISS-                                                              
 )
\begin_inset Newline newline
\end_inset

    REBUILD ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If the disassembly contains something: '
\family typewriter
\series bold
AT-REST?
\family default
\series default
' means we have gone full cycle rest->postits->fixups->commaers.
 Return: the disassembly contains a result.
\end_layout

\begin_layout Scrap

<<RESULT?>>=
\begin_inset Newline newline
\end_inset

: RESULT? AT-REST? DISS? AND   BAD? 0= AND ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If present, print a result and continue searching for a new last item.
\end_layout

\begin_layout Scrap

<<.RESULT>>=
\begin_inset Newline newline
\end_inset

: .RESULT
\begin_inset Newline newline
\end_inset

    RESULT? IF
\begin_inset Newline newline
\end_inset

        DISS-VECTOR @ EXECUTE
\begin_inset Newline newline
\end_inset

        DISS-
\begin_inset Newline newline
\end_inset

        REBUILD
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Try to expand the current instruction in '
\family typewriter
\series bold
DISS
\family default
\series default
' by looking whether DEA fits.
 Leave the next DEA.
\end_layout

\begin_layout Scrap

<<SHOW-STEP>>=
\begin_inset Newline newline
\end_inset

: SHOW-STEP
\begin_inset Newline newline
\end_inset

    TRY-PI TRY-DFI TRY-xFI TRY-FIR TRY-COMMA
\begin_inset Newline newline
\end_inset

    .RESULT
\begin_inset Newline newline
\end_inset

    >NEXT%
\begin_inset Newline newline
\end_inset

(       DUP ID.
                                                         )
\begin_inset Newline newline
\end_inset

    BAD? IF BACKTRACK THEN
\begin_inset Newline newline
\end_inset

    BEGIN DUP VOCEND? DISS? AND WHILE BACKTRACK REPEAT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Show all the instructions present in the assembler vocabulary.
\end_layout

\begin_layout Scrap

<<SHOW-ALL>>=
\begin_inset Newline newline
\end_inset

: SHOW-ALL ( -- )
\begin_inset Newline newline
\end_inset

    !DISS   !TALLY
\begin_inset Newline newline
\end_inset

    STARTVOC BEGIN
\begin_inset Newline newline
\end_inset

        SHOW-STEP
\begin_inset Newline newline
\end_inset

    DUP VOCEND? UNTIL DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Show all the opcodes present in the assembler vocabulary.
\end_layout

\begin_layout Scrap

<<SHOW-OPCODES>>=
\begin_inset Newline newline
\end_inset

: SHOW-OPCODES ( -- )
\begin_inset Newline newline
\end_inset

    !DISS   !TALLY
\begin_inset Newline newline
\end_inset

    STARTVOC BEGIN
\begin_inset Newline newline
\end_inset

        DUP IS-PI IF DUP %ID.
 THEN >NEXT%
\begin_inset Newline newline
\end_inset

    DUP VOCEND? UNTIL DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Show at least all instructions valid for the "OPCODE" given.
\end_layout

\begin_layout Scrap

<<SHOW:>>=
\begin_inset Newline newline
\end_inset

: SHOW:
\begin_inset Newline newline
\end_inset

    !DISS   !TALLY
\begin_inset Newline newline
\end_inset

    ' DUP BEGIN
\begin_inset Newline newline
\end_inset

        SHOW-STEP
\begin_inset Newline newline
\end_inset

    OVER DISS CELL+ @ - OVER VOCEND? OR UNTIL DROP DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Disassemblers
\end_layout

\begin_layout Standard
Disassemblers try to reconstruct an instruction from current bookkeeping.
 They are similar to tryers but disassemblers take one more aspect into
 account, a piece of actual code.
 They do not backtrack but fail.
\end_layout

\begin_layout Scrap

<<disassemblers>>=
\begin_inset Newline newline
\end_inset

<<AS-POINTER>>
\begin_inset Newline newline
\end_inset

<<INSTRUCTION>>
\begin_inset Newline newline
\end_inset

<<LATEST-INSTRUCTION>>
\begin_inset Newline newline
\end_inset

<<DIS-PI>>
\begin_inset Newline newline
\end_inset

<<DIS-xFI>>
\begin_inset Newline newline
\end_inset

<<DIS-DFI>>
\begin_inset Newline newline
\end_inset

<<DIS-DFIR>>
\begin_inset Newline newline
\end_inset

<<DIS-FIR>>
\begin_inset Newline newline
\end_inset

<<DIS-COMMA>>
\begin_inset Newline newline
\end_inset

<<.DFI>>
\begin_inset Newline newline
\end_inset

<<.DFIR>>
\begin_inset Newline newline
\end_inset

<<.COMMA-STANDARD>>
\begin_inset Newline newline
\end_inset

<<.COMMA-SIGNED>>
\begin_inset Newline newline
\end_inset

<<.COMMA>>
\begin_inset Newline newline
\end_inset

<<~ID.>>
\begin_inset Newline newline
\end_inset

<<.DISS>>
\begin_inset Newline newline
\end_inset

<<SHOW-MEMORY>>
\begin_inset Newline newline
\end_inset

<<((DISASSEMBLE))>>
\begin_inset Newline newline
\end_inset

<<DIS>>
\begin_inset Newline newline
\end_inset

<<FORCED-DISASSEMBLY>>
\begin_inset Newline newline
\end_inset

<<DISASSEMBLE-RANGE>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains the position that is being disassembled.
\end_layout

\begin_layout Scrap

<<AS-POINTER>>=
\begin_inset Newline newline
\end_inset

VARIABLE AS-POINTER       HERE AS-POINTER !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Get the valid part of the INSTRUCTION under examination.
\end_layout

\begin_layout Scrap

<<INSTRUCTION>>=
\begin_inset Newline newline
\end_inset

: INSTRUCTION  ISS @   ISL @   MC@ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This is kept up to date during disassembly.
 It is useful for intelligent disassemblers.
\end_layout

\begin_layout Scrap

<<LATEST-INSTRUCTION>>=
\begin_inset Newline newline
\end_inset

VARIABLE LATEST-INSTRUCTION
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
These disassemblers are quite similar: if the DEA on the stack is of the
 right type and if the precondition is fullfilled and if the dissassembly
 fits, it does the reassuring actions toward the tally as with assembling
 and add the fixup/posti/commaer to the disassembly struct.
 Leave the DEA.
\end_layout

\begin_layout Scrap

<<DIS-PI>>=
\begin_inset Newline newline
\end_inset

: DIS-PI ( dea -- dea )
\begin_inset Newline newline
\end_inset

    DUP IS-PI IF
\begin_inset Newline newline
\end_inset

    AT-REST? IF
\begin_inset Newline newline
\end_inset

    DUP >BI OVER >CNT @  MC@ INVERT
\begin_inset Newline newline
\end_inset

    >R AS-POINTER @ OVER >CNT @  MC@ R>   AND
\begin_inset Newline newline
\end_inset

    OVER >DATA @ = IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:,
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

        DUP LATEST-INSTRUCTION !
\begin_inset Newline newline
\end_inset

        AS-POINTER @ ISS !
\begin_inset Newline newline
\end_inset

        DUP >CNT @ AS-POINTER +!
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<DIS-xFI>>=
\begin_inset Newline newline
\end_inset

: DIS-xFI ( dea -- dea )
\begin_inset Newline newline
\end_inset

    DUP IS-xFI IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ INSTRUCTION AND   OVER >DATA @ = IF
\begin_inset Newline newline
\end_inset

    DUP >BA @  CONSISTENT? IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<DIS-DFI>>=
\begin_inset Newline newline
\end_inset

: DIS-DFI ( dea -- dea )
\begin_inset Newline newline
\end_inset

    DUP IS-DFI OVER IS-DFIs OR IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

    DUP >BA @  CONSISTENT? IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<DIS-DFIR>>=
\begin_inset Newline newline
\end_inset

: DIS-DFIR ( dea -- dea )
\begin_inset Newline newline
\end_inset

    DUP IS-DFIR IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ CORRECT-R   TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

    DUP >BA @  CONSISTENT? IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|R
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<DIS-FIR>>=
\begin_inset Newline newline
\end_inset

: DIS-FIR ( dea -- dea )
\begin_inset Newline newline
\end_inset

    DUP IS-FIR IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ CORRECT-R   TALLY-BI @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

    DUP >BI @ CORRECT-R   INSTRUCTION AND   OVER >DATA @ CORRECT-R = IF
\begin_inset Newline newline
\end_inset

    DUP >BA @  CONSISTENT? IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:|R
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<DIS-COMMA>>=
\begin_inset Newline newline
\end_inset

: DIS-COMMA ( dea -- dea )
\begin_inset Newline newline
\end_inset

    DUP IS-COMMA IF
\begin_inset Newline newline
\end_inset

    DUP >BY @ TALLY-BY @ CONTAINED-IN IF
\begin_inset Newline newline
\end_inset

    DUP >BA @  CONSISTENT? IF
\begin_inset Newline newline
\end_inset

        DUP TALLY:,,
\begin_inset Newline newline
\end_inset

        DUP +DISS
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a disassembly for the data-fixup DEA.
\end_layout

\begin_layout Scrap

<<.DFI>>=
\begin_inset Newline newline
\end_inset

: .DFI
\begin_inset Newline newline
\end_inset

    INSTRUCTION   OVER >BI @ AND   OVER >DATA @ RSHIFT   U.
\begin_inset Newline newline
\end_inset

    %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a disassembly for the data-fixup from reverse DEA.
\end_layout

\begin_layout Scrap

<<.DFIR>>=
\begin_inset Newline newline
\end_inset

: .DFIR
\begin_inset Newline newline
\end_inset

    INSTRUCTION   OVER >BI @ CORRECT-R AND   OVER >DATA @ RSHIFT
\begin_inset Newline newline
\end_inset

    REVERSE-BYTES CORRECT-R U.
\begin_inset Newline newline
\end_inset

    %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a standard disassembly for the commaer DEA.
\end_layout

\begin_layout Scrap

<<.COMMA-STANDARD>>=
\begin_inset Newline newline
\end_inset

: .COMMA-STANDARD
\begin_inset Newline newline
\end_inset

    AS-POINTER @ OVER >CNT @ MC@ U.
\begin_inset Newline newline
\end_inset

    DUP >CNT @ AS-POINTER +!
\begin_inset Newline newline
\end_inset

    %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a signed disassembly for the commaer DEA.
\end_layout

\begin_layout Scrap

<<.COMMA-SIGNED>>=
\begin_inset Newline newline
\end_inset

: .COMMA-SIGNED
\begin_inset Newline newline
\end_inset

    AS-POINTER @ OVER >CNT @ MC@ .
\begin_inset Newline newline
\end_inset

    DUP >CNT @ AS-POINTER +!
\begin_inset Newline newline
\end_inset

    %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the disassembly for the commaer DEA, advancing '
\family typewriter
\series bold
AS-POINTER
\family default
\series default
' past the comma-content.
\end_layout

\begin_layout Scrap

<<.COMMA>>=
\begin_inset Newline newline
\end_inset

: .COMMA   DUP >DIS @ IF   DUP >DIS @ EXECUTE   ELSE
\begin_inset Newline newline
\end_inset

        .COMMA-STANDARD   THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the DEA but with suppression, i.e.
 ignore those starting in '~'.
\end_layout

\begin_layout Scrap

<<~ID.>>=
\begin_inset Newline newline
\end_inset

: %~ID.
 DUP IGNORE? IF DROP ELSE %ID.
 THEN  ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the disassembly '
\family typewriter
\series bold
DISS
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<.DISS>>=
\begin_inset Newline newline
\end_inset

: .DISS   DISS @+ SWAP DO
\begin_inset Newline newline
\end_inset

        I @
\begin_inset Newline newline
\end_inset

        DUP IS-COMMA IF
\begin_inset Newline newline
\end_inset

            .COMMA
\begin_inset Newline newline
\end_inset

        ELSE DUP IS-DFI IF
\begin_inset Newline newline
\end_inset

            .DFI
\begin_inset Newline newline
\end_inset

        ELSE DUP IS-DFIs IF
\begin_inset Newline newline
\end_inset

            .DFI            
\backslash
 For the moment.
\begin_inset Newline newline
\end_inset

        ELSE DUP IS-DFIR IF
\begin_inset Newline newline
\end_inset

            .DFIR
\begin_inset Newline newline
\end_inset

        ELSE
\begin_inset Newline newline
\end_inset

            %~ID.
\begin_inset Newline newline
\end_inset

        THEN THEN THEN THEN
\begin_inset Newline newline
\end_inset

    0 CELL+ +LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
From 
\family typewriter
\series bold
AS-POINTER
\family default
\series default
 show memory because the code there can't be disassembled.
 Leave incremented 
\family typewriter
\series bold
AS-POINTER
\family default
\series default
.
\end_layout

\begin_layout Scrap

<<SHOW-MEMORY>>=
\begin_inset Newline newline
\end_inset

VARIABLE I-ALIGNMENT    1 I-ALIGNMENT !   ( Instruction alignment )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SHOW-MEMORY ( a -- a' )   BEGIN  COUNT C.
 S"  C, " TYPE
\begin_inset Newline newline
\end_inset

        DUP I-ALIGNMENT @ MOD WHILE  REPEAT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dissassemble one instruction from 
\family typewriter
\series bold
AS-POINTER
\family default
\series default
 starting at DEA.
 Based on what is currently left in '
\family typewriter
\series bold
TALLY
\family default
\series default
'! Leave a 
\family typewriter
\series bold
AS-POINTER
\family default
\series default
 pointing after that instruction.
\end_layout

\begin_layout Scrap

<<((DISASSEMBLE))>>=
\begin_inset Newline newline
\end_inset

: ((DISASSEMBLE)) ( a dea -- a' )
\begin_inset Newline newline
\end_inset

    SWAP
\begin_inset Newline newline
\end_inset

    DUP AS-POINTER !  >R
\begin_inset Newline newline
\end_inset

    3 SPACES
\begin_inset Newline newline
\end_inset

    ( startdea -- ) BEGIN
\begin_inset Newline newline
\end_inset

        DIS-PI DIS-xFI DIS-DFI DIS-DFIR DIS-FIR DIS-COMMA
\begin_inset Newline newline
\end_inset

        >NEXT%
\begin_inset Newline newline
\end_inset

(       DUP ID.
 S" : " TYPE  DISS-VECTOR @ EXECUTE                         )
\begin_inset Newline newline
\end_inset

    DUP VOCEND? RESULT? OR UNTIL DROP
\begin_inset Newline newline
\end_inset

    RESULT? IF
\begin_inset Newline newline
\end_inset

        .DISS     
\backslash
 Advances pointer past commaers
\begin_inset Newline newline
\end_inset

        LATEST-INSTRUCTION @ >PRF @ BA-XT !
\begin_inset Newline newline
\end_inset

        R> DROP AS-POINTER @
\begin_inset Newline newline
\end_inset

    ELSE
\begin_inset Newline newline
\end_inset

        R> SHOW-MEMORY
\begin_inset Newline newline
\end_inset

    THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dissassemble one instruction from ADDRESS using the whole instruction set
 and starting with a clean slate.
 Leave an ADDRESS pointing after that instruction.
\end_layout

\begin_layout Scrap

<<DIS>>=
\begin_inset Newline newline
\end_inset

: (DISASSEMBLE) ( a -- a' )   !DISS !TALLY STARTVOC ((DISASSEMBLE)) ;
\begin_inset Newline newline
\end_inset

: DIS ( x -- )   PAD !  PAD (DISASSEMBLE) ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Forced dissassembly of one instruction from '
\family typewriter
\series bold
AS-POINTER
\family default
\series default
'.
 Force interpretation as DEA instruction.
 This is useful for instructions that are known or hidden by another instruction
 that is found first.
\end_layout

\begin_layout Scrap

<<FORCED-DISASSEMBLY>>=
\begin_inset Newline newline
\end_inset

: FORCED-DISASSEMBLY ( dea -- )
\begin_inset Newline newline
\end_inset

    !DISS  !TALLY  AS-POINTER @ SWAP ((DISASSEMBLE)) DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dissassemble one instruction from address ONE to address TWO.
\end_layout

\begin_layout Scrap

<<DISASSEMBLE-RANGE>>=
\begin_inset Newline newline
\end_inset

: DISASSEMBLE-RANGE ( first last -- )
\begin_inset Newline newline
\end_inset

    SWAP  BEGIN DUP ADORN-ADDRESS  (DISASSEMBLE) 2DUP > 0= UNTIL  2DROP
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Defining words framework
\end_layout

\begin_layout Standard
Close an assembly definition: restore and check.
\end_layout

\begin_layout Scrap

<<defining-words>>=
\begin_inset Newline newline
\end_inset

: END-CODE
\begin_inset Newline newline
\end_inset

    ?CSP ?EXEC CHECK26 CHECK32 PREVIOUS ; IMMEDIATE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

( FIXME : we must get rid of this one )
\begin_inset Newline newline
\end_inset

: ;C POSTPONE END-CODE S" WARNING: get rid of C;" TYPE CR ; IMMEDIATE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 The following two definitions must *NOT* be in the assembler wordlist.
\begin_inset Newline newline
\end_inset

PREVIOUS DEFINITIONS DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

ALSO ASSEMBLER
\begin_inset Newline newline
\end_inset

<<CODE>>
\begin_inset Newline newline
\end_inset

<<;CODE>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define "word" using assembly instructions up till 
\family typewriter
\series bold
END-CODE
\family default
\series default
.
 One could put a '
\family typewriter
\series bold
SMUDGE
\family default
\series default
' in both.
\end_layout

\begin_layout Scrap

<<CODE>>=
\begin_inset Newline newline
\end_inset

: CODE
\begin_inset Newline newline
\end_inset

    ?EXEC ASM-CREATE POSTPONE ASSEMBLER !TALLY !CSP ; IMMEDIATE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Like '
\family typewriter
\series bold
DOES>
\family default
\series default
' but assembly code follows, closed by 
\family typewriter
\series bold
END-CODE
\family default
\series default
.
\end_layout

\begin_layout Scrap

<<;CODE>>=
\begin_inset Newline newline
\end_inset

: ;CODE
\begin_inset Newline newline
\end_inset

    ?CSP   POSTPONE (;CODE)   POSTPONE [   POSTPONE ASSEMBLER ; IMMEDIATE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Conveniences
\end_layout

\begin_layout Standard
Abbreviations for interactive use.
 In the current dictionary.
\end_layout

\begin_layout Scrap

<<conveniences>>=
\begin_inset Newline newline
\end_inset

: DDD ( a -- a' )   (DISASSEMBLE) ;
\begin_inset Newline newline
\end_inset

: D-R ( first last -- )   DISASSEMBLE-RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Notes
\end_layout

\begin_layout Enumerate
We use the abstraction of a DEA "dictionary entry address".
 aqa "xt".
 Return the DEA from "word".
 A DEA is an address that allows to get at header data like flags and names.
 In ciforth an xt will do.
\end_layout

\begin_layout Subsection
Assembler wrapper
\end_layout

\begin_layout Standard
This file hot patches some words in the prelude of asgen.frt.
 It must be loaded after asgen.frt.
\end_layout

\begin_layout Scrap

<<aswrap.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: aswrap.frt,v 1.21 2009/03/26 19:40:39 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<HOT-PATCH>>
\begin_inset Newline newline
\end_inset

<<CODE-LENGTH>>
\begin_inset Newline newline
\end_inset

<<SECTION-REGISTRY>>
\begin_inset Newline newline
\end_inset

<<CURRENT-SECTION>>
\begin_inset Newline newline
\end_inset

<<SECTION>>
\begin_inset Newline newline
\end_inset

<<DEFAULT-SECTION>>
\begin_inset Newline newline
\end_inset

<<'AS-HERE>>
\begin_inset Newline newline
\end_inset

<<TARGET-END>>
\begin_inset Newline newline
\end_inset

<<PLAUSIBLE-LABEL?>>
\begin_inset Newline newline
\end_inset

<<HOST-END>>
\begin_inset Newline newline
\end_inset

<<ORG>>
\begin_inset Newline newline
\end_inset

<<HOST>TARGET>>
\begin_inset Newline newline
\end_inset

<<TARGET>HOST>>
\begin_inset Newline newline
\end_inset

<<FILE>TARGET>>
\begin_inset Newline newline
\end_inset

<<TARGET>FILE>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 Abbreviation.
\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth NOT [IF]
\begin_inset Newline newline
\end_inset

    ' TARGET>HOST ALIAS th
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<SUB-SECTION>>
\begin_inset Newline newline
\end_inset

<<'AP>>
\begin_inset Newline newline
\end_inset

<<SWAP-AS>>
\begin_inset Newline newline
\end_inset

<<'AS-ALLOT>>
\begin_inset Newline newline
\end_inset

<<'AS-C,>>
\begin_inset Newline newline
\end_inset

<<RESB>>
\begin_inset Newline newline
\end_inset

<<RES-TIL>>
\begin_inset Newline newline
\end_inset

<<AS-ALIGN>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Copy the behaviour of the latest definition into "name" affecting all words
 already using that word.
\end_layout

\begin_layout Scrap

<<HOT-PATCH>>=
\begin_inset Newline newline
\end_inset

: HOT-PATCH ( xt -- ) ' >BODY ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Length of the code buffer.
\end_layout

\begin_layout Scrap

<<CODE-LENGTH>>=
\begin_inset Newline newline
\end_inset

VARIABLE CODE-LENGTH 2000000 CODE-LENGTH !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
A bag with the DEA's of all segments.
\end_layout

\begin_layout Scrap

<<SECTION-REGISTRY>>=
\begin_inset Newline newline
\end_inset

100 BAG SECTION-REGISTRY
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Current segment pointer.
 Create section pointers with 
\family typewriter
\series bold
FILE-OFFSET
\family default
\series default
 
\family typewriter
\series bold
TARGET-START
\family default
\series default
 and 
\family typewriter
\series bold
CODE-SPACE
\end_layout

\begin_layout Scrap

<<CURRENT-SECTION>>=
\begin_inset Newline newline
\end_inset

0 VALUE CURRENT-SECTION
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SECTION-FIELD ( u size -- u' ) CREATE OVER , +
\begin_inset Newline newline
\end_inset

    DOES> ( -- a ) @ CURRENT-SECTION + ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

0
\begin_inset Newline newline
\end_inset

    2 CELLS SECTION-FIELD SECTION-RESERVED
\begin_inset Newline newline
\end_inset

    1 CELLS SECTION-FIELD CP 
\backslash
 The local dictionary pointer ("code pointer")
\begin_inset Newline newline
\end_inset

    1 CELLS SECTION-FIELD 'CODE-SPACE 
\backslash
 Start of the code space
\begin_inset Newline newline
\end_inset

    1 CELLS SECTION-FIELD 'TARGET-START 
\backslash
 Return corresponding target address.
\begin_inset Newline newline
\end_inset

    1 CELLS SECTION-FIELD 'FILE-OFFSET 
\backslash
 Return corresponding files address.
\begin_inset Newline newline
\end_inset

CONSTANT |SECTION|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CODE-SPACE ( -- a ) 'CODE-SPACE @ ;
\begin_inset Newline newline
\end_inset

: -ORG- ( a -- ) 'TARGET-START ! ;
\begin_inset Newline newline
\end_inset

: TARGET-START ( -- a ) 'TARGET-START @ ;
\begin_inset Newline newline
\end_inset

: FILE-OFFSET ( -- a ) 'FILE-OFFSET @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Create section with 
\family typewriter
\series bold
FILE-OFFSET
\family default
\series default
 
\family typewriter
\series bold
TARGET-START
\family default
\series default
.
 Assign ample code space.
 Leave it current.
\end_layout

\begin_layout Scrap

<<SECTION>>=
\begin_inset Newline newline
\end_inset

: ((SECTION)) ( file target code -name- )
\begin_inset Newline newline
\end_inset

    SAVE-INPUT CREATE HERE DUP >R DUP SECTION-REGISTRY BAG+!
\begin_inset Newline newline
\end_inset

    |SECTION| DUP ALLOT ERASE RESTORE-INPUT THROW BL WORD $@ $, R@ >NFA
 !
\begin_inset Newline newline
\end_inset

    CURRENT-SECTION R@ >LFA ! R> TO CURRENT-SECTION DUP CP !
\begin_inset Newline newline
\end_inset

    'CODE-SPACE ! 'TARGET-START ! 'FILE-OFFSET !
\begin_inset Newline newline
\end_inset

    DOES> TO CURRENT-SECTION ;
\begin_inset Newline newline
\end_inset

: (SECTION) ( file target -- ) CODE-LENGTH @ ALLOCATE THROW ((SECTION))
 ;
\begin_inset Newline newline
\end_inset

CREATE 'SECTION ' (SECTION) DUP , , : SECTION 'SECTION @ EXECUTE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define at least one segment lest the user forgets.
\end_layout

\begin_layout Scrap

<<DEFAULT-SECTION>>=
\begin_inset Newline newline
\end_inset

: DEFAULT-SECTION ( -- )
\begin_inset Newline newline
\end_inset

    0 
\backslash
 File start address
\begin_inset Newline newline
\end_inset

    0 
\backslash
 Target start address
\begin_inset Newline newline
\end_inset

    s" SECTION the-default-section" EVALUATE ;
\begin_inset Newline newline
\end_inset

DEFAULT-SECTION
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
'
\family typewriter
\series bold
HERE
\family default
\series default
' such as used in assembly.
\end_layout

\begin_layout Scrap

<<'AS-HERE>>=
\begin_inset Newline newline
\end_inset

:NONAME ( -- a ) CP @ ; HOT-PATCH 'AS-HERE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Use only while disassembling.
 Return the END of the file as a target address (non-inclusive).
\end_layout

\begin_layout Scrap

<<TARGET-END>>=
\begin_inset Newline newline
\end_inset

: TARGET-END ( -- a ) TARGET-START CP @ CODE-SPACE - + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDR return "it is a pointing into the target space"
\end_layout

\begin_layout Scrap

<<PLAUSIBLE-LABEL?>>=
\begin_inset Newline newline
\end_inset

: PLAUSIBLE-LABEL? ( a -- f ) TARGET-START TARGET-END WITHIN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Use only while disassembling.
 The end of the code area while disassembling: a host address.
\end_layout

\begin_layout Scrap

<<HOST-END>>=
\begin_inset Newline newline
\end_inset

: HOST-END ( -- a ) CP @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Associate target ADDRESS with start of '
\family typewriter
\series bold
CODE-BUFFER
\family default
\series default
'.
 The valid range from the code buffer goes to '
\family typewriter
\series bold
CP @
\family default
\series default
' and is not affected.
\end_layout

\begin_layout Standard
Associate ADDRESS with the start of '
\family typewriter
\series bold
CODE-SPACE
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<ORG>>=
\begin_inset Newline newline
\end_inset

: ORG ( a -- ) -ORG- CODE-SPACE CP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Convert host memory ADDRESS.
 Leave target memory ADDRESS.
\end_layout

\begin_layout Scrap

<<HOST>TARGET>>=
\begin_inset Newline newline
\end_inset

: HOST>TARGET ( a -- a' ) CODE-SPACE - TARGET-START + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Convert target memory ADDRESS.
 Leave host memory ADDRESS.
\end_layout

\begin_layout Scrap

<<TARGET>HOST>>=
\begin_inset Newline newline
\end_inset

: TARGET>HOST ( a -- a' ) TARGET-START - CODE-SPACE + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Convert file memory ADDRESS.
 Leave target memory ADDRESS.
\end_layout

\begin_layout Scrap

<<FILE>TARGET>>=
\begin_inset Newline newline
\end_inset

: FILE>TARGET ( a -- a' ) FILE-OFFSET - TARGET-START + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Convert target memory ADDRESS.
 Leave file memory ADDRESS.
\end_layout

\begin_layout Scrap

<<TARGET>FILE>>=
\begin_inset Newline newline
\end_inset

: TARGET>FILE ( a -- a' ) TARGET-START - FILE-OFFSET + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<SUB-SECTION>>=
\begin_inset Newline newline
\end_inset

: SUB-SECTION ( a -name- ) DUP TARGET>FILE
\begin_inset Newline newline
\end_inset

    OVER ROT TARGET>HOST CP @ >R ((SECTION)) R> CP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Instruction pointer in assembly.
 View used in branches etc.
\end_layout

\begin_layout Scrap

<<'AP>>=
\begin_inset Newline newline
\end_inset

:NONAME ( -- a ) CP @ HOST>TARGET ; HOT-PATCH '_AP_
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Swap dictionary pointer back and forth to assembler area.
\end_layout

\begin_layout Scrap

<<SWAP-AS>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    : SWAP-AS ( -- ) CP @ DP @ CP ! DP ! ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth [IF]
\begin_inset Newline newline
\end_inset

    : SWAP-AS ( -- ) CP @ H @ CP ! H ! ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Wrapper for '
\family typewriter
\series bold
ALLOT
\family default
\series default
' such as used in assembly.
\end_layout

\begin_layout Scrap

<<'AS-ALLOT>>=
\begin_inset Newline newline
\end_inset

:NONAME ( n -- ) CP +! ; HOT-PATCH 'AS-ALLOT
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Only Needed.
 Maybe '
\family typewriter
\series bold
CP C! 1 CP +!
\family default
\series default
'.
 Wrapper for '
\family typewriter
\series bold
C,
\family default
\series default
' such as used in assembly.
\end_layout

\begin_layout Scrap

<<'AS-C,>>=
\begin_inset Newline newline
\end_inset

:NONAME ( c -- ) CP @ 1 AS-ALLOT C! ; HOT-PATCH 'AS-C,
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Reserve X bytes, without specifying a content.
\end_layout

\begin_layout Scrap

<<RESB>>=
\begin_inset Newline newline
\end_inset

: RESB ( u -- ) AS-HERE OVER AS-ALLOT SWAP ERASE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Reserve bytes till target ADDRES.
 (Compare '
\family typewriter
\series bold
ORG
\family default
\series default
'.)
\end_layout

\begin_layout Scrap

<<RES-TIL>>=
\begin_inset Newline newline
\end_inset

: RES-TIL ( a -- ) _AP_ - AS-ALLOT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Align to a target address, that is multiple of N.
\end_layout

\begin_layout Scrap

<<AS-ALIGN>>=
\begin_inset Newline newline
\end_inset

: AS-ALIGN ( n -- ) _AP_ BEGIN 2DUP SWAP MOD WHILE 1+ REPEAT RES-TIL DROP
 ; 
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
80386 Assembler
\end_layout

\begin_layout Scrap

<<asi386.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: asi386.frt,v 4.23 2005/05/09 01:00:40 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

ALSO ASSEMBLER DEFINITIONS HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<additions>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 ( ############## 80386 ASSEMBLER PROPER ###############################
 )
\begin_inset Newline newline
\end_inset

 ( The decreasing BY means that a decompiler hits them in the right    
  )
\begin_inset Newline newline
\end_inset

 ( order to reassemble.
                                                  )
\begin_inset Newline newline
\end_inset

 ( Fields: a disassembly XT,      LENGTH to comma, the BA BY information
 )
\begin_inset Newline newline
\end_inset

 ( and the XT that puts data in the dictionary.
                          )
\begin_inset Newline newline
\end_inset

 ( Where there is a placeholder ``_'' the execution token is filled in 
  )
\begin_inset Newline newline
\end_inset

 ( later.
 )
\begin_inset Newline newline
\end_inset

 (   CNT                                                               
  )
\begin_inset Newline newline
\end_inset

 ( XT   BA   BY     XT-AS          NAME                                
  )
\begin_inset Newline newline
\end_inset

   0 2  0000 00100 ' (W,) COMMAER OW,    ( obligatory word     )
\begin_inset Newline newline
\end_inset

   0 4  8000 00080 ' (L,) COMMAER (RL,)  ( cell relative to IP )
\begin_inset Newline newline
\end_inset

   0 2  4000 00080 ' (W,) COMMAER (RW,)  ( cell relative to IP )
\begin_inset Newline newline
\end_inset

   0 1  0000 00040 ' AS-C, COMMAER (RB,) ( byte relative to IP )
\begin_inset Newline newline
\end_inset

   0 2  0000 00020 ' (W,) COMMAER SG,    (  Segment: WORD      )
\begin_inset Newline newline
\end_inset

   0 1  0000 00010 ' AS-C, COMMAER P,    ( port number ; byte     )
\begin_inset Newline newline
\end_inset

   0 1  0000 00008 ' AS-C, COMMAER IS,   ( Single -obl-  byte )
\begin_inset Newline newline
\end_inset

   0 4 20002 00004 ' (L,) COMMAER IL,    ( immediate data : cell)
\begin_inset Newline newline
\end_inset

   0 2 10002 00004 ' (W,) COMMAER IW,    ( immediate data : cell)
\begin_inset Newline newline
\end_inset

   0 1  0001 00004 ' AS-C, COMMAER IB,   ( immediate byte data)
\begin_inset Newline newline
\end_inset

   0 4  8008 00002 ' (L,) COMMAER L,     ( immediate data : address/offset
 )
\begin_inset Newline newline
\end_inset

   0 2  4008 00002 ' (W,) COMMAER W,     ( immediate data : address/offset
 )
\begin_inset Newline newline
\end_inset

   0 1  0004 00002 ' AS-C, COMMAER B,    ( immediate byte : address/offset
 )
\begin_inset Newline newline
\end_inset

   _ 1  0000 00001 _    COMMAER SIB,, ( An instruction within an instruction
 )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 ( Meaning of the bits in TALLY-BA :                                   
  )
\begin_inset Newline newline
\end_inset

 ( Inconsistent:  0001 OPERAND IS BYTE     0002 OPERAND IS CELL  W/L   
  )
\begin_inset Newline newline
\end_inset

 (                0004 OFFSET  IS BYTE     0008 OFFSET  IS CELL  W/L   
  )
\begin_inset Newline newline
\end_inset

 ( By setting 0020 an opcode can force a memory reference, e.g.
 CALLFARO )
\begin_inset Newline newline
\end_inset

 (               0010 Register op         0020 Memory op               
  )
\begin_inset Newline newline
\end_inset

 (               0040 ZO|                 0080 [BP]% {16} [BP] [BP  {32}
 )
\begin_inset Newline newline
\end_inset

 (  sib:         0100 no ..
             0200 [AX +8*| DI]                )
\begin_inset Newline newline
\end_inset

 (  logical      0400 no ..
             0800 Y| Y'| Z| Z'|               )
\begin_inset Newline newline
\end_inset

 (  segment      1000 no ..
             2000 ES| ..
                      )
\begin_inset Newline newline
\end_inset

 (  AS:          4000 16 bit Addr       8000 32 bit Address            
  )
\begin_inset Newline newline
\end_inset

 (  OS:         10000 16 bit Op        20000 32 bit Operand            
  )
\begin_inset Newline newline
\end_inset

 (  Use debug   40000 no ..
            80000 CR0 ..DB0                   )
\begin_inset Newline newline
\end_inset

 (  FP:        100000 FP-specific     200000 Not FP                    
  )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 ( Names *ending* in percent BP|% -- not BP'| the prime registers -- are
 )
\begin_inset Newline newline
\end_inset

 ( only valid for 16 bits mode, or with an address overwite.
 Use W, L,   )
\begin_inset Newline newline
\end_inset

 ( appropriately.
                                                        )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

8200 0 38 T!R
\begin_inset Newline newline
\end_inset

  08 00 8 FAMILY|R AX] CX] DX] BX] 0] BP] SI] DI]
\begin_inset Newline newline
\end_inset

 8200 0 0C0 T!R
\begin_inset Newline newline
\end_inset

  40 00 4 FAMILY|R  +1* +2* +4* +8*
\begin_inset Newline newline
\end_inset

 8200 0 7 REVERSE-BYTES 1 + T!
\begin_inset Newline newline
\end_inset

  01 00 8 FAMILY|R [AX [CX [DX [BX [SP -- [SI [DI
\begin_inset Newline newline
\end_inset

 8280 00 1 REVERSE-BYTES 7 + 05 FIR [BP   ( Fits in the hole, but disallow
 ZO| )
\begin_inset Newline newline
\end_inset

 8248 02 1 REVERSE-BYTES 7 + 05 FIR [MEM  ( Fits in the hole, but requires
 ZO| )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

4120 0 07 T!R
\begin_inset Newline newline
\end_inset

   01 00 8
\begin_inset Newline newline
\end_inset

     FAMILY|R [BX+SI]% [BX+DI]% [BP+SI]% [BP+DI]% [SI]% [DI]% -- [BX]%
\begin_inset Newline newline
\end_inset

 40A0 0000 07 06 FIR [BP]%  ( Fits in the hole, safe inconsistency check)
\begin_inset Newline newline
\end_inset

 8120 0 07 T!R
\begin_inset Newline newline
\end_inset

  01 00 4 FAMILY|R [AX] [CX] [DX] [BX]
\begin_inset Newline newline
\end_inset

 8120 01 07 04 FIR ~SIB|   ( Fits in the hole, but requires ~SIB, )
\begin_inset Newline newline
\end_inset

 81A0 00 07 05 FIR [BP]   ( Fits in the hole, but disallow ZO| )
\begin_inset Newline newline
\end_inset

 8120 0 07 T!R  01 06 2 FAMILY|R [SI] [DI]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 200111 0 07 T!R  01 00 8 FAMILY|R AL| CL| DL| BL| AH| CH| DH| BH|
\begin_inset Newline newline
\end_inset

 200112 0 07 T!R
\begin_inset Newline newline
\end_inset

  01 00 8 FAMILY|R AX| CX| DX| BX| SP| BP| SI| DI|
\begin_inset Newline newline
\end_inset

 0160 00 0C0 00 FIR      ZO|
\begin_inset Newline newline
\end_inset

 0124 02 0C0 40 FIR      BO| 0128 02 0C0 80 FIR      XO|
\begin_inset Newline newline
\end_inset

 200110 00 0C0 0C0 FIR      R|
\begin_inset Newline newline
\end_inset

 204048 02 0C7 06 FIR      MEM|% ( Overrules ZO| [BP]% )
\begin_inset Newline newline
\end_inset

 208108 02 0C7 05 FIR      MEM| ( Overrules ZO| [BP] )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 241101 0000 38 T!R
\begin_inset Newline newline
\end_inset

  08 00 8 FAMILY|R AL'| CL'| DL'| BL'| AH'| CH'| DH'| BH'|
\begin_inset Newline newline
\end_inset

 241102 0000 38 T!R  08 00 8 FAMILY|R AX'| CX'| DX'| BX'| SP'| BP'| SI'|
 DI'|
\begin_inset Newline newline
\end_inset

 242100 0000  38 T!R   08 00 6 FAMILY|R ES| CS| SS| DS| FS| GS|
\begin_inset Newline newline
\end_inset

 280002 0000 138 REVERSE-BYTES T!   ( 3)
\begin_inset Newline newline
\end_inset

  08 00 5 FAMILY|R CR0| -- CR2| CR3| CR4|                 ( 3)
\begin_inset Newline newline
\end_inset

  0008 0100 8 FAMILY|R DR0| DR1| DR2| DR3| DR4| DR5| DR6| DR7| ( 3)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 200000 0000 0200 T!R  0200 00 2 FAMILY|R F| T|
\begin_inset Newline newline
\end_inset

 240401 0000 0100 0000 FIR B|
\begin_inset Newline newline
\end_inset

 240402 0000 0100 0100 FIR X|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<~SIB,>>
\begin_inset Newline newline
\end_inset

<<two-fixup-operands>>
\begin_inset Newline newline
\end_inset

<<one-fixup-operands>>
\begin_inset Newline newline
\end_inset

<<no-fixup-operands>>
\begin_inset Newline newline
\end_inset

<<special-fixups>>
\begin_inset Newline newline
\end_inset

<<no-fixups>>
\begin_inset Newline newline
\end_inset

<<SIB-bytes>>
\begin_inset Newline newline
\end_inset

<<AS:,OS:,>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

( ############## 80386 ASSEMBLER PROPER END ###########################
 )
\begin_inset Newline newline
\end_inset

<<Rx,alt>>
\begin_inset Newline newline
\end_inset

<<BITS>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

BITS-32
\begin_inset Newline newline
\end_inset

PREVIOUS DEFINITIONS DECIMAL
\begin_inset Newline newline
\end_inset

( ############## 8086 ASSEMBLER POST ##################################
 )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
These definitions are such that they work regardless of the endianness of
 the host.
 Lay down word (16 bits) and long (32 bits) constants.
\end_layout

\begin_layout Scrap

<<additions>>=
\begin_inset Newline newline
\end_inset

 : (W,) lsbyte, lsbyte, DROP ;
\begin_inset Newline newline
\end_inset

 : (L,) lsbyte, lsbyte, lsbyte, lsbyte, DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fill in the transformation to TALLY-BA for 
\family typewriter
\series bold
AS:,
\family default
\series default
 and 
\family typewriter
\series bold
OS:,
\family default
\series default
 This flags them as prefixes.
 The toggle inverts the 16 and 32 bits at the same time.
\end_layout

\begin_layout Scrap

<<AS:,OS:,>>=
\begin_inset Newline newline
\end_inset

:NONAME   TALLY-BA  C000 TOGGLE ;  ' AS:, >BODY >PRF !
\begin_inset Newline newline
\end_inset

:NONAME   TALLY-BA 30000 TOGGLE ;  ' OS:, >BODY >PRF !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
You may want to use these always instead of 
\family typewriter
\series bold
(Rx,)
\end_layout

\begin_layout Scrap

<<Rx,alt>>=
\begin_inset Newline newline
\end_inset

: RB, _AP_ 1 + - (RB,) ;    ' .COMMA-SIGNED   ' (RB,) >BODY >DIS !
\begin_inset Newline newline
\end_inset

: RW, _AP_ 2 + - (RW,) ;    ' .COMMA-SIGNED   ' (RW,) >BODY >DIS !
\begin_inset Newline newline
\end_inset

: RL, _AP_ 4 + - (RL,) ;    ' .COMMA-SIGNED   ' (RL,) >BODY >DIS !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Require instructions as per a 32 resp.
 16 bits segment.
\end_layout

\begin_layout Scrap

<<BITS>>=
\begin_inset Newline newline
\end_inset

: BITS-32   28000 BA-DEFAULT ! ;
\begin_inset Newline newline
\end_inset

: BITS-16   14000 BA-DEFAULT ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Two fixup operands
\end_layout

\begin_layout Scrap

<<two-fixup-operands>>=
\begin_inset Newline newline
\end_inset

 041000 0000 FF03 T!
\begin_inset Newline newline
\end_inset

  0008 0000 8 2FAMILY, ADD, OR, ADC, SBB, AND, SUB, XOR, CMP,
\begin_inset Newline newline
\end_inset

 041000 0000 FF01 T!
\begin_inset Newline newline
\end_inset

  0002 0084 2 2FAMILY, TEST, XCHG,
\begin_inset Newline newline
\end_inset

 041000 0000 FF03 0088 2PI MOV,
\begin_inset Newline newline
\end_inset

 1022 0 FF00 008D 2PI LEA,
\begin_inset Newline newline
\end_inset

 1022 0 FF00 T!   0001 00C4 2 2FAMILY, LES, LDS,
\begin_inset Newline newline
\end_inset

 1022 0 FF00 0062 2PI BOUND,  ( 3)
\begin_inset Newline newline
\end_inset

 1002 0 FF00 0063 2PI ARPL,   ( 3)
\begin_inset Newline newline
\end_inset

 1002 04 FF00 0069 2PI IMULI, ( 3)
\begin_inset Newline newline
\end_inset

 1002 08 FF00 006B 2PI IMULSI, ( 3)
\begin_inset Newline newline
\end_inset

 1002 0 FF0000 T! 0100 00020F 2 3FAMILY, LAR, LSL, ( 3)
\begin_inset Newline newline
\end_inset

 1002 0 FF0000 T! 0800 00A30F 4 3FAMILY, BT, BTS, BTR, BTC, ( 3)
\begin_inset Newline newline
\end_inset

 1002 0 FF0000 T! 0800 00A50F 2 3FAMILY, SHLD|C, SHRD|C,    ( 3)
\begin_inset Newline newline
\end_inset

 1002 0 FF0000 T! 0100 00BC0F 2 3FAMILY, BSF, BSR,          ( 3)
\begin_inset Newline newline
\end_inset

 1002 08 FF0000 T! 0800 00A40F 2 3FAMILY, SHLDI, SHRDI,    ( 3)
\begin_inset Newline newline
\end_inset

 1022 0 FF0000 T! 0100 00B20F 4 3FAMILY, LSS, -- LFS, LGS, ( 3)
\begin_inset Newline newline
\end_inset

 1501 0 FF0000 T! 0800 00B60F 2 3FAMILY, MOVZX|B, MOVSX|B,  ( 3)
\begin_inset Newline newline
\end_inset

 1502 0 FF0000 T! 0800 00B70F 2 3FAMILY, MOVZX|W, MOVSX|W,  ( 3)
\begin_inset Newline newline
\end_inset

 1002 0 FF0000 00AF0F 3PI IMUL,                     ( 3)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
One fixup operands
\end_layout

\begin_layout Standard
It is dubious but fairly intractible whether the logical operation with
 sign extended bytes belong in the 386 instruction set.
 They are certainly there in the Pentium.
\end_layout

\begin_layout Scrap

<<one-fixup-operands>>=
\begin_inset Newline newline
\end_inset

 0 04 C701 00C6 2PI MOVI,
\begin_inset Newline newline
\end_inset

 0012 0 0007 T!   0008 40 4 1FAMILY, INC|X, DEC|X, PUSH|X, POP|X,
\begin_inset Newline newline
\end_inset

 0012 0 0007 90 1PI XCHG|AX,
\begin_inset Newline newline
\end_inset

 0011 04 0007 B0 1PI MOVI|B,
\begin_inset Newline newline
\end_inset

 0012 04 0007 B8 1PI MOVI|X,
\begin_inset Newline newline
\end_inset

 0 04 C701 T!
\begin_inset Newline newline
\end_inset

  0800 0080 8 2FAMILY, ADDI, ORI, ADCI, SBBI, ANDI, SUBI, XORI, CMPI,
\begin_inset Newline newline
\end_inset

 0002 08 C700 T!
\begin_inset Newline newline
\end_inset

  0800 0083 8 2FAMILY, ADDSI, ORSI, ADCSI, SBBSI, ANDSI, SUBSI, XORSI, CMPSI,
\begin_inset Newline newline
\end_inset

 0000 0 C701 T!
\begin_inset Newline newline
\end_inset

  0800 10F6 6 2FAMILY, NOT, NEG, MUL|AD, IMUL|AD, DIV|AD, IDIV|AD,
\begin_inset Newline newline
\end_inset

  0800 00FE 2 2FAMILY, INC, DEC,
\begin_inset Newline newline
\end_inset

 0 04 C701 00F6 2PI TESTI,
\begin_inset Newline newline
\end_inset

 0002 0 C700 008F 2PI POP,
\begin_inset Newline newline
\end_inset

 0002 0 C700 30FF 2PI PUSH,
\begin_inset Newline newline
\end_inset

 0002 0 C700 T!  1000 10FF 2 2FAMILY, CALLO, JMPO,
\begin_inset Newline newline
\end_inset

 0022 0 C700 T!  1000 18FF 2 2FAMILY, CALLFARO, JMPFARO,
\begin_inset Newline newline
\end_inset

 0002 08 C70000 T!  080000 20BA0F 4 3FAMILY, BTI, BTSI, BTRI, BTCI, ( 3)
\begin_inset Newline newline
\end_inset

 0002 0 C70000 T! ( It says X but in fact W : descriptor mostly - ) ( 3)
\begin_inset Newline newline
\end_inset

   080000 00000F 6 3FAMILY, SLDT, STR, LLDT, LTR, VERR, VERW,  ( 3)
\begin_inset Newline newline
\end_inset

   100000 20010F 2 3FAMILY, SMSW, LMSW,       ( 3)
\begin_inset Newline newline
\end_inset

 0022 0 C70000 T! ( It says X but in fact memory of different sizes) ( 3)
\begin_inset Newline newline
\end_inset

   080000 00010F 4 3FAMILY, SGDT, SIDT, LGDT, LIDT, ( 3)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
No fixup operands
\end_layout

\begin_layout Scrap

<<no-fixup-operands>>=
\begin_inset Newline newline
\end_inset

 0001 0 02000001 00 FIR B'|
\begin_inset Newline newline
\end_inset

 0002 0 02000001 01 FIR X'|
\begin_inset Newline newline
\end_inset

 0008 02 0201 T!    0002 A0 2 1FAMILY, MOV|TA, MOV|FA,
\begin_inset Newline newline
\end_inset

 0 04 0201 T!
\begin_inset Newline newline
\end_inset

  0008 04 8 1FAMILY, ADDI|A, ORI|A, ADCI|A, SBBI|A, ANDI|A, SUBI|A, XORI|A,
 CMPI|A,
\begin_inset Newline newline
\end_inset

 0000 04 0201 00A8 1PI TESTI|A,
\begin_inset Newline newline
\end_inset

 0000 0 0201 T!  0002 A4 6 1FAMILY, MOVS, CMPS, -- STOS, LODS, SCAS,
\begin_inset Newline newline
\end_inset

 0 10 0201 T!   0002 E4 2 1FAMILY, IN|P, OUT|P,
\begin_inset Newline newline
\end_inset

 0 00 0201 T!   0002 EC 2 1FAMILY, IN|D, OUT|D,
\begin_inset Newline newline
\end_inset

 0 00 0201 T!   0002 6C 2 1FAMILY, INS, OUTS,     ( 3)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Special fixups
\end_layout

\begin_layout Scrap

<<special-fixups>>=
\begin_inset Newline newline
\end_inset

 0800     0000 01000001 T!R     01 00 2 FAMILY|R Y| N|
\begin_inset Newline newline
\end_inset

 0800     0000 0400000E T!R     02 00 8 FAMILY|R O| C| Z| CZ| S| P| L| LE|
\begin_inset Newline newline
\end_inset

 0800 40 050F 0070 1PI J,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 2102 0 FF02 008C 2PI MOV|SG,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 0000 0 02000200 0000 FIR 1|   0000 0 02000200 0200 FIR V|          ( 3)
\begin_inset Newline newline
\end_inset

 0100 0 2C703 T! ( 20000 is a lockin for 1| V|)                   ( 3)
\begin_inset Newline newline
\end_inset

  0800 00D0 8 2FAMILY, ROL, ROR, RCL, RCR, SHL, SHR, -- SAR,  ( 3)
\begin_inset Newline newline
\end_inset

 0000 8 C701 T!  0800 00C0 8 2FAMILY, ROLI, RORI, RCLI, RCRI, SHLI, SHRI,
 -- SARI,  ( 3)
\begin_inset Newline newline
\end_inset

 80012 0000 3F0300 C0200F 3PI  MOV|CD,  ( 3)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 0800 80 50F00 800F 2PI J|X,                                           (
 3)
\begin_inset Newline newline
\end_inset

 0800 0 0100 T!R  0100 0000 2 FAMILY|R Y'| N'|                         
 ( 3)
\begin_inset Newline newline
\end_inset

 0800 0 0E00 T!R  0200 0000 8 FAMILY|R O'| C'| Z'| CZ'| S'| P'| L'| LE'|
 ( 3)
\begin_inset Newline newline
\end_inset

 0901 0 C70F00 00900F 3PI SET,  ( 3)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
No fixups
\end_layout

\begin_layout Scrap

<<no-fixups>>=
\begin_inset Newline newline
\end_inset

 2000 0000 0 T!  0008 06 4 1FAMILY, PUSH|ES, PUSH|CS, PUSH|SS, PUSH|DS,
\begin_inset Newline newline
\end_inset

 2000 0000 0 T!  0008 07 4 1FAMILY, POP|ES, -- POP|SS, POP|DS,
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

 0001 04 0000 T!    0001 D4 2 1FAMILY, AAM, AAD, 0001 04 0000 0CD 1PI INT,
\begin_inset Newline newline
\end_inset

 0008 22 0000 09A 1PI CALLFAR,
\begin_inset Newline newline
\end_inset

 0008 22 0000 0EA 1PI JMPFAR,
\begin_inset Newline newline
\end_inset

 0 0100 0000 T!   0008 C2 2 1FAMILY, RET+, RETFAR+,
\begin_inset Newline newline
\end_inset

 0004 80 0000 T!   0001 E8 2 1FAMILY, CALL, JMP,
\begin_inset Newline newline
\end_inset

 0 40 0000 0EB 1PI JMPS,
\begin_inset Newline newline
\end_inset

 0 40 0000 T!   0001 E0 4 1FAMILY, LOOPNZ, LOOPZ, LOOP, JCXZ,
\begin_inset Newline newline
\end_inset

 0000 0 0000 T!
\begin_inset Newline newline
\end_inset

    0008   0026 4 1FAMILY, ES:, CS:, SS:, DS:,
\begin_inset Newline newline
\end_inset

    0008   0027 4 1FAMILY, DAA, DAS, AAA, AAS,
\begin_inset Newline newline
\end_inset

    0001   0098 8 1FAMILY, CBW, CWD, -- WAIT, PUSHF, POPF, SAHF, LAHF,
\begin_inset Newline newline
\end_inset

    0008   00C3 2 1FAMILY, RET,  RETFAR,
\begin_inset Newline newline
\end_inset

    0001   00CC 4 1FAMILY, INT3, -- INTO, IRET,
\begin_inset Newline newline
\end_inset

    0001   00F0 6 1FAMILY, LOCK, -- REPNZ, REPZ, HLT, CMC,
\begin_inset Newline newline
\end_inset

    0001   00F8 6 1FAMILY, CLC, STC, CLI, STI, CLD, STD,
\begin_inset Newline newline
\end_inset

    0001   0060 2 1FAMILY, PUSH|ALL, POP|ALL, ( 3)
\begin_inset Newline newline
\end_inset

    0001   0064 4 1FAMILY, FS:, GS:, OS:, AS:, ( 3)
\begin_inset Newline newline
\end_inset

  0100 A00F 3 2FAMILY, PUSH|FS, POP|FS, CPUID,
\begin_inset Newline newline
\end_inset

  0100 A80F 2 2FAMILY, PUSH|GS, POP|GS, ( RSM,)
\begin_inset Newline newline
\end_inset

   0002 04 0000   0068 1PI PUSHI|X,  ( 3)
\begin_inset Newline newline
\end_inset

   0001 04 0000   006A 1PI PUSHI|B,  ( 3)
\begin_inset Newline newline
\end_inset

   0001 0104 0000   00C8 1PI ENTER, ( 3)
\begin_inset Newline newline
\end_inset

       0000 0 00   00C9 1PI LEAVE, ( 3)
\begin_inset Newline newline
\end_inset

       0000 0 00   00D7 1PI XLAT,  ( 3)
\begin_inset Newline newline
\end_inset

       0000 0 00 060F 2PI CLTS,  ( 3)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Handling the SIB byte
\end_layout

\begin_layout Standard
These must be found last
\end_layout

\begin_layout Scrap

<<~SIB,>>=
\begin_inset Newline newline
\end_inset

0600 0 01FF 0000 1PI ~SIB,
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Handle a 'sib' bytes as an instruction-within-an-instruction.
 This is really straightforward, we say the sib commaer is a sib instruction.
 as per -- error checking omitted -- "
\family typewriter
\series bold
10000 ' ~SIB, >CFA COMMAER SIB,,
\family default
\series default
".
 All the rest is to nest the state in this recursive situation: Leaving
 BY would flag commaers to be done after the sib byte as errors.
\end_layout

\begin_layout Scrap

<<SIB-bytes>>=
\begin_inset Newline newline
\end_inset

<<(SIB),,>>
\begin_inset Newline newline
\end_inset

<<DIS-SIB>>
\begin_inset Newline newline
\end_inset

<<SIBfixups>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Handle bad bits by hand, prevent resetting of '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
' which could switch 16/32 bits modes.
 0900 are the bad bits conflicting with 
\family typewriter
\series bold
~SIB,
\family default
\series default
.
 Fill in deferred data creation action.
\end_layout

\begin_layout Scrap

<<(SIB),,>>=
\begin_inset Newline newline
\end_inset

: (SIB),,   TALLY-BY @   0 TALLY-BY !
\begin_inset Newline newline
\end_inset

    CHECK32 TALLY-BA @ 0900 INVERT AND TALLY-BA !   ['] NOOP BA-XT !
\begin_inset Newline newline
\end_inset

    ~SIB,   TALLY-BY !   ;
\begin_inset Newline newline
\end_inset

' (SIB),,  ' SIB,, >BODY >DATA !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble the sib byte where the disassembler sits now.
 '
\family typewriter
\series bold
FORCED-DISASSEMBLY
\family default
\series default
' takes care itself of incrementing the disassembly pointer.
 Fill in deferred disassembler action.
\end_layout

\begin_layout Scrap

<<DIS-SIB>>=
\begin_inset Newline newline
\end_inset

: DIS-SIB DROP
\begin_inset Newline newline
\end_inset

    LATEST-INSTRUCTION @        
\backslash
 We don't want sib visible.
\begin_inset Newline newline
\end_inset

    [ ' ~SIB, >BODY ] LITERAL FORCED-DISASSEMBLY
\begin_inset Newline newline
\end_inset

    LATEST-INSTRUCTION ! ;
\begin_inset Newline newline
\end_inset

' DIS-SIB    ' SIB,, >BODY >DIS !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Redefine some fixups, such that the user may say "
\family typewriter
\series bold
[AX
\family default
\series default
" instead of "
\family typewriter
\series bold
~SIB| SIB,, [AX
\family default
\series default
".
 Note that the disassembly is made to look like the same.
 The 
\family typewriter
\series bold
~SIB|
\family default
\series default
 and the 
\family typewriter
\series bold
~SIB,
\family default
\series default
 inside the 
\family typewriter
\series bold
SIB,,
\family default
\series default
 are print-suppressed.
\end_layout

\begin_layout Scrap

<<SIBfixups>>=
\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: [AX   ~SIB| SIB,, [AX ;
\begin_inset Newline newline
\end_inset

: [SP   ~SIB| SIB,, [SP ;
\begin_inset Newline newline
\end_inset

: [CX   ~SIB| SIB,, [CX ;
\begin_inset Newline newline
\end_inset

: [BP   ~SIB| SIB,, [BP ;
\begin_inset Newline newline
\end_inset

: [DX   ~SIB| SIB,, [DX ;
\begin_inset Newline newline
\end_inset

: [SI   ~SIB| SIB,, [SI ;
\begin_inset Newline newline
\end_inset

: [BX   ~SIB| SIB,, [BX ;
\begin_inset Newline newline
\end_inset

: [DI   ~SIB| SIB,, [DI ;
\begin_inset Newline newline
\end_inset

: [MEM  ~SIB| SIB,, [MEM ;
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Access words
\end_layout

\begin_layout Standard
Contains access words and other little utilities that complement ciasdis.
 In particular regarding unexpected missing words.
\end_layout

\begin_layout Scrap

<<access.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: access.frt,v 1.6 2005/01/04 19:20:35 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

ALSO ASSEMBLER
\begin_inset Newline newline
\end_inset

: B@ TARGET>HOST C@ ;
\begin_inset Newline newline
\end_inset

: W@ TARGET>HOST 2 MC@ ;
\begin_inset Newline newline
\end_inset

: L@ TARGET>HOST 4 MC@ ;
\begin_inset Newline newline
\end_inset

PREVIOUS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Handle labels
\end_layout

\begin_layout Scrap

<<labelas.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: labelas.frt,v 1.17 2009/03/26 19:40:39 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE BAG             
\backslash
 Simple bag facility
\begin_inset Newline newline
\end_inset

    REQUIRE DO-BAG          
\backslash
 More advanced bag facility
\begin_inset Newline newline
\end_inset

    REQUIRE POSTFIX
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<FIX-DEA>>
\begin_inset Newline newline
\end_inset

<<BACKSPACE-IN>>
\begin_inset Newline newline
\end_inset

<<FIX-NMB>>
\begin_inset Newline newline
\end_inset

<<ERROR10>>
\begin_inset Newline newline
\end_inset

<<ERROR12>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE OLD:
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<?ERROR-FIXING>>
\begin_inset Newline newline
\end_inset

<<RESET-SECTION>>
\begin_inset Newline newline
\end_inset

<<PASSES>>
\begin_inset Newline newline
\end_inset

<<'LABELS>>
\begin_inset Newline newline
\end_inset

<<IS-A-LABEL?>>
\begin_inset Newline newline
\end_inset

<<KNOWN-LABEL?>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    <<:PREFIX>>
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<constant-data>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make sure undefined labels don't fool up the first pass of the assembly.
 Replace not found FLAG, by a valid DEA with the stack effect of a label.
 The result is that unknown words are compiled as a 
\family typewriter
\series bold
_
\family default
\series default
, i.e.
 it generates a don't care value.
 Supposedly these are labels that have not been defined yet.
 Go on compiling.
 Loading the same code another time will give correct code.
\end_layout

\begin_layout Scrap

<<FIX-DEA>>=
\begin_inset Newline newline
\end_inset

: FIX-DEA DROP ['] _ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Backspace a character, but not if we are at the end of input.
 We find out by trial reading another character, then back two up.
\end_layout

\begin_layout Scrap

<<BACKSPACE-IN>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

     : BACKSPACE-IN   -2 >IN +! 0 ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    : BACKSPACE-IN   IN[] IF -2 IN +! THEN DROP ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make sure undefined labels that looks like numbers, don't fool up the first
 pass of the assembly.
 Not that we endorse the idea to name labels like 
\family typewriter
\series bold
250HUP
\family default
\series default
.
 All of a word may have been scanned, so before using 
\family typewriter
\series bold
(WORD)
\family default
\series default
, we backspace one char.
 Afterwards we backspace again, such that the number routine we return to
 concludes it is ready.
 We leave some random number, which is okay, but it must be single precision!
\end_layout

\begin_layout Scrap

<<FIX-NMB>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForSwiftForth
\begin_inset Newline newline
\end_inset

[DEFINED] ForGForth OR [IF]
\begin_inset Newline newline
\end_inset

    : FIX-NMB   -1 >IN +!  BL WORD DROP  BACKSPACE-IN ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    : FIX-NMB   -1 IN +!  (WORD) 2DROP  BACKSPACE-IN   0 DPL ! ;
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If FLAG we have a misspelled number, skip its remainder.
\end_layout

\begin_layout Scrap

<<ERROR10>>=
\begin_inset Newline newline
\end_inset

: ERROR10 ( f n -- )   DROP IF  FIX-NMB  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If FLAG we have an unknown word, treat it as a label.
\end_layout

\begin_layout Scrap

<<ERROR12>>=
\begin_inset Newline newline
\end_inset

: ERROR12 ( f n -- )   DROP IF  FIX-DEA  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Replacement for 
\family typewriter
\series bold
?ERROR
\family default
\series default
, if FLAG, give error NUMBER.
 Fix up errors, see 
\family typewriter
\series bold
FIX-NMB
\family default
\series default
 and 
\family typewriter
\series bold
FIX-DEA
\family default
\series default
.
\end_layout

\begin_layout Scrap

<<?ERROR-FIXING>>=
\begin_inset Newline newline
\end_inset

: ?ERROR-FIXING ( f n -- )
\begin_inset Newline newline
\end_inset

    DUP 10 = IF  ERROR10  ELSE
\begin_inset Newline newline
\end_inset

    DUP 12 = IF  ERROR12  ELSE
\begin_inset Newline newline
\end_inset

        (?ERROR)
\begin_inset Newline newline
\end_inset

    THEN THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Ignore 
\family typewriter
\series bold
FILE-OFFSET
\family default
\series default
 and 
\family typewriter
\series bold
TARGET
\family default
\series default
 address.
 Make section "name" current, and reset its allocation pointer.
 Like '
\family typewriter
\series bold
SECTION
\family default
\series default
' but this behaviour is appropriate for the second pass.
\end_layout

\begin_layout Scrap

<<RESET-SECTION>>=
\begin_inset Newline newline
\end_inset

: RESET-SECTION ( file target -- )   2DROP  BL WORD COUNT EVALUATE  CODE-SPACE
 CP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Ignore undefined labels during first pass ...
 Define section in the first pass ...
 but just start section, and have normal errors in the second pass.
\end_layout

\begin_layout Scrap

<<PASSES>>=
\begin_inset Newline newline
\end_inset

: FIRSTPASS ( -- )   CR S" FIRSTPASS " TYPE CR
\begin_inset Newline newline
\end_inset

    ['] ?ERROR-FIXING '?ERROR !
\begin_inset Newline newline
\end_inset

    'SECTION RESTORED ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: SECONDPASS ( -- )   CR S" SECONDPASS " TYPE CR
\begin_inset Newline newline
\end_inset

    ['] RESET-SECTION 'SECTION !
\begin_inset Newline newline
\end_inset

    '?ERROR RESTORED ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
All labels link back to here.
\end_layout

\begin_layout Scrap

<<'LABELS>>=
\begin_inset Newline newline
\end_inset

CREATE 'LABELS  HERE ,
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For NAME: "name REPRESENTS a label."
\end_layout

\begin_layout Scrap

<<IS-A-LABEL?>>=
\begin_inset Newline newline
\end_inset

: IS-A-LABEL? ( a n -- f )   GET-CURRENT SEARCH-WORDLIST DUP IF
\begin_inset Newline newline
\end_inset

        SWAP >BODY  BEGIN  >LFA ['] @ CATCH IF  DROP 0= EXIT
\begin_inset Newline newline
\end_inset

            THEN  ?DUP WHILE  DUP 'LABELS = IF  DROP EXIT
\begin_inset Newline newline
\end_inset

                THEN  REPEAT  0=  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For NAME: NAME and "it is a KNOWN label." We don't need to define it if there
 is already a label of that name.
 If it has not the value of the program counter we must report a phase error.
\end_layout

\begin_layout Scrap

<<KNOWN-LABEL?>>=
\begin_inset Newline newline
\end_inset

: KNOWN-LABEL? ( a n -- a n f )   2DUP IS-A-LABEL? >R
\begin_inset Newline newline
\end_inset

    R@ IF  2DUP GET-CURRENT SEARCH-WORDLIST IF
\begin_inset Newline newline
\end_inset

            EXECUTE _AP_ <> IF  S" ERROR: phase error defining label "
\begin_inset Newline newline
\end_inset

                TYPE  2DUP TYPE  CR
\begin_inset Newline newline
\end_inset

    THEN THEN THEN  R> ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection*
ciForth specific
\end_layout

\begin_layout Standard
Make a denotation for labels.
 They look like '
\family typewriter
\series bold
:LABEL
\family default
\series default
'.
 Put '
\family typewriter
\series bold
:
\family default
\series default
' in the 
\family typewriter
\series bold
ONLY
\family default
\series default
 wordlist, such that it doesn't interfere with the normal semicolon.
 A word starting with a '
\family typewriter
\series bold
:
\family default
\series default
' is a label definition denotation.
 The part after the '
\family typewriter
\series bold
:
\family default
\series default
' may be defined already, but if it is a label it must have the value of
 the current program counter.
 So it is possible to redefine words as labels (heed the warnings).
 This is very tricky, but the assembler programmer must not be restricted
 by what words are in Forth.
 Note: this is actually an abuse of the denotation mechanism.
\end_layout

\begin_layout Scrap

<<:PREFIX>>=
\begin_inset Newline newline
\end_inset

'ONLY >WID CURRENT !  
\backslash
 Making ONLY the CONTEXT is dangerous! This will do.
\begin_inset Newline newline
\end_inset

: : (WORD)
\begin_inset Newline newline
\end_inset

    KNOWN-LABEL? IF 2DROP ELSE 2>R _AP_ 2R> POSTFIX CONSTANT THEN ;
\begin_inset Newline newline
\end_inset

PREFIX IMMEDIATE DEFINITIONS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Handle constant data
\end_layout

\begin_layout Standard
Handle constant data in assembler.
\end_layout

\begin_layout Scrap

<<constant-data>>=
\begin_inset Newline newline
\end_inset

<<DX-SET>>
\begin_inset Newline newline
\end_inset

<<GET-DX-SET>>
\begin_inset Newline newline
\end_inset

<<C,-DX-SET>>
\begin_inset Newline newline
\end_inset

<<db>>
\begin_inset Newline newline
\end_inset

ALSO ASSEMBLER
\begin_inset Newline newline
\end_inset

<<W,-DX-SET>>
\begin_inset Newline newline
\end_inset

<<dw>>
\begin_inset Newline newline
\end_inset

<<L,-DX-SET>>
\begin_inset Newline newline
\end_inset

<<dl>>
\begin_inset Newline newline
\end_inset

<<(,)>>
\begin_inset Newline newline
\end_inset

<<,-DX-SET>>
\begin_inset Newline newline
\end_inset

<<d>>
\begin_inset Newline newline
\end_inset

PREVIOUS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains the data on the remainder of the line in reverse order.
\end_layout

\begin_layout Scrap

<<DX-SET>>=
\begin_inset Newline newline
\end_inset

100 BAG DX-SET    : !DX-SET DX-SET !BAG ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fill '
\family typewriter
\series bold
DX-SET
\family default
\series default
' from the remainder of the line in reverse order.
\end_layout

\begin_layout Scrap

<<GET-DX-SET>>=
\begin_inset Newline newline
\end_inset

: GET-DX-SET ( -- )   DEPTH >R
\begin_inset Newline newline
\end_inset

    BEGIN  BL WORD DUP C@  WHILE  FIND IF  EXECUTE  ELSE
\begin_inset Newline newline
\end_inset

            COUNT 0 0 2SWAP >NUMBER 2DROP DROP
\begin_inset Newline newline
\end_inset

        THEN  REPEAT  DROP
\begin_inset Newline newline
\end_inset

    DEPTH R> ?DO  DX-SET BAG+!  LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Output '
\family typewriter
\series bold
DX-SET
\family default
\series default
' as bytes.
\end_layout

\begin_layout Scrap

<<C,-DX-SET>>=
\begin_inset Newline newline
\end_inset

: C,-DX-SET ( -- )   BEGIN  DX-SET BAG@- AS-C,  DX-SET BAG? 0=  UNTIL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add remainder of line to codespace, as bytes.
\end_layout

\begin_layout Scrap

<<db>>=
\begin_inset Newline newline
\end_inset

: db ( -- )   !DX-SET  GET-DX-SET  C,-DX-SET ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
NOTE: The following assumes 
\family typewriter
\series bold
(W,)
\family default
\series default
 and 
\family typewriter
\series bold
(L,)
\family default
\series default
 are defined in the specific assembler.
 These must not be commaers, just lay down 16 or 32 bits entities in the
 right endian format.
\end_layout

\begin_layout Standard
Output '
\family typewriter
\series bold
DX-SET
\family default
\series default
' as words (16-bits).
\end_layout

\begin_layout Scrap

<<W,-DX-SET>>=
\begin_inset Newline newline
\end_inset

: W,-DX-SET ( -- )   BEGIN  DX-SET BAG@- (W,)  DX-SET BAG? 0=  UNTIL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add remainder of line to codespace, as words.
\end_layout

\begin_layout Scrap

<<dw>>=
\begin_inset Newline newline
\end_inset

: dw ( -- )   !DX-SET  GET-DX-SET  W,-DX-SET ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Output '
\family typewriter
\series bold
DX-SET
\family default
\series default
' as longs (32-bits)
\end_layout

\begin_layout Scrap

<<L,-DX-SET>>=
\begin_inset Newline newline
\end_inset

: L,-DX-SET ( -- )   BEGIN  DX-SET BAG@- (L,)  DX-SET BAG? 0=  UNTIL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add remainder of line to codespace, as longs (or, mostly, cells).
\end_layout

\begin_layout Scrap

<<dl>>=
\begin_inset Newline newline
\end_inset

: dl ( -- )   !DX-SET  GET-DX-SET  L,-DX-SET ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Lay down a STRING in assembler memory.
\end_layout

\begin_layout Scrap

<<(,)>>=
\begin_inset Newline newline
\end_inset

: ($,) ( a n -- )   AS-HERE SWAP DUP AS-ALLOT MOVE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Output '
\family typewriter
\series bold
DX-SET
\family default
\series default
' as longs (32-bits)
\end_layout

\begin_layout Scrap

<<,-DX-SET>>=
\begin_inset Newline newline
\end_inset

: $,-DX-SET ( -- )
\begin_inset Newline newline
\end_inset

    BEGIN  DX-SET BAG@- DUP 256 0 WITHIN IF
\begin_inset Newline newline
\end_inset

        DX-SET BAG@- ($,)  ELSE  AS-C,  THEN
\begin_inset Newline newline
\end_inset

    DX-SET BAG? 0=  UNTIL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add remainder of line to codespace, as strings.
\end_layout

\begin_layout Scrap

<<d>>=
\begin_inset Newline newline
\end_inset

: d$ ( -- )   !DX-SET  GET-DX-SET  $,-DX-SET ;
\begin_inset Newline newline
\end_inset

: "   [CHAR] " PARSE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Handle labels in disassembly
\end_layout

\begin_layout Standard
Handle labels as far as disassembly is concerned.
 There is a separate one for the assembler.
\end_layout

\begin_layout Scrap

<<labeldis.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: labeldis.frt,v 1.86 2010/06/03 23:27:28 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2004}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE ALIAS    REQUIRE @+    REQUIRE QSORT    REQUIRE EXCHANGE
\begin_inset Newline newline
\end_inset

    REQUIRE BIN-SEARCH    REQUIRE POSTFIX    REQUIRE H.
 
\backslash
 In behalf of (DH.)
\begin_inset Newline newline
\end_inset

    REQUIRE 2>R REQUIRE BAG 
\backslash
 Simple bag facility
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

1000 CONSTANT MAX-LABEL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 -------------------- INTRODUCTION --------------------------------
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<generic-labels>>
\begin_inset Newline newline
\end_inset

<<names-of-labels>>
\begin_inset Newline newline
\end_inset

<<comment-remainder>>
\begin_inset Newline newline
\end_inset

<<multi-line-comment>>
\begin_inset Newline newline
\end_inset

<<printing-strings>>
\begin_inset Newline newline
\end_inset

<<start-of-line>>
\begin_inset Newline newline
\end_inset

<<disassembly-ranges>>
\begin_inset Newline newline
\end_inset

<<disassemble>>
\begin_inset Newline newline
\end_inset

<<unspecified>>
\begin_inset Newline newline
\end_inset

<<bytes>>
\begin_inset Newline newline
\end_inset

<<words>>
\begin_inset Newline newline
\end_inset

<<longs>>
\begin_inset Newline newline
\end_inset

<<strings>>
\begin_inset Newline newline
\end_inset

<<IGNORE>>
\begin_inset Newline newline
\end_inset

<<.HOW-FIT>>
\begin_inset Newline newline
\end_inset

<<HOW-FIT>>
\begin_inset Newline newline
\end_inset

<<HOW-FIT-END>>
\begin_inset Newline newline
\end_inset

<<DISASSEMBLE-ALL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 ------------------- Generic again -------------------
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<(ADORN-ADDRESS)>>
\begin_inset Newline newline
\end_inset

<<INIT-ALL>>
\begin_inset Newline newline
\end_inset

<<SORT-ALL>>
\begin_inset Newline newline
\end_inset

<<DECOMP-ONE>>
\begin_inset Newline newline
\end_inset

<<DECOMP-ALL>>
\begin_inset Newline newline
\end_inset

<<MAKE-CUL>>
\begin_inset Newline newline
\end_inset

<<SHOW-REGISTER>>
\begin_inset Newline newline
\end_inset

<<DISASSEMBLE-TARGET>>
\begin_inset Newline newline
\end_inset

<<DISASSEMBLE-TARGET-i386>>
\begin_inset Newline newline
\end_inset

<<DEFAULT-DISASSEMBLY>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

ALSO ASSEMBLER
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<ranges>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DEFINITIONS
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<instructions>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

PREVIOUS DEFINITIONS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Ignore addresses in this range.
 Define range to ignore.
\end_layout

\begin_layout Scrap

<<IGNORE>>=
\begin_inset Newline newline
\end_inset

' 2DROP DIS: IGNORE ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

: -ignore ( a n -- )   2>R ['] IGNORE 2R> RANGE ;
\begin_inset Newline newline
\end_inset

' -ignore RANGE: -ignore: ( -name- )
\begin_inset Newline newline
\end_inset

: -ignore- ( a n -- )   -warning >R  NONAME$ -ignore  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a remark about whether START and END fit.
\end_layout

\begin_layout Scrap

<<.HOW-FIT>>=
\begin_inset Newline newline
\end_inset

: .HOW-FIT ( a1 a2 -- )   2DUP = IF  2DROP  ELSE  > IF
\begin_inset Newline newline
\end_inset

            S" 
\backslash
 WARNING: This range overlaps with the previous one."  ELSE
\begin_inset Newline newline
\end_inset

            S" 
\backslash
 WARNING: There is hole between this range and the previous one"
\begin_inset Newline newline
\end_inset

    THEN  CR TYPE CR  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a remark about whether start of the current range fits to the END
 of the previous range.
 Leave END of current range for the next check.
\end_layout

\begin_layout Scrap

<<HOW-FIT>>=
\begin_inset Newline newline
\end_inset

: HOW-FIT ( a -- a' )   RANGE-START .HOW-FIT  RANGE-END ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a remark about whether the END of the previous range is really the
 end of the input file.
\end_layout

\begin_layout Scrap

<<HOW-FIT-END>>=
\begin_inset Newline newline
\end_inset

: HOW-FIT-END ( a -- )   TARGET-END .HOW-FIT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble all those ranges with their own disassemblers.
 No range will print their end labels, which is no problem if everything
 fits, except for the last range.
 Do that expressly.
\end_layout

\begin_layout Scrap

<<DISASSEMBLE-ALL>>=
\begin_inset Newline newline
\end_inset

: DISASSEMBLE-ALL ( -- )   TARGET-START  RANGE-LABELS DO-LAB
\begin_inset Newline newline
\end_inset

        I CELL+ @ RANGE-SECTION  HOW-FIT RANGE-DECODE
\begin_inset Newline newline
\end_inset

    LOOP-LAB  HOW-FIT-END   HOST-END CR-ADORNED ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
During assembly there is no decision needed whether to have a new line.
 Just do new line at ADDRESS, and get the eol-comment, if any.
 Revector '
\family typewriter
\series bold
ADORN-ADDRESS
\family default
\series default
' used in "
\family typewriter
\series bold
asgen.frt
\family default
\series default
".
\end_layout

\begin_layout Scrap

<<(ADORN-ADDRESS)>>=
\begin_inset Newline newline
\end_inset

: (ADORN-ADDRESS)   DUP CR-ADORNED   REMEMBER-COMMENT: ;
\begin_inset Newline newline
\end_inset

' (ADORN-ADDRESS) 'ADORN-ADDRESS !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Initialise all registered label classes.
\end_layout

\begin_layout Scrap

<<INIT-ALL>>=
\begin_inset Newline newline
\end_inset

: INIT-ALL   THE-REGISTER DO-BAG  I @ TO CURRENT-LABELSTRUCT  LABELS !BAG
\begin_inset Newline newline
\end_inset

    LOOP-BAG  INIT-COMMENT: ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Sort all registered label classes.
\end_layout

\begin_layout Scrap

<<SORT-ALL>>=
\begin_inset Newline newline
\end_inset

: SORT-ALL   THE-REGISTER DO-BAG  I @ TO CURRENT-LABELSTRUCT  SORT-LABELS
\begin_inset Newline newline
\end_inset

    LOOP-BAG ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Decompile all labels of current label class.
\end_layout

\begin_layout Scrap

<<DECOMP-ONE>>=
\begin_inset Newline newline
\end_inset

: DECOMP-ONE  LAB-UPB 1+ 1 ?DO  I DECOMP  LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate the source of all label classs.
\end_layout

\begin_layout Scrap

<<DECOMP-ALL>>=
\begin_inset Newline newline
\end_inset

: DECOMP-ALL   THE-REGISTER DO-BAG  I @ TO CURRENT-LABELSTRUCT  DECOMP-ONE
\begin_inset Newline newline
\end_inset

    LOOP-BAG ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make a full blown cul file from the internal data.
\end_layout

\begin_layout Scrap

<<MAKE-CUL>>=
\begin_inset Newline newline
\end_inset

: MAKE-CUL  S" HEX" TYPE CR  TARGET-START 8 H.R
\begin_inset Newline newline
\end_inset

    S"  -ORG-" TYPE CR DECOMP-ALL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Show what type of labels there are.
\end_layout

\begin_layout Scrap

<<SHOW-REGISTER>>=
\begin_inset Newline newline
\end_inset

: SHOW-REGISTER   THE-REGISTER DO-BAG  I @ %ID.
  LOOP-BAG ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble the current program as stored in the '
\family typewriter
\series bold
CODE-BUFFER
\family default
\series default
'.
 Using what is known about it.
\end_layout

\begin_layout Scrap

<<DISASSEMBLE-TARGET>>=
\begin_inset Newline newline
\end_inset

: DISASSEMBLE-TARGET ( -- )   TARGET-START .
 S"  ORG" TYPE CR
\begin_inset Newline newline
\end_inset

    DISASSEMBLE-ALL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
i386 dependant, should somehow be separated out.
\end_layout

\begin_layout Scrap

<<DISASSEMBLE-TARGET-i386>>=
\begin_inset Newline newline
\end_inset

-warning
\begin_inset Newline newline
\end_inset

: DISASSEMBLE-TARGET ( -- )   S" [ASM HEX BITS-32" TYPE CR  DISASSEMBLE-TARGET
 CR ;
\begin_inset Newline newline
\end_inset

+warning
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This is used to plug holes, where the user doesn't specify how to disassemble.
\end_layout

\begin_layout Scrap

<<DEFAULT-DISASSEMBLY>>=
\begin_inset Newline newline
\end_inset

VARIABLE DEFAULT-DISASSEMBLY
\begin_inset Newline newline
\end_inset

' -d$- DEFAULT-DISASSEMBLY !
\begin_inset Newline newline
\end_inset

: -ddef- DEFAULT-DISASSEMBLY @ EXECUTE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Generic definition of labels
\end_layout

\begin_layout Standard
Labels are bags of two cell structs, a target address and a pointer to the
 payload (mostly a string).
 They are sorted on target address for convenience.
\end_layout

\begin_layout Scrap

<<generic-labels>>=
\begin_inset Newline newline
\end_inset

<<THE-REGISTER>>
\begin_inset Newline newline
\end_inset

<<REALLOC>>
\begin_inset Newline newline
\end_inset

<<REALLOC-POINTER>>
\begin_inset Newline newline
\end_inset

<<LABEL-FIELD>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<LABELS[]>>
\begin_inset Newline newline
\end_inset

<<REMOVE-LABEL>>
\begin_inset Newline newline
\end_inset

<<DO-LAB>>
\begin_inset Newline newline
\end_inset

<<.PAY.>>
\begin_inset Newline newline
\end_inset

<<.PAY>>
\begin_inset Newline newline
\end_inset

<<.PAY-DEA>>
\begin_inset Newline newline
\end_inset

<<LABEL-NAME>>
\begin_inset Newline newline
\end_inset

<<.LABELS>>
\begin_inset Newline newline
\end_inset

<<LAB-BOUNDS>>
\begin_inset Newline newline
\end_inset

<<LAB<>>
\begin_inset Newline newline
\end_inset

<<LAB<->>
\begin_inset Newline newline
\end_inset

<<SORT-LABELS>>
\begin_inset Newline newline
\end_inset

<<CONT>>
\begin_inset Newline newline
\end_inset

<<L<>>
\begin_inset Newline newline
\end_inset

<<WHERE-LABEL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

VARIABLE LABEL-CACHE    
\backslash
 Index of next label.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<FIND-LABEL>>
\begin_inset Newline newline
\end_inset

<<>LABEL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

VARIABLE MAX-DEV-P   -8 MAX-DEV-P !    
\backslash
 Max deviation acceptable with previous
\begin_inset Newline newline
\end_inset

VARIABLE MAX-DEV-N    8 MAX-DEV-N !    
\backslash
 Max deviation acceptable with next
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<(~LABEL)>>
\begin_inset Newline newline
\end_inset

<<IMPROVE-LABEL>>
\begin_inset Newline newline
\end_inset

<<~LABEL>>
\begin_inset Newline newline
\end_inset

<<ROLL-LABEL>>
\begin_inset Newline newline
\end_inset

<<NEXT-LABEL>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
A bag with the dea's of all labelclasses.
\end_layout

\begin_layout Scrap

<<THE-REGISTER>>=
\begin_inset Newline newline
\end_inset

100 BAG THE-REGISTER
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Realloc ADDRESS to new LENGTH, return new ADDRESS.
 Ignoring old length, we may copy garbage, too bad.
\end_layout

\begin_layout Scrap

<<REALLOC>>=
\begin_inset Newline newline
\end_inset

: REALLOC ( u -- a )   HERE >R  DUP ALLOT  R@ SWAP MOVE   R> ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Realloc POINTER to old buffer to new LENGTH.
 Afterwards pointer points to new buffer.
\end_layout

\begin_layout Scrap

<<REALLOC-POINTER>>=
\begin_inset Newline newline
\end_inset

: REALLOC-POINTER ( a n -- )   >R  DUP @ R> REALLOC  SWAP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define a class for label-like things of length N.
 A label-like thing is two cells: address and a payload.
\end_layout

\begin_layout Scrap

<<LABEL-FIELD>>=
\begin_inset Newline newline
\end_inset

0 VALUE CURRENT-LABELSTRUCT 
\backslash
 current label pointer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: LABEL-FIELD ( u size -- u' )   CREATE  OVER , +
\begin_inset Newline newline
\end_inset

    DOES> ( -- a )   @ CURRENT-LABELSTRUCT + ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

0
\begin_inset Newline newline
\end_inset

    2 CELLS LABEL-FIELD LABEL-RESERVED
\begin_inset Newline newline
\end_inset

    1 CELLS LABEL-FIELD 'CURRENT-LABEL
\begin_inset Newline newline
\end_inset

    1 CELLS LABEL-FIELD 'DECOMP           
\backslash
 (Re)generate source for INDEX.
\begin_inset Newline newline
\end_inset

    1 CELLS LABEL-FIELD '.PAY             
\backslash
 Print payload
\begin_inset Newline newline
\end_inset

    1 CELLS LABEL-FIELD 'MAX-LAB
\begin_inset Newline newline
\end_inset

    0 LABEL-FIELD LABELS            
\backslash
 Return ADDRESS
\begin_inset Newline newline
\end_inset

CONSTANT |LABELSTRUCT|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CURRENT-LABEL ( -- a )   'CURRENT-LABEL @ ;
\begin_inset Newline newline
\end_inset

: DECOMP ( -- )   'DECOMP @ EXECUTE ;
\begin_inset Newline newline
\end_inset

: .PAY ( -- )   '.PAY @ EXECUTE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<DOUBLE-SIZE>>
\begin_inset Newline newline
\end_inset

<<MAX-LAB>>
\begin_inset Newline newline
\end_inset

<<LAB-UPB>>
\begin_inset Newline newline
\end_inset

<<RELOCATABLE>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: LABELSTRUCT ( n print gen -- )   SAVE-INPUT  CREATE  HERE DUP >R
\begin_inset Newline newline
\end_inset

    DUP THE-REGISTER BAG+!  |LABELSTRUCT| DUP ALLOT  ERASE
\begin_inset Newline newline
\end_inset

    RESTORE-INPUT THROW  BL WORD $@ $, R@ >NFA !
\begin_inset Newline newline
\end_inset

    CURRENT-LABELSTRUCT R@ >LFA !  R> TO CURRENT-LABELSTRUCT
\begin_inset Newline newline
\end_inset

    DUP 'CURRENT-LABEL !  'DECOMP !  '.PAY !  DUP 'MAX-LAB ! 2* BUILD-BAG
\begin_inset Newline newline
\end_inset

    DOES>  TO CURRENT-LABELSTRUCT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Remember that from now on two times as much labels are allowed.
\end_layout

\begin_layout Scrap

<<DOUBLE-SIZE>>=
\begin_inset Newline newline
\end_inset

: DOUBLE-SIZE ( -- )   'MAX-LAB DUP @ 2* SWAP ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return a VARIABLE containing the max labels allowed.
\end_layout

\begin_layout Scrap

<<MAX-LAB>>=
\begin_inset Newline newline
\end_inset

: MAX-LAB ( -- n )   'MAX-LAB @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return largest INDEX of labels present.
\end_layout

\begin_layout Scrap

<<LAB-UPB>>=
\begin_inset Newline newline
\end_inset

: LAB-UPB ( -- n )   LABELS |BAG| 2/ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add to '
\family typewriter
\series bold
LABELS
\family default
\series default
'.
 Reallocate if the class is full.
 6 cells : does> pointer, 4 fields and upperbound of bag.
 Make label relocatable and back.
 Don't use in between!
\end_layout

\begin_layout Scrap

<<RELOCATABLE>>=
\begin_inset Newline newline
\end_inset

: >RELOCATABLE ( -- )   LABELS DUP @  OVER - SWAP ! ;
\begin_inset Newline newline
\end_inset

: RELOCATABLE> ( -- )   LABELS DUP +! ;
\begin_inset Newline newline
\end_inset

: ?REALLOC? ( -- )
\begin_inset Newline newline
\end_inset

    MAX-LAB LAB-UPB = IF  DOUBLE-SIZE
\begin_inset Newline newline
\end_inset

        >RELOCATABLE  CURRENT-LABEL MAX-LAB 2* 6 + CELLS REALLOC-POINTER
\begin_inset Newline newline
\end_inset

        CURRENT-LABEL EXECUTE   RELOCATABLE>  THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: LAB+! ( a -- )   LABELS BAG+!  ?REALLOC? ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For I return the ith LABEL .
 1 returns the first label.
 All indices are compatible with this.
\end_layout

\begin_layout Scrap

<<LABELS[]>>=
\begin_inset Newline newline
\end_inset

: LABELS[] ( n -- a )   1- 2* CELLS LABELS CELL+ + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Remove label I.
\end_layout

\begin_layout Scrap

<<REMOVE-LABEL>>=
\begin_inset Newline newline
\end_inset

: REMOVE-LABEL ( -- )   LABELS[] LABELS  2DUP BAG-REMOVE BAG-REMOVE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Loop through all '
\family typewriter
\series bold
LABELS
\family default
\series default
', similar to '
\family typewriter
\series bold
DO-BAG ..
 DO-LOOP
\family default
\series default
' but with a stride of 2 cells and the bag built-in.
\end_layout

\begin_layout Scrap

<<DO-LAB>>=
\begin_inset Newline newline
\end_inset

: DO-LAB   POSTPONE LABELS POSTPONE DO-BAG ; IMMEDIATE
\begin_inset Newline newline
\end_inset

: LOOP-LAB   2 CELLS POSTPONE LITERAL POSTPONE +LOOP ; IMMEDIATE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
A simple printout of the payload.
\end_layout

\begin_layout Scrap

<<.PAY.>>=
\begin_inset Newline newline
\end_inset

: .PAY.
 ( a -- )   CELL+ ? ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the payload of the label at ADDRESS , provided it is a string.
\end_layout

\begin_layout Scrap

<<.PAY>>=
\begin_inset Newline newline
\end_inset

: .PAY$ ( a -- )   CELL+ @ $@ TYPE  3 SPACES ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the name of the label at ADDRESS , provided it is a dea.
 This applies to plain labels that are in fact constants.
\end_layout

\begin_layout Scrap

<<.PAY-DEA>>=
\begin_inset Newline newline
\end_inset

: .PAY-DEA ( a -- )   CELL+ @ %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For label INDEX return the label NAME, provided it is a dea.
\end_layout

\begin_layout Scrap

<<LABEL-NAME>>=
\begin_inset Newline newline
\end_inset

: LABEL-NAME ( n -- a n )   LABELS[] CELL+ @ >BODY >NFA @ $@ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the addresses and payloads of the labels.
\end_layout

\begin_layout Scrap

<<.LABELS>>=
\begin_inset Newline newline
\end_inset

: .LABELS ( -- )   DO-LAB  I @ .
  I .PAY  CR  LOOP-LAB ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return LOWER and UPPER indices of the labels, inclusive.
 The lower index is 1 and the upper index is corresponding.
\end_layout

\begin_layout Scrap

<<LAB-BOUNDS>>=
\begin_inset Newline newline
\end_inset

: LAB-BOUNDS ( -- l u )   1 LAB-UPB ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
In behalf of qsort.
 For INDEX1 and INDEX2: "the value of the first label is less than that
 of the second"
\end_layout

\begin_layout Scrap

<<LAB<>>=
\begin_inset Newline newline
\end_inset

: LAB< ( i1 i2 -- f )   LABELS[] @  SWAP LABELS[] @  SWAP < ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
In behalf of qsort.
 Exchange the labels with INDEX1 and INDEX2 .
\end_layout

\begin_layout Scrap

<<LAB<->>=
\begin_inset Newline newline
\end_inset

: LAB<-> ( i1 i2 -- )   LABELS[] SWAP LABELS[]  2 CELLS EXCHANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Sort the labels of '
\family typewriter
\series bold
LABELS
\family default
\series default
' in ascending order.
\end_layout

\begin_layout Scrap

<<SORT-LABELS>>=
\begin_inset Newline newline
\end_inset

: SORT-LABELS ( -- )   LAB-BOUNDS  ['] LAB<  ['] LAB<->  QSORT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
In behalf of bin-search.
 Comparant.
\end_layout

\begin_layout Scrap

<<CONT>>=
\begin_inset Newline newline
\end_inset

VARIABLE CONT
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
In behalf of bin-search.
 For INDEX1 : "the value of the label is less than '
\family typewriter
\series bold
CONT
\family default
\series default
'"
\end_layout

\begin_layout Scrap

<<L<>>=
\begin_inset Newline newline
\end_inset

: L< ( n -- f )   LABELS[] @  CONT @ < ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Find where ADDRESS belongs in a sorted array.
 Return the INDEX.
 If address is already present, its index is returned.
 This may be outside, if it is larger than any.
\end_layout

\begin_layout Scrap

<<WHERE-LABEL>>=
\begin_inset Newline newline
\end_inset

: WHERE-LABEL ( a -- )   CONT !  LAB-BOUNDS 1+  ['] L<  BIN-SEARCH ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Find the first label that is equal to (or greater than) VALUE.
 Return INDEX or zero if not found.
 Put it in the label-cache too.
 Note '
\family typewriter
\series bold
BIN-SEARCH
\family default
\series default
' returns the non-inclusive upper bound if not found.
\end_layout

\begin_layout Scrap

<<FIND-LABEL>>=
\begin_inset Newline newline
\end_inset

: FIND-LABEL ( n -- )   WHERE-LABEL  DUP LAB-UPB 1+ <> AND  DUP LABEL-CACHE
 ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Find ADDRESS in the label table.
 Return table ADDRESS of an exact matching label or zero if not found.
\end_layout

\begin_layout Scrap

<<>LABEL>>=
\begin_inset Newline newline
\end_inset

: >LABEL ( a -- )   DUP >R  FIND-LABEL DUP IF  LABELS[] DUP @  R@ <> IF
\begin_inset Newline newline
\end_inset

    DROP 0  THEN THEN
\begin_inset Newline newline
\end_inset

    R> DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Find ADDRESS in the label table.
 Return INDEX of an approximately matching label or zero if not found.
\end_layout

\begin_layout Scrap

<<(~LABEL)>>=
\begin_inset Newline newline
\end_inset

: (~LABEL)   DUP MAX-DEV-P @ + FIND-LABEL
\begin_inset Newline newline
\end_inset

    DUP 0= IF 2DROP 0 ELSE
\begin_inset Newline newline
\end_inset

        OVER MAX-DEV-N @ + OVER LABELS[] @  < IF 2DROP 0 ELSE
\begin_inset Newline newline
\end_inset

    SWAP DROP THEN THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS and INDEX return ADDRESS and INDEX where the deviation is minimal.
\end_layout

\begin_layout Scrap

<<IMPROVE-LABEL>>=
\begin_inset Newline newline
\end_inset

: IMPROVE-LABEL
\begin_inset Newline newline
\end_inset

    BEGIN  DUP LAB-UPB <> IF  2DUP 1+ LABELS[] @ < 0=  ELSE  0  THEN
\begin_inset Newline newline
\end_inset

    WHILE  1+  REPEAT ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Find target ADDRESS in the label table.
 Return table ADDRESS of an approximately matching label, or zero if not
 found, plus the OFFSET.
\end_layout

\begin_layout Scrap

<<~LABEL>>=
\begin_inset Newline newline
\end_inset

: ~LABEL   DUP (~LABEL) DUP 0= IF  2DROP 0 0
\begin_inset Newline newline
\end_inset

    ELSE  IMPROVE-LABEL  LABELS[] SWAP OVER @ -  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Roll the last label to place INDEX.
 A label occupies two consecutive places!
\end_layout

\begin_layout Scrap

<<ROLL-LABEL>>=
\begin_inset Newline newline
\end_inset

: ROLL-LABEL   DUP   LABELS[]  DUP LABELS BAG-HOLE   LABELS BAG-HOLE
\begin_inset Newline newline
\end_inset

    LAB-BOUNDS SWAP DROP   LAB<->   -2 CELLS LABELS  +! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
FIXME: The following is dead code.
 (As is 
\family typewriter
\series bold
LABEL-CACHE
\family default
\series default
).
 Return the next label or 0.
\end_layout

\begin_layout Scrap

<<NEXT-LABEL>>=
\begin_inset Newline newline
\end_inset

: NEXT-LABEL   LABEL-CACHE @   DUP IF
\begin_inset Newline newline
\end_inset

        1+ DUP LAB-BOUNDS + = IF DROP 0 THEN
\begin_inset Newline newline
\end_inset

    DUP LABEL-CACHE ! THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Names of labels
\end_layout

\begin_layout Scrap

<<names-of-labels>>=
\begin_inset Newline newline
\end_inset

<<.EQU>>
\begin_inset Newline newline
\end_inset

<<EQU-LABELS>>
\begin_inset Newline newline
\end_inset

<<LABELED>>
\begin_inset Newline newline
\end_inset

<<LABEL>>
\begin_inset Newline newline
\end_inset

<<=EQU-LABEL>>
\begin_inset Newline newline
\end_inset

<<.EQU-ALL>>
\begin_inset Newline newline
\end_inset

<<ADORN-WITH-LABEL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX FFFF0000 CONSTANT LARGE-NUMBER-MASK
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<.0?>>
\begin_inset Newline newline
\end_inset

<<SMART.>>
\begin_inset Newline newline
\end_inset

<<.~LABEL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

VARIABLE SMALL-LABEL-LIMIT   100 SMALL-LABEL-LIMIT !
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<.LABEL/.>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 0 SMALL-LABEL-LIMIT !
\begin_inset Newline newline
\end_inset


\backslash
D 12 LABEL AAP
\begin_inset Newline newline
\end_inset


\backslash
D 5 LABEL NOOT
\begin_inset Newline newline
\end_inset


\backslash
D 2 LABEL MIES
\begin_inset Newline newline
\end_inset


\backslash
D 123 LABEL POPI
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D .LABELS CR
\begin_inset Newline newline
\end_inset


\backslash
D SORT-LABELS
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS CR
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 200 FIND-LABEL .
 CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 FIND-LABEL  LABELS[] .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 1- FIND-LABEL  LABELS[] .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 >LABEL .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 1- >LABEL H.
 CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 ADORN-WITH-LABEL  4 <?> CR  
\backslash
 Should give zero, not found!
\begin_inset Newline newline
\end_inset


\backslash
D 12 0 HOST>TARGET - ADORN-WITH-LABEL  CR
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<@LABEL>>
\begin_inset Newline newline
\end_inset

<<LABEL=>>
\begin_inset Newline newline
\end_inset

<<REMOVE-TRIVIAL>>
\begin_inset Newline newline
\end_inset

<<CLEAN-LABELS>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Decompile label INDEX.
\end_layout

\begin_layout Scrap

<<.EQU>>=
\begin_inset Newline newline
\end_inset

: .EQU    LABELS[] DUP @ 8 H.R S"  LABEL " TYPE  CELL+ @ %ID.
 CR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains equ labels, i.e.
 classes as associate with '
\family typewriter
\series bold
LABEL
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<EQU-LABELS>>=
\begin_inset Newline newline
\end_inset

MAX-LABEL ' .PAY-DEA ' .EQU LABELSTRUCT EQU-LABELS  LABELS !BAG
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate a equ label at (target) ADDRESS with NAME, this can be any symbolic
 constant in fact.
 The payload is the dea of a constant leaving that address.
\end_layout

\begin_layout Scrap

<<LABELED>>=
\begin_inset Newline newline
\end_inset

: LABELED ( x a n -- )   S" CREATE " PAD $!  PAD COUNT + OVER
\begin_inset Newline newline
\end_inset

    2SWAP PAD $+!  PAD $@ EVALUATE  HERE >R  'LABELS @ , ( >LFA )
\begin_inset Newline newline
\end_inset

    R@ 'LABELS !  HERE 2 CELLS + , ( >NFA )  ROT DUP , ( >DATA )
\begin_inset Newline newline
\end_inset

    -ROT $, DROP  EQU-LABELS  LAB+!  R> LAB+!
\begin_inset Newline newline
\end_inset

    DOES> ( -- x )   >DATA @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate a equ label at (target) ADDRESS with "NAME".
 Like '
\family typewriter
\series bold
LABEL
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<LABEL>>=
\begin_inset Newline newline
\end_inset

: LABEL   BL WORD COUNT LABELED ;
\begin_inset Newline newline
\end_inset

: EQU LABEL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For host ADDRESS return an associated equ LABEL or 0.
 CAVEAT: if there are more than one label for the same addres, just the
 first one is returned.
\end_layout

\begin_layout Scrap

<<=EQU-LABEL>>=
\begin_inset Newline newline
\end_inset

: =EQU-LABEL   HOST>TARGET  EQU-LABELS >LABEL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For host ADDRESS print all labels at that addres, return the NUMBER of labels
 printed.
\end_layout

\begin_layout Scrap

<<.EQU-ALL>>=
\begin_inset Newline newline
\end_inset

: .EQU-ALL   HOST>TARGET  EQU-LABELS   0 ( no labels printed) SWAP
\begin_inset Newline newline
\end_inset

    LAB-UPB 1+ OVER WHERE-LABEL ?DO
\begin_inset Newline newline
\end_inset

        DUP I LABELS[] @ <> IF LEAVE THEN
\begin_inset Newline newline
\end_inset

        SWAP 1+ SWAP
\begin_inset Newline newline
\end_inset

        [CHAR] : EMIT I LABELS[] .PAY
\begin_inset Newline newline
\end_inset

    LOOP DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Adorn the ADDRESS we are currently disassembling with a named label if any.
\end_layout

\begin_layout Scrap

<<ADORN-WITH-LABEL>>=
\begin_inset Newline newline
\end_inset

: ADORN-WITH-LABEL   .EQU-ALL    0= IF 12 SPACES THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Prevent leading hex letter for NUMBER by printing a zero.
\end_layout

\begin_layout Scrap

<<.0?>>=
\begin_inset Newline newline
\end_inset

: .0?   DUP 0A0 100 WITHIN SWAP 0A 10 WITHIN OR IF [CHAR] 0 EMIT THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a NUMBER in hex in a smart way.
\end_layout

\begin_layout Scrap

<<SMART.>>=
\begin_inset Newline newline
\end_inset

: SMART.
   DUP ABS 100 < IF DUP .0? .
 ELSE
\begin_inset Newline newline
\end_inset

    LARGE-NUMBER-MASK OVER AND IF 8 ELSE 4 THEN H.R SPACE THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For label INDEX and OFFSET print the label with offset.
\end_layout

\begin_layout Scrap

<<.~LABEL>>=
\begin_inset Newline newline
\end_inset

: .~LABEL   SWAP .PAY   ?DUP IF
\begin_inset Newline newline
\end_inset

    DUP 0< IF NEGATE .
 S" - " TYPE ELSE .
 S" + " TYPE THEN THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print X as a symbolic label if possible, else as a number.
\end_layout

\begin_layout Scrap

<<.LABEL/.>>=
\begin_inset Newline newline
\end_inset

: .LABEL/.
   EQU-LABELS
\begin_inset Newline newline
\end_inset

    DUP ABS SMALL-LABEL-LIMIT @ < IF SMART.
\begin_inset Newline newline
\end_inset

    ELSE DUP ~LABEL OVER IF .~LABEL DROP
\begin_inset Newline newline
\end_inset

    ELSE 2DROP SMART.
\begin_inset Newline newline
\end_inset

    THEN THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For label INDEX , return its XT.
\end_layout

\begin_layout Scrap

<<@LABEL>>=
\begin_inset Newline newline
\end_inset

: @LABEL    LABELS[] CELL+ @ ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 5 DUP INVENT-NAME LABELED
\begin_inset Newline newline
\end_inset


\backslash
D SORT-LABELS .LABELS 5 <?> CR
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS 6 <?> CR
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 5: " TYPE 5 FIND-LABEL @LABEL >DATA @ .
 7 <?> CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For labels INDEX1 and INDEX2 return "they are equal".
\end_layout

\begin_layout Scrap

<<LABEL=>>=
\begin_inset Newline newline
\end_inset

: LABEL=   @LABEL >DATA @   SWAP @LABEL >DATA @   = ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT -1:" TYPE 5 FIND-LABEL DUP 1+ LABEL= .
 CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Get rid of a label with INDEX if trivial .
 Return next INDEX to try.
\end_layout

\begin_layout Scrap

<<REMOVE-TRIVIAL>>=
\begin_inset Newline newline
\end_inset

: REMOVE-TRIVIAL   DUP @LABEL DUP >DATA @ SWAP >NFA @ $@ INVENTED-NAME?
 IF
\begin_inset Newline newline
\end_inset

        DUP REMOVE-LABEL ELSE 1+ THEN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 5 FIND-LABEL  DUP REMOVE-TRIVIAL .
  REMOVE-TRIVIAL .
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS 8 <?> CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Get rid of superfluous equ labels
\end_layout

\begin_layout Scrap

<<CLEAN-LABELS>>=
\begin_inset Newline newline
\end_inset

: CLEAN-LABELS   EQU-LABELS
\begin_inset Newline newline
\end_inset

    2 BEGIN DUP LAB-UPB < WHILE DUP DUP 1- LABEL= >R DUP DUP 1+ LABEL= R>
 OR IF
\begin_inset Newline newline
\end_inset

            REMOVE-TRIVIAL ELSE 1+ THEN REPEAT DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 5 DUP INVENT-NAME LABELED  SORT-LABELS
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS 9 <?> CR
\begin_inset Newline newline
\end_inset


\backslash
D CLEAN-LABELS
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS 10 <?> CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Comment remainder of line
\end_layout

\begin_layout Standard
Comment till remainder of line.
\end_layout

\begin_layout Scrap

<<comment-remainder>>=
\begin_inset Newline newline
\end_inset

<<.COMMENT:>>
\begin_inset Newline newline
\end_inset

<<COMMENT:-LABELS>>
\begin_inset Newline newline
\end_inset

<<COMMENT:>>
\begin_inset Newline newline
\end_inset

<<COMMENT:-TO-BE>>
\begin_inset Newline newline
\end_inset

<<INIT-COMMENT:>>
\begin_inset Newline newline
\end_inset

<<PRINT-OLD-COMMENT:>>
\begin_inset Newline newline
\end_inset

<<REMEMBER-COMMENT:>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D .LABELS CR
\begin_inset Newline newline
\end_inset


\backslash
D SORT-LABELS
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS CR
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 200 FIND-LABEL .
 CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 FIND-LABEL  LABELS[] .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 1- FIND-LABEL  LABELS[] .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 >LABEL .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 1- >LABEL H.
 CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Decompile comment: label INDEX.
\end_layout

\begin_layout Scrap

<<.COMMENT:>>=
\begin_inset Newline newline
\end_inset

: .COMMENT:   LABELS[] DUP @ 8 H.R S"  COMMENT: " TYPE  CELL+ @ $@ TYPE CR
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains comment labels, i.e.
 classes as associate with '
\family typewriter
\series bold
COMMENT:
\family default
\series default
'
\end_layout

\begin_layout Scrap

<<COMMENT:-LABELS>>=
\begin_inset Newline newline
\end_inset

MAX-LABEL ' .PAY$ ' .COMMENT: LABELSTRUCT COMMENT:-LABELS  LABELS !BAG
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Generate a comment label at ADDRESS.
 A pointer to the remainder of the line is the payload.
\end_layout

\begin_layout Scrap

<<COMMENT:>>=
\begin_inset Newline newline
\end_inset

: COMMENT:   COMMENT:-LABELS   LAB+!  [CTRL] J PARSE $, LAB+! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 12 COMMENT: AAP
\begin_inset Newline newline
\end_inset


\backslash
D 115 COMMENT: NOOTJE
\begin_inset Newline newline
\end_inset


\backslash
D 2 COMMENT: MIES
\begin_inset Newline newline
\end_inset


\backslash
D 123 COMMENT: POPI
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Remember the comment at the end of this instruction.
 Zero means no comment.
\end_layout

\begin_layout Scrap

<<COMMENT:-TO-BE>>=
\begin_inset Newline newline
\end_inset

VARIABLE COMMENT:-TO-BE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Initialise to no comment.
\end_layout

\begin_layout Scrap

<<INIT-COMMENT:>>=
\begin_inset Newline newline
\end_inset

: INIT-COMMENT:   0 COMMENT:-TO-BE ! ;
\begin_inset Newline newline
\end_inset

  INIT-COMMENT:
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print comment at the end of previous instruction.
\end_layout

\begin_layout Scrap

<<PRINT-OLD-COMMENT:>>=
\begin_inset Newline newline
\end_inset

: PRINT-OLD-COMMENT:   COMMENT:-TO-BE @ DUP IF
\begin_inset Newline newline
\end_inset

    S" 
\backslash
 " TYPE   $@ TYPE _ THEN DROP
\begin_inset Newline newline
\end_inset

    INIT-COMMENT: ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Remember what comment to put after the disassembly of ADDRESS.
\end_layout

\begin_layout Scrap

<<REMEMBER-COMMENT:>>=
\begin_inset Newline newline
\end_inset

: REMEMBER-COMMENT:   COMMENT:-LABELS   HOST>TARGET >LABEL
\begin_inset Newline newline
\end_inset

    DUP IF CELL+ @ COMMENT:-TO-BE ! _ THEN DROP  ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 12 REMEMBER-COMMENT: PRINT-OLD-COMMENT: CR  
\backslash
 Should give nothing, not found!
\begin_inset Newline newline
\end_inset


\backslash
D 12 0 HOST>TARGET - REMEMBER-COMMENT: PRINT-OLD-COMMENT: CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Multi-line comments
\end_layout

\begin_layout Standard
Multiple line comment/command in front.
\end_layout

\begin_layout Scrap

<<multi-line-comment>>=
\begin_inset Newline newline
\end_inset

<<.MDIRECTIVE>>
\begin_inset Newline newline
\end_inset

<<MCOMMENT-LABELS>>
\begin_inset Newline newline
\end_inset

<<NEW-DIRECTIVE>>
\begin_inset Newline newline
\end_inset

<<OLD-DIRECTIVE>>
\begin_inset Newline newline
\end_inset

<<DIRECTIVE>>
\begin_inset Newline newline
\end_inset

<<COMMENT>>
\begin_inset Newline newline
\end_inset

<<PRINT-DIRECTIVE>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D .LABELS CR
\begin_inset Newline newline
\end_inset


\backslash
D SORT-LABELS
\begin_inset Newline newline
\end_inset


\backslash
D .LABELS CR
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 200 FIND-LABEL .
 CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 FIND-LABEL  LABELS[] .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 1- FIND-LABEL  LABELS[] .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 >LABEL .PAY CR
\begin_inset Newline newline
\end_inset


\backslash
D 12 1- >LABEL H.
 CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Decompile mcomment label INDEX.
 Duplicate the line heading on each line of output.
\end_layout

\begin_layout Scrap

<<.MDIRECTIVE>>=
\begin_inset Newline newline
\end_inset

: .MDIRECTIVE   LABELS[] DUP @ DUP >R 8 H.R S"  :COMMENT " TYPE
\begin_inset Newline newline
\end_inset

    CELL+ @ $@  BEGIN  2DUP 10 SCAN ?DUP
\begin_inset Newline newline
\end_inset

    WHILE  1 /STRING 2SWAP 2OVER NIP - 1- 2 /STRING TYPE CR
\begin_inset Newline newline
\end_inset

        R@ 8 H.R S"  :COMMENT " TYPE
\begin_inset Newline newline
\end_inset

    REPEAT  R> 2DROP 2 /STRING TYPE CR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains multiple line comment labels, i.e.
 classes associate with '
\family typewriter
\series bold
COMMENT
\family default
\series default
'
\end_layout

\begin_layout Scrap

<<MCOMMENT-LABELS>>=
\begin_inset Newline newline
\end_inset

MAX-LABEL ' .PAY$ ' .MDIRECTIVE LABELSTRUCT MCOMMENT-LABELS  LABELS !BAG
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
New directive STRING at ADDRESS.
 (See '
\family typewriter
\series bold
DIRECTIVE
\family default
\series default
').
 Primitive, doesn't keep it sorted.
\end_layout

\begin_layout Scrap

<<NEW-DIRECTIVE>>=
\begin_inset Newline newline
\end_inset

: NEW-DIRECTIVE ( a n x -- )   LAB+! $, LAB+! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Directive STRING to old ADDRESS.
 Append.
 (See '
\family typewriter
\series bold
DIRECTIVE
\family default
\series default
').
\end_layout

\begin_layout Scrap

<<OLD-DIRECTIVE>>=
\begin_inset Newline newline
\end_inset

: OLD-DIRECTIVE ( a n -- )   >LABEL CELL+ DUP >R
\begin_inset Newline newline
\end_inset

    @ $@ PAD $!  [CTRL] J PAD $C+  PAD $+!  PAD $@ $, R> ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make STRING the command in front of label at ADDRESS.
 A pointer to this string the payload.
 If there is already a directive there, this one is appended.
 Keep things sorted.
\end_layout

\begin_layout Scrap

<<DIRECTIVE>>=
\begin_inset Newline newline
\end_inset

: DIRECTIVE ( a n x -- )   MCOMMENT-LABELS >R
\begin_inset Newline newline
\end_inset

    R@ >LABEL IF   R@ OLD-DIRECTIVE   ELSE
\begin_inset Newline newline
\end_inset

    R@ NEW-DIRECTIVE   R@ WHERE-LABEL ROLL-LABEL THEN R> DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make STRING the comment in front of label at ADDRESS.
 A pointer to this string the payload.
\end_layout

\begin_layout Scrap

<<COMMENT>>=
\begin_inset Newline newline
\end_inset

: COMMENT ( a n x -- )   >R  S" 
\backslash
 " $,  DUP >R  OVER ALLOT  $+!
\begin_inset Newline newline
\end_inset

    R> $@  R> DIRECTIVE ;
\begin_inset Newline newline
\end_inset

: :COMMENT ( x -line- )   [CTRL] J PARSE $, $@ ROT COMMENT ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D S" AAP" 12 COMMENT
\begin_inset Newline newline
\end_inset


\backslash
D S" NOOT" 5 COMMENT
\begin_inset Newline newline
\end_inset


\backslash
D S" MIES" 2 COMMENT
\begin_inset Newline newline
\end_inset


\backslash
D S" POPI
\begin_inset Newline newline
\end_inset


\backslash
 
\backslash
D JOPI"
\begin_inset Newline newline
\end_inset


\backslash
D 123 COMMENT
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print comment for instruction at ADDRESS , if any.
\end_layout

\begin_layout Scrap

<<PRINT-DIRECTIVE>>=
\begin_inset Newline newline
\end_inset

: PRINT-DIRECTIVE MCOMMENT-LABELS  HOST>TARGET  >LABEL DUP IF
\begin_inset Newline newline
\end_inset

    CR   .PAY _ THEN DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 12 PRINT-DIRECTIVE CR  
\backslash
 Should give nothing, not found!
\begin_inset Newline newline
\end_inset


\backslash
D 12 0 HOST>TARGET - PRINT-DIRECTIVE CR
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Printing strings
\end_layout

\begin_layout Standard
The special printing of strings.
\end_layout

\begin_layout Scrap

<<printing-strings>>=
\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE NEW-IF
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<TABLE2>>
\begin_inset Newline newline
\end_inset

<<IS-CTRL>>
\begin_inset Newline newline
\end_inset

<<IS-PRINT>>
\begin_inset Newline newline
\end_inset

<<ACCU>>
\begin_inset Newline newline
\end_inset

<<.ACCU>>
\begin_inset Newline newline
\end_inset

<<.C>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 FIXME: to be renamd in WHERE-FLUSH
\begin_inset Newline newline
\end_inset

VARIABLE NEXT-CUT       
\backslash
 Host address where to separate db etc.
 in chunks.
\begin_inset Newline newline
\end_inset

VARIABLE CUT-SIZE    16 CUT-SIZE !   
\backslash
 Chunks for data-disassembly.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<ACCU-C+>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains a printing indicator:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
as hex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
control character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a blank
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
"xxx xxx"
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal printable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&Z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
"xxxZxxx"
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Scrap

<<TABLE2>>=
\begin_inset Newline newline
\end_inset

CREATE TABLE2 256 ALLOT      TABLE2 256 ERASE
\begin_inset Newline newline
\end_inset

: /TABLE2 [CHAR] ~ 1 + BL 1 + DO 3 TABLE2 I + C! LOOP ;
\begin_inset Newline newline
\end_inset

/TABLE2
\begin_inset Newline newline
\end_inset

2 BL TABLE2 + C!
\begin_inset Newline newline
\end_inset

1 CTRL I TABLE2 + C!
\begin_inset Newline newline
\end_inset

1 CTRL J TABLE2 + C!
\begin_inset Newline newline
\end_inset

1 CTRL M TABLE2 + C!
\begin_inset Newline newline
\end_inset

1 CTRL L TABLE2 + C!
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For CHAR: "it is control"
\end_layout

\begin_layout Scrap

<<IS-CTRL>>=
\begin_inset Newline newline
\end_inset

: IS-CTRL   TABLE2 + C@ 1 = ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 0 -1 :" TYPE CHAR A IS-CTRL .
   CTRL J IS-CTRL .
 CR 11 <?>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For CHAR: "it is printable".
\end_layout

\begin_layout Scrap

<<IS-PRINT>>=
\begin_inset Newline newline
\end_inset

: IS-PRINT   TABLE2 + C@ 1 > ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 0 -1 -1 :" TYPE CTRL A IS-PRINT .
\begin_inset Newline newline
\end_inset


\backslash
D CHAR A IS-PRINT .
 BL IS-PRINT .
 CR 12 <?>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Accumulates characters that may form a string.
\end_layout

\begin_layout Scrap

<<ACCU>>=
\begin_inset Newline newline
\end_inset

CREATE ACCU 100 ALLOT           ACCU 100 ERASE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 
\backslash
D S" Expect " TYPE  """ AA""""AA """ TYPE CHAR : EMIT " AA""AA " S" $" TYPE
 CR 13 <?>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the accumulated chars, if any.
\end_layout

\begin_layout Scrap

<<.ACCU>>=
\begin_inset Newline newline
\end_inset

: .ACCU   ACCU $@
\begin_inset Newline newline
\end_inset

    OVER C@ BL = OVER 1 = AND IF  2DROP  S"  BL" TYPE  ELSE
\begin_inset Newline newline
\end_inset

        DUP 1 > IF  SPACE [CHAR] " EMIT SPACE TYPE [CHAR] " EMIT  ELSE
\begin_inset Newline newline
\end_inset

            IF  SPACE [CHAR] " EMIT SPACE C@ EMIT [CHAR] " EMIT  ELSE  DROP
\begin_inset Newline newline
\end_inset

    THEN THEN THEN  0 0 ACCU $! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT " TYPE  S" XY :" TYPE  S" XY" ACCU $! .ACCU CR 14 <?>
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT BL :" TYPE   S"  " ACCU $!   .ACCU CR 15 <?>
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT CHAR Y :" TYPE   S" Y" ACCU $!   .ACCU CR 16 <?>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Display a BYTE in clean hex.
 Display the non-printable character.
\end_layout

\begin_layout Scrap

<<.C>>=
\begin_inset Newline newline
\end_inset

: .B-CLEAN   DUP .0? 0 <# BL HOLD #S #> TYPE ;
\begin_inset Newline newline
\end_inset

: .C   .ACCU SPACE DUP IS-CTRL IF  S" CTRL " TYPE  [CHAR] @ + EMIT
\begin_inset Newline newline
\end_inset

    ELSE  .B-CLEAN  THEN  ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT CTRL J :" TYPE  CTRL J .C CR 17 <?>
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 0: " TYPE  0 .C CR 18 <?>
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 9A: " TYPE  HEX 9A .C CR 19 <?> DECIMAL
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 0FA: " TYPE  HEX FA .C CR 20 <?> DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDR of a (printable) char, add it to the accumulated range.
 Force an immediate flush, if the range is full.
 Otherwise postpone the flush at least one char.
 If the character following is a string ender, this is a desirable place
 to break.
 (String enders like ^J and 0 are not printable.)
\end_layout

\begin_layout Scrap

<<ACCU-C+>>=
\begin_inset Newline newline
\end_inset

: ACCU-$C+   DUP C@ ACCU $C+   ACCU @ 64 = IF 1+ ELSE 2 + THEN NEXT-CUT
 ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Start of line
\end_layout

\begin_layout Standard
Things to print at the start of a line.
\end_layout

\begin_layout Scrap

<<start-of-line>>=
\begin_inset Newline newline
\end_inset

<<.TARGET-ADDRESS>>
\begin_inset Newline newline
\end_inset

<<CR-ADORNED>>
\begin_inset Newline newline
\end_inset

<<NEXT-CUT?>>
\begin_inset Newline newline
\end_inset

<<CR+GENERIC>>
\begin_inset Newline newline
\end_inset

<<CR+dx>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the ADDRES as target address in hex.
\end_layout

\begin_layout Scrap

<<.TARGET-ADDRESS>>=
\begin_inset Newline newline
\end_inset

: .TARGET-ADDRESS S" ( " TYPE DUP HOST>TARGET 8 H.R S"  )   " TYPE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Start a new line, with printing the decompiled ADDRESS as seen.
\end_layout

\begin_layout Scrap

<<CR-ADORNED>>=
\begin_inset Newline newline
\end_inset

: CR-ADORNED
\begin_inset Newline newline
\end_inset

    PRINT-OLD-COMMENT:
\begin_inset Newline newline
\end_inset

    DUP PRINT-DIRECTIVE
\begin_inset Newline newline
\end_inset

    CR 'ADORN-ADDRESS 2@ - IF  .TARGET-ADDRESS  THEN
\begin_inset Newline newline
\end_inset

    ADORN-WITH-LABEL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS: "it is at next cut." If so, advance.
\end_layout

\begin_layout Scrap

<<NEXT-CUT?>>=
\begin_inset Newline newline
\end_inset

: NEXT-CUT?   NEXT-CUT @ =  DUP IF CUT-SIZE @ NEXT-CUT +! THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS and assembler directive STRING (such "
\family typewriter
\series bold
db
\family default
\series default
"), interrupt the laying down of memory classes by a new line and possibly
 a label, when appropriate.
\end_layout

\begin_layout Scrap

<<CR+GENERIC>>=
\begin_inset Newline newline
\end_inset

: CR+GENERIC   2>R DUP =EQU-LABEL >R DUP NEXT-CUT?   R> OR IF
\begin_inset Newline newline
\end_inset

    DUP CR-ADORNED  2R@ TYPE THEN REMEMBER-COMMENT: 2R> 2DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: CR+$         2>R DUP =EQU-LABEL >R DUP NEXT-CUT?   R> OR IF .ACCU
\begin_inset Newline newline
\end_inset

    DUP CR-ADORNED  2R@ TYPE THEN REMEMBER-COMMENT: 2R> 2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS : interupt byte display.
\end_layout

\begin_layout Scrap

<<CR+dx>>=
\begin_inset Newline newline
\end_inset

: CR+dn   S"   " CR+GENERIC ;
\begin_inset Newline newline
\end_inset

: CR+db   S"   db " CR+GENERIC ;
\begin_inset Newline newline
\end_inset

: CR+dw   S"   dw " CR+GENERIC ;
\begin_inset Newline newline
\end_inset

: CR+dl   S"   dl " CR+GENERIC ;
\begin_inset Newline newline
\end_inset

: CR+d$   S"   d$ " CR+$ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Disassembly ranges
\end_layout

\begin_layout Standard
A 'range' is defined here as a range of addresses that is kept together,
 even during relocation and such, and contains data for the same type.
 A 'section' is defined here as a range of addresses that is kept together,
 even during relocation and such, where data need not be of the same type.
 'Disassembly' is to be understood as interpreting the content of a range,
 not necessarily as executable code.
 Range ADDRESS1 ..
 ADDRESS2 always refers to a target range, where address2 is exclusive.
\end_layout

\begin_layout Scrap

<<disassembly-ranges>>=
\begin_inset Newline newline
\end_inset

0 VALUE CURRENT-RANGE 
\backslash
 current range pointer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<RANGE-FIELD>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

0
\begin_inset Newline newline
\end_inset

    2 CELLS RANGE-FIELD RANGE-RESERVED
\begin_inset Newline newline
\end_inset

    1 CELLS RANGE-FIELD 'RANGE-START      
\backslash
 Start of range
\begin_inset Newline newline
\end_inset

    1 CELLS RANGE-FIELD 'RANGE-END        
\backslash
 End of range
\begin_inset Newline newline
\end_inset

    1 CELLS RANGE-FIELD 'RANGE-STRIDE     
\backslash
 For the moment = 1 FIXME!
\begin_inset Newline newline
\end_inset

    1 CELLS RANGE-FIELD 'RANGE-XT
\begin_inset Newline newline
\end_inset

    1 CELLS RANGE-FIELD 'RANGE-SECTION
\begin_inset Newline newline
\end_inset

CONSTANT |RANGE|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: RANGE-START ( -- a )   'RANGE-START @ ;
\begin_inset Newline newline
\end_inset

: RANGE-END! ( a -- )   'RANGE-END ! ;
\begin_inset Newline newline
\end_inset

: RANGE-END ( -- a )   'RANGE-END @ ;
\begin_inset Newline newline
\end_inset

: RANGE-STRIDE ( -- n )   'RANGE-STRIDE @ ;
\begin_inset Newline newline
\end_inset

: RANGE-XT ( -- xt )   'RANGE-XT @ ;
\begin_inset Newline newline
\end_inset

: RANGE-DECODE ( -- )   'RANGE-XT @ >R RANGE-START RANGE-END R> EXECUTE
 ;
\begin_inset Newline newline
\end_inset

: RANGE-SECTION ( a -- )   TO CURRENT-RANGE
\begin_inset Newline newline
\end_inset

    'RANGE-SECTION @ TO CURRENT-SECTION ;
\begin_inset Newline newline
\end_inset

<<.PAY-RANGE>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

20 BAG RANGE-TYPES  
\backslash
 Contains dea of dumper, creator, alternating.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<ARE-COUPLED>>
\begin_inset Newline newline
\end_inset

<<CREATOR-XT>>
\begin_inset Newline newline
\end_inset

<<MAKE-CURRENT>>
\begin_inset Newline newline
\end_inset

<<DECOMP-RANGE>>
\begin_inset Newline newline
\end_inset

<<RANGE-LABELS>>
\begin_inset Newline newline
\end_inset

<<RANGE>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

0 VALUE DISASSEMBLERS
\begin_inset Newline newline
\end_inset

0 VALUE RANGE-RANGES
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

0
\begin_inset Newline newline
\end_inset

    2 CELLS DEA-FIELD DEA-RESERVED
\begin_inset Newline newline
\end_inset

    1 CELLS DEA-FIELD >DIS:
\begin_inset Newline newline
\end_inset

CONSTANT |DISASSEMBLER|
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<DIS:>>
\begin_inset Newline newline
\end_inset

<<RANGE:>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Define a range.
\end_layout

\begin_layout Scrap

<<RANGE-FIELD>>=
\begin_inset Newline newline
\end_inset

: RANGE-FIELD ( u size -- u' )   CREATE  OVER , +
\begin_inset Newline newline
\end_inset

    DOES> ( -- a )   @ CURRENT-RANGE + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print the range LAB as a matter of testing.
\end_layout

\begin_layout Scrap

<<.PAY-RANGE>>=
\begin_inset Newline newline
\end_inset

: .PAY-RANGE   CELL+ @ DUP RANGE-SECTION
\begin_inset Newline newline
\end_inset

    RANGE-START 8 H.R SPACE  RANGE-END 8 H.R  S"  BY " TYPE
\begin_inset Newline newline
\end_inset

    RANGE-XT >BODY %ID.
  %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
DEA of dump belongs to DEA of creator.
 Add to '
\family typewriter
\series bold
RANGE-TYPES
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<ARE-COUPLED>>=
\begin_inset Newline newline
\end_inset

: ARE-COUPLED   >BODY SWAP >BODY  RANGE-TYPES BAG+! RANGE-TYPES BAG+! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For current range, return the XT of a proper defining word.
\end_layout

\begin_layout Scrap

<<CREATOR-XT>>=
\begin_inset Newline newline
\end_inset

: CREATOR-XT   RANGE-XT >BODY RANGE-TYPES BAG-WHERE CELL+ @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Make range I current, provided the payload is a dea.
\end_layout

\begin_layout Scrap

<<MAKE-CURRENT>>=
\begin_inset Newline newline
\end_inset

: MAKE-CURRENT ( n -- )   LABELS[] CELL+ @ RANGE-SECTION ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Display range INDEX in a reconsumable form.
 Shortens the 
\family typewriter
\series bold
NONAME
\family default
\series default
 ranges with a 
\begin_inset Quotes eld
\end_inset


\family typewriter
\series bold
-
\family default
\series default

\begin_inset Quotes erd
\end_inset

 replacing the 
\begin_inset Quotes eld
\end_inset


\family typewriter
\series bold
:
\family default
\series default

\begin_inset Quotes erd
\end_inset

 at the end of the type name.
\end_layout

\begin_layout Scrap

<<DECOMP-RANGE>>=
\begin_inset Newline newline
\end_inset

: DECOMP-RANGE   MAKE-CURRENT RANGE-START 8 H.R SPACE RANGE-END 8 H.R SPACE
\begin_inset Newline newline
\end_inset

    CURRENT-RANGE >NFA @ $@  CREATOR-XT >NFA @ $@
\begin_inset Newline newline
\end_inset

    2OVER S" NONAME" COMPARE 0= IF
\begin_inset Newline newline
\end_inset

        1- TYPE ." - "  2DROP
\begin_inset Newline newline
\end_inset

    ELSE  TYPE SPACE  TYPE
\begin_inset Newline newline
\end_inset

    THEN  CR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains range specification, limits plus type.
\end_layout

\begin_layout Scrap

<<RANGE-LABELS>>=
\begin_inset Newline newline
\end_inset

MAX-LABEL ' .PAY-RANGE ' DECOMP-RANGE LABELSTRUCT RANGE-LABELS  LABELS !BAG
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Create a disassembly range from AD1 to AD2 using dis-assembler DEA1 with
 or without a name.
 Register it as a labeled range.
\end_layout

\begin_layout Scrap

<<RANGE>>=
\begin_inset Newline newline
\end_inset

: RANGE ( ad1 ad2 dea1 a n -- )   S" CREATE " PAD $!  PAD COUNT + OVER
\end_layout

\begin_layout Scrap

    2SWAP PAD $+!  PAD $@ EVALUATE  HERE DUP >R  |RANGE| DUP ALLOT  ERASE
\end_layout

\begin_layout Scrap

    $, R@ >NFA !  CURRENT-RANGE R@ >LFA !  R> TO CURRENT-RANGE
\end_layout

\begin_layout Scrap

    'RANGE-XT !  1 'RANGE-STRIDE !  'RANGE-END !  'RANGE-START !
\end_layout

\begin_layout Scrap

    RANGE-LABELS  RANGE-START LAB+!  CURRENT-RANGE LAB+!
\end_layout

\begin_layout Scrap

    CURRENT-SECTION 'RANGE-SECTION !
\end_layout

\begin_layout Scrap

    DOES>  RANGE-SECTION ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: ANON-RANGE ( ad1 ad2 dea1 -- )   -warning >R  NONAME$ RANGE  R> +warning
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<DIS:>>=
\begin_inset Newline newline
\end_inset

: DIS: ( xt -- )   SAVE-INPUT  CREATE  HERE DUP >R  |DISASSEMBLER| DUP
\begin_inset Newline newline
\end_inset

    ALLOT  ERASE  RESTORE-INPUT THROW  BL WORD $@ $, R@ >NFA !
\begin_inset Newline newline
\end_inset

    DISASSEMBLERS R@ >LFA !  R@ >DIS: !  R> TO DISASSEMBLERS
\begin_inset Newline newline
\end_inset

    DOES> ( a1 a2 -- )   >R TARGET>HOST SWAP TARGET>HOST
\begin_inset Newline newline
\end_inset

        DUP NEXT-CUT !  R> >DIS: @ EXECUTE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<RANGE:>>=
\begin_inset Newline newline
\end_inset

: RANGE: ( xt -- )   SAVE-INPUT  CREATE  HERE DUP >R  |DISASSEMBLER| DUP
\begin_inset Newline newline
\end_inset

    ALLOT  ERASE  RESTORE-INPUT THROW  BL WORD $@ $, R@ >NFA !
\begin_inset Newline newline
\end_inset

    RANGE-RANGES R@ >LFA !  R@ >DIS: !  R> TO RANGE-RANGES
\begin_inset Newline newline
\end_inset

    DOES> ( a1 a2 -- )   >R BL WORD COUNT  R> >DIS: @ EXECUTE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Disassemble
\end_layout

\begin_layout Scrap

<<disassemble>>=
\begin_inset Newline newline
\end_inset

<<(D-R-T)>>
\begin_inset Newline newline
\end_inset

<<D-R-T>>
\begin_inset Newline newline
\end_inset

<<-dc>>
\begin_inset Newline newline
\end_inset

<<-dc:>>
\begin_inset Newline newline
\end_inset

<<-dc->>
\begin_inset Newline newline
\end_inset

' D-R-T  ' -dc:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble to ADDRESS2 from ADDRESS1.
\end_layout

\begin_layout Scrap

<<(D-R-T)>>=
\begin_inset Newline newline
\end_inset

: (D-R-T) ( a2 a1 -- )   SWAP DISASSEMBLE-RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble from target ADDRESS1 to ADDRESS2.
\end_layout

\begin_layout Scrap

<<D-R-T>>=
\begin_inset Newline newline
\end_inset

' (D-R-T) DIS: D-R-T ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is code with name NAME.
\end_layout

\begin_layout Scrap

<<-dc>>=
\begin_inset Newline newline
\end_inset

: -dc ( a n -- )   2>R ['] D-R-T 2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is code with name "name".
\end_layout

\begin_layout Scrap

<<-dc:>>=
\begin_inset Newline newline
\end_inset

' -dc RANGE: -dc: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous code range.
\end_layout

\begin_layout Scrap

<<-dc->>=
\begin_inset Newline newline
\end_inset

: -dc- ( a n -- )   -warning >R  NONAME$ -dc  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Dump unspecified content
\end_layout

\begin_layout Scrap

<<unspecified>>=
\begin_inset Newline newline
\end_inset

<<(DUMP-N)>>
\begin_inset Newline newline
\end_inset

<<DUMP-N>>
\begin_inset Newline newline
\end_inset

<<-dn>>
\begin_inset Newline newline
\end_inset

<<-dn:>>
\begin_inset Newline newline
\end_inset

<<-dn->>
\begin_inset Newline newline
\end_inset

' DUMP-N  ' -dn:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump storage with unspecified content to ADDRESS2 from ADDRESS1.
\end_layout

\begin_layout Scrap

<<(DUMP-N)>>=
\begin_inset Newline newline
\end_inset

: (DUMP-N) ( a2 a1 -- )   DUP CR+dn - .LABEL/.
 S"  RESB" TYPE CR   ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump such from target ADDRESS1 to ADDRESS2 where only address1 may be adorned
 with with a label.
\end_layout

\begin_layout Scrap

<<DUMP-N>>=
\begin_inset Newline newline
\end_inset

' (DUMP-N) DIS: DUMP-N ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are such with name NAME.
\end_layout

\begin_layout Scrap

<<-dn>>=
\begin_inset Newline newline
\end_inset

: -dn ( a n -- )   2>R ['] DUMP-N 2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are such with name "name".
\end_layout

\begin_layout Scrap

<<-dn:>>=
\begin_inset Newline newline
\end_inset

' -dn RANGE: -dn: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous such range.
\end_layout

\begin_layout Scrap

<<-dn->>=
\begin_inset Newline newline
\end_inset

: -dn- ( a n -- )   -warning >R  NONAME$ -dn  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Dump bytes
\end_layout

\begin_layout Scrap

<<bytes>>=
\begin_inset Newline newline
\end_inset

<<(DUMP-B)>>
\begin_inset Newline newline
\end_inset

<<DUMP-B>>
\begin_inset Newline newline
\end_inset

<<-db>>
\begin_inset Newline newline
\end_inset

<<-db:>>
\begin_inset Newline newline
\end_inset

<<-db->>
\begin_inset Newline newline
\end_inset

' DUMP-B  ' -db:  ARE-COUPLED 
\backslash
 Register the decompiler.
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump bytes from target ADDRESS1 to ADDRESS2 plain.
\end_layout

\begin_layout Scrap

<<(DUMP-B)>>=
\begin_inset Newline newline
\end_inset

: (DUMP-B) ( a2 a1 -- )   DO  I DUP CR+db C@ .B-CLEAN  LOOP     PRINT-OLD-COMMENT
: CR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump bytes from target ADDRESS1 to ADDRESS2 adorned with labels.
\end_layout

\begin_layout Scrap

<<DUMP-B>>=
\begin_inset Newline newline
\end_inset

' (DUMP-B) DIS: DUMP-B ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are bytes with name NAME.
\end_layout

\begin_layout Scrap

<<-db>>=
\begin_inset Newline newline
\end_inset

: -db ( a n -- )   2>R ['] DUMP-B 2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are bytes with name "name".
\end_layout

\begin_layout Scrap

<<-db:>>=
\begin_inset Newline newline
\end_inset

' -db RANGE: -db: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous byte range.
\end_layout

\begin_layout Scrap

<<-db->>=
\begin_inset Newline newline
\end_inset

: -db- ( a n -- )   -warning >R  NONAME$ -db  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Dump words
\end_layout

\begin_layout Scrap

<<words>>=
\begin_inset Newline newline
\end_inset

<<W.>>
\begin_inset Newline newline
\end_inset

<<(DUMP-W)>>
\begin_inset Newline newline
\end_inset

<<DUMP-W>>
\begin_inset Newline newline
\end_inset

<<-dw>>
\begin_inset Newline newline
\end_inset

<<-dw:>>
\begin_inset Newline newline
\end_inset

<<-dw->>
\begin_inset Newline newline
\end_inset

' DUMP-W  ' -dw:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print X as a word (4 hex digits).
\end_layout

\begin_layout Scrap

<<W.>>=
\begin_inset Newline newline
\end_inset

: W.
 4 H.R SPACE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump words to ADDRESS1 from ADDRESS2, plain.
\end_layout

\begin_layout Scrap

<<(DUMP-W)>>=
\begin_inset Newline newline
\end_inset

: (DUMP-W) ( a2 a1 -- )   DO  I DUP CR+dw @ W.
  2 +LOOP
\begin_inset Newline newline
\end_inset

    PRINT-OLD-COMMENT: CR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump words from target ADDRESS1 to ADDRESS2 adorned with labels.
\end_layout

\begin_layout Scrap

<<DUMP-W>>=
\begin_inset Newline newline
\end_inset

' (DUMP-W) DIS: DUMP-W ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are words with name NAME.
\end_layout

\begin_layout Scrap

<<-dw>>=
\begin_inset Newline newline
\end_inset

: -dw ( a n -- )   2>R ['] DUMP-W 2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are words with name "name".
\end_layout

\begin_layout Scrap

<<-dw:>>=
\begin_inset Newline newline
\end_inset

' -dw RANGE: -dw: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous word range.
\end_layout

\begin_layout Scrap

<<-dw->>=
\begin_inset Newline newline
\end_inset

: -dw- ( a n -- )   -warning >R  NONAME$ -dw  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Dump longs
\end_layout

\begin_layout Scrap

<<longs>>=
\begin_inset Newline newline
\end_inset

<<(DUMP-L)>>
\begin_inset Newline newline
\end_inset

<<DUMP-L>>
\begin_inset Newline newline
\end_inset

<<-dl>>
\begin_inset Newline newline
\end_inset

<<-dl:>>
\begin_inset Newline newline
\end_inset

<<-dl->>
\begin_inset Newline newline
\end_inset

' DUMP-L  ' -dl:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump longs to ADDRESS1 from ADDRESS2, plain.
\end_layout

\begin_layout Scrap

<<(DUMP-L)>>=
\begin_inset Newline newline
\end_inset

: (DUMP-L) ( a2 a1 -- )   DO  I DUP CR+dl @ .LABEL/.
  4 +LOOP
\begin_inset Newline newline
\end_inset

    PRINT-OLD-COMMENT: CR ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump words from target ADDRESS1 to ADDRESS2 adorned with labels.
\end_layout

\begin_layout Scrap

<<DUMP-L>>=
\begin_inset Newline newline
\end_inset

' (DUMP-L) DIS: DUMP-L ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are longs with name NAME.
\end_layout

\begin_layout Scrap

<<-dl>>=
\begin_inset Newline newline
\end_inset

: -dl ( a n -- )   2>R ['] DUMP-L 2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are longs with name "name".
\end_layout

\begin_layout Scrap

<<-dl:>>=
\begin_inset Newline newline
\end_inset

' -dl RANGE: -dl: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous long range.
\end_layout

\begin_layout Scrap

<<-dl->>=
\begin_inset Newline newline
\end_inset

: -dl- ( a n -- )   -warning >R  NONAME$ -dl  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Dump strings
\end_layout

\begin_layout Scrap

<<strings>>=
\begin_inset Newline newline
\end_inset

<<(DUMP-)>>
\begin_inset Newline newline
\end_inset

<<DUMP->>
\begin_inset Newline newline
\end_inset

<<-d>>
\begin_inset Newline newline
\end_inset

<<-d:>>
\begin_inset Newline newline
\end_inset

<<-d->>
\begin_inset Newline newline
\end_inset

' DUMP-$  ' -d$:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print all chars to ADDR1 from ADDR2 appropriately.
 Try to combine, playing with the next flush.
\end_layout

\begin_layout Scrap

<<(DUMP-)>>=
\begin_inset Newline newline
\end_inset

: (DUMP-$) ( a2 a1 -- )
\begin_inset Newline newline
\end_inset

    DO  I CR+d$
\begin_inset Newline newline
\end_inset

        I C@ IS-PRINT   IF I ACCU-$C+ ELSE I C@ .C THEN
\begin_inset Newline newline
\end_inset

    LOOP  .ACCU   PRINT-OLD-COMMENT: CR ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 'ADORN-ADDRESS @  'ADORN-ADDRESS RESTORED  HERE
\begin_inset Newline newline
\end_inset


\backslash
D S" AAP" $, DROP CTRL J C, CTRL M C, CHAR A C, CHAR A C, BL C, CHAR P C,
\begin_inset Newline newline
\end_inset


\backslash
D 0 C, 1 C, BL C, 2 C, 3 C,
\begin_inset Newline newline
\end_inset


\backslash
D HERE
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT  ``3 0 0 0 'AAP' XX ^J ^M 'AA P' 0 1 BL 2 3 '':" TYPE
\begin_inset Newline newline
\end_inset


\backslash
D SWAP (DUMP-$) CR  'ADORN-ADDRESS !  22 <?>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Dump words from target ADDRESS1 to ADDRESS2 adorned with labels.
\end_layout

\begin_layout Scrap

<<DUMP->>=
\begin_inset Newline newline
\end_inset

' (DUMP-$) DIS: DUMP-$ ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are longs with name NAME.
\end_layout

\begin_layout Scrap

<<-d>>=
\begin_inset Newline newline
\end_inset

: -d$ ( a n -- )   2>R ['] DUMP-$ 2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 are longs with name "name".
\end_layout

\begin_layout Scrap

<<-d:>>=
\begin_inset Newline newline
\end_inset

' -d$ RANGE: -d$: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous long range.
\end_layout

\begin_layout Scrap

<<-d->>=
\begin_inset Newline newline
\end_inset

: -d$- ( a n -- )   -warning >R  NONAME$ -d$  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Ranges
\end_layout

\begin_layout Standard

\family typewriter
\series bold
asi386
\family default
\series default
 dependant part, does it belong here?
\end_layout

\begin_layout Standard
Not yet definitions, these thingies must be visible in the disassembler.
\end_layout

\begin_layout Scrap

<<ranges>>=
\begin_inset Newline newline
\end_inset

<<(D-R-T-16)>>
\begin_inset Newline newline
\end_inset

<<D-R-T-16>>
\begin_inset Newline newline
\end_inset

<<-dc16>>
\begin_inset Newline newline
\end_inset

<<-dc16:>>
\begin_inset Newline newline
\end_inset

<<-dc16->>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

' D-R-T-16  ' -dc16:  ARE-COUPLED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble from target ADDRESS1 to ADDRESS2 as 16 bit.
\end_layout

\begin_layout Scrap

<<(D-R-T-16)>>=
\begin_inset Newline newline
\end_inset

: (D-R-T-16) ( a2 a1 -- )   BITS-16 CR S" BITS-16" TYPE  SWAP DISASSEMBLE-RANGE
\begin_inset Newline newline
\end_inset

    BITS-32 CR S" BITS-32" TYPE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Disassemble from target ADDRESS1 to ADDRESS2.
\end_layout

\begin_layout Scrap

<<D-R-T-16>>=
\begin_inset Newline newline
\end_inset

' (D-R-T-16) DIS: D-R-T-16 ( a1 a2 -- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is 16-bit code with name NAME.
\end_layout

\begin_layout Scrap

<<-dc16>>=
\begin_inset Newline newline
\end_inset

: -dc16 ( a n -- )   2>R ['] D-R-T-16   2R> RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is 16-bit code with name "name".
\end_layout

\begin_layout Scrap

<<-dc16:>>=
\begin_inset Newline newline
\end_inset

' -dc16 RANGE: -dc16: ( -name- )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range ADDRESS1 ..
 ADDRESS2 is an anonymous 16-bit code-range.
\end_layout

\begin_layout Scrap

<<-dc16->>=
\begin_inset Newline newline
\end_inset

: -dc16- ( a n -- )   -warning >R  NONAME$ -dc16  R> +warning ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Instructions
\end_layout

\begin_layout Scrap

<<instructions>>=
\begin_inset Newline newline
\end_inset

<<AS-@+>>
\begin_inset Newline newline
\end_inset

<<AS-S-@+>>
\begin_inset Newline newline
\end_inset

<<LATEST-OFFSET>>
\begin_inset Newline newline
\end_inset

<<.COMMA-LABEL>>
\begin_inset Newline newline
\end_inset

<<ID.-NO()>>
\begin_inset Newline newline
\end_inset

<<NEXT-INSTRUCTION>>
\begin_inset Newline newline
\end_inset

<<GET-OFFSET>>
\begin_inset Newline newline
\end_inset

<<GOAL-RB>>
\begin_inset Newline newline
\end_inset

<<.BRANCH/.>>
\begin_inset Newline newline
\end_inset

<<.COMMA-REL>>
\begin_inset Newline newline
\end_inset

<<UNCONDITIONAL-TRANSFERS>>
\begin_inset Newline newline
\end_inset

<<JUMPS>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
DEA is a commaer.
 Fetch proper DATA from autoincremented '
\family typewriter
\series bold
AS-POINTER
\family default
\series default
'
\end_layout

\begin_layout Scrap

<<AS-@+>>=
\begin_inset Newline newline
\end_inset

: AS-@+ ( xt -- )   >CNT @ >R  AS-POINTER @ R@ MC@  R> AS-POINTER +! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D HEX
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT 34 12 " TYPE 1234 PAD ! PAD AS-POINTER !
\begin_inset Newline newline
\end_inset


\backslash
D ' IB, >BODY DUP AS-@+ .
 AS-@+ .
 CR 23 <?>
\begin_inset Newline newline
\end_inset


\backslash
D DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
DEA is a commaer.
 Fetch proper signed DATA from autoincremented '
\family typewriter
\series bold
AS-POINTER
\family default
\series default
'
\end_layout

\begin_layout Scrap

<<AS-S-@+>>=
\begin_inset Newline newline
\end_inset

: AS-S-@+ ( xt -- )   >CNT @ >R  AS-POINTER @ R@ MC@-S  R> AS-POINTER +!
 ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D HEX
\begin_inset Newline newline
\end_inset


\backslash
D S" EXPECT -1 12 " TYPE 12FF PAD ! PAD AS-POINTER !
\begin_inset Newline newline
\end_inset


\backslash
D ' IB, >BODY DUP AS-S-@+ .
 AS-S-@+ .
 CR
\begin_inset Newline newline
\end_inset


\backslash
D DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This is kept up to date during disassembly.
 It is useful for the code crawler.
\end_layout

\begin_layout Scrap

<<LATEST-OFFSET>>=
\begin_inset Newline newline
\end_inset

VARIABLE LATEST-OFFSET
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a disassembly, for a commaer DEA , taking into account labels, (suitable
 for e.g.
 the commaer '
\family typewriter
\series bold
IX,
\family default
\series default
').
\end_layout

\begin_layout Scrap

<<.COMMA-LABEL>>=
\begin_inset Newline newline
\end_inset

: .COMMA-LABEL   DUP AS-@+ .LABEL/.
 %ID.
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For DEA print the name without the surrounding brackets.
\end_layout

\begin_layout Scrap

<<ID.-NO()>>=
\begin_inset Newline newline
\end_inset

: ID.-NO() ( xt -- )   >NFA @ $@  2 - SWAP 1 + SWAP TYPE SPACE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Assuming the disassembly sits at the offset of a relative branch assembled
 by commaer DEA , return the host space ADDRESS of the next instruction.
\end_layout

\begin_layout Scrap

<<NEXT-INSTRUCTION>>=
\begin_inset Newline newline
\end_inset

: NEXT-INSTRUCTION  >CNT @ AS-POINTER @ + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Assuming the disassembly sits at the offset of a relative branch assembled
 by commaer DEA , return that OFFSET.
\end_layout

\begin_layout Scrap

<<GET-OFFSET>>=
\begin_inset Newline newline
\end_inset

: GET-OFFSET   AS-POINTER @ SWAP >CNT @ MC@-S DUP LATEST-OFFSET ! ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For the commaer DEA return ADDRESS in host space that is the target of the
 current relative jump.
\end_layout

\begin_layout Scrap

<<GOAL-RB>>=
\begin_inset Newline newline
\end_inset

: GOAL-RB   DUP GET-OFFSET SWAP NEXT-INSTRUCTION + ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For the relative branch commaer DEA print the target ADDRESS as a symbolic
 label if possible else print the branch offset, followed by an appropriate
 commaer for each case.
\end_layout

\begin_layout Scrap

<<.BRANCH/.>>=
\begin_inset Newline newline
\end_inset

: .BRANCH/.
  EQU-LABELS   ~LABEL OVER IF .~LABEL ID.-NO() ELSE
\begin_inset Newline newline
\end_inset

    2DROP DUP GET-OFFSET .
 %ID.
 THEN  ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Print a disassembly for a relative branch DEA.
 This relies on the convention that the commaer that consumes an absolute
 address has the name of that with a relative address surrounded with brackets.
\end_layout

\begin_layout Scrap

<<.COMMA-REL>>=
\begin_inset Newline newline
\end_inset

: .COMMA-REL
\begin_inset Newline newline
\end_inset

    DUP  DUP GOAL-RB HOST>TARGET  .BRANCH/.
\begin_inset Newline newline
\end_inset

    >CNT @ AS-POINTER +! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
D 5 .LABEL/.
 CR
\begin_inset Newline newline
\end_inset


\backslash
D 5 .LABEL/.
 CR
\begin_inset Newline newline
\end_inset


\backslash
D ' (RB,) >BODY ID.-NO() CR
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' OW,   >BODY >DIS !  ( obligatory word     )
\begin_inset Newline newline
\end_inset

' .COMMA-REL    ' (RL,) >BODY >DIS !  ( cell relative to IP )
\begin_inset Newline newline
\end_inset

' .COMMA-REL    ' (RW,) >BODY >DIS !  ( cell relative to IP )
\begin_inset Newline newline
\end_inset

' .COMMA-REL    ' (RB,) >BODY >DIS !  ( byte relative to IP )
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' SG,   >BODY >DIS !  (  Segment: WORD      )
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' P,    >BODY >DIS !  ( port number ; byte     )
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' IS,   >BODY >DIS !  ( Single -obl-  byte )
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' IL,   >BODY >DIS !  ( immediate data : cell)
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' IW,   >BODY >DIS !  ( immediate data : cell)
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' IB,   >BODY >DIS !  ( immediate byte data)
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' L,    >BODY >DIS !  ( immediate data : address/offset )
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' W,    >BODY >DIS !  ( immediate data : address/offset )
\begin_inset Newline newline
\end_inset

' .COMMA-LABEL  ' B,    >BODY >DIS !  ( immediate byte : address/offset )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains all instruction that represent an unconditional transfer of control.
 It may be followed by data instead of code.
\end_layout

\begin_layout Scrap

<<UNCONDITIONAL-TRANSFERS>>=
\begin_inset Newline newline
\end_inset

0 BAG UNCONDITIONAL-TRANSFERS
\begin_inset Newline newline
\end_inset

    ' CALL, , ' CALLFAR, , ' CALLFARO, , ' CALLO, , ' INT, , ' INT3, , '
 INTO, ,
\begin_inset Newline newline
\end_inset

    ' IRET, , ' JMP, , ' JMPFAR, , ' JMPFARO, , ' JMPO, , ' JMPS, , ' RET+,
 ,
\begin_inset Newline newline
\end_inset

    ' RET, , ' RETFAR+, , ' RETFAR, ,
\begin_inset Newline newline
\end_inset

HERE UNCONDITIONAL-TRANSFERS ! 100 CELLS ALLOT         
\backslash
 Allow to put more here
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Contains all instructions that represent intra-segment jumps.
\end_layout

\begin_layout Scrap

<<JUMPS>>=
\begin_inset Newline newline
\end_inset

0 BAG JUMPS
\begin_inset Newline newline
\end_inset

    ' CALL, , ' J, , ' JCXZ, , ' JMP, , ' JMPS, , ' J|X, ,
\begin_inset Newline newline
\end_inset

    ' LOOP, , ' LOOPNZ, , ' LOOPZ, ,
\begin_inset Newline newline
\end_inset

HERE JUMPS ! 100 CELLS ALLOT         
\backslash
 Allow to put more here
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Crawler
\end_layout

\begin_layout Standard
Crawling is the process of following jumps to determine code space.
\end_layout

\begin_layout Scrap

<<crawl.frt>>=
\begin_inset Newline newline
\end_inset

( $Id: crawl.frt,v 1.36 2009/03/26 09:07:17 albert Exp $ )
\begin_inset Newline newline
\end_inset

( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)
\begin_inset Newline newline
\end_inset

( Uses Richard Stallmans convention.
 Uppercased word are parameters.
    )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

[DEFINED] ForCiForth [IF]
\begin_inset Newline newline
\end_inset

    REQUIRE H.
\begin_inset Newline newline
\end_inset

    REQUIRE BAG
\begin_inset Newline newline
\end_inset

[THEN]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<INSERT-EQU>>
\begin_inset Newline newline
\end_inset

<<INSERT-EQU-INVENT>>
\begin_inset Newline newline
\end_inset

<<?INSERT-EQU?>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

RANGE-LABELS LABELS !BAG
\begin_inset Newline newline
\end_inset

4FE 510 -dc-
\begin_inset Newline newline
\end_inset

520 530 -dc: oops
\begin_inset Newline newline
\end_inset

530 570 -dc-
\begin_inset Newline newline
\end_inset

560 590 -db: bytes
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-RANGES
\begin_inset Newline newline
\end_inset

    assert( LABELS |BAG| 8 = )
\begin_inset Newline newline
\end_inset

; TEST-RANGES
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<COMPATIBLE?>>
\begin_inset Newline newline
\end_inset

<<RANGE-NAME>>
\begin_inset Newline newline
\end_inset

<<NEW-RANGE-START>>
\begin_inset Newline newline
\end_inset

<<NEW-RANGE-END>>
\begin_inset Newline newline
\end_inset

<<REPLACE>>
\begin_inset Newline newline
\end_inset

<<SAME-ALIGN>>
\begin_inset Newline newline
\end_inset

<<END+START>>
\begin_inset Newline newline
\end_inset

<<OVERLAP?>>
\begin_inset Newline newline
\end_inset

<<OVERLAP-OR-BORDER?>>
\begin_inset Newline newline
\end_inset

<<GAP?>>
\begin_inset Newline newline
\end_inset

<<IS-NAMED>>
\begin_inset Newline newline
\end_inset

<<COLLAPSE>>
\begin_inset Newline newline
\end_inset

<<TRIM-RANGE>>
\begin_inset Newline newline
\end_inset

<<COMBINE>>
\begin_inset Newline newline
\end_inset

<<KILL-OVERLAP>>
\begin_inset Newline newline
\end_inset

<<FILL-GAP>>
\begin_inset Newline newline
\end_inset

<<CLEANUP-RANGES>>
\begin_inset Newline newline
\end_inset

<<PLUG-FIRST>>
\begin_inset Newline newline
\end_inset

<<PLUG-LAST>>
\begin_inset Newline newline
\end_inset

<<PLUG-SPECIAL>>
\begin_inset Newline newline
\end_inset

<<PLUG-HOLES>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

ALSO ASSEMBLER
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<STARTERS>>
\begin_inset Newline newline
\end_inset

<<REQUIRED-XT>>
\begin_inset Newline newline
\end_inset

<<NORMAL-DISASSEMBLY>>
\begin_inset Newline newline
\end_inset

<<IN-CURRENT-CODE?>>
\begin_inset Newline newline
\end_inset

<<IN-CODE-N?>>
\begin_inset Newline newline
\end_inset

<<IN-CODE?>>
\begin_inset Newline newline
\end_inset

<<KNOWN-CODE?>>
\begin_inset Newline newline
\end_inset

<<IN-CODE-SPACE?>>
\begin_inset Newline newline
\end_inset

<<STARTER?>>
\begin_inset Newline newline
\end_inset

<<JUMP-TARGET>>
\begin_inset Newline newline
\end_inset

<<ANALYSE-INSTRUCTION>>
\begin_inset Newline newline
\end_inset

<<COLLAPSE[I1]>>
\begin_inset Newline newline
\end_inset

<<INSERT-RANGE>>
\begin_inset Newline newline
\end_inset

<<CRAWL-ONE>>
\begin_inset Newline newline
\end_inset

<<?CRAWL-ONE?>>
\begin_inset Newline newline
\end_inset

<<(CRAWL)>>
\begin_inset Newline newline
\end_inset

<<CRAWL>>
\begin_inset Newline newline
\end_inset

<<dl-range>>
\begin_inset Newline newline
\end_inset

<<CRAWL16>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

PREVIOUS
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Insert the equ-label ADDRESS1 with an NAME.
 If equ labels was sorted, it remains so.
\end_layout

\begin_layout Scrap

<<INSERT-EQU>>=
\begin_inset Newline newline
\end_inset

: INSERT-EQU 2>R DUP EQU-LABELS WHERE-LABEL SWAP 2R> LABELED
\begin_inset Newline newline
\end_inset

    ROLL-LABEL ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Insert the equ-label ADDRESS1 with an invented name.
 If equ labels was sorted, it remains so.
\end_layout

\begin_layout Scrap

<<INSERT-EQU-INVENT>>=
\begin_inset Newline newline
\end_inset

: INSERT-EQU-INVENT DUP INVENT-NAME INSERT-EQU ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add target ADDRESS to the equ labels if it is not there.
 Invent a name.
\end_layout

\begin_layout Scrap

<<?INSERT-EQU?>>=
\begin_inset Newline newline
\end_inset

: ?INSERT-EQU?    EQU-LABELS DUP >LABEL IF DROP ELSE INSERT-EQU-INVENT THEN
 ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

EQU-LABELS LABELS !BAG
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-?INSERT-EQU?
\begin_inset Newline newline
\end_inset

    assert( EQU-LABELS LABELS |BAG| 0= )
\begin_inset Newline newline
\end_inset

    42 ?INSERT-EQU?
\begin_inset Newline newline
\end_inset

    assert( EQU-LABELS LABELS |BAG| 2 = )
\begin_inset Newline newline
\end_inset

    42 ?INSERT-EQU?
\begin_inset Newline newline
\end_inset

    assert( EQU-LABELS LABELS |BAG| 2 = )
\begin_inset Newline newline
\end_inset

; TEST-?INSERT-EQU?
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For range INDEX : "it is of the same type as the previous one".
\end_layout

\begin_layout Scrap

<<COMPATIBLE?>>=
\begin_inset Newline newline
\end_inset

: COMPATIBLE?   DUP MAKE-CURRENT RANGE-XT   SWAP 1- MAKE-CURRENT RANGE-XT
  = ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-COMPATIBLE?
\begin_inset Newline newline
\end_inset

    assert( 2 COMPATIBLE? -1 = )
\begin_inset Newline newline
\end_inset

    assert( 3 COMPATIBLE? -1 = )
\begin_inset Newline newline
\end_inset

    assert( 4 COMPATIBLE? 0= )
\begin_inset Newline newline
\end_inset

; TEST-COMPATIBLE?
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Get the name of range INDEX.
\end_layout

\begin_layout Scrap

<<RANGE-NAME>>=
\begin_inset Newline newline
\end_inset

: RANGE-NAME LABELS[] CELL+ @ >NFA @ $@ ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-RANGE-NAME
\begin_inset Newline newline
\end_inset

    assert( 1 RANGE-NAME S" NONAME" COMPARE 0= )
\begin_inset Newline newline
\end_inset

    assert( 2 RANGE-NAME S" oops" COMPARE 0= )
\begin_inset Newline newline
\end_inset

; TEST-RANGE-NAME
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For a collapsible pair of range with INDEX1 and INDEX2 return INDEX1 and
 INDEX2 plus a new START for the combined range.
\end_layout

\begin_layout Scrap

<<NEW-RANGE-START>>=
\begin_inset Newline newline
\end_inset

: NEW-RANGE-START OVER MAKE-CURRENT RANGE-START  OVER MAKE-CURRENT RANGE-START
\begin_inset Newline newline
\end_inset

    MIN ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-NEW-RANGE-START
\begin_inset Newline newline
\end_inset

    assert( 2 3 NEW-RANGE-START NIP NIP 520 = )
\begin_inset Newline newline
\end_inset

; TEST-NEW-RANGE-START
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For a collapsible pair of range with INDEX1 and INDEX2 return INDEX1 and
 INDEX2 plus a new END for the combined range.
\end_layout

\begin_layout Scrap

<<NEW-RANGE-END>>=
\begin_inset Newline newline
\end_inset

: NEW-RANGE-END OVER MAKE-CURRENT RANGE-END  OVER MAKE-CURRENT RANGE-END
\begin_inset Newline newline
\end_inset

    MAX ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-NEW-RANGE-END
\begin_inset Newline newline
\end_inset

    assert( 3 4 NEW-RANGE-END NIP NIP 590 = )
\begin_inset Newline newline
\end_inset

; TEST-NEW-RANGE-END
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Replace the two ranges INDEX1 and INDEX2 with the last range.
 Place it at index1 (which has the correct start address).
\end_layout

\begin_layout Scrap

<<REPLACE>>=
\begin_inset Newline newline
\end_inset

: REPLACE  OVER >R REMOVE-LABEL REMOVE-LABEL R> ROLL-LABEL ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-REPLACE
\begin_inset Newline newline
\end_inset

   assert( LABELS |BAG| 2 3 REPLACE LABELS |BAG| - 4 = )
\begin_inset Newline newline
\end_inset

; TEST-REPLACE
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This looks like a proper design.
\end_layout

\begin_layout Itemize
sort on the start address, type (disassembler) and end address.
\end_layout

\begin_layout Itemize
start with the last range and work down until the second.
\end_layout

\begin_layout Itemize
if it overlaps with or borders at the previous one and has the same type
 and alignment, and the second one is not named collapse the ranges.
\end_layout

\begin_layout Itemize
if it overlaps with the previous one and has the same type and alignment,
 and the second one is named, trim the first range.
\end_layout

\begin_layout Itemize
if it overlaps with the previous and has different type, issue warning.
\end_layout

\begin_layout Itemize
if it has a gap, introduce a character range.
 This may lead to an extra range, one less range, or no change in the number
 of ranges, but only at or after the current range.
\end_layout

\begin_layout Itemize
As a last action, introduce extra ranges at the beginning and end.
\end_layout

\begin_layout Standard
This leads to words: 
\family typewriter
\series bold
SAME-TYPE
\family default
\series default
 
\family typewriter
\series bold
SAME-ALIGN
\family default
\series default
 
\family typewriter
\series bold
OVERLAP
\family default
\series default
 
\family typewriter
\series bold
BORDER
\family default
\series default
 
\family typewriter
\series bold
GAP
\family default
\series default
 
\family typewriter
\series bold
IS-NAMED
\family default
\series default
.
\end_layout

\begin_layout Standard
For range INDEX: "It has the same type and alignment as the previous one."
\end_layout

\begin_layout Scrap

<<SAME-ALIGN>>=
\begin_inset Newline newline
\end_inset

: SAME-ALIGN    DUP MAKE-CURRENT  RANGE-START SWAP
\begin_inset Newline newline
\end_inset

    1- MAKE-CURRENT   RANGE-START - RANGE-STRIDE MOD 0= ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

INIT-ALL RANGE-LABELS
\begin_inset Newline newline
\end_inset

12 34 -dc-
\begin_inset Newline newline
\end_inset

34 65 -db: AAP
\begin_inset Newline newline
\end_inset

38 80 -dl-
\begin_inset Newline newline
\end_inset

82 90 -dl-
\begin_inset Newline newline
\end_inset

88 94 -dl-
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-SAME-ALIGN
\begin_inset Newline newline
\end_inset

    assert( 2 SAME-ALIGN -1 = )
\begin_inset Newline newline
\end_inset

    assert( 3 SAME-ALIGN -1 = ) 
\backslash
 Must become 0
\begin_inset Newline newline
\end_inset

    assert( 4 SAME-ALIGN -1 = )
\begin_inset Newline newline
\end_inset

; TEST-SAME-ALIGN
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For range INDEX return END of previous, START of this one,
\end_layout

\begin_layout Scrap

<<END+START>>=
\begin_inset Newline newline
\end_inset

: END+START DUP MAKE-CURRENT RANGE-START SWAP 1- MAKE-CURRENT RANGE-END
 SWAP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-END+START
\begin_inset Newline newline
\end_inset

    assert( 2 END+START 34 = SWAP 34 = AND )
\begin_inset Newline newline
\end_inset

    assert( 3 END+START 38 = SWAP 65 = AND )
\begin_inset Newline newline
\end_inset

; TEST-END+START
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range INDEX overlaps with previous one.
\end_layout

\begin_layout Scrap

<<OVERLAP?>>=
\begin_inset Newline newline
\end_inset

: OVERLAP? END+START > ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-OVERLAP?
\begin_inset Newline newline
\end_inset

    assert( 2 OVERLAP? 0= )
\begin_inset Newline newline
\end_inset

    assert( 3 OVERLAP? -1 = )
\begin_inset Newline newline
\end_inset

    assert( 4 OVERLAP? 0= )
\begin_inset Newline newline
\end_inset

; TEST-OVERLAP?
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range INDEX overlaps or borders with the previous one.
\end_layout

\begin_layout Scrap

<<OVERLAP-OR-BORDER?>>=
\begin_inset Newline newline
\end_inset

: OVERLAP-OR-BORDER? END+START >= ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-OVERLAP-OR-BORDER?
\begin_inset Newline newline
\end_inset

    assert( 2 OVERLAP-OR-BORDER? -1 = )
\begin_inset Newline newline
\end_inset

    assert( 3 OVERLAP-OR-BORDER? -1 = )
\begin_inset Newline newline
\end_inset

    assert( 4 OVERLAP-OR-BORDER? 0= )
\begin_inset Newline newline
\end_inset

; TEST-OVERLAP-OR-BORDER?
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Range INDEX has a gap with the previous one.
\end_layout

\begin_layout Scrap

<<GAP?>>=
\begin_inset Newline newline
\end_inset

: GAP? END+START < ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-GAP?
\begin_inset Newline newline
\end_inset

    assert( 2 GAP? 0 = )
\begin_inset Newline newline
\end_inset

    assert( 3 GAP? 0= )
\begin_inset Newline newline
\end_inset

    assert( 4 GAP? -1 = )
\begin_inset Newline newline
\end_inset

; TEST-GAP?
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For range INDEX: "It has a name"
\end_layout

\begin_layout Scrap

<<IS-NAMED>>=
\begin_inset Newline newline
\end_inset

: IS-NAMED ( n -- )   RANGE-NAME NONAME$ $= 0= ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-IS-NAMED
\begin_inset Newline newline
\end_inset

    assert( 2 IS-NAMED -1 = )
\begin_inset Newline newline
\end_inset

    assert( 3 IS-NAMED 0= )
\begin_inset Newline newline
\end_inset

; TEST-IS-NAMED
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Collapse range I into the previous range, that determines the properties.
\end_layout

\begin_layout Scrap

<<COLLAPSE>>=
\begin_inset Newline newline
\end_inset

: COLLAPSE ( i -- )   DUP MAKE-CURRENT  RANGE-END OVER 1- MAKE-CURRENT
\begin_inset Newline newline
\end_inset

    RANGE-END MAX RANGE-END!  REMOVE-LABEL ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-COLLAPSE
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 5 COLLAPSE 4 MAKE-CURRENT
\begin_inset Newline newline
\end_inset

    assert( RANGE-START 82 = )
\begin_inset Newline newline
\end_inset

    assert( RANGE-END 94 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 4 = )
\begin_inset Newline newline
\end_inset

; TEST-COLLAPSE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Trim the range previous to INDEX, such that it borders to range index.
\end_layout

\begin_layout Scrap

<<TRIM-RANGE>>=
\begin_inset Newline newline
\end_inset

: TRIM-RANGE ( i -- )   DUP MAKE-CURRENT  RANGE-START SWAP 1- MAKE-CURRENT
\begin_inset Newline newline
\end_inset

    RANGE-END! ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

90 1000 -dl-
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-TRIM-RANGE
\begin_inset Newline newline
\end_inset

    5 TRIM-RANGE 4 MAKE-CURRENT
\begin_inset Newline newline
\end_inset

    assert( RANGE-START 82 = ) assert( RANGE-END 90 = )
\begin_inset Newline newline
\end_inset

; TEST-TRIM-RANGE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Combine range INDEX with the previous one.
\end_layout

\begin_layout Scrap

<<COMBINE>>=
\begin_inset Newline newline
\end_inset

: COMBINE ( n -- )
\begin_inset Newline newline
\end_inset

    DUP OVERLAP-OR-BORDER? OVER IS-NAMED 0= AND IF DUP COLLAPSE THEN
\begin_inset Newline newline
\end_inset

    DUP OVERLAP? OVER IS-NAMED AND IF DUP TRIM-RANGE THEN  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

INIT-ALL
\begin_inset Newline newline
\end_inset

10  30 -dl-
\begin_inset Newline newline
\end_inset

20  40 -dl-
\begin_inset Newline newline
\end_inset

30  50 -dl: aap0
\begin_inset Newline newline
\end_inset

60  80 -dl-
\begin_inset Newline newline
\end_inset

90 100 -dl: noot
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-COMBINE
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 5 COMBINE assert( LAB-UPB 5 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 4 COMBINE assert( LAB-UPB 5 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 3 COMBINE assert( LAB-UPB 5 = )
\begin_inset Newline newline
\end_inset

    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 30 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 2 COMBINE assert( LAB-UPB 4 = )
\begin_inset Newline newline
\end_inset

    1 MAKE-CURRENT assert( RANGE-START 10 = ) assert( RANGE-END 30 = )
\begin_inset Newline newline
\end_inset

; TEST-COMBINE
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Combine range INDEX with a previous overlapping or bordering range.
\end_layout

\begin_layout Scrap

<<KILL-OVERLAP>>=
\begin_inset Newline newline
\end_inset

: KILL-OVERLAP ( i -- )   DUP SAME-ALIGN  OVER COMPATIBLE? AND IF
\begin_inset Newline newline
\end_inset

        DUP COMBINE  THEN  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

INIT-ALL
\begin_inset Newline newline
\end_inset

10  30 -dl-
\begin_inset Newline newline
\end_inset

20  40 -dl-
\begin_inset Newline newline
\end_inset

30  50 -dl: aap1
\begin_inset Newline newline
\end_inset

60  80 -dl-
\begin_inset Newline newline
\end_inset

90 100 -dl: noot1
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-KILL-OVERLAP-1
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 5 KILL-OVERLAP assert( LAB-UPB 5 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 4 KILL-OVERLAP assert( LAB-UPB 5 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 3 KILL-OVERLAP assert( LAB-UPB 5 = )
\begin_inset Newline newline
\end_inset

    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 30 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 2 KILL-OVERLAP assert( LAB-UPB 4 = )
\begin_inset Newline newline
\end_inset

    1 MAKE-CURRENT assert( RANGE-START 10 = ) assert( RANGE-END 30 = )
\begin_inset Newline newline
\end_inset

; TEST-KILL-OVERLAP-1
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

INIT-ALL
\begin_inset Newline newline
\end_inset

10  30 -dl-
\begin_inset Newline newline
\end_inset

20  28 -db-
\begin_inset Newline newline
\end_inset

30  70 -dl: aap2
\begin_inset Newline newline
\end_inset

60  80 -dl-
\begin_inset Newline newline
\end_inset

7F 10F -dl-
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 The following is actually wrong because the aligning is not tested yet.
\begin_inset Newline newline
\end_inset

: TEST-KILL-OVERLAP-2
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 5 = ) 5 KILL-OVERLAP assert( LAB-UPB 4 = )
\begin_inset Newline newline
\end_inset

    4 MAKE-CURRENT assert( RANGE-START 60 = ) assert( RANGE-END 10F = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 4 = ) 4 KILL-OVERLAP assert( LAB-UPB 3 = )
\begin_inset Newline newline
\end_inset

    3 MAKE-CURRENT assert( RANGE-START 30 = ) assert( RANGE-END 10F = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 3 = ) 3 KILL-OVERLAP assert( LAB-UPB 3 = )
\begin_inset Newline newline
\end_inset

    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 28 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 3 = ) 2 KILL-OVERLAP assert( LAB-UPB 3 = )
\begin_inset Newline newline
\end_inset

    1 MAKE-CURRENT assert( RANGE-START 10 = ) assert( RANGE-END 30 = )
\begin_inset Newline newline
\end_inset

; TEST-KILL-OVERLAP-2
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Introduce char range to fill the gap at INDEX.
 Note that the result is unordered.
\end_layout

\begin_layout Scrap

<<FILL-GAP>>=
\begin_inset Newline newline
\end_inset

: FILL-GAP ( i -- )   DUP GAP? IF   DUP END+START -ddef-
\begin_inset Newline newline
\end_inset

        DUP 1+ LAB-UPB MAX KILL-OVERLAP
\begin_inset Newline newline
\end_inset

        DUP KILL-OVERLAP  THEN  DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-FILL-GAP
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 3 = ) 3 FILL-GAP assert( LAB-UPB 4 = )
\begin_inset Newline newline
\end_inset

    4 MAKE-CURRENT assert( RANGE-START 28 = ) assert( RANGE-END 30 = )
\begin_inset Newline newline
\end_inset

    assert( LAB-UPB 4 = ) 2 FILL-GAP assert( LAB-UPB 4 = )
\begin_inset Newline newline
\end_inset

    2 MAKE-CURRENT assert( RANGE-START 20 = ) assert( RANGE-END 28 = )
\begin_inset Newline newline
\end_inset

; TEST-FILL-GAP
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Clean up the range labels, from behind.
 Although the bounds may not be valid after a clean up, this works because
 a clean up of a range only concerns higher ranges, no longer considered.
 So a range can comfortably be removed using the regular removal mechanism
 for bags.
 A newly introduced range automatically falls into place, because of the
 conditions regarding the start addresses.
\end_layout

\begin_layout Scrap

<<CLEANUP-RANGES>>=
\begin_inset Newline newline
\end_inset

: CLEANUP-RANGES ( -- )   RANGE-LABELS
\begin_inset Newline newline
\end_inset

    2 LAB-UPB 2DUP <= IF  DO  I KILL-OVERLAP  -1 +LOOP  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Plug a hole at the first range.
\end_layout

\begin_layout Scrap

<<PLUG-FIRST>>=
\begin_inset Newline newline
\end_inset

: PLUG-FIRST ( -- )   1 MAKE-CURRENT
\begin_inset Newline newline
\end_inset

    TARGET-START RANGE-START 2DUP <> IF
\begin_inset Newline newline
\end_inset

        -ddef- _ _  THEN  2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Plug a hole at the last range.
\end_layout

\begin_layout Scrap

<<PLUG-LAST>>=
\begin_inset Newline newline
\end_inset

: PLUG-LAST ( -- )   LAB-UPB MAKE-CURRENT
\begin_inset Newline newline
\end_inset

    RANGE-END TARGET-END 2DUP <> IF
\begin_inset Newline newline
\end_inset

        -ddef- _ _  THEN  2DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
If there are no ranges at all, make the buffer into a default range.
 Else check last and first ranges.
 Note that plugging results in a change of the number of ranges, interfering
 with other plugging.
\end_layout

\begin_layout Scrap

<<PLUG-SPECIAL>>=
\begin_inset Newline newline
\end_inset

: PLUG-SPECIAL ( -- )   LAB-UPB IF  PLUG-LAST PLUG-FIRST  ELSE
\begin_inset Newline newline
\end_inset

    TARGET-START TARGET-END -ddef-  THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Fill any holes with character ranges.
\end_layout

\begin_layout Scrap

<<PLUG-HOLES>>=
\begin_inset Newline newline
\end_inset

: PLUG-HOLES ( -- )   CURRENT-SECTION  RANGE-LABELS LAB-UPB 1+ 2
\begin_inset Newline newline
\end_inset

    2DUP > IF  DO  I FILL-GAP  LOOP  ELSE  2DROP  THEN
\begin_inset Newline newline
\end_inset

    SORT-LABELS  PLUG-SPECIAL  SORT-LABELS
\begin_inset Newline newline
\end_inset

    TO CURRENT-SECTION ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Jump targets that are starting points for further crawling.
 Adding and removing from this bag ressembles a recursive action.
 Recursion will not do here! This is because ranges are not added until
 the end is detected.
\end_layout

\begin_layout Scrap

<<STARTERS>>=
\begin_inset Newline newline
\end_inset

1000 BAG STARTERS
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Files  FILE Starters.dbf  FILE= Starters.dbf
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

( Bytes  records   origin             name )
\begin_inset Newline newline
\end_inset

      4     1000        0 BLOCK-DATA (STARTERS)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: /Starters ( -- )   Starters.dbf  FILE-HANDLE @ 0= IF
\begin_inset Newline newline
\end_inset

        S" Starters.dbf" >FILE  THEN
\begin_inset Newline newline
\end_inset

    (STARTERS) INITIALIZE ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Assem
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Required xt.
 Return the XT that is required for the current disassembly.
\end_layout

\begin_layout Scrap

<<REQUIRED-XT>>=
\begin_inset Newline newline
\end_inset

VARIABLE (R-XT)
\begin_inset Newline newline
\end_inset

: REQUIRED-XT (R-XT) @ ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Specify normal disassembly.
\end_layout

\begin_layout Scrap

<<NORMAL-DISASSEMBLY>>=
\begin_inset Newline newline
\end_inset

: NORMAL-DISASSEMBLY ['] D-R-T (R-XT) ! BITS-32 ;
\begin_inset Newline newline
\end_inset

  NORMAL-DISASSEMBLY
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The following are auxiliary words for '
\family typewriter
\series bold
KNOWN-CODE?
\family default
\series default
' mainly.
 For all those range labels must be current and sorted.
 Prepend '
\family typewriter
\series bold
RANGE-LABELS
\family default
\series default
' if you want to use the auxiliary words.
\end_layout

\begin_layout Standard
For ADDRESS : "it is in a current code range"
\end_layout

\begin_layout Scrap

<<IN-CURRENT-CODE?>>=
\begin_inset Newline newline
\end_inset

: IN-CURRENT-CODE? ( -- f )   RANGE-START RANGE-END WITHIN
\begin_inset Newline newline
\end_inset

    RANGE-XT REQUIRED-XT =  AND ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS and range number N: "address SITS in code range n"
\end_layout

\begin_layout Scrap

<<IN-CODE-N?>>=
\begin_inset Newline newline
\end_inset

: IN-CODE-N? ( i -- f ) MAKE-CURRENT IN-CURRENT-CODE? ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS and range I : "It is code and address is part of it, or same
 holds for previous range."
\end_layout

\begin_layout Scrap

<<IN-CODE?>>=
\begin_inset Newline newline
\end_inset

: IN-CODE?  DUP 0 = IF 2DROP 0 ELSE   
\backslash
 Not present.
\begin_inset Newline newline
\end_inset

        2DUP IN-CODE-N? IF 2DROP -1 ELSE
\begin_inset Newline newline
\end_inset

            DUP 1 = IF 2DROP 0 ELSE   
\backslash
 Previous not present.
\begin_inset Newline newline
\end_inset

                1- IN-CODE-N? THEN THEN THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS: "It is known code, according to '
\family typewriter
\series bold
RANGE-LABELS
\family default
\series default
'".
\end_layout

\begin_layout Scrap

<<KNOWN-CODE?>>=
\begin_inset Newline newline
\end_inset

: KNOWN-CODE?   RANGE-LABELS DUP WHERE-LABEL LAB-UPB MIN IN-CODE? ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS : "it falls within the binary image"
\end_layout

\begin_layout Scrap

<<IN-CODE-SPACE?>>=
\begin_inset Newline newline
\end_inset

: IN-CODE-SPACE?   TARGET-START TARGET-END WITHIN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDRESS: "It is usable as a new starter".
\end_layout

\begin_layout Scrap

<<STARTER?>>=
\begin_inset Newline newline
\end_inset

: STARTER?   DUP KNOWN-CODE? 0=  SWAP IN-CODE-SPACE? AND ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Return the target ADDRESS of the current instruction.
 It must be a jump of course.
\end_layout

\begin_layout Scrap

<<JUMP-TARGET>>=
\begin_inset Newline newline
\end_inset

: JUMP-TARGET   AS-POINTER @   LATEST-OFFSET @  + HOST>TARGET ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Analyse current instruction after disassembly.
 
\family typewriter
\series bold
DISS
\family default
\series default
 
\family typewriter
\series bold
LATEST-INSTRUCTION
\family default
\series default
 
\family typewriter
\series bold
ISS
\family default
\series default
 
\family typewriter
\series bold
ISL
\family default
\series default
 are all valid.
\end_layout

\begin_layout Scrap

<<ANALYSE-INSTRUCTION>>=
\begin_inset Newline newline
\end_inset

: ANALYSE-INSTRUCTION   LATEST-INSTRUCTION @ JUMPS IN-BAG? IF
\begin_inset Newline newline
\end_inset

    JUMP-TARGET DUP ?INSERT-EQU?
\begin_inset Newline newline
\end_inset

    STARTER? IF JUMP-TARGET STARTERS SET+ THEN THEN ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Collapse the label at INDEX with the next and or previous labels.
\end_layout

\begin_layout Scrap

<<COLLAPSE[I1]>>=
\begin_inset Newline newline
\end_inset

: COLLAPSE[I1] RANGE-LABELS
\begin_inset Newline newline
\end_inset

    DUP LAB-UPB < IF DUP 1+ KILL-OVERLAP THEN
\begin_inset Newline newline
\end_inset

    DUP 1 > IF DUP KILL-OVERLAP THEN
\begin_inset Newline newline
\end_inset

    DROP ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

HEX
\begin_inset Newline newline
\end_inset

LABELS !BAG
\begin_inset Newline newline
\end_inset

4FE 520 -dc-
\begin_inset Newline newline
\end_inset

520 530 -dc: oops1
\begin_inset Newline newline
\end_inset

52A 570 -dc-
\begin_inset Newline newline
\end_inset

560 590 -db: bytes1
\begin_inset Newline newline
\end_inset

DECIMAL
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

: TEST-COLLAPSE[I1]
\begin_inset Newline newline
\end_inset

    assert( LABELS |BAG| 2 COLLAPSE[I1] LABELS |BAG| - 2 = )
\begin_inset Newline newline
\end_inset

; TEST-COLLAPSE[I1]
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Add the information that ADDRESS1 to ADDRESS2 is a code range.
 If range labels was sorted, it remains so.
\end_layout

\begin_layout Scrap

<<INSERT-RANGE>>=
\begin_inset Newline newline
\end_inset

: INSERT-RANGE   OVER RANGE-LABELS WHERE-LABEL >R
\begin_inset Newline newline
\end_inset

    REQUIRED-XT ANON-RANGE   R@ ROLL-LABEL   R> COLLAPSE[I1] ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Analyse the code range from ADDRESS up to an unconditional transfer.
 Add information about jumps to '
\family typewriter
\series bold
STARTERS
\family default
\series default
' and new ranges to '
\family typewriter
\series bold
LABELS
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<CRAWL-ONE>>=
\begin_inset Newline newline
\end_inset

: CRAWL-ONE  DUP >R TARGET>HOST BEGIN
\begin_inset Newline newline
\end_inset

        (DISASSEMBLE) ANALYSE-INSTRUCTION DUP HOST-END >=
\begin_inset Newline newline
\end_inset

        LATEST-INSTRUCTION @ UNCONDITIONAL-TRANSFERS IN-BAG? OR
\begin_inset Newline newline
\end_inset

    UNTIL R> SWAP HOST>TARGET INSERT-RANGE ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Analyse code from ADDRESS , unless already known.
\end_layout

\begin_layout Scrap

<<?CRAWL-ONE?>>=
\begin_inset Newline newline
\end_inset

: ?CRAWL-ONE? ( a -- )   DUP STARTER? IF CRAWL-ONE _ THEN DROP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Crawl through code from all points in '
\family typewriter
\series bold
STARTERS
\family default
\series default
'.
\end_layout

\begin_layout Scrap

<<(CRAWL)>>=
\begin_inset Newline newline
\end_inset

: (CRAWL)   BEGIN STARTERS BAG? WHILE STARTERS BAG@- ?CRAWL-ONE? REPEAT
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
ADDRESS points into code.
 Crawl through code from there, i.e.
 add all information about code ranges that can be derived from that.
\end_layout

\begin_layout Scrap

<<CRAWL>>=
\begin_inset Newline newline
\end_inset

: CRAWL ( a -- )   DUP ?INSERT-EQU?   RANGE-LABELS SORT-LABELS
\begin_inset Newline newline
\end_inset

    STARTERS DUP !BAG BAG+!   SHUTUP (CRAWL) ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
INTEL 80386 specific.
 There is a need to specify the disassembly xt.
 Crawl with normal disassembly (observing '
\family typewriter
\series bold
TALLY-BA
\family default
\series default
') resp.
 Crawl through 16 / 32 bits code.
 The other owns change it all the time.
\end_layout

\begin_layout Scrap

<<CRAWL16>>=
\begin_inset Newline newline
\end_inset

: CRAWL16 ( a -- )  ['] D-R-T-16 (R-XT) ! BITS-16 CRAWL NORMAL-DISASSEMBLY
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
DL range
\end_layout

\begin_layout Scrap

<<dl-range>>=
\begin_inset Newline newline
\end_inset

<<NEW-LABEL?>>
\begin_inset Newline newline
\end_inset

<<ADD-L-LABELS>>
\begin_inset Newline newline
\end_inset

<<ALL-L-LABELS>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For ADDR create a label if it points in the target space.
\end_layout

\begin_layout Scrap

<<NEW-LABEL?>>=
\begin_inset Newline newline
\end_inset

: NEW-LABEL? ( a -- )   DUP PLAUSIBLE-LABEL? IF  ?INSERT-EQU? _  THEN  DROP
 ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For dl-range from ADDR1 to ADDR2 add all plausible labels found in data.
\end_layout

\begin_layout Scrap

<<ADD-L-LABELS>>=
\begin_inset Newline newline
\end_inset

: ADD-L-LABELS ( l h -- )   SWAP DO  I L@ NEW-LABEL?  0 CELL+ +LOOP ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For all dl-ranges add all plausible labels.
\end_layout

\begin_layout Scrap

<<ALL-L-LABELS>>=
\begin_inset Newline newline
\end_inset

: ALL-L-LABELS ( -- )   CURRENT-SECTION  RANGE-LABELS DO-LAB
\begin_inset Newline newline
\end_inset

        I CELL+ @ RANGE-SECTION  RANGE-XT ['] DUMP-L = IF
\begin_inset Newline newline
\end_inset

            RANGE-START RANGE-END ADD-L-LABELS  THEN
\begin_inset Newline newline
\end_inset

    LOOP-LAB  TO CURRENT-SECTION ;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Section
Extracting code
\end_layout

\begin_layout Standard
A script for converting this document to PDF form follows:
\end_layout

\begin_layout Scrap

<<final>>=
\begin_inset Newline newline
\end_inset

lyx -e pdf cfasdis.lyx
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap

<<*>>=
\begin_inset Newline newline
\end_inset

echo "Extract script cfasdis.frt from cfasdis.lyx..."
\begin_inset Newline newline
\end_inset

rm -f cfasdis.nw
\begin_inset Newline newline
\end_inset

lyx -e literate cfasdis.lyx
\begin_inset Newline newline
\end_inset

notangle -Rcfasdis.frt cfasdis.nw > cfasdis
\begin_inset Newline newline
\end_inset

chmod a+x cfasdis
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Each of these scripts can be pulled out manually given the default 
\family typewriter
\series bold
*
\family default
\series default
 script defined above.
\end_layout

\end_body
\end_document
