
<1> 30 <?>

BITS-32
200000  ORG

BITS-16
\ This code actually starts running at 0x7C00   
( 0020,0000 )   :Boot0    JMPS, Boot1 RB, 
BITS-32
( 0020,0002 )   :SectorsPerTrack   dw 0000 
\ 0B40 = 2880 512-byte sectors = 1.44MB floppy   
( 0020,0004 )   :SectorsToLoad   dw 0B40 
( 0020,0006 )   :UnusedStore   dw 0000 
( 0020,0008 )   :NumberOfHeads   dw 0000 
( 0020,000A )   :BootDrive   dw 0000 \ e.g. 80 is DOS C:, 01 is floppy B:
( 0020,000C )   :LoadCX   dw 0000 
( 0020,000E )   :CylindersAndSectors   dw 0000 
( 0020,0010 )   :StoreForDump   dw 0000 
( 0020,0012 )   :ScreenLoc   dw 0000 

( 0020,0014 )   :HexTable   d$  "0123456789ABCDEF"

( 0020,0024 )   :RelocateGdt   dw 0000 0000 0000 0000 0000 0000 0000 0000 
( 0020,0034 )                 dw FFFF F000 9300 0000 FFFF 0000 9320 0000 
( 0020,0044 )                 dw 0000 0000 0000 0000 0000 0000 0000 0000 

BITS-16
( 0020,0054 )   :Relocate    PUSH|ALL, \ called with di = start of bootblock
( 0020,0055 )                  PUSH|ES, 
( 0020,0056 )                  MOVI|X, CX| 0200 IW, \ number of words to copy
( 0020,0059 )                  MOV, X| T| SI'| R| DI| 
\ point si to GDT for extended memory copy   
( 0020,005B )                  ADDSI, R| SI| 24 IS, 
( 0020,005E )                  XOR, X| T| AX'| R| AX| 
( 0020,0060 )                  MOV|SG, T| ES| R| AX| 
\ int 15 ah=87 copy extended memory   
( 0020,0062 )                  MOVI|B, AH| 87 IB, 
( 0020,0064 )                  INT, 15 IB, 
( 0020,0066 )                  XOR, X| T| AX'| R| AX| 
\ adjust low word of destination addr upwards   
( 0020,0068 )                  ADDI, X| BO| [DI]% 3E B, 0200 IW, 
\ add any carry to 3rd byte of destination   
( 0020,006D )                  ADC, B| F| AL'| BO| [DI]% 40 B, 
( 0020,0070 )                  POP|ES, 
( 0020,0071 )                  POP|ALL, 
\ so adding 200 will bring it to zero   
( 0020,0072 )                  MOVI|X, BX| FE00 IW, 
( 0020,0075 )                  RET, 
( 0020,0076 )   :Boot1    JMPS, BootStart RB, 
( 0020,0078 )   :DumpToScreen    PUSH|ES, 
( 0020,0079 )                  PUSH|X, AX| 
( 0020,007A )                  PUSH|X, CX| 
( 0020,007B )                  PUSH|X, SI| 
( 0020,007C )                  MOVI|X, AX| B800 IW, \ = video RAM (text mode)
( 0020,007F )                  MOV|SG, T| ES| R| AX| 
( 0020,0081 )                  MOVI|X, CX| 4 IW, \ loop count
( 0020,0084 )   :DTSLoop    XOR, X| T| AX'| R| AX| 
( 0020,0086 )                  MOV, B| T| AL'| BO| [DI]% 11 B, \ high byte
( 0020,0089 )                  SHR, 1| X| R| AX| \ shift right to get high nybble
( 0020,008B )                  SHR, 1| X| R| AX| 
( 0020,008D )                  SHR, 1| X| R| AX| 
( 0020,008F )                  SHR, 1| X| R| AX| 
( 0020,0091 )                  MOV, X| T| SI'| R| AX| 
( 0020,0093 )                  ADD, X| T| SI'| R| DI| 
( 0020,0095 )                  MOV, B| T| AL'| BO| [SI]% 14 B, \ index HexTable
\ load si with next screen location   
( 0020,0098 )                  MOV, X| T| SI'| BO| [DI]% 12 B, 
( 0020,009B )                  ES:, 
( 0020,009C )                  MOV, B| F| AL'| ZO| [SI]% \ write to screen
\ point to next screen location (odd byte is attribute)   
( 0020,009E )                  ADDSI, BO| [DI]% 12 B, 2 IS, 
( 0020,00A2 )                  ANDI, X| BO| [DI]% 12 B, 07FF IW, \ keep on-screen
\ shift entire word to be displayed left 4 bits   
( 0020,00A7 )                  SHL, 1| X| BO| [DI]% 10 B, 
( 0020,00AA )                  SHL, 1| X| BO| [DI]% 10 B, 
( 0020,00AD )                  SHL, 1| X| BO| [DI]% 10 B, 
( 0020,00B0 )                  SHL, 1| X| BO| [DI]% 10 B, 
( 0020,00B3 )                  LOOP, DTSLoop RB, \ until word has been dumped
\ leave a space before next word is dumped   
( 0020,00B5 )                  ADDSI, BO| [DI]% 12 B, 2 IS, 
( 0020,00B9 )                  POP|X, SI| 
( 0020,00BA )                  POP|X, CX| 
( 0020,00BB )                  POP|X, AX| 
( 0020,00BC )                  POP|ES, 
( 0020,00BD )                  RET, 
\ boot starts here after two jumps   
( 0020,00BE )   :BootStart    SUB, X| T| DI'| R| DI| 
( 0020,00C0 )                  MOV|SG, T| DS| R| DI| \ zero out both DS and
( 0020,00C2 )                  MOV|SG, T| ES| R| DI| \ ES segment registers
( 0020,00C4 )                  MOVI|X, DI| 7C00 IW, 
( 0020,00C7 )                  STI, 
\ dl contains boot disk number,
\ see http://tldp.org/LDP/lki/lki-1.html   
( 0020,00C8 )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
( 0020,00CB )                  CALL, DumpToScreen RW, 
( 0020,00CE )                  OR, B| F| DL'| BO| [DI]% 0A B, 
( 0020,00D1 )                  MOV, B| T| DL'| BO| [DI]% 0A B, 
\ int 13 ah=08 read drive parameters   
( 0020,00D4 )                  MOVI|B, AH| 8 IB, 
( 0020,00D6 )                  PUSH|X, DI| \ does it mess with di?
( 0020,00D7 )                  INT, 13 IB, 
( 0020,00D9 )                  POP|X, DI| 
\ after BIOS call, dh is 0-based index of last head   
( 0020,00DA )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
( 0020,00DD )                  CALL, DumpToScreen RW, 
( 0020,00E0 )                  INC, B| R| DH| \ add 1 to get number of heads
\ store number of heads   
( 0020,00E2 )                  MOV, B| F| DH'| BO| [DI]% 8 B, 
( 0020,00E5 )                  MOV, X| F| DX'| BO| [DI]% 10 B, 
\ dump number of heads in high byte   
( 0020,00E8 )                  CALL, DumpToScreen RW, 
\ after BIOS call, low 6 bits of cx are 1-based last track index,
\ high 10 bits 0-based last cylinder index   
( 0020,00EB )                  MOV, X| F| CX'| BO| [DI]% 10 B, 
( 0020,00EE )                  CALL, DumpToScreen RW, 
\ store number of cylinders and sectors   
( 0020,00F1 )                  MOV, X| F| CX'| BO| [DI]% 0E B, 
\ extract sectors per track   
( 0020,00F4 )                  ANDI, B| R| CL| 3F IB, 
\ store sectors per track   
( 0020,00F7 )                  MOV, B| F| CL'| BO| [DI]% 2 B, 
\ dump sectors per track (low byte)   
( 0020,00FA )                  MOV, X| F| CX'| BO| [DI]% 10 B, 
( 0020,00FD )                  CALL, DumpToScreen RW, 
\ es:bx is buffer address, adding 200 to FE00 zeroes bx   
( 0020,0100 )                  MOVI|X, BX| FE00 IW, 
\ ch=track, cl=sector to read   
( 0020,0103 )                  MOV, X| T| CX'| BO| [DI]% 0C B, 
\ dh=head, dl=drive to read   
( 0020,0106 )                  MOV, X| T| DX'| BO| [DI]% 0A B, 
\ total number of sectors to read   
( 0020,0109 )                  MOV, X| T| SI'| BO| [DI]% 4 B, 
( 0020,010C )                  MOVI|X, AX| 0F00 IW, 
\ store sector data starting at F000   
( 0020,010F )                  MOV|SG, T| ES| R| AX| 
( 0020,0111 )                  STI, 
\ have we reached number of sectors per track?   
( 0020,0112 )   :ReadCylinder    CMP, B| T| CL'| BO| [DI]% 2 B, 
( 0020,0115 )                  J, Z| N| ReadSector RB, \ continue if not, else...
( 0020,0117 )                  INC, B| R| DH| \ next head
( 0020,0119 )                  CMP, B| T| DH'| BO| [DI]% 8 B, \ reached # heads?
( 0020,011C )                  J, Z| N| ReadTrack RB, \ continue if not, else...
( 0020,011E )                  XOR, B| T| DH'| R| DH| \ back to head 0
( 0020,0120 )                  ADDI, B| R| CH| 1 IB, \ next track
\ start with first sector (only low 6 bits matter)   
( 0020,0123 )   :ReadTrack    ANDI, B| R| CL| 0C0 IB, 
\ next sector: sector is 1-based, so must be nonzero   
( 0020,0126 )   :ReadSector    INC|X, CX| 
\ es:bx is buffer address pointer for BIOS call   
( 0020,0127 )                  ADDI, X| R| BX| 0200 IW, 
\ int 13 ah=02 read sectors from drive   
( 0020,012B )                  MOVI|X, AX| 0201 IW, 
( 0020,012E )                  INT, 13 IB, 
\ ah=error code, al=actual number of sectors read   
( 0020,0130 )                  MOV, X| F| AX'| BO| [DI]% 10 B, 
\ check no error, and one sector read   
( 0020,0133 )                  DEC|X, AX| 
\ if all OK, just continue   
( 0020,0134 )                  J, Z| Y| NextSector RB, 
\ otherwise, show problem on screen   
( 0020,0136 )                  CALL, DumpToScreen RW, 
\ Relocate has side effect of resetting buffer address bx to zero   
( 0020,0139 )   :NextSector    CALL, Relocate RW, 
( 0020,013C )                  DEC|X, SI| 
( 0020,013D )                  J, Z| N| ReadCylinder RB, 
\ done loading colorForth, set es back to zero   
( 0020,013F )                  XOR, X| T| AX'| R| AX| 
( 0020,0141 )                  MOV|SG, T| ES| R| AX| 
\ 3FB is Line Control Register (LCR) of first serial port   
( 0020,0143 )                  MOVI|X, DX| 03FB IW, 
\ 03 sets word length to 8 bits,
\ 80 sets ports 3F8 and 3F9 to be the baud rate divisor   
( 0020,0146 )                  MOVI|B, AL| 83 IB, 
( 0020,0148 )                  OUT|D, B'| 
\ divisor 03 sets baud rate to 38400,
\ see http://www.pelletiernet.com/helppc/8250.html   
( 0020,0149 )                  MOVI|B, AL| 3 IB, 
( 0020,014B )                  SUBI, B| R| DL| 3 IB, \ LSBs of divisor
( 0020,014E )                  OUT|D, B'| 
( 0020,014F )                  XOR, X| T| AX'| R| AX| \ MSBs are 0
( 0020,0151 )                  INC|X, DX| \ MSBs of divisor
( 0020,0152 )                  OUT|D, B'| 
( 0020,0153 )                  MOVI|B, AL| 3 IB, \ word length 8 bits (again)
( 0020,0155 )                  ADDI, B| R| DL| 2 IB, \ point to LCR
\ clear bit 7, now we've set the baud rate;
\ this allows us to use 3F8 and 3F9 as transmit/receive buffer
\ and Interrupt Enable register (IER), respectively   
( 0020,0158 )                  OUT|D, B'| 
\ zero all interrupt-enable bits   
( 0020,0159 )                  XOR, X| T| AX'| R| AX| 
( 0020,015B )                  SUBI, B| R| DL| 2 IB, \ point to 3F9, IER
( 0020,015E )                  OUT|D, B'| \ disable all serial port interrupts
\ enable RTS (bit 1) and DTR (bit 0)   
( 0020,015F )                  MOVI|B, AL| 3 IB, 
\ point dx to Modem Control Register (MCR)   
( 0020,0161 )                  ADDI, B| R| DL| 3 IB, 
( 0020,0164 )                  OUT|D, B'| \ set the bits
( 0020,0165 )                  JMPS, SetVideoMode RB, 
BITS-32
( 0020,0167 )                 db 0 

( 0020,0168 )   :GdtStruct   dw 0017 7D70 0000 0000 0000 0000 0000 0000 
( 0020,0178 )                 dw FFFF 0000 9A00 00CF FFFF 0000 9200 00CF 

BITS-16
\ int 10 ax=4f02 set supervga video mode   
( 0020,0188 )   :SetVideoMode    MOVI|X, AX| 4F02 IW, 
\ 118 means 1024x768 pixels at 24 bits per pixel,
\ 4000 sets linear framebuffer:
\ http://en.wikipedia.org/wiki/VESA_BIOS_Extensions   
( 0020,018B )                  MOVI|X, BX| 4118 IW, 
( 0020,018E )                  INT, 10 IB, 
( 0020,0190 )                  CLI, 
\ size override allows us to use 32-bit registers in real mode   
( 0020,0191 )                  OS:, 
( 0020,0192 )                  XOR, X| T| AX'| R| AX| 
( 0020,0194 )                  OS:, 
( 0020,0195 )                  MOV, X| T| BX'| R| AX| 
\ zero out segment registers cs, ds, es   
( 0020,0197 )                  MOV|SG, F| CS| R| BX| 
( 0020,0199 )                  MOV|SG, T| DS| R| BX| 
( 0020,019B )                  MOV|SG, T| ES| R| AX| 
( 0020,019D )                  OS:, 
\ zero out registers esi and edi   
( 0020,019E )                  MOV, X| T| DI'| R| AX| 
( 0020,01A0 )                  OS:, 
( 0020,01A1 )                  MOV, X| T| SI'| R| AX| 
( 0020,01A3 )                  MOV|SG, T| DS| R| AX| 
\ load Global Descriptor Table   
( 0020,01A5 )                  LGDT, MEM|% 7D68 W, \ actually GdtStruct
( 0020,01AA )                  MOVI|B, AL| 1 IB, 
\ see http://en.wikipedia.org/wiki/Protected_mode   
( 0020,01AC )                  MOV|CD, T| CR0| AX| \ set PE bit
\ selector of 8 points cs to executable segment descriptor   
( 0020,01AF )                  JMPFAR, 7DB4 W, 8 SG, 
BITS-32
\ now we are in Protected Mode (PM)   
( 0020,01B4 )   :Start32    JMPS, SetupDataSegments RB, 
( 0020,01B6 )   :SendSerial    PUSH|X, AX| 
( 0020,01B7 )                  PUSH|X, DX| 
\ fetch byte pointed to by stack return pointer   
( 0020,01B8 )                  MOV, X| T| DX'| BO|    [SP +1* 0] 8 B, 
( 0020,01BC )                  MOV, B| T| AL'| ZO| [DX] 
( 0020,01BE )                  MOVI|X, DX| 03F8 IL, 
( 0020,01C3 )                  OUT|D, B'| \ send through serial port
( 0020,01C4 )                  POP|X, DX| 
( 0020,01C5 )                  POP|X, AX| 
\ real return address is one past data byte pointer   
( 0020,01C6 )                  INC, X| ZO|    [SP +1* 0] 
( 0020,01C9 )                  RET, 
\ selector 10 points to segment descriptor
\ with executable bit cleared   
( 0020,01CA )   :SetupDataSegments    MOVI|B, AL| 10 IB, 
( 0020,01CC )                  MOV|SG, T| DS| R| AX| 
( 0020,01CE )                  MOV|SG, T| ES| R| AX| 
( 0020,01D0 )                  MOV|SG, T| SS| R| AX| 
( 0020,01D2 )                  MOVI|X, SP| 000A,0000 IL, \ set top of stack
( 0020,01D7 )                  XOR, X| T| CX'| R| CX| 
\ see http://www.win.tue.nl/~aeb/linux/kbd/A20.html   
( 0020,01D9 )                  MOVI|B, AL| 0D1 IB, \ enable address line 20
\ this just tells the keyboard controller we want to write to it   
( 0020,01DB )                  OUT|P, B'| 64 P, 
\ busy-wait until keyboard controller ready   
( 0020,01DD )   :WaitKbdReady    IN|P, B'| 64 P, 
( 0020,01DF )                  ANDI|A, B'| 2 IB, 
( 0020,01E1 )                  J, Z| N| WaitKbdReady RB, 
\ bit 1 (value 02) is set to enable A20 address line   
( 0020,01E3 )                  MOVI|B, AL| 4B IB, 
( 0020,01E5 )                  OUT|P, B'| 60 P, 
( 0020,01E7 )                  MOVI|X, SI| 0009,F400 IL, \ set esi to 9F400
( 0020,01EC )                  CALL, SendSerial RL, 
\ send ASCII 'A' through serial port   
( 0020,01F1 )                 d$  &A

\ by this point, all code has been relocated to 0x200000   
( 0020,01F2 )                  MOVI|X, DI| Init0 IL, 
( 0020,01F7 )                  JMPO, R| DI| 
( 0020,01F9 )                 db 0 0 0 0 0 55 0AA 

( 0020,0200 )   :Init0    JMPS, Init1 RB, 
\ see http://www.kwant.info/howto/mirror/ser-tr.html   
( 0020,0202 )   :SerialOut    PUSH|X, AX| 
( 0020,0203 )                  PUSH|X, DX| 
\ first serial port's Line Status Register [LSR]   
( 0020,0204 )                  MOVI|X, DX| 03FD IL, 
( 0020,0209 )   :SOWaitReady    IN|D, B'| 
\ check THRE, Transmitter Holding Register Empty   
( 0020,020A )                  TESTI|A, B'| 20 IB, 
( 0020,020C )                  J, Z| Y| SOWaitReady RB, 
\ now point to 03F8, transmit/receive buffer   
( 0020,020E )                  SUBI, B| R| DL| 5 IB, 
\ fetch return address from stack   
( 0020,0211 )                  MOV, X| T| AX'| BO|    [SP +1* 0] 8 B, 
\ retrieve byte at return address   
( 0020,0215 )                  MOV, B| T| AL'| ZO| [AX] 
( 0020,0217 )                  OUT|D, B'| \ send the byte out serial line
( 0020,0218 )                  POP|X, DX| 
( 0020,0219 )                  POP|X, AX| 
\ adjust return address to the opcode following data byte   
( 0020,021A )                  INC, X| ZO|    [SP +1* 0] 
( 0020,021D )                  RET, 
\ same as SerialOut but uses byte in AL instead of from stack   
( 0020,021E )   :SerialOutAL    PUSH|X, DX| 
( 0020,021F )                  PUSH|X, AX| 
( 0020,0220 )                  MOVI|X, DX| 03FD IL, \ serial port address
( 0020,0225 )   :SOAWaitReady    IN|D, B'| 
( 0020,0226 )                  TESTI|A, B'| 20 IB, 
( 0020,0228 )                  J, Z| Y| SOAWaitReady RB, 
( 0020,022A )                  SUBI, B| R| DL| 5 IB, 
( 0020,022D )                  POP|X, AX| 
( 0020,022E )                  OUT|D, B'| 
( 0020,022F )                  POP|X, DX| 
( 0020,0230 )                  RET, 
\ convert word in eax to hexadecimal and send out serial port   
( 0020,0231 )   :SerialOutHexWord    PUSH|ALL, 
( 0020,0232 )                  MOVI|X, CX| 8 IL, 
( 0020,0237 )                  MOV, X| T| DX'| R| AX| 
\ rotate 4 MSBs into low nybble   
( 0020,0239 )   :SerialOutNybble    ROLI, X| R| DX| 4 IS, 
( 0020,023C )                  MOV, X| T| AX'| R| DX| 
( 0020,023E )                  ANDI|A, X'| 0F IL, \ mask off high bits
\ index into hexadecimal translation table binary->ASCII   
( 0020,0243 )                  MOV, B| T| AL'| XO| [AX] 7C14 L, 
( 0020,0249 )                  CALL, SerialOutAL RL, 
( 0020,024E )                  LOOP, SerialOutNybble RB, 
\ follow output with a space   
( 0020,0250 )                  CALL, SerialOut RL, 
( 0020,0255 )                 d$  BL

( 0020,0256 )                  POP|ALL, 
\ load eax with next word from esi pointer, and increment pointer   
( 0020,0257 )                  LODS, X'| 
( 0020,0258 )                  RET, 
( 0020,0259 )   :Init1    JMPS, Initialize RB, 
\ send carriage return and linefeed out serial port   
( 0020,025B )   :SerialOutCRLF    CALL, SerialOut RL, 
( 0020,0260 )                 d$  ^M

\ send linefeed out serial port   
( 0020,0261 )   :SerialOutLF    CALL, SerialOut RL, 
( 0020,0266 )                 d$  ^J

( 0020,0267 )                  RET, 
( 0020,0268 )   :X_serialDump    MOV, X| T| CX'| R| AX| 
( 0020,026A )                  SHRI, X| R| CX| 2 IS, 
( 0020,026D )                  LODS, X'| 
( 0020,026E )                  MOV, X| T| DI'| R| AX| 
( 0020,0270 )                  XOR, X| T| DX'| R| DX| 
( 0020,0272 )   :X_serialDumpLoop    TESTI, B| R| DL| 0F IB, 
( 0020,0275 )                  J, Z| N| X_serialDump2 RB, 
( 0020,0277 )                  CALL, SerialOutCRLF RL, 
( 0020,027C )                  MOV, X| T| AX'| R| DI| 
( 0020,027E )                  ADD, X| T| AX'| R| DX| 
( 0020,0280 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0283 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0285 )                  CALL, SerialOutHexWord RL, 
( 0020,028A )                  CALL, SerialOut RL, 
( 0020,028F )                 d$  BL

( 0020,0290 )   :X_serialDump2    MOV, X| T| AX'| ZO|    [DI +1* DX] 
( 0020,0293 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0296 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0298 )                  CALL, SerialOutHexWord RL, 
( 0020,029D )                  ADDSI, R| DX| 4 IS, 
( 0020,02A0 )                  LOOP, X_serialDumpLoop RB, 
( 0020,02A2 )                  CALL, SerialOutCRLF RL, 
( 0020,02A7 )                  LODS, X'| 
( 0020,02A8 )                  RET, 
\ this seems to be dead code, nothing calls it   
( 0020,02A9 )   :L0020,02A9    PUSH|ALL, 
( 0020,02AA )                  MOV, X| T| DI'| BO|    [SP +1* 0] 20 B, 
( 0020,02AE )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,02B1 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,02B3 )                  MOV, X| T| AX'| ZO| [DI] 
( 0020,02B5 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,02B8 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,02BA )                  MOV, X| T| AX'| BO| [DI] 4 B, 
( 0020,02BD )                  CALL, X_serialDump RL, 
( 0020,02C2 )                  POP|ALL, 
( 0020,02C3 )                  ADDSI, ZO|    [SP +1* 0] 8 IS, 
( 0020,02C7 )                  RET, 
( 0020,02C8 )   :Initialize    CALL, SerialOutCRLF RL, 
\ adding -4 to esi to push arg onto data stack   
( 0020,02CD )                  LEA, SI'| BO| [SI] 0FC B, 
\ though eax doesn't contain anything useful at this point   
( 0020,02D0 )                  MOV, X| F| AX'| ZO| [SI] 
\ checking SerialOutHexWord before sending any real data   
( 0020,02D2 )                  MOVI|X, AX| 1234,5678 IL, 
( 0020,02D7 )                  CALL, SerialOutHexWord RL, 
( 0020,02DC )                  CALL, SerialOutCRLF RL, 
( 0020,02E1 )                  JMP, Start0 RL, 
( 0020,02E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,02F6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0306 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0316 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0326 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0336 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0346 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0356 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0366 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0376 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0386 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,0396 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,03A6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,03B6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,03C6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,03D6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,03E6 )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,03F6 )                 db 0 0 0 0 0 0 0 0 0 0 

( 0020,0400 )   :Start0    JMP, Start RL, 
( 0020,0405 )                 d$  0  0  0  0E9  0E5  1A  0  0  0  0  0 
( 0020,0410 )   :Version   d$  "cmcf 4.1-pd" 0 

( 0020,041C )   :X_pause    LEA, SI'| BO| [SI] 0FC B, 
( 0020,041F )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0421 )                  PUSH|X, SI| 
( 0020,0422 )                  MOV|TA, X'| L0020,27FC L, 
( 0020,0427 )                  MOV, X| F| SP'| ZO| [AX] 
( 0020,0429 )                  ADDSI, R| AX| 4 IS, 
( 0020,042C )                  JMPO, R| AX| 
( 0020,042E )   :L0020,042E    POP|X, AX| 
( 0020,042F )                  MOV, X| T| SP'| ZO| [AX] 
( 0020,0431 )                  MOV|FA, X'| L0020,27FC L, 
( 0020,0436 )                  POP|X, SI| 
( 0020,0437 )                  LODS, X'| 
( 0020,0438 )                  RET, 
( 0020,0439 )   :L0020,0439    CALL, L0020,042E RL, 
( 0020,043E )   :L0020,043E   dl 0009,FFF8 

( 0020,0442 )   :L0020,0442    CALL, L0020,042E RL, 
( 0020,0447 )   :L0020,0447   dl 0009,DBF8 

( 0020,044B )   :L0020,044B    CALL, L0020,042E RL, 
( 0020,0450 )   :L0020,0450   dl 0009,B7F8 

( 0020,0454 )   :L0020,0454    JMPS, L0020,0439 RB, 
( 0020,0456 )   :L0020,0456    MOVI|X, DX| 0009,CFFC IL, 
( 0020,045B )                  MOV, X| F| CX'| ZO| [DX] 
( 0020,045D )                  MOVI|X, CX| 0009,DBFC IL, 
( 0020,0462 )                  POP, ZO| [CX] 
( 0020,0464 )                  LEA, CX'| BO| [CX] 0FC B, 
( 0020,0467 )                  MOV, X| F| DX'| ZO| [CX] 
( 0020,0469 )                  MOV, X| F| CX'| MEM| L0020,0447 L, 
( 0020,046F )                  RET, 
( 0020,0470 )   :L0020,0470    MOVI|X, DX| 0009,ABFC IL, 
( 0020,0475 )                  MOV, X| F| CX'| ZO| [DX] 
( 0020,0477 )                  MOVI|X, CX| 0009,B7FC IL, 
( 0020,047C )                  POP, ZO| [CX] 
( 0020,047E )                  LEA, CX'| BO| [CX] 0FC B, 
( 0020,0481 )                  MOV, X| F| DX'| ZO| [CX] 
( 0020,0483 )                  MOV, X| F| CX'| MEM| L0020,0450 L, 
( 0020,0489 )                  RET, 
( 0020,048A )   :X_nul    RET, 
( 0020,048B )   :X_show    POP, MEM| L0020,2800 L, 
( 0020,0491 )                  CALL, L0020,0456 RL, 
( 0020,0496 )   :L0020,0496    CALLO, MEM| L0020,2808 L, 
( 0020,049C )                  CALLO, MEM| L0020,2800 L, 
( 0020,04A2 )                  CALLO, MEM| L0020,280C L, 
( 0020,04A8 )                  JMPS, L0020,0496 RB, 
( 0020,04AA )   :L0020,04AA    CALL, X_show RL, 
( 0020,04AF )                  RET, 
( 0020,04B0 )   :X_freeze    POP, MEM| L0020,2800 L, 
( 0020,04B6 )                  CALL, L0020,0456 RL, 
( 0020,04BB )                  CALLO, MEM| L0020,2800 L, 
( 0020,04C1 )                  JMPS, -8 (RB,) 
( 0020,04C3 )   :X_serve    POP, MEM| L0020,2804 L, 
( 0020,04C9 )                  CALL, L0020,0470 RL, 
( 0020,04CE )   :X_serveLoop    CALL, X_pause RL, 
( 0020,04D3 )                  CALLO, MEM| L0020,2804 L, 
( 0020,04D9 )                  JMPS, X_serveLoop RB, 
( 0020,04DB )   :L0020,04DB    CALL, X_serve RL, 
( 0020,04E0 )                  RET, 
( 0020,04E1 )   :X_c    MOVI|X, SI| 0009,F404 IL, 
( 0020,04E6 )                  RET, 
( 0020,04E7 )   :X_mark    MOV, X| T| CX'| MEM| ForthMacros L, 
( 0020,04ED )                  MOV, X| F| CX'| MEM| L0020,2794 L, 
( 0020,04F3 )                  MOV, X| T| CX'| MEM| ForthWords L, 
( 0020,04F9 )                  MOV, X| F| CX'| MEM| L0020,2798 L, 
( 0020,04FF )                  MOV, X| T| CX'| MEM| L0020,27A0 L, 
( 0020,0505 )                  MOV, X| F| CX'| MEM| L0020,279C L, 
( 0020,050B )                  RET, 
( 0020,050C )   :X_empt    MOV, X| T| CX'| MEM| L0020,279C L, 
( 0020,0512 )                  MOV, X| F| CX'| MEM| L0020,27A0 L, 
( 0020,0518 )                  MOV, X| T| CX'| MEM| L0020,2798 L, 
( 0020,051E )                  MOV, X| F| CX'| MEM| ForthWords L, 
( 0020,0524 )                  MOV, X| T| CX'| MEM| L0020,2794 L, 
( 0020,052A )                  MOV, X| F| CX'| MEM| ForthMacros L, 
( 0020,0530 )                  MOVI, X| MEM| L0020,27A8 L, 0 IL, 
( 0020,053A )                  RET, 
( 0020,053B )   :L0020,053B    MOV, X| T| CX'| MEM| ForthMacros L, 
( 0020,0541 )                  PUSH|X, DI| 
( 0020,0542 )                  LEA, DI'| ZO|    [MEM +4* CX] L0020,2838 L, 
( 0020,0549 )                  JMPS, L0020,0559 RB, 
( 0020,054B )   :L0020,054B    MOV, X| T| CX'| MEM| ForthWords L, 
( 0020,0551 )                  PUSH|X, DI| 
( 0020,0552 )                  LEA, DI'| ZO|    [MEM +4* CX] 0036,7FFC L, 
( 0020,0559 )   :L0020,0559    STD, 
( 0020,055A )                  REPNZ, 
( 0020,055B )                  SCAS, X'| 
( 0020,055C )                  CLD, 
( 0020,055D )                  POP|X, DI| 
( 0020,055E )                  RET, 
( 0020,055F )   :X_abort    JMPO, MEM| L0020,2754 L, 
( 0020,0565 )   :X_drop    MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,056B )                  MOV, X| F| DX'| MEM| L0020,27AC L, 
( 0020,0571 )                  MOVI, B| ZO| [DX] 0AD IB, 
( 0020,0574 )                  INC, X| MEM| L0020,27A0 L, 
( 0020,057A )                  RET, 
( 0020,057B )   :X_?dup    MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,0581 )                  DEC|X, DX| 
( 0020,0582 )                  CMP, X| F| DX'| MEM| L0020,27AC L, 
( 0020,0588 )                  J, Z| N| X_dup RB, 
( 0020,058A )                  CMPI, B| ZO| [DX] 0AD IB, 
( 0020,058D )                  J, Z| N| X_dup RB, 
( 0020,058F )                  MOV, X| F| DX'| MEM| L0020,27A0 L, 
( 0020,0595 )                  RET, 
( 0020,0596 )   :X_dup    MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,059C )                  MOVI, X| ZO| [DX] 89FC,768D IL, 
( 0020,05A2 )                  MOVI, B| BO| [DX] 4 B, 6 IB, 
( 0020,05A6 )                  ADDSI, MEM| L0020,27A0 L, 5 IS, 
( 0020,05AD )                  RET, 
( 0020,05AE )   :L0020,05AE    LEA, SI'| BO| [SI] 0FC B, 
( 0020,05B1 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,05B3 )                  RET, 
( 0020,05B4 )   :L0020,05B4    POP, MEM| L0020,27C8 L, 
( 0020,05BA )                  RET, 
( 0020,05BB )   :X_macro    CALL, L0020,05B4 RL, 
( 0020,05C0 )                  PUSH|X, AX| 
( 0020,05C1 )                  MOV, X| T| CX'| MEM| ForthMacros L, 
( 0020,05C7 )                  INC, X| MEM| ForthMacros L, 
( 0020,05CD )                  LEA, CX'| ZO|    [MEM +4* CX] L0020,283C L, 
( 0020,05D4 )                  MOVI|X, AX| 0218 IL, 
( 0020,05D9 )                  JMPS, L0020,05F9 RB, 
( 0020,05DB )   :X_forth    CALL, L0020,05B4 RL, 
( 0020,05E0 )   :L0020,05E0    PUSH|X, AX| 
( 0020,05E1 )                  MOV, X| T| CX'| MEM| ForthWords L, 
( 0020,05E7 )                  INC, X| MEM| ForthWords L, 
( 0020,05ED )                  LEA, CX'| ZO|    [MEM +4* CX] 0036,8000 L, 
( 0020,05F4 )                  MOVI|X, AX| 2800 IL, 
( 0020,05F9 )   :L0020,05F9    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,0600 )                  ANDSI, R| DX| 0F0 IS, 
( 0020,0603 )                  MOV, X| F| DX'| ZO| [CX] 
( 0020,0605 )                  MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,060B )                  MOV, X| F| DX'| ZO|    [CX +1* AX] 
( 0020,060E )                  LEA, DX'| ZO|    [CX +1* AX] 
( 0020,0611 )                  SHRI, X| R| DX| 2 IS, 
( 0020,0614 )                  MOV, X| F| DX'| MEM| L0020,27A4 L, 
( 0020,061A )                  POP|X, AX| 
( 0020,061B )                  MOV, X| F| SP'| MEM| L0020,27AC L, 
( 0020,0621 )                  MOVI, X| MEM| L0020,2790 L, L0020,05AE IL, 
( 0020,062B )                  TESTI, X| MEM| L0020,27A8 L, -1 IL, 
( 0020,0635 )                  J, Z| Y| L0020,063D RB, 
( 0020,0637 )                  JMPO, MEM| L0020,27A8 L, 
( 0020,063D )   :L0020,063D    RET, 
( 0020,063E )   :L0020,063E    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0641 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0643 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 0036,8004 L, 
( 0020,064A )                  RET, 
( 0020,064B )   :L0020,064B    CALL, L0020,05E0 RL, 
( 0020,0650 )                  MOVI, X| XO| [CX] 2800 L, L0020,063E IL, 
( 0020,065A )                  INC, X| MEM| ForthWords L, 
( 0020,0660 )                  MOV, X| F| DI'| BO| [CX] 4 B, 
( 0020,0663 )                  INC|X, DI| 
( 0020,0664 )                  RET, 
( 0020,0665 )   :L0020,0665    MOVI, X| MEM| L0020,2790 L, L0020,05AE IL, 
( 0020,066F )   :L0020,066F    CALL, X_?dup RL, 
( 0020,0674 )                  MOV, X| T| DX'| MEM| L0020,27AC L, 
( 0020,067A )                  MOV, X| F| DX'| MEM| L0020,27B0 L, 
( 0020,0680 )                  MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,0686 )                  MOV, X| F| DX'| MEM| L0020,27AC L, 
( 0020,068C )                  MOVI, B| ZO| [DX] 0B8 IB, 
( 0020,068F )                  MOV, X| F| AX'| BO| [DX] 1 B, 
( 0020,0692 )                  ADDSI, MEM| L0020,27A0 L, 5 IS, 
( 0020,0699 )                  RET, 
( 0020,069A )   :L0020,069A    CALLO, MEM| L0020,2790 L, 
( 0020,06A0 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,06A7 )                  INC|X, DI| 
( 0020,06A8 )                  JMPS, L0020,06BA RB, 
( 0020,06AA )   :L0020,06AA    CALLO, MEM| L0020,2790 L, 
( 0020,06B0 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,06B7 )                  SARI, X| R| AX| 5 IS, 
( 0020,06BA )   :L0020,06BA    CALL, L0020,066F RL, 
( 0020,06BF )                  LODS, X'| 
( 0020,06C0 )                  RET, 
( 0020,06C1 )   :L0020,06C1    XOR, X| T| DI'| R| DI| 
( 0020,06C3 )   :L0020,06C3    DEC, X| MEM| L0020,2784 L, 
( 0020,06C9 )                  J, Z| Y| L0020,06E7 RB, 
( 0020,06CB )                  LODS, X'| 
( 0020,06CC )                  JMPS, L0020,06C3 RB, 
( 0020,06CE )   :L0020,06CE    MOVI, X| MEM| L0020,2790 L, L0020,0665 IL, 
( 0020,06D8 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,06DB )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,06DD )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,06E4 )                  ANDSI, R| AX| 0F0 IS, 
( 0020,06E7 )   :L0020,06E7    CALL, L0020,054B RL, 
( 0020,06EC )                  J|X, Z| N| X_abort RL, 
( 0020,06F2 )                  LODS, X'| 
( 0020,06F3 )                  JMPO, ZO|    [MEM +4* CX] 0036,A800 L, 
( 0020,06FA )   :L0020,06FA    CALLO, MEM| L0020,2790 L, 
( 0020,0700 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,0707 )                  ANDSI, R| AX| 0F0 IS, 
( 0020,070A )                  CALL, L0020,053B RL, 
( 0020,070F )                  J, Z| N| L0020,0719 RB, 
( 0020,0711 )                  LODS, X'| 
( 0020,0712 )                  JMPO, ZO|    [MEM +4* CX] L0020,2A54 L, 
( 0020,0719 )   :L0020,0719    CALL, L0020,054B RL, 
( 0020,071E )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 0036,A800 L, 
( 0020,0725 )   :L0020,0725    J|X, Z| N| X_abort RL, 
( 0020,072B )                  MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,0731 )                  MOV, X| F| DX'| MEM| L0020,27AC L, 
( 0020,0737 )                  MOVI, B| ZO| [DX] 0E8 IB, 
( 0020,073A )                  ADDSI, R| DX| 5 IS, 
( 0020,073D )                  SUB, X| T| AX'| R| DX| 
( 0020,073F )                  MOV, X| F| AX'| BO| [DX] 0FC B, 
( 0020,0742 )                  MOV, X| F| DX'| MEM| L0020,27A0 L, 
( 0020,0748 )                  LODS, X'| 
( 0020,0749 )                  RET, 
( 0020,074A )   :L0020,074A    CALLO, MEM| L0020,2790 L, 
( 0020,0750 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,0757 )                  ANDSI, R| AX| 0F0 IS, 
( 0020,075A )                  CALL, L0020,053B RL, 
( 0020,075F )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] L0020,2A54 L, 
( 0020,0766 )                  JMPS, L0020,0725 RB, 
( 0020,0768 )   :L0020,0768    MOVI, X| MEM| L0020,2790 L, L0020,0665 IL, 
( 0020,0772 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0775 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0777 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,077E )                  SARI, X| R| AX| 5 IS, 
( 0020,0781 )                  RET, 
( 0020,0782 )   :L0020,0782    MOVI, X| MEM| L0020,2790 L, L0020,0665 IL, 
( 0020,078C )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,078F )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0791 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,0798 )                  INC|X, DI| 
( 0020,0799 )                  RET, 
( 0020,079A )   :X_,    MOVI|X, CX| 4 IL, 
( 0020,079F )   :L0020,079F    MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,07A5 )                  MOV, X| F| AX'| ZO| [DX] 
( 0020,07A7 )                  MOV, X| T| AX'| ZO| [SI] 
( 0020,07A9 )                  LEA, DX'| ZO|    [CX +1* DX] 
( 0020,07AC )                  LEA, SI'| BO| [SI] 4 B, 
( 0020,07AF )                  MOV, X| F| DX'| MEM| L0020,27A0 L, 
( 0020,07B5 )                  RET, 
( 0020,07B6 )   :X_1,    MOVI|X, CX| 1 IL, 
( 0020,07BB )                  JMPS, L0020,079F RB, 
( 0020,07BD )   :X_2,    MOVI|X, CX| 2 IL, 
( 0020,07C2 )                  JMPS, L0020,079F RB, 
( 0020,07C4 )   :X_3,    MOVI|X, CX| 3 IL, 
( 0020,07C9 )                  JMPS, L0020,079F RB, 
( 0020,07CB )   :X_;    MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,07D1 )                  SUBSI, R| DX| 5 IS, 
( 0020,07D4 )                  CMP, X| F| DX'| MEM| L0020,27AC L, 
( 0020,07DA )                  J, Z| N| L0020,07E4 RB, 
( 0020,07DC )                  CMPI, B| ZO| [DX] 0E8 IB, 
( 0020,07DF )                  J, Z| N| L0020,07E4 RB, 
( 0020,07E1 )                  INC, B| ZO| [DX] 
( 0020,07E3 )                  RET, 
( 0020,07E4 )   :L0020,07E4    MOVI, B| BO| [DX] 5 B, 0C3 IB, 
( 0020,07E8 )                  INC, X| MEM| L0020,27A0 L, 
( 0020,07EE )                  RET, 
( 0020,07EF )   :X_then    MOV, X| F| SP'| MEM| L0020,27AC L, 
( 0020,07F5 )                  MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,07FB )                  SUB, X| T| DX'| R| AX| 
( 0020,07FD )                  MOV, B| F| DL'| BO| [AX] 0FF B, 
( 0020,0800 )                  LODS, X'| 
( 0020,0801 )                  RET, 
( 0020,0802 )   :X_begin    MOV, X| F| SP'| MEM| L0020,27AC L, 
( 0020,0808 )   :X_here    LEA, SI'| BO| [SI] 0FC B, 
( 0020,080B )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,080D )                  MOV|TA, X'| L0020,27A0 L, 
( 0020,0812 )                  RET, 
( 0020,0813 )   :X_?lit    MOV, X| T| DX'| MEM| L0020,27A0 L, 
( 0020,0819 )                  LEA, DX'| BO| [DX] 0FB B, 
( 0020,081C )                  CMP, X| F| DX'| MEM| L0020,27AC L, 
( 0020,0822 )                  J, Z| N| X_?lit2 RB, 
( 0020,0824 )                  CMPI, B| ZO| [DX] 0B8 IB, 
( 0020,0827 )                  J, Z| N| X_?lit2 RB, 
( 0020,0829 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,082C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,082E )                  MOV|TA, X'| L0020,27B0 L, 
( 0020,0833 )                  MOV|FA, X'| L0020,27AC L, 
( 0020,0838 )                  MOV, X| T| AX'| BO| [DX] 1 B, 
( 0020,083B )                  CMPI, X| BO| [DX] 0FB B, 89FC,768D IL, 
( 0020,0842 )                  J, Z| Y| X_?lit1 RB, 
( 0020,0844 )                  MOV, X| F| DX'| MEM| L0020,27A0 L, 
( 0020,084A )                  JMP, X_drop RL, 
( 0020,084F )   :X_?lit1    ADDSI, MEM| L0020,27A0 L, 0F6 IS, 
( 0020,0856 )                  RET, 
( 0020,0857 )   :X_?lit2    XOR, X| T| DX'| R| DX| 
( 0020,0859 )                  RET, 
( 0020,085A )   :X_less    CMP, X| F| AX'| ZO| [SI] 
( 0020,085C )                  J, S| Y| X_less1 RB, 
( 0020,085E )                  XOR, X| T| CX'| R| CX| 
( 0020,0860 )   :X_less1    RET, 
( 0020,0861 )   :L0020,0861    TESTI, X| ZO|    [MEM +4* DI] -4 L, -10 IL, 
( 0020,086C )                  J, Z| N| L0020,0870 RB, 
( 0020,086E )                  POP|X, DI| 
( 0020,086F )                  POP|X, DI| 
( 0020,0870 )   :L0020,0870    RET, 
( 0020,0871 )   :X_jump    POP|X, DX| 
( 0020,0872 )                  ADD, X| T| DX'| R| AX| 
( 0020,0874 )                  LEA, DX'| BO|    [DX +4* AX] 5 B, 
( 0020,0878 )                  ADD, X| T| DX'| BO| [DX] 0FC B, 
( 0020,087B )                  LODS, X'| 
( 0020,087C )                  JMPO, R| DX| 
( 0020,087E )   :X_load    ADD, X| T| AX'| MEM| L0020,2744 L, 
( 0020,0884 )                  SHLI, X| R| AX| 8 IS, 
( 0020,0887 )                  PUSH|X, DI| 
( 0020,0888 )                  MOV, X| T| DI'| R| AX| 
( 0020,088A )                  LODS, X'| 
( 0020,088B )   :X_load1    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,0892 )                  INC|X, DI| 
( 0020,0893 )                  ANDSI, R| DX| 0F IS, 
( 0020,0896 )                  CALLO, ZO|    [MEM +4* DX] L0020,27BC L, 
( 0020,089D )                  JMPS, X_load1 RB, 
( 0020,089F )                 d$  0 

( 0020,08A0 )   :X_top    MOV, X| T| CX'| MEM| L0020,2814 L, 
( 0020,08A6 )                  SHLI, X| R| CX| 10 IS, 
( 0020,08A9 )                  ADDSI, R| CX| 3 IS, 
( 0020,08AC )                  MOV, X| F| CX'| MEM| L0020,2810 L, 
( 0020,08B2 )                  MOV, X| F| CX'| MEM| L0020,281C L, 
( 0020,08B8 )                  RET, 
( 0020,08B9 )   :L0020,08B9    OS:, 
( 0020,08BA )                  MOV, X| T| CX'| MEM| L0020,2812 L, 
( 0020,08C0 )                  OS:, 
( 0020,08C1 )                  CMP, X| T| CX'| MEM| L0020,2818 L, 
( 0020,08C7 )                  J, S| Y| X_cr1 RB, 
( 0020,08C9 )   :X_cr    MOV, X| T| CX'| MEM| L0020,2814 L, 
( 0020,08CF )                  SHLI, X| R| CX| 10 IS, 
( 0020,08D2 )                  OS:, 
( 0020,08D3 )                  MOV, X| T| CX'| MEM| L0020,2810 L, 
( 0020,08D9 )                  ADDSI, R| CX| 1E IS, 
( 0020,08DC )                  MOV, X| F| CX'| MEM| L0020,2810 L, 
( 0020,08E2 )   :X_cr1    RET, 
( 0020,08E3 )   :L0020,08E3    LEA, SI'| BO| [SI] 0FC B, 
( 0020,08E6 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,08E8 )                  MOVI|X, AX| 00FF,FFFF IL, 
( 0020,08ED )   :X_color    MOV|FA, X'| L0020,2830 L, 
( 0020,08F2 )                  LODS, X'| 
( 0020,08F3 )                  RET, 
\ pci [a - n] fetches a cell from PCI configuration space
\ given address. uses config mechanism as defined by PCI
\ local bus spec 2.0   
( 0020,08F4 )   :X_pci    MOVI|X, DX| 0CF8 IL, 
( 0020,08F9 )                  OUT|D, X'| 
( 0020,08FA )                  LEA, DX'| BO| [DX] 4 B, 
( 0020,08FD )                  IN|D, X'| 
( 0020,08FE )                  RET, 
\ device [n - a] given class number in high byte of n,
\ return configuration register for first device,
\ searching downwards, matching it. if none found,
\ returns configuration register for last device examined   
( 0020,08FF )   :X_devic    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0902 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0904 )                  MOVI|X, AX| 8008,0008 IL, 
( 0020,0909 )                  MOVI|X, CX| 0FE IL, 
( 0020,090E )   :X_devic1    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0911 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0913 )                  CALL, X_pci RL, 
( 0020,0918 )                  ANDI|A, X'| FF00,0000 IL, 
( 0020,091D )                  XOR, X| T| AX'| BO| [SI] 4 B, 
( 0020,0920 )                  LODS, X'| 
( 0020,0921 )                  J, Z| Y| X_devic2 RB, 
( 0020,0923 )                  SUBI|A, X'| 0800 IL, 
( 0020,0928 )                  DEC|X, CX| 
( 0020,0929 )                  J, Z| N| X_devic1 RB, 
( 0020,092B )   :X_devic2    LEA, SI'| BO| [SI] 4 B, 
( 0020,092E )                  LEA, AX'| BO| [AX] 0F8 B, 
( 0020,0931 )                  RET, 
\ 03 is PCI class code for display device   
( 0020,0932 )   :InitDisplay    MOVI|X, AX| 0300,0000 IL, 
( 0020,0937 )                  CALL, X_devic RL, 
( 0020,093C )                  LEA, AX'| BO| [AX] 10 B, 
( 0020,093F )                  MOVI|B, CL| 6 IB, 
( 0020,0941 )   :L0020,0941    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0944 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0946 )                  CALL, X_pci RL, 
( 0020,094B )                  ANDI|A, B'| 0FB IB, 
( 0020,094D )                  XORI|A, B'| 8 IB, 
( 0020,094F )                  J, Z| Y| L0020,0967 RB, 
( 0020,0951 )                  LODS, X'| 
( 0020,0952 )                  LEA, AX'| BO| [AX] 4 B, 
( 0020,0955 )                  DEC|X, CX| 
( 0020,0956 )                  J, Z| N| L0020,0941 RB, 
( 0020,0958 )                  LEA, AX'| BO| [AX] 0E8 B, 
( 0020,095B )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,095E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0960 )                  CALL, X_pci RL, 
( 0020,0965 )                  ANDI|A, B'| 0F0 IB, 
( 0020,0967 )   :L0020,0967    MOV|FA, X'| L0020,282C L, 
( 0020,096C )                  LODS, X'| 
( 0020,096D )                  RET, 
( 0020,096E )   :X_fifo    LODS, X'| 
( 0020,096F )   :X_graph    RET, 
( 0020,0970 )   :X_switch    PUSH|X, SI| 
( 0020,0971 )                  MOV, X| T| SI'| MEM| L0020,2828 L, 
( 0020,0977 )                  PUSH|X, DI| 
( 0020,0978 )                  MOV, X| T| DI'| MEM| L0020,282C L, 
( 0020,097E )                  MOVI|X, CX| 000C,0000 IL, 
( 0020,0983 )                  REPZ, 
( 0020,0984 )                  MOVS, X'| 
( 0020,0985 )                  POP|X, DI| 
( 0020,0986 )                  POP|X, SI| 
( 0020,0987 )                  RET, 
( 0020,0988 )   :L0020,0988    CALL, X_switch RL, 
( 0020,098D )                  JMP, X_pause RL, 
( 0020,0992 )   :L0020,0992    MOV, X| T| DI'| MEM| L0020,2810 L, 
( 0020,0998 )                  MOV, X| T| CX'| R| DI| 
( 0020,099A )                  OS:, 
( 0020,099B )                  TEST, X| CX'| R| CX| 
( 0020,099D )                  J, S| N| L0020,09A1 RB, 
( 0020,099F )                  XOR, X| T| CX'| R| CX| 
( 0020,09A1 )   :L0020,09A1    ANDI, X| R| CX| FFFF IL, 
( 0020,09A7 )                  MOV, X| F| CX'| MEM| L0020,2838 L, 
( 0020,09AD )                  IMULI, CX'| R| CX| 1000 IL, 
( 0020,09B3 )                  SARI, X| R| DI| 10 IS, 
( 0020,09B6 )                  J, S| N| L0020,09BA RB, 
( 0020,09B8 )                  XOR, X| T| DI'| R| DI| 
( 0020,09BA )   :L0020,09BA    MOV, X| F| DI'| MEM| L0020,2834 L, 
( 0020,09C0 )                  LEA, DI'| ZO|    [CX +4* DI] 
( 0020,09C3 )                  ADD, X| T| DI'| MEM| L0020,2824 L, 
( 0020,09C9 )                  RET, 
( 0020,09CA )   :L0020,09CA    OS:, 
( 0020,09CB )                  LODS, X'| 
( 0020,09CC )                  XCHG, B| AL'| R| AH| 
( 0020,09CE )                  MOVI|X, CX| 10 IL, 
( 0020,09D3 )   :L0020,09D3    OS:, 
( 0020,09D4 )                  SHL, 1| X| R| AX| 
( 0020,09D6 )                  J, C| N| L0020,09DA RB, 
( 0020,09D8 )                  MOV, X| F| DX'| ZO| [DI] 
( 0020,09DA )   :L0020,09DA    ADDSI, R| DI| 4 IS, 
( 0020,09DD )                  DEC|X, CX| 
( 0020,09DE )                  J, Z| N| L0020,09D3 RB, 
( 0020,09E0 )                  RET, 
( 0020,09E1 )   :L0020,09E1    OS:, 
( 0020,09E2 )                  LODS, X'| 
( 0020,09E3 )                  XCHG, B| AL'| R| AH| 
( 0020,09E5 )                  MOVI|X, CX| 10 IL, 
( 0020,09EA )   :L0020,09EA    SHL, 1| X| R| AX| 
( 0020,09EC )                  J, C| N| L0020,09FF RB, 
( 0020,09EE )                  MOV, X| F| DX'| ZO| [DI] 
( 0020,09F0 )                  MOV, X| F| DX'| BO| [DI] 4 B, 
( 0020,09F3 )                  MOV, X| F| DX'| XO| [DI] 1000 L, 
( 0020,09F9 )                  MOV, X| F| DX'| XO| [DI] 1004 L, 
( 0020,09FF )   :L0020,09FF    ADDSI, R| DI| 8 IS, 
( 0020,0A02 )                  DEC|X, CX| 
( 0020,0A03 )                  J, Z| N| L0020,09EA RB, 
( 0020,0A05 )                  RET, 
( 0020,0A06 )   :X_emit    CALL, L0020,08B9 RL, 
( 0020,0A0B )                  PUSH|X, SI| 
( 0020,0A0C )                  PUSH|X, DI| 
( 0020,0A0D )                  PUSH|X, DX| 
( 0020,0A0E )                  IMULSI, AX'| R| AX| 30 IS, 
( 0020,0A11 )                  LEA, SI'| XO| [AX] IconImages L, 
( 0020,0A17 )                  CALL, L0020,0992 RL, 
( 0020,0A1C )                  MOV, X| T| DX'| MEM| L0020,2830 L, 
( 0020,0A22 )                  MOVI|X, CX| 18 IL, 
( 0020,0A27 )   :X_emit1    PUSH|X, CX| 
( 0020,0A28 )                  CALL, L0020,09CA RL, 
( 0020,0A2D )                  ADDI, X| R| DI| 0FC0 IL, 
( 0020,0A33 )                  POP|X, CX| 
( 0020,0A34 )                  DEC|X, CX| 
( 0020,0A35 )                  J, Z| N| X_emit1 RB, 
( 0020,0A37 )                  POP|X, DX| 
( 0020,0A38 )                  POP|X, DI| 
( 0020,0A39 )                  POP|X, SI| 
( 0020,0A3A )                  LODS, X'| 
( 0020,0A3B )   :X_space    ADDI, X| MEM| L0020,2810 L, 0016,0000 IL, 
( 0020,0A45 )                  RET, 
( 0020,0A46 )   :X_2emit    PUSH|X, SI| 
( 0020,0A47 )                  PUSH|X, DI| 
( 0020,0A48 )                  PUSH|X, DX| 
( 0020,0A49 )                  IMULSI, AX'| R| AX| 30 IS, 
( 0020,0A4C )                  LEA, SI'| XO| [AX] IconImages L, 
( 0020,0A52 )                  CALL, L0020,0992 RL, 
( 0020,0A57 )                  MOV, X| T| DX'| MEM| L0020,2830 L, 
( 0020,0A5D )                  MOVI|X, CX| 18 IL, 
( 0020,0A62 )   :X_2emit1    PUSH|X, CX| 
( 0020,0A63 )                  CALL, L0020,09E1 RL, 
( 0020,0A68 )                  ADDI, X| R| DI| 1F80 IL, 
( 0020,0A6E )                  POP|X, CX| 
( 0020,0A6F )                  DEC|X, CX| 
( 0020,0A70 )                  J, Z| N| X_2emit1 RB, 
( 0020,0A72 )                  POP|X, DX| 
( 0020,0A73 )                  POP|X, DI| 
( 0020,0A74 )                  POP|X, SI| 
( 0020,0A75 )                  ADDI, X| MEM| L0020,2810 L, 002C,0000 IL, 
( 0020,0A7F )                  LODS, X'| 
( 0020,0A80 )                  RET, 
( 0020,0A81 )   :X_text    CALL, L0020,08E3 RL, 
( 0020,0A86 )                  MOVI, X| MEM| L0020,2814 L, 3 IL, 
( 0020,0A90 )                  MOVI, X| MEM| L0020,2818 L, 03F4 IL, 
( 0020,0A9A )                  JMP, X_top RL, 
( 0020,0A9F )   :X_line    CALL, L0020,0992 RL, 
( 0020,0AA4 )                  MOV, X| T| CX'| ZO| [SI] 
( 0020,0AA6 )                  SHL, 1| X| R| CX| 
( 0020,0AA8 )                  SHL, 1| X| R| CX| 
( 0020,0AAA )                  SUB, X| T| DI'| R| CX| 
( 0020,0AAC )                  MOV, X| T| CX'| R| AX| 
( 0020,0AAE )                  MOV|TA, X'| L0020,2830 L, 
( 0020,0AB3 )                  REPZ, 
( 0020,0AB4 )                  STOS, X'| 
( 0020,0AB5 )                  INC, X| MEM| L0020,2810 L, 
( 0020,0ABB )                  LODS, X'| 
( 0020,0ABC )                  LODS, X'| 
( 0020,0ABD )                  RET, 
( 0020,0ABE )   :X_box    CALL, L0020,0992 RL, 
( 0020,0AC3 )                  CMPI|A, X'| 0301 IL, 
( 0020,0AC8 )                  J, S| Y| X_box1 RB, 
( 0020,0ACA )                  MOVI|X, AX| 0300 IL, 
( 0020,0ACF )   :X_box1    MOV, X| T| CX'| R| AX| 
( 0020,0AD1 )                  SUB, X| T| CX'| MEM| L0020,2838 L, 
( 0020,0AD7 )                  J, LE| Y| X_box4 RB, 
( 0020,0AD9 )                  CMPI, X| ZO| [SI] 0401 IL, 
( 0020,0ADF )                  J, S| Y| X_box2 RB, 
( 0020,0AE1 )                  MOVI, X| ZO| [SI] 0400 IL, 
( 0020,0AE7 )   :X_box2    MOV|TA, X'| L0020,2834 L, 
( 0020,0AEC )                  SUB, X| F| AX'| ZO| [SI] 
( 0020,0AEE )                  J, LE| Y| X_box4 RB, 
( 0020,0AF0 )                  MOVI|X, DX| 0400 IL, 
( 0020,0AF5 )                  SUB, X| T| DX'| ZO| [SI] 
( 0020,0AF7 )                  SHLI, X| R| DX| 2 IS, 
( 0020,0AFA )                  MOV|TA, X'| L0020,2830 L, 
( 0020,0AFF )   :X_box3    PUSH|X, CX| 
( 0020,0B00 )                  MOV, X| T| CX'| ZO| [SI] 
( 0020,0B02 )                  REPZ, 
( 0020,0B03 )                  STOS, X'| 
( 0020,0B04 )                  ADD, X| T| DI'| R| DX| 
( 0020,0B06 )                  POP|X, CX| 
( 0020,0B07 )                  DEC|X, CX| 
( 0020,0B08 )                  J, Z| N| X_box3 RB, 
( 0020,0B0A )   :X_box4    LODS, X'| 
( 0020,0B0B )                  LODS, X'| 
( 0020,0B0C )                  RET, 
( 0020,0B0D )   :X_color0FF    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B10 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B12 )                  MOVI|X, AX| FFFF IL, 
( 0020,0B17 )                  JMP, X_color RL, 
( 0020,0B1C )   :X_colorF0F    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B1F )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B21 )                  MOVI|X, AX| 00FF,00FF IL, 
( 0020,0B26 )                  JMP, X_color RL, 
( 0020,0B2B )   :X_colorCCC    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B2E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B30 )                  MOVI|X, AX| 00C0,C0C0 IL, 
( 0020,0B35 )                  JMP, X_color RL, 
( 0020,0B3A )   :X_color44F    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B3D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B3F )                  MOVI|X, AX| 0040,40FF IL, 
( 0020,0B44 )                  JMP, X_color RL, 
( 0020,0B49 )   :X_colorF00    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B4C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B4E )                  MOVI|X, AX| 00FF,0000 IL, 
( 0020,0B53 )                  JMP, X_color RL, 
( 0020,0B58 )   :X_color80F0    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B5B )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B5D )                  MOVI|X, AX| 8000,FF00 IL, 
( 0020,0B62 )                  JMP, X_color RL, 
( 0020,0B67 )   :L0020,0B67   db 0 0 0 0 0 0 0 0 0 0 
( 0020,0B71 )   :L0020,0B71   db 0 

( 0020,0B72 )   :L0020,0B72    PUSH|X, SI| 
( 0020,0B73 )                  MOVI|X, CX| 0A IL, 
( 0020,0B78 )                  LEA, DI'| MEM| L0020,0B67 L, 
( 0020,0B7E )                  LEA, SI'| BO| [DI] 1 B, 
( 0020,0B81 )                  REPZ, 
( 0020,0B82 )                  MOVS, B'| 
( 0020,0B83 )                  POP|X, SI| 
( 0020,0B84 )                  MOV|FA, B'| L0020,0B71 L, 
( 0020,0B89 )                  LODS, X'| 
( 0020,0B8A )                  RET, 
( 0020,0B8B )   :L0020,0B8B    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0B8E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0B90 )                  MOVI|X, CX| 0B IL, 
( 0020,0B95 )                  LEA, DI'| MEM| L0020,0B67 L, 
( 0020,0B9B )                  XOR, X| T| AX'| R| AX| 
( 0020,0B9D )                  REPZ, 
( 0020,0B9E )                  STOS, B'| 
( 0020,0B9F )                  LODS, X'| 
( 0020,0BA0 )                  RET, 
( 0020,0BA1 )   :X_down    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0BA4 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0BA6 )                  XOR, X| T| DX'| R| DX| 
( 0020,0BA8 )                  MOVI|X, CX| 1E IL, 
( 0020,0BAD )                  DIV|AD, X| R| CX| 
( 0020,0BAF )                  MOV, X| T| AX'| R| DX| 
( 0020,0BB1 )                  ADDI, X| R| DX| 0003,7FE5 IL, 
( 0020,0BB7 )                  MOV, X| F| DX'| MEM| L0020,2810 L, 
( 0020,0BBD )                  TEST, X| AX'| R| AX| 
( 0020,0BBF )                  MOVI|X, AX| 0 IL, 
( 0020,0BC4 )                  J, Z| N| X_down1 RB, 
( 0020,0BC6 )                  INC|X, AX| 
( 0020,0BC7 )   :X_down1    RET, 
( 0020,0BC8 )   :L0020,0BC8    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0BCB )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0BCD )                  XOR, X| T| AX'| R| AX| 
( 0020,0BCF )                  MOV|FA, X'| L0020,2810 L, 
( 0020,0BD4 )                  CALL, X_color RL, 
( 0020,0BD9 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0BDC )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0BDE )                  MOVI|X, AX| 0400 IL, 
( 0020,0BE3 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0BE6 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0BE8 )                  MOVI|X, AX| 0300 IL, 
( 0020,0BED )                  JMP, X_box RL, 
( 0020,0BF2 )   :X_lm    MOV|FA, X'| L0020,2814 L, 
( 0020,0BF7 )                  LODS, X'| 
( 0020,0BF8 )                  RET, 
( 0020,0BF9 )   :X_rm    MOV|FA, X'| L0020,2818 L, 
( 0020,0BFE )                  LODS, X'| 
( 0020,0BFF )                  RET, 
( 0020,0C00 )   :X_at    OS:, 
( 0020,0C01 )                  MOV|FA, X'| L0020,2810 L, 
( 0020,0C06 )                  LODS, X'| 
( 0020,0C07 )                  OS:, 
( 0020,0C08 )                  MOV|FA, X'| L0020,2812 L, 
( 0020,0C0D )                  LODS, X'| 
( 0020,0C0E )                  RET, 
( 0020,0C0F )   :X_+at    OS:, 
( 0020,0C10 )                  ADD, X| F| AX'| MEM| L0020,2810 L, 
( 0020,0C16 )                  LODS, X'| 
( 0020,0C17 )                  OS:, 
( 0020,0C18 )                  ADD, X| F| AX'| MEM| L0020,2812 L, 
( 0020,0C1E )                  LODS, X'| 
( 0020,0C1F )                  RET, 
( 0020,0C20 )   :X_octant    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0C23 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0C25 )                  MOVI|X, AX| 43 IL, 
( 0020,0C2A )                  MOV, X| T| DX'| BO| [SI] 4 B, 
( 0020,0C2D )                  TEST, X| DX'| R| DX| 
( 0020,0C2F )                  J, S| N| X_octant1 RB, 
( 0020,0C31 )                  NEG, X| R| DX| 
( 0020,0C33 )                  MOV, X| F| DX'| BO| [SI] 4 B, 
( 0020,0C36 )                  XORI|A, B'| 1 IB, 
( 0020,0C38 )   :X_octant1    CMP, X| T| DX'| ZO| [SI] 
( 0020,0C3A )                  J, S| N| X_octant2 RB, 
( 0020,0C3C )                  XORI|A, B'| 4 IB, 
( 0020,0C3E )   :X_octant2    RET, 
( 0020,0C3F )   :digitChars   db 18 19 1A 1B 1C 1D 1E 1F 20 21 5 13 0A 10 4 0E 

( 0020,0C4F )   :L0020,0C4F    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0C52 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0C54 )   :X_digit    PUSH|X, CX| 
( 0020,0C55 )                  MOV, B| T| AL'| XO| [AX] digitChars L, 
( 0020,0C5B )                  CALL, X_emit RL, 
( 0020,0C60 )                  POP|X, CX| 
( 0020,0C61 )                  RET, 
( 0020,0C62 )   :L0020,0C62    ROLI, X| R| AX| 4 IS, 
( 0020,0C65 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0C68 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0C6A )                  ANDSI, R| AX| 0F IS, 
( 0020,0C6D )                  RET, 
( 0020,0C6E )   :X_h.n    MOV, X| T| DX'| R| AX| 
( 0020,0C70 )                  NEG, X| R| AX| 
( 0020,0C72 )                  LEA, CX'| ZO|    [MEM +4* AX] 20 L, 
( 0020,0C79 )                  LODS, X'| 
( 0020,0C7A )                  ROL, V| X| R| AX| 
( 0020,0C7C )                  MOV, X| T| CX'| R| DX| 
( 0020,0C7E )                  JMPS, X_h.1 RB, 
( 0020,0C80 )   :X_h.    MOVI|X, CX| 8 IL, 
( 0020,0C85 )   :X_h.1    CALL, L0020,0C62 RL, 
( 0020,0C8A )                  CALL, X_digit RL, 
( 0020,0C8F )                  DEC|X, CX| 
( 0020,0C90 )                  J, Z| N| X_h.1 RB, 
( 0020,0C92 )                  LODS, X'| 
( 0020,0C93 )                  RET, 
( 0020,0C94 )   :L0020,0C94    MOVI|X, CX| 7 IL, 
( 0020,0C99 )   :L0020,0C99    CALL, L0020,0C62 RL, 
( 0020,0C9E )                  J, Z| N| L0020,0CB9 RB, 
( 0020,0CA0 )                  LODS, X'| 
( 0020,0CA1 )                  DEC|X, CX| 
( 0020,0CA2 )                  J, Z| N| L0020,0C99 RB, 
( 0020,0CA4 )                  INC|X, CX| 
( 0020,0CA5 )   :L0020,0CA5    CALL, L0020,0C62 RL, 
( 0020,0CAA )   :L0020,0CAA    CALL, X_digit RL, 
( 0020,0CAF )                  DEC|X, CX| 
( 0020,0CB0 )                  J, Z| N| L0020,0CA5 RB, 
( 0020,0CB2 )                  CALL, X_space RL, 
( 0020,0CB7 )                  LODS, X'| 
( 0020,0CB8 )                  RET, 
( 0020,0CB9 )   :L0020,0CB9    INC|X, CX| 
( 0020,0CBA )                  JMPS, L0020,0CAA RB, 
( 0020,0CBC )   :L0020,0CBC    CMPSI, MEM| L0020,276C L, 0A IS, 
( 0020,0CC3 )                  J, Z| N| L0020,0C94 RB, 
( 0020,0CC5 )   :X_.    MOV, X| T| DX'| R| AX| 
( 0020,0CC7 )                  TEST, X| DX'| R| DX| 
( 0020,0CC9 )                  J, S| N| X_.1 RB, 
( 0020,0CCB )                  NEG, X| R| DX| 
( 0020,0CCD )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0CD0 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0CD2 )                  MOVI|X, AX| 23 IL, 
( 0020,0CD7 )                  CALL, X_emit RL, 
( 0020,0CDC )   :X_.1    MOVI|X, CX| 8 IL, 
( 0020,0CE1 )   :X_.2    MOV, X| T| AX'| R| DX| 
( 0020,0CE3 )                  XOR, X| T| DX'| R| DX| 
( 0020,0CE5 )                  DIV|AD, X| ZO|    [MEM +4* CX] L0020,2700 L, 
( 0020,0CEC )                  TEST, X| AX'| R| AX| 
( 0020,0CEE )                  J, Z| N| X_.4 RB, 
( 0020,0CF0 )                  DEC|X, CX| 
( 0020,0CF1 )                  J, S| N| X_.2 RB, 
( 0020,0CF3 )                  JMPS, X_.5 RB, 
( 0020,0CF5 )   :X_.3    MOV, X| T| AX'| R| DX| 
( 0020,0CF7 )                  XOR, X| T| DX'| R| DX| 
( 0020,0CF9 )                  DIV|AD, X| ZO|    [MEM +4* CX] L0020,2700 L, 
( 0020,0D00 )   :X_.4    CALL, L0020,0C4F RL, 
( 0020,0D05 )                  DEC|X, CX| 
( 0020,0D06 )                  J, S| N| X_.3 RB, 
( 0020,0D08 )   :X_.5    MOV, X| T| AX'| R| DX| 
( 0020,0D0A )                  CALL, L0020,0C4F RL, 
( 0020,0D0F )                  CALL, X_space RL, 
( 0020,0D14 )                  LODS, X'| 
( 0020,0D15 )                  RET, 
( 0020,0D16 )   :L0020,0D16    ADDSI, R| DI| 0C IS, 
( 0020,0D19 )                  CALL, L0020,0D26 RL, 
( 0020,0D1E )                  CALL, X_space RL, 
( 0020,0D23 )                  SUBSI, R| DI| 10 IS, 
( 0020,0D26 )   :L0020,0D26    MOVI|X, CX| 4 IL, 
( 0020,0D2B )   :L0020,0D2B    PUSH|X, CX| 
( 0020,0D2C )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0D2F )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0D31 )                  XOR, X| T| AX'| R| AX| 
( 0020,0D33 )                  MOV, B| T| AL'| BO| [DI] 4 B, 
( 0020,0D36 )                  INC|X, DI| 
( 0020,0D37 )                  CALL, X_emit RL, 
( 0020,0D3C )                  POP|X, CX| 
( 0020,0D3D )                  DEC|X, CX| 
( 0020,0D3E )                  J, Z| N| L0020,0D2B RB, 
( 0020,0D40 )                  RET, 
( 0020,0D41 )   :L0020,0D41    MOVI|X, DI| 0009,F3FC IL, 
( 0020,0D46 )   :L0020,0D46    MOV, X| T| DX'| MEM| L0020,043E L, 
( 0020,0D4C )                  CMP, X| F| DI'| ZO| [DX] 
( 0020,0D4E )                  J, C| N| 11 (RB,) 
( 0020,0D50 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0D53 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0D55 )                  MOV, X| T| AX'| ZO| [DI] 
( 0020,0D57 )                  SUBSI, R| DI| 4 IS, 
( 0020,0D5A )                  CALL, L0020,0CBC RL, 
( 0020,0D5F )   :L0020,0D5F    JMPS, L0020,0D46 RB, 
( 0020,0D61 )                  RET, 
( 0020,0D62 )   :X_keybo    CALL, X_text RL, 
( 0020,0D67 )                  MOV, X| T| DI'| MEM| L0020,2764 L, 
( 0020,0D6D )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,0D70 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0D72 )                  MOV|TA, X'| L0020,2774 L, 
( 0020,0D77 )                  CALL, X_color RL, 
( 0020,0D7C )                  MOV|TA, X'| L0020,275C L, 
( 0020,0D81 )                  ADDSI, R| AX| 0 IS, 
( 0020,0D84 )                  MOV|FA, X'| L0020,2814 L, 
( 0020,0D89 )                  MOV, X| T| DX'| R| AX| 
( 0020,0D8B )                  ADDI, X| R| DX| 0C6 IL, 
( 0020,0D91 )                  MOV, X| F| DX'| MEM| L0020,2818 L, 
( 0020,0D97 )                  SHLI, X| R| AX| 10 IS, 
( 0020,0D9A )                  ADD, X| T| AX'| MEM| L0020,2760 L, 
( 0020,0DA0 )                  MOV|FA, X'| L0020,2810 L, 
( 0020,0DA5 )                  CALL, L0020,0D16 RL, 
( 0020,0DAA )                  CALL, L0020,0D16 RL, 
( 0020,0DAF )                  CALL, L0020,0D16 RL, 
( 0020,0DB4 )                  CALL, X_cr RL, 
( 0020,0DB9 )                  ADDI, X| MEM| L0020,2810 L, 0058,0000 IL, 
( 0020,0DC3 )                  MOV, X| T| DI'| MEM| L0020,2768 L, 
( 0020,0DC9 )                  ADDSI, R| DI| 0C IS, 
( 0020,0DCC )                  MOVI|X, CX| 3 IL, 
( 0020,0DD1 )                  CALL, L0020,0D2B RL, 
( 0020,0DD6 )                  MOVI, X| MEM| L0020,2814 L, 3 IL, 
( 0020,0DE0 )                  OS:, 
( 0020,0DE1 )                  MOVI, X| MEM| L0020,2812 L, 3 IW, 
( 0020,0DE9 )                  CALL, L0020,0D41 RL, 
( 0020,0DEE )                  OS:, 
( 0020,0DEF )                  MOVI, X| MEM| L0020,2812 L, 024B IW, 
( 0020,0DF7 )                  LEA, DI'| MEM| L0020,0B63 L, 
( 0020,0DFD )                  MOVI|X, CX| 0B IL, 
( 0020,0E02 )                  JMP, L0020,0D2B RL, 
( 0020,0E07 )                 db 0D 0A 1 0C 14 2 6 8 13 9 0F 11 12 0B 0E 7 
( 0020,0E17 )                 db 5 3 4 16 
( 0020,0E1B )   :L0020,0E1B   db 17 24 15 10 19 1A 1B 0 1C 1D 1E 18 
( 0020,0E27 )                 db 1F 20 21 2F 29 28 2A 2C 26 22 25 2E 
( 0020,0E33 )   :L0020,0E33   db 2D 27 2B 23 
( 0020,0E37 )                 db 19 1A 1B 0 1C 1D 1E 18 1F 20 21 0 0 0 0 0 
( 0020,0E47 )                 db 0 0 0 0 
( 0020,0E4B )   :L0020,0E4B   db 0 0 0 0 19 1A 1B 0 1C 1D 1E 18 
( 0020,0E57 )                 db 1F 20 21 0 0 5 13 0A 0 10 4 0E 0 0 
( 0020,0E65 )   :L0020,0E65   db 0 0 

( 0020,0E67 )   :L0020,0E67    CMPI|A, B'| 4 IB, 
( 0020,0E69 )                  J, S| Y| L0020,0E74 RB, 
( 0020,0E6B )                  MOV, X| T| DX'| MEM| L0020,2764 L, 
( 0020,0E71 )                  MOV, B| T| AL'| ZO|    [AX +1* DX] 
( 0020,0E74 )   :L0020,0E74    RET, 
( 0020,0E75 )                 dl 1312,1110 0504,0000 0706 1514,0000 
( 0020,0E85 )                 dl 1716 0B0A,0908 0 1B1A,1918 
( 0020,0E95 )                 dl 0D0C,0100 0F0E 768D,0203 

( 0020,0E9F )   :L0020,0E9F    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0EA2 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0EA4 )                  XOR, X| T| AX'| R| AX| 
( 0020,0EA6 )                  CALL, X_pause RL, 
( 0020,0EAB )   :L0020,0EAB    IN|P, B'| 64 P, 
( 0020,0EAD )                  TESTI|A, B'| 1 IB, 
( 0020,0EAF )                  J, Z| Y| L0020,0EAB RB, 
( 0020,0EB1 )                  IN|P, B'| 60 P, 
( 0020,0EB3 )                  TESTI|A, B'| 0F0 IB, 
( 0020,0EB5 )                  J, Z| Y| L0020,0EAB RB, 
( 0020,0EB7 )                  CMPI|A, B'| 3A IB, 
( 0020,0EB9 )                  J, C| N| L0020,0EAB RB, 
( 0020,0EBB )                  MOV, B| T| AL'| XO| [AX] L0020,0E65 L, 
( 0020,0EC1 )                  RET, 
( 0020,0EC2 )                 db 90 0 
( 0020,0EC4 )   :L0020,0EC4   db 0B 18 2 19 3 1A 4 1B 5 1C 6 1D 7 1E 
( 0020,0ED2 )                 db 8 1F 9 20 0A 21 1E 5 30 13 2E 0A 20 10 12 4 
( 0020,0EE2 )                 db 21 0E 22 0D 23 14 17 7 24 22 25 24 26 0C 32 9 
( 0020,0EF2 )                 db 31 6 18 3 19 12 10 17 13 1 1F 8 14 2 16 16 
( 0020,0F02 )                 db 2F 11 11 0F 2D 15 15 0B 2C 26 0C 23 34 25 35 27 
( 0020,0F12 )                 db 27 28 28 29 82 2A 8D 2B 83 2C 89 2D 33 2E 0B5 2F 
( 0020,0F22 )                 db 39 80 1C 81 0E 82 1 83 3B 84 29 30 

( 0020,0F2E )   :X_qkey    LEA, SI'| BO| [SI] 0FC B, 
( 0020,0F31 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,0F33 )                  XOR, X| T| AX'| R| AX| 
( 0020,0F35 )                  CALL, X_pause RL, 
( 0020,0F3A )   :X_qkey1    IN|P, B'| 64 P, 
( 0020,0F3C )                  TESTI|A, B'| 1 IB, 
( 0020,0F3E )                  J, Z| Y| X_qkey1 RB, 
( 0020,0F40 )                  IN|P, B'| 60 P, 
( 0020,0F42 )                  MOV, X| T| CX'| R| AX| 
( 0020,0F44 )                  ANDI, B| R| CL| 7F IB, 
( 0020,0F47 )                  CMPI, B| R| CL| 2A IB, 
( 0020,0F4A )                  J, Z| Y| X_qkey2 RB, 
( 0020,0F4C )                  CMPI, B| R| CL| 36 IB, 
( 0020,0F4F )                  J, Z| N| X_qkey3 RB, 
( 0020,0F51 )   :X_qkey2    ANDI|A, B'| 80 IB, 
( 0020,0F53 )                  XORI|A, B'| 80 IB, 
( 0020,0F55 )                  MOV|FA, X'| L0020,2788 L, 
( 0020,0F5A )                  JMPS, X_qkey1 RB, 
( 0020,0F5C )   :X_qkey3    OR, B| T| AL'| R| AL| 
( 0020,0F5E )                  J, S| Y| X_qkey1 RB, 
( 0020,0F60 )                  ANDI|A, B'| 7F IB, 
( 0020,0F62 )                  OR, X| T| AX'| MEM| L0020,2788 L, 
( 0020,0F68 )                  MOVI|X, DX| L0020,0EC4 IL, 
( 0020,0F6D )                  MOVI|X, CX| 35 IL, 
( 0020,0F72 )   :X_qkey4    CMP, B| F| AL'| ZO| [DX] 
( 0020,0F74 )                  J, Z| Y| X_qkey5 RB, 
( 0020,0F76 )                  ADDSI, R| DX| 2 IS, 
( 0020,0F79 )                  LOOP, X_qkey4 RB, 
( 0020,0F7B )                  XOR, X| T| AX'| R| AX| 
( 0020,0F7D )                  RET, 
( 0020,0F7E )   :X_qkey5    MOV, B| T| AL'| BO| [DX] 1 B, 
( 0020,0F81 )                  SUBI, X| R| DX| L0020,0EC4 IL, 
( 0020,0F87 )                  SHR, 1| X| R| DX| 
( 0020,0F89 )                  MOV, X| F| DX'| MEM| L0020,278C L, 
( 0020,0F8F )                  TESTI|A, X'| 80 IL, 
( 0020,0F94 )                  RET, 
( 0020,0F95 )   :L0020,0F95   db 0CF 11 20 0 0CF 11 20 0 0CF 11 20 0 21 12 20 0 
( 0020,0FA5 )                 db 0 0 5 0 
( 0020,0FA9 )   :L0020,0FA9   db 0DC 10 20 0 74 10 20 0 1A 10 20 0 
( 0020,0FB5 )                 db 46 12 20 0 15 25 5 0 
( 0020,0FBD )   :L0020,0FBD   db 0CF 11 20 0 
( 0020,0FC1 )   :L0020,0FC1   db 0CF 11 20 0 
( 0020,0FC5 )                 db 0D 11 20 0 33 12 20 0 
( 0020,0FCD )   :L0020,0FCD   db 0 21 2D 0 
( 0020,0FD1 )   :L0020,0FD1   db 0DC 10 20 0 
( 0020,0FD5 )                 db 74 10 20 0 1A 10 20 0 58 12 20 0 15 25 2D 0 
( 0020,0FE5 )   :L0020,0FE5   db 0CF 11 20 0 3 11 20 0 20 12 20 0 
( 0020,0FF1 )   :L0020,0FF1   db 0AB 11 20 0 
( 0020,0FF5 )                 db 23 5 
( 0020,0FF7 )   :L0020,0FF7   db 0E 0 
( 0020,0FF9 )   :L0020,0FF9   db 0A 11 20 0 0C7 11 20 0 60 11 20 0 
( 0020,1005 )                 db 0A 11 20 0 15 25 0 0 
( 0020,100D )   :L0020,100D   db 1C 

( 0020,100E )   :L0020,100E    MOV, B| T| CL'| MEM| L0020,100D L, 
( 0020,1014 )                  ADDI, B| R| CL| 4 IB, 
( 0020,1017 )                  SHL, V| X| ZO| [SI] 
( 0020,1019 )                  RET, 
( 0020,101A )   :L0020,101A    CALL, L0020,100E RL, 
( 0020,101F )                  LODS, X'| 
( 0020,1020 )                  RET, 
( 0020,1021 )   :L0020,1021    CALL, L0020,100E RL, 
( 0020,1026 )                  INC, X| MEM| L0020,2784 L, 
( 0020,102C )                  MOVI, B| MEM| L0020,100D L, 1C IB, 
( 0020,1033 )                  SUB, B| F| CH'| MEM| L0020,100D L, 
( 0020,1039 )                  MOV, X| T| AX'| R| DX| 
( 0020,103B )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,103E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1040 )                  RET, 
( 0020,1041 )   :L0020,1041    ADDSI, R| AX| 50 IS, 
( 0020,1044 )                  MOVI|B, CL| 7 IB, 
( 0020,1046 )                  JMPS, L0020,1055 RB, 
( 0020,1048 )   :L0020,1048    CMPI|A, B'| 10 IB, 
( 0020,104A )                  J, C| N| L0020,1041 RB, 
( 0020,104C )                  MOVI|B, CL| 4 IB, 
( 0020,104E )                  TESTI|A, B'| 8 IB, 
( 0020,1050 )                  J, Z| Y| L0020,1055 RB, 
( 0020,1052 )                  INC|X, CX| 
( 0020,1053 )                  XORI|A, B'| 18 IB, 
( 0020,1055 )   :L0020,1055    MOV, X| T| DX'| R| AX| 
( 0020,1057 )                  MOV, B| T| CH'| R| CL| 
( 0020,1059 )   :L0020,1059    CMP, B| F| CL'| MEM| L0020,100D L, 
( 0020,105F )                  J, C| N| L0020,1069 RB, 
( 0020,1061 )                  SHR, 1| B| R| AL| 
( 0020,1063 )                  J, C| Y| L0020,1021 RB, 
( 0020,1065 )                  DEC, B| R| CL| 
( 0020,1067 )                  JMPS, L0020,1059 RB, 
( 0020,1069 )   :L0020,1069    SHL, V| X| ZO| [SI] 
( 0020,106B )                  XOR, X| F| AX'| ZO| [SI] 
( 0020,106D )                  SUB, B| F| CL'| MEM| L0020,100D L, 
( 0020,1073 )                  RET, 
( 0020,1074 )   :L0020,1074    CALL, L0020,0B8B RL, 
( 0020,1079 )                  MOV|TA, X'| L0020,2784 L, 
( 0020,107E )                  LEA, SI'| ZO|    [SI +4* AX] 
( 0020,1081 )                  LODS, X'| 
( 0020,1082 )                  JMPO, MEM| L0020,274C L, 
( 0020,1088 )   :L0020,1088    CALL, L0020,0B8B RL, 
( 0020,108D )                  MOVI, X| MEM| L0020,2784 L, 1 IL, 
( 0020,1097 )                  MOVI, X| MEM| L0020,2778 L, 1 IL, 
( 0020,10A1 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,10A4 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,10A6 )                  MOVI, X| ZO| [SI] 0 IL, 
( 0020,10AC )                  MOVI, B| MEM| L0020,100D L, 1C IB, 
( 0020,10B3 )   :L0020,10B3    CALL, L0020,0E67 RL, 
( 0020,10B8 )                  J, S| N| L0020,10C3 RB, 
( 0020,10BA )                  MOV, X| T| DX'| MEM| L0020,2768 L, 
( 0020,10C0 )                  JMPO, ZO|    [DX +4* AX] 
( 0020,10C3 )   :L0020,10C3    TEST, B| AL'| R| AL| 
( 0020,10C5 )                  J, Z| Y| 15 (RB,) 
( 0020,10C7 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,10CA )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,10CC )                  CALL, L0020,0B72 RL, 
( 0020,10D1 )                  CALL, L0020,1048 RL, 
( 0020,10D6 )                  INC, X| MEM| L0020,2778 L, 
( 0020,10DC )                  LODS, X'| 
( 0020,10DD )                  CALL, L0020,0E9F RL, 
( 0020,10E2 )                  JMPS, L0020,10B3 RB, 
( 0020,10E4 )                 db 0E 0A 0 0 0 0 0C 0 0 0 0F 0 0D 0 0 0B 
( 0020,10F4 )                 db 0 0 0 0 0 1 2 3 4 5 6 7 8 9 
( 0020,1102 )   :L0020,1102   db 0 

( 0020,1103 )   :L0020,1103    MOV|FA, B'| L0020,1102 L, 
( 0020,1108 )                  JMPS, L0020,1153 RB, 
( 0020,110A )   :L0020,110A    LODS, X'| 
( 0020,110B )                  JMPS, L0020,111C RB, 
( 0020,110D )   :L0020,110D    CALLO, MEM| L0020,2770 L, 
( 0020,1113 )                  MOVI, B| MEM| L0020,1102 L, 0 IB, 
( 0020,111A )                  XOR, X| T| AX'| R| AX| 
( 0020,111C )   :L0020,111C    CALL, L0020,0E9F RL, 
( 0020,1121 )                  CALL, L0020,0E67 RL, 
( 0020,1126 )                  J, S| N| L0020,1131 RB, 
( 0020,1128 )                  MOV, X| T| DX'| MEM| L0020,2768 L, 
( 0020,112E )                  JMPO, ZO|    [DX +4* AX] 
( 0020,1131 )   :L0020,1131    TEST, B| AL'| R| AL| 
( 0020,1133 )                  J, Z| Y| L0020,110A RB, 
( 0020,1135 )                  MOV, B| T| AL'| XO| [AX] L0020,10E0 L, 
( 0020,113B )                  TESTI, B| MEM| L0020,1102 L, 1F IB, 
( 0020,1142 )                  J, Z| Y| L0020,1146 RB, 
( 0020,1144 )                  NEG, X| R| AX| 
( 0020,1146 )   :L0020,1146    MOV, X| T| DX'| ZO| [SI] 
( 0020,1148 )                  IMUL, DX'| MEM| L0020,276C L, 
( 0020,114F )                  ADD, X| T| DX'| R| AX| 
( 0020,1151 )                  MOV, X| F| DX'| ZO| [SI] 
( 0020,1153 )   :L0020,1153    LODS, X'| 
( 0020,1154 )                  MOVI, X| MEM| L0020,2768 L, L0020,0FF9 IL, 
( 0020,115E )                  JMPS, L0020,111C RB, 
( 0020,1160 )   :L0020,1160    LODS, X'| 
( 0020,1161 )                  CALLO, MEM| L0020,2780 L, 
( 0020,1167 )                  JMPO, MEM| L0020,274C L, 
( 0020,116D )   :L0020,116D    MOVI, X| MEM| L0020,276C L, 0A IL, 
( 0020,1177 )                  MOVI, X| MEM| L0020,2768 L, L0020,0FE5 IL, 
( 0020,1181 )                  MOVI, X| MEM| L0020,2764 L, L0020,0E33 IL, 
( 0020,118B )                  RET, 
( 0020,118C )   :L0020,118C    MOVI, X| MEM| L0020,276C L, 10 IL, 
( 0020,1196 )                  MOVI, X| MEM| L0020,2768 L, L0020,0FE5 IL, 
( 0020,11A0 )                  MOVI, X| MEM| L0020,2764 L, L0020,0E4B IL, 
( 0020,11AA )                  RET, 
( 0020,11AB )   :L0020,11AB    XORI, X| MEM| L0020,2770 L, 0E1 IL, 
( 0020,11B5 )                  XORI, B| MEM| L0020,0FF7 L, 2F IB, 
( 0020,11BC )                  CALLO, MEM| L0020,2770 L, 
( 0020,11C2 )                  JMP, L0020,110A RL, 
( 0020,11C7 )   :L0020,11C7    LODS, X'| 
( 0020,11C8 )                  LODS, X'| 
( 0020,11C9 )                  JMPO, MEM| L0020,274C L, 
( 0020,11CF )   :L0020,11CF    LODS, X'| 
( 0020,11D0 )                  JMPS, X_accept2 RB, 
( 0020,11D2 )   :X_accept    MOVI, X| MEM| L0020,2768 L, L0020,0FBD IL, 
( 0020,11DC )                  LEA, DI'| MEM| L0020,0E03 L, 
( 0020,11E2 )   :X_accept1    MOV, X| F| DI'| MEM| L0020,2764 L, 
( 0020,11E8 )   :X_accept2    TESTI, X| MEM| L0020,2750 L, -1 IL, 
( 0020,11F2 )                  J, Z| Y| X_accept3 RB, 
( 0020,11F4 )                  JMPO, MEM| L0020,2750 L, 
( 0020,11FA )   :X_accept3    CALL, L0020,0E9F RL, 
( 0020,11FF )                  CMPI|A, B'| 4 IB, 
( 0020,1201 )                  J, S| N| X_accept4 RB, 
( 0020,1203 )                  MOV, X| T| DX'| MEM| L0020,2768 L, 
( 0020,1209 )                  JMPO, ZO|    [DX +4* AX] 
( 0020,120C )   :X_accept4    ADDSI, MEM| L0020,2768 L, 14 IS, 
( 0020,1213 )                  CALL, L0020,1088 RL, 
( 0020,1218 )                  CALLO, MEM| L0020,277C L, 
( 0020,121E )                  JMPS, X_accept RB, 
( 0020,1220 )   :L0020,1220    LODS, X'| 
( 0020,1221 )   :L0020,1221    MOVI, X| MEM| L0020,2768 L, L0020,0FBD IL, 
( 0020,122B )                  LEA, DI'| MEM| L0020,0E03 L, 
( 0020,1231 )                  JMPS, L0020,1243 RB, 
( 0020,1233 )   :L0020,1233    MOVI, X| MEM| L0020,2768 L, L0020,0F95 IL, 
( 0020,123D )                  LEA, DI'| MEM| L0020,0E1B L, 
( 0020,1243 )   :L0020,1243    LODS, X'| 
( 0020,1244 )                  JMPS, X_accept1 RB, 
( 0020,1246 )   :L0020,1246    MOVI, X| MEM| L0020,2768 L, L0020,0FD1 IL, 
( 0020,1250 )                  LEA, DI'| MEM| L0020,0E03 L, 
( 0020,1256 )                  JMPS, L0020,1268 RB, 
( 0020,1258 )   :L0020,1258    MOVI, X| MEM| L0020,2768 L, L0020,0FA9 IL, 
( 0020,1262 )                  LEA, DI'| MEM| L0020,0E1B L, 
( 0020,1268 )   :L0020,1268    MOV, X| F| DI'| MEM| L0020,2764 L, 
( 0020,126E )                  JMP, -197 (RL,) 
( 0020,1273 )   :X_unpac    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1276 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1278 )                  TEST, X| AX'| R| AX| 
( 0020,127A )                  J, S| Y| X_unpac1 RB, 
( 0020,127C )                  SHLI, X| ZO| [SI] 4 IS, 
( 0020,127F )                  ROLI, X| R| AX| 4 IS, 
( 0020,1282 )                  ANDSI, R| AX| 7 IS, 
( 0020,1285 )                  RET, 
( 0020,1286 )   :X_unpac1    SHL, 1| X| R| AX| 
( 0020,1288 )                  J, S| Y| X_unpac2 RB, 
( 0020,128A )                  SHLI, X| ZO| [SI] 5 IS, 
( 0020,128D )                  ROLI, X| R| AX| 4 IS, 
( 0020,1290 )                  ANDSI, R| AX| 7 IS, 
( 0020,1293 )                  XORI|A, B'| 8 IB, 
( 0020,1295 )                  RET, 
( 0020,1296 )   :X_unpac2    SHLI, X| ZO| [SI] 7 IS, 
( 0020,1299 )                  ROLI, X| R| AX| 6 IS, 
( 0020,129C )                  ANDSI, R| AX| 3F IS, 
( 0020,129F )                  SUBI|A, B'| 10 IB, 
( 0020,12A1 )                  RET, 
( 0020,12A2 )   :L0020,12A2    LEA, SI'| BO| [SI] 0FC B, 
( 0020,12A5 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,12A7 )                  INC, X| ZO| [SI] 
( 0020,12A9 )                  CMP, X| F| DI'| MEM| L0020,2730 L, 
( 0020,12AF )                  J, Z| N| L0020,12B6 RB, 
( 0020,12B1 )                  MOV|FA, X'| L0020,2730 L, 
( 0020,12B6 )   :L0020,12B6    CMP, X| T| AX'| MEM| L0020,2730 L, 
( 0020,12BC )                  J, Z| Y| L0020,12C8 RB, 
( 0020,12BE )                  J, S| N| L0020,12C6 RB, 
( 0020,12C0 )                  MOV, X| F| DI'| MEM| L0020,2738 L, 
( 0020,12C6 )   :L0020,12C6    LODS, X'| 
( 0020,12C7 )                  RET, 
( 0020,12C8 )   :L0020,12C8    MOV, X| F| DI'| MEM| L0020,2734 L, 
( 0020,12CE )                  SUBI, X| MEM| L0020,2810 L, 0016,0000 IL, 
( 0020,12D8 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,12DB )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,12DD )                  MOVI|X, AX| 00E0,4000 IL, 
( 0020,12E2 )                  CALL, X_color RL, 
( 0020,12E7 )                  MOVI|X, AX| 30 IL, 
( 0020,12EC )                  OS:, 
( 0020,12ED )                  MOV, X| T| CX'| MEM| L0020,2812 L, 
( 0020,12F3 )                  OS:, 
( 0020,12F4 )                  CMP, X| T| CX'| MEM| L0020,2818 L, 
( 0020,12FA )                  J, S| Y| L0020,130C RB, 
( 0020,12FC )                  CALL, X_emit RL, 
( 0020,1301 )                  SUBI, X| MEM| L0020,2810 L, 0016,0000 IL, 
( 0020,130B )                  RET, 
( 0020,130C )   :L0020,130C    JMP, X_emit RL, 
( 0020,1311 )   :L0020,1311    CALL, L0020,08E3 RL, 
( 0020,1316 )   :L0020,1316    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1319 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,131B )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,1322 )                  ANDSI, R| AX| 0F0 IS, 
( 0020,1325 )   :L0020,1325    CALL, X_unpac RL, 
( 0020,132A )                  J, Z| Y| L0020,1333 RB, 
( 0020,132C )                  CALL, X_emit RL, 
( 0020,1331 )                  JMPS, L0020,1325 RB, 
( 0020,1333 )   :L0020,1333    CALL, X_space RL, 
( 0020,1338 )                  LODS, X'| 
( 0020,1339 )                  LODS, X'| 
( 0020,133A )                  RET, 
( 0020,133B )   :L0020,133B    OS:, 
( 0020,133C )                  MOV, X| T| CX'| MEM| L0020,2812 L, 
( 0020,1342 )                  OS:, 
( 0020,1343 )                  CMP, X| T| CX'| MEM| L0020,2814 L, 
( 0020,1349 )                  J, Z| Y| L0020,1350 RB, 
( 0020,134B )                  CALL, X_cr RL, 
( 0020,1350 )   :L0020,1350    CALL, X_colorF00 RL, 
( 0020,1355 )                  JMPS, L0020,1316 RB, 
( 0020,1357 )   :L0020,1357    CALL, X_color80F0 RL, 
( 0020,135C )                  JMPS, L0020,1316 RB, 
( 0020,135E )   :L0020,135E    CALL, X_color0FF RL, 
( 0020,1363 )                  JMPS, L0020,1316 RB, 
( 0020,1365 )   :L0020,1365    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1368 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,136A )                  MOVI|X, AX| 00FF,FF00 IL, 
( 0020,136F )                  CALL, X_color RL, 
( 0020,1374 )                  JMPS, L0020,1316 RB, 
( 0020,1376 )   :L0020,1376    CALL, L0020,08E3 RL, 
( 0020,137B )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,137E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1380 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,1387 )                  ANDSI, R| AX| 0F0 IS, 
( 0020,138A )                  CALL, X_unpac RL, 
( 0020,138F )                  ADDI|A, B'| 30 IB, 
( 0020,1391 )                  CALL, X_emit RL, 
( 0020,1396 )                  JMPS, L0020,1325 RB, 
( 0020,1398 )   :L0020,1398    CALL, L0020,08E3 RL, 
( 0020,139D )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,13A0 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,13A2 )                  MOV, X| T| AX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,13A9 )                  ANDSI, R| AX| 0F0 IS, 
( 0020,13AC )   :L0020,13AC    CALL, X_unpac RL, 
( 0020,13B1 )                  J, Z| Y| L0020,1333 RB, 
( 0020,13B3 )                  ADDI|A, B'| 30 IB, 
( 0020,13B5 )                  CALL, X_emit RL, 
( 0020,13BA )                  JMPS, L0020,13AC RB, 
( 0020,13BC )   :L0020,13BC    SUBI, X| MEM| L0020,2810 L, 0016,0000 IL, 
( 0020,13C6 )                  TESTI, X| ZO|    [MEM +4* DI] -4 L, -10 IL, 
( 0020,13D1 )                  J|X, Z| N| L0020,1316 RL, 
( 0020,13D7 )                  DEC|X, DI| 
( 0020,13D8 )                  MOV, X| F| DI'| MEM| L0020,273C L, 
( 0020,13DE )                  CALL, X_space RL, 
( 0020,13E3 )                  CALL, L0020,12A2 RL, 
( 0020,13E8 )                  POP|X, DX| 
( 0020,13E9 )                  LODS, X'| 
( 0020,13EA )                  RET, 
( 0020,13EB )   :L0020,13EB    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,13F2 )                  SARI, X| R| DX| 5 IS, 
( 0020,13F5 )                  JMPS, L0020,1413 RB, 
( 0020,13F7 )   :L0020,13F7    MOVI, X| MEM| L0020,2724 L, X_. IL, 
( 0020,1401 )                  CALL, X_colorF0F RL, 
( 0020,1406 )                  CALL, L0020,1316 RL, 
( 0020,140B )   :L0020,140B    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,1412 )                  INC|X, DI| 
( 0020,1413 )   :L0020,1413    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1416 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1418 )                  MOVI|X, AX| F800 IL, 
( 0020,141D )                  CMPI, X| MEM| L0020,2724 L, X_. IL, 
( 0020,1427 )                  J, Z| Y| L0020,145F RB, 
( 0020,1429 )                  MOVI|X, AX| C000 IL, 
( 0020,142E )                  JMPS, L0020,145F RB, 
( 0020,1430 )   :L0020,1430    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,1437 )                  SARI, X| R| DX| 5 IS, 
( 0020,143A )                  JMPS, L0020,1444 RB, 
( 0020,143C )   :L0020,143C    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,1443 )                  INC|X, DI| 
( 0020,1444 )   :L0020,1444    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1447 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1449 )                  MOVI|X, AX| 00FF,FF00 IL, 
( 0020,144E )                  CMPI, X| MEM| L0020,2724 L, X_. IL, 
( 0020,1458 )                  J, Z| Y| L0020,145F RB, 
( 0020,145A )                  MOVI|X, AX| 00C0,C000 IL, 
( 0020,145F )   :L0020,145F    CALL, X_color RL, 
( 0020,1464 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1467 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1469 )                  MOV, X| T| AX'| R| DX| 
( 0020,146B )                  JMPO, MEM| L0020,2724 L, 
( 0020,1471 )   :L0020,1471    MOV, X| T| DX'| ZO|    [MEM +4* DI] -4 L, 
( 0020,1478 )                  SARI, X| R| DX| 5 IS, 
( 0020,147B )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,147E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1480 )                  MOVI|X, AX| 00FF,FFFF IL, 
( 0020,1485 )                  CMPI, X| MEM| L0020,2724 L, X_. IL, 
( 0020,148F )                  J, Z| Y| L0020,1496 RB, 
( 0020,1491 )                  MOVI|X, AX| 00C0,C0C0 IL, 
( 0020,1496 )   :L0020,1496    JMPS, L0020,145F RB, 
( 0020,1498 )   :L0020,1498   dl L0020,13BC L0020,1365 L0020,143C L0020,133B 
( 0020,14A8 )                 dl L0020,1357 L0020,140B L0020,13EB L0020,135E 
( 0020,14B8 )                 dl L0020,1430 L0020,1311 L0020,1376 L0020,1398 
( 0020,14C8 )                 dl L0020,13F7 X_nul X_nul L0020,1471 

( 0020,14D8 )   :X_+list    CALL, X_text RL, 
( 0020,14DD )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,14E0 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,14E2 )                  MOV|TA, X'| L0020,273C L, 
( 0020,14E7 )                  MOV|FA, X'| L0020,2734 L, 
( 0020,14EC )                  XOR, X| T| AX'| R| AX| 
( 0020,14EE )                  MOV, X| T| DI'| MEM| L0020,2728 L, 
( 0020,14F4 )                  ADD, X| T| DI'| MEM| L0020,2744 L, 
( 0020,14FA )   :X_+list1    SHLI, X| R| DI| 8 IS, 
( 0020,14FD )                  MOV, X| F| DI'| MEM| L0020,2738 L, 
( 0020,1503 )   :X_+list2    TESTI, X| ZO|    [MEM +4* DI] 0 L, 0F IL, 
( 0020,150E )                  J, Z| Y| X_+list3 RB, 
( 0020,1510 )                  CALL, L0020,12A2 RL, 
( 0020,1515 )   :X_+list3    MOV, X| T| DX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,151C )                  INC|X, DI| 
( 0020,151D )                  MOVI, X| MEM| L0020,2724 L, X_. IL, 
( 0020,1527 )                  TESTI, B| R| DL| 10 IB, 
( 0020,152A )                  J, Z| Y| X_+list4 RB, 
( 0020,152C )                  MOVI, X| MEM| L0020,2724 L, L0020,0C94 IL, 
( 0020,1536 )   :X_+list4    ANDSI, R| DX| 0F IS, 
( 0020,1539 )                  CALLO, ZO|    [MEM +4* DX] L0020,1498 L, 
( 0020,1540 )                  JMPS, X_+list2 RB, 
( 0020,1542 )   :X_lis    CALL, X_show RL, 
( 0020,1547 )                  CALL, L0020,0BC8 RL, 
( 0020,154C )                  CALL, X_+list RL, 
( 0020,1551 )                  JMP, X_keybo RL, 
( 0020,1556 )                 db 0 0 0 0FF 0FF 0 0 0 0 0 0 0 0FF 0 0 0C0 
( 0020,1566 )                 db 0 0 0 0 0 0 0 0 0 0 0FF 0FF 0 0 0 0 
( 0020,1576 )                 db 0 0 0FF 0FF 0FF 0 0FF 0FF 0FF 0 0FF 0FF 0FF 0 0FF 80 
( 0020,1586 )                 db 80 0 0C0 0C0 0C0 0 0FF 0 0 0 0 0 0 0 
( 0020,1594 )   :L0020,1594   db 0 0 
( 0020,1596 )                 db 0 0 
( 0020,1598 )   :L0020,1598   db 1 

( 0020,1599 )   :L0020,1599    DEC, X| MEM| L0020,2730 L, 
( 0020,159F )                  J, S| N| L0020,15A7 RB, 
( 0020,15A1 )   :L0020,15A1    INC, X| MEM| L0020,2730 L, 
( 0020,15A7 )   :L0020,15A7    RET, 
( 0020,15A8 )   :L0020,15A8    SUBSI, MEM| L0020,2730 L, 8 IS, 
( 0020,15AF )                  J, S| N| L0020,15BB RB, 
( 0020,15B1 )                  MOVI, X| MEM| L0020,2730 L, 0 IL, 
( 0020,15BB )   :L0020,15BB    RET, 
( 0020,15BC )   :L0020,15BC    ADDSI, MEM| L0020,2730 L, 8 IS, 
( 0020,15C3 )                  RET, 
( 0020,15C4 )   :L0020,15C4    ADDSI, MEM| L0020,2728 L, 2 IS, 
( 0020,15CB )                  RET, 
( 0020,15CC )   :L0020,15CC    CMPSI, MEM| L0020,2728 L, 14 IS, 
( 0020,15D3 )                  J, S| Y| L0020,15DC RB, 
( 0020,15D5 )                  SUBSI, MEM| L0020,2728 L, 2 IS, 
( 0020,15DC )   :L0020,15DC    RET, 
( 0020,15DD )   :L0020,15DD    MOV, X| T| CX'| MEM| L0020,2728 L, 
( 0020,15E3 )                  XCHG, X| CX'| MEM| L0020,272C L, 
( 0020,15E9 )                  MOV, X| F| CX'| MEM| L0020,2728 L, 
( 0020,15EF )                  RET, 
( 0020,15F0 )   :L0020,15F0    XORSI, MEM| L0020,2728 L, 1 IS, 
( 0020,15F7 )                  RET, 
( 0020,15F8 )   :L0020,15F8    MOV, X| T| CX'| MEM| L0020,273C L, 
( 0020,15FE )                  ADD, X| T| CX'| MEM| L0020,2784 L, 
( 0020,1604 )                  XOR, X| T| CX'| MEM| L0020,273C L, 
( 0020,160A )                  ANDI, X| R| CX| FFFF,FF00 IL, 
( 0020,1610 )                  J, Z| Y| L0020,161D RB, 
( 0020,1612 )                  MOV, X| T| CX'| MEM| L0020,2784 L, 
( 0020,1618 )   :L0020,1618    LODS, X'| 
( 0020,1619 )                  DEC|X, CX| 
( 0020,161A )                  J, Z| N| L0020,1618 RB, 
( 0020,161C )                  RET, 
( 0020,161D )   :L0020,161D    PUSH|X, SI| 
( 0020,161E )                  MOV, X| T| SI'| MEM| L0020,273C L, 
( 0020,1624 )                  MOV, X| T| CX'| R| SI| 
( 0020,1626 )                  DEC|X, SI| 
( 0020,1627 )                  MOV, X| T| DI'| R| SI| 
( 0020,1629 )                  ADD, X| T| DI'| MEM| L0020,2784 L, 
( 0020,162F )                  SHLI, X| R| DI| 2 IS, 
( 0020,1632 )                  SUB, X| T| CX'| MEM| L0020,2734 L, 
( 0020,1638 )                  J, S| Y| L0020,1641 RB, 
( 0020,163A )                  SHLI, X| R| SI| 2 IS, 
( 0020,163D )                  STD, 
( 0020,163E )                  REPZ, 
( 0020,163F )                  MOVS, X'| 
( 0020,1640 )                  CLD, 
( 0020,1641 )   :L0020,1641    POP|X, SI| 
( 0020,1642 )                  SHRI, X| R| DI| 2 IS, 
( 0020,1645 )                  INC|X, DI| 
( 0020,1646 )                  MOV, X| F| DI'| MEM| L0020,2730 L, 
( 0020,164C )                  MOV, X| T| CX'| MEM| L0020,2784 L, 
( 0020,1652 )   :L0020,1652    DEC|X, DI| 
( 0020,1653 )                  MOV, X| F| AX'| ZO|    [MEM +4* DI] 0 L, 
( 0020,165A )                  LODS, X'| 
( 0020,165B )                  DEC|X, CX| 
( 0020,165C )                  J, Z| N| L0020,1652 RB, 
( 0020,165E )                  RET, 
( 0020,165F )   :L0020,165F    CALL, L0020,15F8 RL, 
( 0020,1664 )                  MOV, B| T| CL'| MEM| L0020,1598 L, 
( 0020,166A )                  XOR, B| F| CL'| ZO|    [MEM +4* DI] 0 L, 
( 0020,1671 )                  CMPI, B| R| CL| 3 IB, 
( 0020,1674 )                  J, Z| N| L0020,1687 RB, 
( 0020,1676 )                  MOVI, B| MEM| L0020,1598 L, 4 IB, 
( 0020,167D )                  MOVI, X| MEM| L0020,2774 L, C000 IL, 
( 0020,1687 )   :L0020,1687    RET, 
( 0020,1688 )   :L0020,1688    POP, MEM| L0020,277C L, 
( 0020,168E )                  MOVI, X| MEM| L0020,277C L, L0020,06C1 IL, 
( 0020,1698 )                  RET, 
( 0020,1699 )   :X_word    MOVI, X| MEM| L0020,277C L, L0020,1688 IL, 
( 0020,16A3 )                  JMP, X_accept RL, 
( 0020,16A8 )   :L0020,16A8    LEA, SI'| BO| [SI] 0FC B, 
( 0020,16AB )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,16AD )                  MOVI|X, AX| 1 IL, 
( 0020,16B2 )                  CMPI, B| MEM| L0020,1598 L, 4 IB, 
( 0020,16B9 )                  J, Z| Y| L0020,16BD RB, 
( 0020,16BB )                  MOVI|B, AL| 3 IB, 
( 0020,16BD )   :L0020,16BD    CMPSI, MEM| L0020,276C L, 0A IS, 
( 0020,16C4 )                  J, Z| Y| L0020,16C8 RB, 
( 0020,16C6 )                  XORI|A, B'| 10 IB, 
( 0020,16C8 )   :L0020,16C8    XCHG, X| AX'| ZO| [SI] 
( 0020,16CA )                  MOVI, X| MEM| L0020,2784 L, 2 IL, 
( 0020,16D4 )                  JMPS, L0020,165F RB, 
( 0020,16D6 )   :L0020,16D6    TESTI, B| MEM| L0020,1598 L, 0A IB, 
( 0020,16DD )                  J, Z| N| L0020,171B RB, 
( 0020,16DF )                  MOV, X| T| DX'| R| AX| 
( 0020,16E1 )                  ANDI, X| R| DX| FC00,0000 IL, 
( 0020,16E7 )                  J, Z| Y| L0020,16F1 RB, 
( 0020,16E9 )                  CMPI, X| R| DX| FC00,0000 IL, 
( 0020,16EF )                  J, Z| N| L0020,16A8 RB, 
( 0020,16F1 )   :L0020,16F1    SHLI, X| R| AX| 5 IS, 
( 0020,16F4 )                  XORI|A, B'| 2 IB, 
( 0020,16F6 )                  CMPI, B| MEM| L0020,1598 L, 4 IB, 
( 0020,16FD )                  J, Z| Y| L0020,1701 RB, 
( 0020,16FF )                  XORI|A, B'| 0B IB, 
( 0020,1701 )   :L0020,1701    CMPSI, MEM| L0020,276C L, 0A IS, 
( 0020,1708 )                  J, Z| Y| L0020,170C RB, 
( 0020,170A )                  XORI|A, B'| 10 IB, 
( 0020,170C )   :L0020,170C    MOVI, X| MEM| L0020,2784 L, 1 IL, 
( 0020,1716 )                  JMP, L0020,165F RL, 
( 0020,171B )   :L0020,171B    CMPI, B| MEM| L0020,1598 L, 9 IB, 
( 0020,1722 )                  J, Z| N| L0020,1730 RB, 
( 0020,1724 )                  MOV, X| T| DX'| R| AX| 
( 0020,1726 )                  SHLI, X| R| DX| 5 IS, 
( 0020,1729 )                  SARI, X| R| DX| 5 IS, 
( 0020,172C )                  CMP, X| T| DX'| R| AX| 
( 0020,172E )                  J, Z| Y| L0020,1732 RB, 
( 0020,1730 )   :L0020,1730    LODS, X'| 
( 0020,1731 )                  RET, 
( 0020,1732 )   :L0020,1732    SHLI, X| R| AX| 5 IS, 
( 0020,1735 )                  XORI|A, B'| 6 IB, 
( 0020,1737 )                  JMPS, L0020,1701 RB, 
( 0020,1739 )   :L0020,1739    LEA, SI'| BO| [SI] 0FC B, 
( 0020,173C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,173E )                  MOV|TA, X'| L0020,2734 L, 
( 0020,1743 )                  SUB, X| T| AX'| MEM| L0020,2738 L, 
( 0020,1749 )                  J, Z| Y| L0020,1772 RB, 
( 0020,174B )                  MOV, X| T| CX'| R| AX| 
( 0020,174D )                  XCHG|AX, DX| 
( 0020,174E )                  PUSH|X, SI| 
( 0020,174F )                  MOV, X| T| SI'| MEM| L0020,2734 L, 
( 0020,1755 )                  LEA, SI'| ZO|    [MEM +4* SI] -4 L, 
( 0020,175C )                  MOV, X| T| DI'| MEM| L0020,2740 L, 
( 0020,1762 )   :L0020,1762    STD, 
( 0020,1763 )                  LODS, X'| 
( 0020,1764 )                  CLD, 
( 0020,1765 )                  STOS, X'| 
( 0020,1766 )                  DEC|X, CX| 
( 0020,1767 )                  J, Z| N| L0020,1762 RB, 
( 0020,1769 )                  XCHG|AX, DX| 
( 0020,176A )                  STOS, X'| 
( 0020,176B )                  MOV, X| F| DI'| MEM| L0020,2740 L, 
( 0020,1771 )                  POP|X, SI| 
( 0020,1772 )   :L0020,1772    LODS, X'| 
( 0020,1773 )                  RET, 
( 0020,1774 )   :L0020,1774    CALL, L0020,1739 RL, 
( 0020,1779 )                  MOV, X| T| DI'| MEM| L0020,2738 L, 
( 0020,177F )                  MOV, X| T| CX'| MEM| L0020,273C L, 
( 0020,1785 )                  SUB, X| T| CX'| R| DI| 
( 0020,1787 )                  SHLI, X| R| DI| 2 IS, 
( 0020,178A )                  PUSH|X, SI| 
( 0020,178B )                  MOV, X| T| SI'| MEM| L0020,2734 L, 
( 0020,1791 )                  SHLI, X| R| SI| 2 IS, 
( 0020,1794 )                  REPZ, 
( 0020,1795 )                  MOVS, X'| 
( 0020,1796 )                  POP|X, SI| 
( 0020,1797 )                  JMP, L0020,1599 RL, 
( 0020,179C )   :L0020,179C    CALL, L0020,1739 RL, 
( 0020,17A1 )                  JMP, L0020,1599 RL, 
( 0020,17A6 )   :L0020,17A6    MOVI|B, AL| 1 IB, 
( 0020,17A8 )                  JMPS, L0020,17C8 RB, 
( 0020,17AA )   :L0020,17AA    MOVI|B, AL| 3 IB, 
( 0020,17AC )                  JMPS, L0020,17C8 RB, 
( 0020,17AE )   :L0020,17AE    MOVI|B, AL| 4 IB, 
( 0020,17B0 )                  JMPS, L0020,17C8 RB, 
( 0020,17B2 )   :L0020,17B2    MOVI|B, AL| 9 IB, 
( 0020,17B4 )                  JMPS, L0020,17C8 RB, 
( 0020,17B6 )   :L0020,17B6    MOVI|B, AL| 0A IB, 
( 0020,17B8 )                  JMPS, L0020,17C8 RB, 
( 0020,17BA )   :L0020,17BA    MOVI|B, AL| 0B IB, 
( 0020,17BC )                  JMPS, L0020,17C8 RB, 
( 0020,17BE )   :L0020,17BE    MOVI|B, AL| 0D IB, 
( 0020,17C0 )                  JMPS, L0020,17C8 RB, 
( 0020,17C2 )   :L0020,17C2    MOVI|B, AL| 0E IB, 
( 0020,17C4 )                  JMPS, L0020,17C8 RB, 
( 0020,17C6 )   :L0020,17C6    MOVI|B, AL| 7 IB, 
( 0020,17C8 )   :L0020,17C8    MOV|FA, B'| L0020,1598 L, 
( 0020,17CD )                  MOVI, X| MEM| L0020,277C L, L0020,165F IL, 
( 0020,17D7 )                  MOV, X| T| AX'| ZO|    [MEM +4* AX] L0020,1554 L, 
( 0020,17DE )   :L0020,17DE    MOV|FA, X'| L0020,2774 L, 
( 0020,17E3 )                  POP|X, AX| 
( 0020,17E4 )                  LODS, X'| 
( 0020,17E5 )                  JMP, X_accept RL, 
( 0020,17EA )   :L0020,17EA    LEA, SI'| BO| [SI] 0FC B, 
( 0020,17ED )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,17EF )                  XOR, X| T| AX'| R| AX| 
( 0020,17F1 )                  INC, X| MEM| L0020,2784 L, 
( 0020,17F7 )                  JMP, L0020,165F RL, 
( 0020,17FC )   :L0020,17FC    MOVI, B| MEM| L0020,1598 L, 0C IB, 
( 0020,1803 )                  MOVI|X, AX| 00FF,00FF IL, 
( 0020,1808 )                  MOVI, X| MEM| L0020,277C L, L0020,17EA IL, 
( 0020,1812 )                  JMPS, L0020,17DE RB, 
( 0020,1814 )   :L0020,1814    POP|X, AX| 
( 0020,1815 )   :L0020,1815    LODS, X'| 
( 0020,1816 )                  MOVI, X| MEM| L0020,277C L, L0020,06C1 IL, 
( 0020,1820 )                  MOVI, X| MEM| L0020,2780 L, X_nul IL, 
( 0020,182A )                  MOVI, B| MEM| L0020,0FCD L, 0 IB, 
( 0020,1831 )                  MOVI, X| MEM| L0020,0FC1 L, L0020,11CF IL, 
( 0020,183B )                  MOVI, X| MEM| L0020,2774 L, 00FF,FF00 IL, 
( 0020,1845 )                  JMP, X_accept RL, 
( 0020,184A )   :L0020,184A    MOV, X| T| DX'| MEM| L0020,2740 L, 
( 0020,1850 )                  CMPI, X| R| DX| 0009,4C00 IL, 
( 0020,1856 )                  J, Z| N| L0020,1859 RB, 
( 0020,1858 )                  RET, 
( 0020,1859 )   :L0020,1859    SUBSI, R| DX| 8 IS, 
( 0020,185C )                  MOV, X| T| CX'| BO| [DX] 4 B, 
( 0020,185F )                  MOV, X| F| CX'| MEM| L0020,2784 L, 
( 0020,1865 )   :L0020,1865    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1868 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,186A )                  MOV, X| T| AX'| ZO| [DX] 
( 0020,186C )                  SUBSI, R| DX| 4 IS, 
( 0020,186F )                  DEC|X, CX| 
( 0020,1870 )                  J, Z| N| L0020,1865 RB, 
( 0020,1872 )                  ADDSI, R| DX| 4 IS, 
( 0020,1875 )                  MOV, X| F| DX'| MEM| L0020,2740 L, 
( 0020,187B )                  JMP, L0020,15F8 RL, 
( 0020,1880 )   :L0020,1880   dl X_nul L0020,1774 L0020,1814 L0020,184A 
( 0020,1890 )                 dl L0020,17A6 L0020,17AA L0020,17AE L0020,15F0 
( 0020,18A0 )                 dl L0020,1599 L0020,15A8 L0020,15BC L0020,15A1 
( 0020,18B0 )                 dl L0020,15CC L0020,17FC L0020,17C6 L0020,15C4 
( 0020,18C0 )                 dl X_nul L0020,17BA L0020,17B6 L0020,17B2 
( 0020,18D0 )                 dl X_nul X_nul X_nul L0020,15DD 
( 0020,18E0 )   :L0020,18E0   dl L0020,17BE L0020,17C2 X_nul L0020,179C 
( 0020,18F0 )   :L0020,18F0   dl 0007,2515 2D0D,010B 0110,160C 2B0A,0923 
( 0020,1900 )                 dl 023A,3800 220E,1000 2400,1305 
( 0020,190C )   :L0020,190C   dl X_no-ret 

( 0020,1910 )   :L0020,1910    LODS, X'| 
( 0020,1911 )                  JMPS, X_e2 RB, 
( 0020,1913 )   :X_edit    MOV, X| T| CX'| MEM| L0020,2728 L, 
( 0020,1919 )                  MOV, X| F| CX'| MEM| L0020,272C L, 
( 0020,191F )                  MOV|FA, X'| L0020,2728 L, 
( 0020,1924 )                  LODS, X'| 
( 0020,1925 )   :X_e    CALL, X_lis RL, 
( 0020,192A )   :X_+e    CALLO, MEM| L0020,190C L, 
( 0020,1930 )                  MOVI, X| MEM| L0020,2780 L, L0020,16D6 IL, 
( 0020,193A )                  MOVI, B| MEM| L0020,0FCD L, 25 IB, 
( 0020,1941 )                  MOVI, X| MEM| L0020,0FC1 L, L0020,1910 IL, 
( 0020,194B )   :X_e2    MOVI, X| MEM| L0020,2768 L, L0020,18E0 IL, 
( 0020,1955 )                  MOVI, X| MEM| L0020,2764 L, L0020,18F0 IL, 
( 0020,195F )                  MOVI, X| MEM| L0020,2774 L, 00FF,FF00 IL, 
( 0020,1969 )   :X_e3    CALL, L0020,0E9F RL, 
( 0020,196E )                  CALLO, ZO|    [MEM +4* AX] L0020,1880 L, 
( 0020,1975 )                  LODS, X'| 
( 0020,1976 )                  JMPS, X_e3 RB, 
( 0020,1978 )   :X_pad    POP|X, DX| 
( 0020,1979 )                  MOV, X| F| DX'| MEM| L0020,1594 L, 
( 0020,197F )                  ADDI, X| R| DX| 8C IL, 
( 0020,1985 )                  MOV, X| F| DX'| MEM| L0020,2764 L, 
( 0020,198B )                  SUBSI, R| DX| 10 IS, 
( 0020,198E )                  MOV, X| F| DX'| MEM| L0020,2768 L, 
( 0020,1994 )   :X_pad1    CALL, L0020,0E9F RL, 
( 0020,1999 )                  MOV, X| T| DX'| MEM| L0020,1594 L, 
( 0020,199F )                  ADD, X| T| DX'| R| AX| 
( 0020,19A1 )                  LEA, DX'| BO|    [DX +4* AX] 5 B, 
( 0020,19A5 )                  ADD, X| T| DX'| BO| [DX] 0FC B, 
( 0020,19A8 )                  LODS, X'| 
( 0020,19A9 )   :L0020,19A9    CALLO, R| DX| 
( 0020,19AB )                  JMPS, X_pad1 RB, 
( 0020,19AD )   :L0020,19AD   db 0 0 0 0 
( 0020,19B1 )   :L0020,19B1   db 0 0 0 0 0 0 0 0 17 0F 4 1 
( 0020,19BD )                 db 0 0 0 0 0 0 0 0 

( 0020,19C5 )   :L0020,19C5    XORI, X| MEM| L0020,2770 L, 0E1 IL, 
( 0020,19CF )                  XORI, B| MEM| L0020,0FF1 L, 2F IB, 
( 0020,19D6 )   :L0020,19D6    CALLO, MEM| L0020,2770 L, 
( 0020,19DC )                  MOVI, X| MEM| L0020,19AD L, 0 IL, 
( 0020,19E6 )                  CMPSI, MEM| L0020,276C L, 10 IS, 
( 0020,19ED )                  J, Z| N| L0020,19F9 RB, 
( 0020,19EF )                  MOVI, X| MEM| L0020,19AD L, 0015,0414 IL, 
( 0020,19F9 )   :L0020,19F9    MOVI, X| MEM| L0020,2764 L, L0020,19A9 IL, 
( 0020,1A03 )                  MOVI, X| MEM| L0020,2768 L, L0020,19AD IL, 
( 0020,1A0D )                  RET, 
( 0020,1A0E )   :L0020,1A0E    CALL, L0020,19C5 RL, 
( 0020,1A13 )                  JMPS, L0020,1A8E RB, 
( 0020,1A15 )                 dl L0020,1160 L0020,1160 L0020,11C7 L0020,1A8E 
( 0020,1A25 )                 dl L0020,1A0E 

( 0020,1A29 )   :L0020,1A29    CALL, L0020,0B8B RL, 
( 0020,1A2E )                  MOVI, X| MEM| L0020,19B1 L, 0009,1606 IL, 
( 0020,1A38 )                  CALL, L0020,19D6 RL, 
( 0020,1A3D )                  MOVI, B| MEM| L0020,1102 L, 0 IB, 
( 0020,1A44 )                  MOV|TA, X'| L0020,278C L, 
( 0020,1A49 )   :L0020,1A49    CALL, X_qkey RL, 
( 0020,1A4E )                  J, Z| Y| L0020,1A57 RB, 
( 0020,1A50 )                  JMPO, ZO|    [MEM +4* AX] L0020,1815 L, 
( 0020,1A57 )   :L0020,1A57    TEST, X| AX'| R| AX| 
( 0020,1A59 )                  J, LE| Y| L0020,1A8E RB, 
( 0020,1A5B )                  CMPI|A, B'| 23 IB, 
( 0020,1A5D )                  J, Z| Y| L0020,1A86 RB, 
( 0020,1A5F )                  MOV|TA, X'| L0020,278C L, 
( 0020,1A64 )                  CMP, X| T| AX'| MEM| L0020,276C L, 
( 0020,1A6A )                  J, S| N| 18 (RB,) 
( 0020,1A6C )                  TESTI, B| MEM| L0020,1102 L, 0FF IB, 
( 0020,1A73 )                  J, Z| Y| L0020,1A77 RB, 
( 0020,1A75 )                  NEG, X| R| AX| 
( 0020,1A77 )   :L0020,1A77    MOV, X| T| DX'| ZO| [SI] 
( 0020,1A79 )                  IMUL, DX'| MEM| L0020,276C L, 
( 0020,1A80 )                  ADD, X| T| DX'| R| AX| 
( 0020,1A82 )                  MOV, X| F| DX'| ZO| [SI] 
( 0020,1A84 )                  JMPS, L0020,1A8E RB, 
( 0020,1A86 )   :L0020,1A86    XOR, X| F| AX'| MEM| L0020,1102 L, 
( 0020,1A8C )                  NEG, X| ZO| [SI] 
( 0020,1A8E )   :L0020,1A8E    LODS, X'| 
( 0020,1A8F )                  JMPS, L0020,1A49 RB, 
( 0020,1A91 )                 dl L0020,101A L0020,101A L0020,1074 

( 0020,1A9D )   :L0020,1A9D    MOVI, X| MEM| L0020,19B1 L, 0215,0402 IL, 
( 0020,1AA7 )                  CALL, L0020,0B8B RL, 
( 0020,1AAC )                  MOVI, X| MEM| L0020,2784 L, 1 IL, 
( 0020,1AB6 )                  MOVI, X| MEM| L0020,2778 L, 1 IL, 
( 0020,1AC0 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1AC3 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1AC5 )                  MOVI, X| ZO| [SI] 0 IL, 
( 0020,1ACB )                  MOVI, B| MEM| L0020,100D L, 1C IB, 
( 0020,1AD2 )   :L0020,1AD2    J, Z| Y| L0020,1AE2 RB, 
( 0020,1AD4 )                  CMPI|A, X'| 83 IL, 
( 0020,1AD9 )                  J, S| N| L0020,1AE2 RB, 
( 0020,1ADB )                  JMPO, ZO|    [MEM +4* AX] L0020,1891 L, 
( 0020,1AE2 )   :L0020,1AE2    TEST, X| AX'| R| AX| 
( 0020,1AE4 )                  J, LE| Y| L0020,1B02 RB, 
( 0020,1AE6 )                  CMPI|A, X'| 30 IL, 
( 0020,1AEB )                  J, S| N| L0020,1B02 RB, 
( 0020,1AED )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1AF0 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1AF2 )                  CALL, L0020,0B72 RL, 
( 0020,1AF7 )                  CALL, L0020,1048 RL, 
( 0020,1AFC )                  INC, X| MEM| L0020,2778 L, 
( 0020,1B02 )   :L0020,1B02    LODS, X'| 
( 0020,1B03 )                  CALL, X_qkey RL, 
( 0020,1B08 )                  JMPS, L0020,1AD2 RB, 
( 0020,1B0A )                  CALL, L0020,19C5 RL, 
( 0020,1B0F )                  JMP, L0020,11CF RL, 
( 0020,1B14 )   :L0020,1B14    JMPO, MEM| L0020,0FC1 L, 
( 0020,1B1A )                  IRET, 
( 0020,1B1B )                  ADC, X| F| SP'| ZO| [AX] 
( 0020,1B1D )                  ADD, B| F| CL'| R| BH| 
( 0020,1B1F )                  ADC, X| F| SP'| ZO| [AX] 
( 0020,1B21 )                  ADD, B| F| CL'| R| BH| 
( 0020,1B23 )                  ADC, X| F| SP'| ZO| [AX] 
( 0020,1B25 )                  ADD, B| F| DL'| ZO|    [BX +1* BX] 
( 0020,1B28 )                  AND, B| F| AL'| ZO| [AX] 
( 0020,1B2A )                  OR, B| T| BL'| ZO| [BX] 
( 0020,1B2C )                  AND, B| F| AL'| ZO| [AX] 
( 0020,1B2E )   :L0020,1B2E    MOVI, X| MEM| L0020,19B1 L, 0 IL, 
( 0020,1B38 )                  MOVI, X| MEM| L0020,2768 L, L0020,19AD IL, 
( 0020,1B42 )                  MOVI, X| MEM| L0020,2764 L, L0020,19A9 IL, 
( 0020,1B4C )   :L0020,1B4C    CALL, X_qkey RL, 
( 0020,1B51 )                  J, Z| Y| L0020,1B5A RB, 
( 0020,1B53 )                  JMPO, ZO|    [MEM +4* AX] L0020,191A L, 
( 0020,1B5A )   :L0020,1B5A    CMPI|A, B'| 30 IB, 
( 0020,1B5C )                  J, Z| N| L0020,1B6B RB, 
( 0020,1B5E )                  MOVI, X| MEM| L0020,19B1 L, 0215,0402 IL, 
( 0020,1B68 )                  LODS, X'| 
( 0020,1B69 )                  JMPS, L0020,1B4C RB, 
( 0020,1B6B )   :L0020,1B6B    TEST, X| AX'| R| AX| 
( 0020,1B6D )                  J, LE| Y| L0020,1B9F RB, 
( 0020,1B6F )                  TESTI, X| MEM| L0020,19B1 L, -1 IL, 
( 0020,1B79 )                  J, Z| N| L0020,1B88 RB, 
( 0020,1B7B )                  CMPI, B| MEM| L0020,278C L, 0A IB, 
( 0020,1B82 )                  J|X, S| Y| L0020,1A29 RL, 
( 0020,1B88 )   :L0020,1B88    CMPI|A, X'| 30 IL, 
( 0020,1B8D )                  J, S| N| L0020,1B9F RB, 
( 0020,1B8F )                  CALL, L0020,1A9D RL, 
( 0020,1B94 )                  CALLO, MEM| L0020,277C L, 
( 0020,1B9A )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1B9D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1B9F )   :L0020,1B9F    LODS, X'| 
( 0020,1BA0 )                  JMP, X_accept RL, 
( 0020,1BA5 )   :X_qwert    MOVI, X| MEM| L0020,2750 L, L0020,1B2E IL, 
( 0020,1BAF )                  RET, 
( 0020,1BB0 )   :L0020,1BB0    SUBI, X| R| DI| 0008,1200 IL, 
( 0020,1BB6 )                  J, C| Y| L0020,1BE1 RB, 
( 0020,1BB8 )                  ADDI, X| R| DI| 1200 IL, 
( 0020,1BBE )                  MOV, X| T| AX'| R| DI| 
( 0020,1BC0 )                  ANDI|A, X'| 0FF IL, 
( 0020,1BC5 )                  SHRI, X| R| DI| 8 IS, 
( 0020,1BC8 )                  CMPI, X| R| DI| 05A0 IL, 
( 0020,1BCE )                  J, C| N| L0020,1BE1 RB, 
( 0020,1BD0 )                  MOV|FA, X'| L0020,2730 L, 
( 0020,1BD5 )                  MOV, X| F| DI'| MEM| L0020,2728 L, 
( 0020,1BDB )                  CALLO, MEM| L0020,2758 L, 
( 0020,1BE1 )   :L0020,1BE1    MOVI|X, SP| 000A,0000 IL, 
( 0020,1BE6 )                  CMPI, X| R| SI| 0009,F400 IL, 
( 0020,1BEC )                  J, C| Y| L0020,1BF3 RB, 
( 0020,1BEE )                  MOVI|X, SI| 0009,F400 IL, 
( 0020,1BF3 )   :L0020,1BF3    MOVI, X| MEM| L0020,27C8 L, L0020,05E0 IL, 
( 0020,1BFD )                  MOVI, X| MEM| L0020,27CC L, L0020,06FA IL, 
( 0020,1C07 )                  MOVI, X| MEM| L0020,27D0 L, L0020,069A IL, 
( 0020,1C11 )                  MOVI, X| MEM| L0020,27D4 L, L0020,06AA IL, 
( 0020,1C1B )                  MOVI|X, AX| 2F IL, 
( 0020,1C20 )                  CALL, L0020,0B72 RL, 
( 0020,1C25 )                  JMP, X_accept RL, 
( 0020,1C2A )   :X_no-ret    POP|X, CX| 
( 0020,1C2B )                  MOVI|X, SP| 000A,0000 IL, 
( 0020,1C30 )                  JMPO, R| CX| 
( 0020,1C32 )   :X_r?    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1C35 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1C37 )                  MOVI|X, AX| 000A,0000 IL, 
( 0020,1C3C )                  SUB, X| T| AX'| R| SP| 
( 0020,1C3E )                  SHR, 1| X| R| AX| 
( 0020,1C40 )                  SHR, 1| X| R| AX| 
( 0020,1C42 )                  RET, 
( 0020,1C43 )   :X_boot    MOVI|B, AL| 0FE IB, 
( 0020,1C45 )                  OUT|P, B'| 64 P, 
( 0020,1C47 )   :X_bootLoop    JMPS, X_bootLoop RB, 
( 0020,1C49 )   :X_erase    MOV, X| T| CX'| R| AX| 
( 0020,1C4B )                  SHLI, X| R| CX| 8 IS, 
( 0020,1C4E )                  LODS, X'| 
( 0020,1C4F )                  PUSH|X, DI| 
( 0020,1C50 )                  MOV, X| T| DI'| R| AX| 
( 0020,1C52 )                  SHLI, X| R| DI| 0A IS, 
( 0020,1C55 )                  XOR, X| T| AX'| R| AX| 
( 0020,1C57 )                  REPZ, 
( 0020,1C58 )                  STOS, X'| 
( 0020,1C59 )                  POP|X, DI| 
( 0020,1C5A )                  LODS, X'| 
( 0020,1C5B )                  RET, 
( 0020,1C5C )   :X_copy    CMPSI, R| AX| 0C IS, 
( 0020,1C5F )                  J|X, C| Y| X_abort RL, 
( 0020,1C65 )                  PUSH|X, DI| 
( 0020,1C66 )                  MOV, X| T| DI'| R| AX| 
( 0020,1C68 )                  SHLI, X| R| DI| 0A IS, 
( 0020,1C6B )                  PUSH|X, SI| 
( 0020,1C6C )                  MOV, X| T| SI'| MEM| L0020,2728 L, 
( 0020,1C72 )                  SHLI, X| R| SI| 0A IS, 
( 0020,1C75 )                  MOVI|X, CX| 0200 IL, 
( 0020,1C7A )                  REPZ, 
( 0020,1C7B )                  MOVS, X'| 
( 0020,1C7C )                  POP|X, SI| 
( 0020,1C7D )                  POP|X, DI| 
( 0020,1C7E )                  MOV|FA, X'| L0020,2728 L, 
( 0020,1C83 )                  LODS, X'| 
( 0020,1C84 )                  RET, 
( 0020,1C85 )   :X_debu    MOVI, X| MEM| L0020,2810 L, 0003,02B5 IL, 
( 0020,1C8F )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1C92 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1C94 )                  MOV|TA, X'| L0020,043E L, 
( 0020,1C99 )                  PUSH, ZO| [AX] 
( 0020,1C9B )                  CALL, L0020,0C94 RL, 
( 0020,1CA0 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1CA3 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1CA5 )                  POP|X, AX| 
( 0020,1CA6 )                  CALL, L0020,0C94 RL, 
( 0020,1CAB )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1CAE )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1CB0 )                  MOV|TA, X'| L0020,0447 L, 
( 0020,1CB5 )                  CALL, L0020,0C94 RL, 
( 0020,1CBA )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1CBD )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1CBF )                  MOV, X| T| AX'| R| SI| 
( 0020,1CC1 )                  JMP, L0020,0C94 RL, 
( 0020,1CC6 )   :L0020,1CC6    DEC, X| MEM| L0020,2784 L, 
( 0020,1CCC )                  J, Z| Y| L0020,1CD1 RB, 
( 0020,1CCE )                  LODS, X'| 
( 0020,1CCF )                  JMPS, L0020,1CC6 RB, 
( 0020,1CD1 )   :L0020,1CD1    RET, 
( 0020,1CD2 )   :X_tic    CALL, X_word RL, 
( 0020,1CD7 )                  CALL, L0020,1CC6 RL, 
( 0020,1CDC )                  CALL, L0020,054B RL, 
( 0020,1CE1 )                  J|X, Z| N| X_abort RL, 
( 0020,1CE7 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 0036,A800 L, 
( 0020,1CEE )                  RET, 
( 0020,1CEF )   :X_itick    ANDI|A, X'| -10 IL, 
( 0020,1CF4 )                  CALL, L0020,054B RL, 
( 0020,1CF9 )                  MOV, X| T| AX'| ZO|    [MEM +4* CX] 0036,A800 L, 
( 0020,1D00 )                  RET, 
( 0020,1D01 )   :X_winver    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1D04 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1D06 )                  MOVI|X, AX| 0 IL, 
( 0020,1D0B )                  OR, X| T| AX'| R| AX| 
( 0020,1D0D )                  RET, 
( 0020,1D0E )                 db 0 0 
( 0020,1D10 )   :L0020,1D10   db 1 0 
( 0020,1D12 )   :L0020,1D12   db 0 
( 0020,1D13 )   :L0020,1D13   db 0 
( 0020,1D14 )   :L0020,1D14   db 0 0 1 2 12 1B 0FF 0 

( 0020,1D1C )   :L0020,1D1C    OS:, 
( 0020,1D1D )                  MOVI|X, DX| 03F4 IW, 
( 0020,1D20 )   :L0020,1D20    IN|D, B'| 
( 0020,1D21 )                  OUT|P, B'| 0E1 P, 
( 0020,1D23 )                  SHL, 1| B| R| AL| 
( 0020,1D25 )                  J, C| N| L0020,1D20 RB, 
( 0020,1D27 )                  INC|X, DX| 
( 0020,1D28 )                  TEST, B| AL'| R| AL| 
( 0020,1D2A )                  RET, 
( 0020,1D2B )   :L0020,1D2B    LEA, DX'| MEM| L0020,1D12 L, 
( 0020,1D31 )                  MOV, B| F| AL'| ZO| [DX] 
( 0020,1D33 )   :L0020,1D33    PUSH|X, SI| 
( 0020,1D34 )                  MOV, X| T| SI'| R| DX| 
( 0020,1D36 )   :L0020,1D36    CALL, L0020,1D1C RL, 
( 0020,1D3B )                  J, S| N| L0020,1D42 RB, 
( 0020,1D3D )                  IN|D, B'| 
( 0020,1D3E )                  OUT|P, B'| 0E1 P, 
( 0020,1D40 )                  JMPS, L0020,1D36 RB, 
( 0020,1D42 )   :L0020,1D42    LODS, B'| 
( 0020,1D43 )                  MOVI|B, AH| 1E IB, 
( 0020,1D45 )                  OUT|D, B'| 
( 0020,1D46 )   :L0020,1D46    OUT|P, B'| 0E1 P, 
( 0020,1D48 )                  DEC, B| R| AH| 
( 0020,1D4A )                  J, Z| N| L0020,1D46 RB, 
( 0020,1D4C )                  LOOP, L0020,1D36 RB, 
( 0020,1D4E )                  POP|X, SI| 
( 0020,1D4F )                  RET, 
( 0020,1D50 )   :L0020,1D50    MOVI|B, AL| 8 IB, 
( 0020,1D52 )                  MOVI|B, CL| 1 IB, 
( 0020,1D54 )                  CALL, L0020,1D2B RL, 
( 0020,1D59 )                  CALL, L0020,1D1C RL, 
( 0020,1D5E )                  IN|D, B'| 
( 0020,1D5F )                  OUT|P, B'| 0E1 P, 
( 0020,1D61 )                  CMPI|A, B'| 80 IB, 
( 0020,1D63 )                  RET, 
( 0020,1D64 )   :L0020,1D64    OUT|P, B'| 0B P, 
( 0020,1D66 )   :L0020,1D66    CALL, L0020,1D50 RL, 
( 0020,1D6B )                  J, Z| N| L0020,1D66 RB, 
( 0020,1D6D )                  MOVI|B, AL| 0F IB, 
( 0020,1D6F )                  MOVI|B, CL| 3 IB, 
( 0020,1D71 )   :L0020,1D71    CALL, L0020,1D2B RL, 
( 0020,1D76 )   :L0020,1D76    CALL, L0020,1D50 RL, 
( 0020,1D7B )                  J, Z| Y| L0020,1D76 RB, 
( 0020,1D7D )                  RET, 
( 0020,1D7E )   :L0020,1D7E    MOVI, X| MEM| L0020,2740 L, 0009,4C00 IL, 
( 0020,1D88 )                  MOVI|B, AL| 0C IB, 
( 0020,1D8A )   :L0020,1D8A    OS:, 
( 0020,1D8B )                  MOVI|X, DX| 03F2 IW, 
( 0020,1D8E )                  MOVI|B, AH| 0F IB, 
( 0020,1D90 )                  OUT|D, B'| 
( 0020,1D91 )   :L0020,1D91    OUT|P, B'| 0E1 P, 
( 0020,1D93 )                  DEC, B| R| AH| 
( 0020,1D95 )                  J, Z| N| L0020,1D91 RB, 
( 0020,1D97 )                  RET, 
( 0020,1D98 )   :L0020,1D98    MOVI|B, AL| 1C IB, 
( 0020,1D9A )                  CALL, L0020,1D8A RL, 
( 0020,1D9F )                  MOVI|X, CX| 0478,68C0 IL, 
( 0020,1DA4 )   :L0020,1DA4    LOOP, L0020,1DA4 RB, 
( 0020,1DA6 )                  MOVI|B, AL| 7 IB, 
( 0020,1DA8 )                  MOVI|B, CL| 2 IB, 
( 0020,1DAA )                  JMPS, L0020,1D71 RB, 
( 0020,1DAC )   :L0020,1DAC    OUT|P, B'| 5 P, 
( 0020,1DAE )                  MOV, B| T| AL'| R| AH| 
( 0020,1DB0 )                  OUT|P, B'| 5 P, 
( 0020,1DB2 )                  MOVI|X, AX| 0009,4C00 IL, 
( 0020,1DB7 )                  OUT|P, B'| 4 P, 
( 0020,1DB9 )                  MOV, B| T| AL'| R| AH| 
( 0020,1DBB )                  OUT|P, B'| 4 P, 
( 0020,1DBD )                  SHRI, X| R| AX| 10 IS, 
( 0020,1DC0 )                  OUT|P, B'| 81 P, 
( 0020,1DC2 )                  MOVI|B, AL| 0B IB, 
( 0020,1DC4 )                  OUT|P, B'| 0F P, 
( 0020,1DC6 )                  OS:, 
( 0020,1DC7 )                  MOVI, X| MEM| L0020,1D13 L, 02A1 IW, 
( 0020,1DCF )                  MOVI|B, AL| 3 IB, 
( 0020,1DD1 )                  MOVI|B, CL| 3 IB, 
( 0020,1DD3 )                  CALL, L0020,1D2B RL, 
( 0020,1DD8 )                  OS:, 
( 0020,1DD9 )                  MOVI, X| MEM| L0020,1D13 L, 0 IW, 
( 0020,1DE1 )                  MOVI, B| MEM| L0020,1D10 L, 0 IB, 
( 0020,1DE8 )                  RET, 
( 0020,1DE9 )   :L0020,1DE9    MOVI|B, CL| 9 IB, 
( 0020,1DEB )                  CALL, L0020,1D2B RL, 
( 0020,1DF0 )                  INC, B| MEM| L0020,1D14 L, 
( 0020,1DF6 )   :L0020,1DF6    CALL, L0020,1D1C RL, 
( 0020,1DFB )                  J, S| N| L0020,1DF6 RB, 
( 0020,1DFD )                  RET, 
( 0020,1DFE )   :L0020,1DFE    MOVI|B, AL| 16 IB, 
( 0020,1E00 )                  CALL, L0020,1D64 RL, 
( 0020,1E05 )                  MOVI|B, AL| 0E6 IB, 
( 0020,1E07 )                  CALL, L0020,1DE9 RL, 
( 0020,1E0C )                  PUSH|X, SI| 
( 0020,1E0D )                  MOVI|X, SI| 0009,4C00 IL, 
( 0020,1E12 )                  MOVI|X, CX| 1200 IL, 
( 0020,1E17 )                  REPZ, 
( 0020,1E18 )                  MOVS, X'| 
( 0020,1E19 )                  POP|X, SI| 
( 0020,1E1A )                  RET, 
( 0020,1E1B )   :L0020,1E1B    MOVI|X, DI| 0009,4C00 IL, 
( 0020,1E20 )                  MOVI|X, CX| 1200 IL, 
( 0020,1E25 )                  REPZ, 
( 0020,1E26 )                  MOVS, X'| 
( 0020,1E27 )                  MOVI|B, AL| 1A IB, 
( 0020,1E29 )                  CALL, L0020,1D64 RL, 
( 0020,1E2E )                  MOVI|B, AL| 0C5 IB, 
( 0020,1E30 )                  JMPS, L0020,1DE9 RB, 
( 0020,1E32 )   :L0020,1E32    MOV|FA, B'| L0020,1D14 L, 
( 0020,1E37 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1E3A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1E3C )                  OS:, 
( 0020,1E3D )                  MOVI|X, DX| 03F2 IW, 
( 0020,1E40 )                  IN|D, B'| 
( 0020,1E41 )                  OUT|P, B'| 0E1 P, 
( 0020,1E43 )                  TESTI|A, B'| 10 IB, 
( 0020,1E45 )                  J, Z| N| L0020,1E4C RB, 
( 0020,1E47 )                  JMP, L0020,1D98 RL, 
( 0020,1E4C )   :L0020,1E4C    RET, 
( 0020,1E4D )   :L0020,1E4D    XOR, X| T| CX'| R| CX| 
( 0020,1E4F )                  TESTI, B| MEM| L0020,1D10 L, 0FF IB, 
( 0020,1E56 )                  J, Z| Y| L0020,1E68 RB, 
( 0020,1E58 )                  LEA, SI'| BO| [SI] 0FC B, 
( 0020,1E5B )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1E5D )                  MOVI|X, AX| 47FF IL, 
( 0020,1E62 )                  CALL, L0020,1DAC RL, 
( 0020,1E67 )                  LODS, X'| 
( 0020,1E68 )   :L0020,1E68    RET, 
( 0020,1E69 )   :X_read    CALL, L0020,1E4D RL, 
( 0020,1E6E )                  CALL, L0020,1E32 RL, 
( 0020,1E73 )                  PUSH|X, DI| 
( 0020,1E74 )                  MOV, X| T| DI'| BO| [SI] 4 B, 
( 0020,1E77 )                  SHLI, X| R| DI| 2 IS, 
( 0020,1E7A )                  CALL, L0020,1DFE RL, 
( 0020,1E7F )                  POP|X, DI| 
( 0020,1E80 )   :X_read1    LODS, X'| 
( 0020,1E81 )                  INC|X, AX| 
( 0020,1E82 )                  ADDI, X| ZO| [SI] 1200 IL, 
( 0020,1E88 )                  RET, 
( 0020,1E89 )   :X_write    CALL, L0020,1E4D RL, 
( 0020,1E8E )                  CALL, L0020,1E32 RL, 
( 0020,1E93 )                  PUSH|X, SI| 
( 0020,1E94 )                  MOV, X| T| SI'| BO| [SI] 4 B, 
( 0020,1E97 )                  SHLI, X| R| SI| 2 IS, 
( 0020,1E9A )                  CALL, L0020,1E1B RL, 
( 0020,1E9F )                  POP|X, SI| 
( 0020,1EA0 )                  JMPS, X_read1 RB, 
( 0020,1EA2 )   :X_stop    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1EA5 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1EA7 )                  CALL, L0020,1D7E RL, 
( 0020,1EAC )                  LODS, X'| 
( 0020,1EAD )                  RET, 
( 0020,1EAE )   :L0020,1EAE    MOVI|B, AL| 1A IB, 
( 0020,1EB0 )                  CALL, L0020,1D64 RL, 
( 0020,1EB5 )                  MOV, X| T| DX'| R| SI| 
( 0020,1EB7 )                  MOVI|B, CL| 6 IB, 
( 0020,1EB9 )                  CALL, L0020,1D33 RL, 
( 0020,1EBE )   :L0020,1EBE    CALL, L0020,1D1C RL, 
( 0020,1EC3 )                  J, S| N| L0020,1EBE RB, 
( 0020,1EC5 )                  RET, 
( 0020,1EC6 )   :X_format    PUSH|X, AX| 
( 0020,1EC7 )                  MOVI|X, AX| 47 IL, 
( 0020,1ECC )                  XOR, X| T| CX'| R| CX| 
( 0020,1ECE )                  CALL, L0020,1DAC RL, 
( 0020,1ED3 )                  POP|X, AX| 
( 0020,1ED4 )                  CALL, L0020,1E32 RL, 
( 0020,1ED9 )                  PUSH|X, SI| 
( 0020,1EDA )                  MOV, X| T| SI'| BO| [SI] 4 B, 
( 0020,1EDD )                  SHLI, X| R| SI| 2 IS, 
( 0020,1EE0 )                  CALL, L0020,1EAE RL, 
( 0020,1EE5 )                  POP|X, SI| 
( 0020,1EE6 )                  MOVI|X, AX| 47FF IL, 
( 0020,1EEB )                  CALL, L0020,1DAC RL, 
( 0020,1EF0 )                  LODS, X'| 
( 0020,1EF1 )                  RET, 
( 0020,1EF2 )   :X_warm    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1EF5 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1EF7 )   :Start    CALL, InitDisplay RL, 
( 0020,1EFC )                  CALL, L0020,04AA RL, 
( 0020,1F01 )                  CALL, L0020,04DB RL, 
( 0020,1F06 )                  CALL, X_stop RL, 
( 0020,1F0B )                  MOVI, B| MEM| L0020,1D10 L, 1 IB, 
\ 95 high-level Forth words embedded in kernel   
( 0020,1F12 )                  MOVI, X| MEM| ForthWords L, 5E IL, 
\ 6 high-level Forth macros   
( 0020,1F1C )                  MOVI, X| MEM| ForthMacros L, 6 IL, 
( 0020,1F26 )                  MOVI, X| MEM| L0020,2740 L, 0009,4C00 IL, 
( 0020,1F30 )                  PUSH|X, SI| 
\ point to Shannon-encoded high-level Forth words   
( 0020,1F31 )                  LEA, SI'| MEM| EncodedWords L, 
( 0020,1F37 )                  MOVI|X, DI| 0036,8000 IL, \ move to higher memory
( 0020,1F3C )                  MOV, X| T| CX'| MEM| ForthWords L, 
( 0020,1F42 )                  REPZ, 
( 0020,1F43 )                  MOVS, X'| 
\ point to list of code pointers for high-level Forth words   
( 0020,1F44 )                  LEA, SI'| MEM| CodePointers L, 
( 0020,1F4A )                  MOVI|X, DI| 0036,A800 IL, \ move to high memory
( 0020,1F4F )                  MOV, X| T| CX'| MEM| ForthWords L, 
( 0020,1F55 )                  REPZ, 
( 0020,1F56 )                  MOVS, X'| 
( 0020,1F57 )                  POP|X, SI| 
( 0020,1F58 )                  MOVI, X| MEM| L0020,27A0 L, 0036,D000 IL, 
( 0020,1F62 )                  MOVI, X| MEM| L0020,2758 L, X_nul IL, 
( 0020,1F6C )                  MOVI, X| MEM| L0020,2750 L, 0 IL, 
( 0020,1F76 )                  MOVI, X| MEM| L0020,2744 L, 0800 IL, 
( 0020,1F80 )                  MOVI|X, AX| 12 IL, 
\ load block 18, the startup block of high-level code   
( 0020,1F85 )                  CALL, X_load RL, 
( 0020,1F8A )                  JMP, X_accept RL, 
( 0020,1F8F )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,1F9F )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,1FAF )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 

( 0020,1FBC )   :X_nc/tsim    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1FBF )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1FC1 )                  MOVI|X, AX| 0008,09D2 IL, 
( 0020,1FC6 )                  RET, 
( 0020,1FC7 )   :X_xy    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1FCA )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1FCC )                  MOVI|X, AX| 0008,0A04 IL, 
( 0020,1FD1 )                  RET, 
( 0020,1FD2 )   :X_fov    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1FD5 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1FD7 )                  MOVI|X, AX| 0008,0A08 IL, 
( 0020,1FDC )                  RET, 
( 0020,1FDD )   :X_sp    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1FE0 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1FE2 )                  MOVI|X, AX| 0008,09EF IL, 
( 0020,1FE7 )                  RET, 
( 0020,1FE8 )   :X_last    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1FEB )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1FED )                  MOVI|X, AX| 0008,09E9 IL, 
( 0020,1FF2 )                  RET, 
( 0020,1FF3 )   :X_blk    LEA, SI'| BO| [SI] 0FC B, 
( 0020,1FF6 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,1FF8 )                  MOVI|X, AX| 0008,09CA IL, 
( 0020,1FFD )                  RET, 
( 0020,1FFE )   :X_curs    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2001 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2003 )                  MOVI|X, AX| 0008,09CC IL, 
( 0020,2008 )                  RET, 
( 0020,2009 )   :X_ekt    LEA, SI'| BO| [SI] 0FC B, 
( 0020,200C )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,200E )                  MOVI|X, AX| 0008,0620 IL, 
( 0020,2013 )                  RET, 
( 0020,2014 )   :X_cpoint    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2017 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2019 )                  MOVI|X, AX| 0008,09D6 IL, 
( 0020,201E )                  RET, 
( 0020,201F )   :X_words    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2022 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2024 )                  MOVI|X, AX| 0008,09E1 IL, 
( 0020,2029 )                  RET, 
( 0020,202A )   :X_digin    LEA, SI'| BO| [SI] 0FC B, 
( 0020,202D )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,202F )                  MOVI|X, AX| 0008,09E3 IL, 
( 0020,2034 )                  RET, 
( 0020,2035 )   :X_actc    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2038 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,203A )                  MOVI|X, AX| 0008,0556 IL, 
( 0020,203F )                  RET, 
( 0020,2040 )   :X_h    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2043 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2045 )                  MOVI|X, AX| 0008,09E8 IL, 
( 0020,204A )                  RET, 
( 0020,204B )   :X_offset    LEA, SI'| BO| [SI] 0FC B, 
( 0020,204E )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2050 )                  MOVI|X, AX| 0008,09D1 IL, 
( 0020,2055 )                  RET, 
( 0020,2056 )   :X_aper    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2059 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,205B )                  MOVI|X, AX| 0008,0A0A IL, 
( 0020,2060 )                  RET, 
( 0020,2061 )   :X_vesa    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2064 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2066 )                  MOVI|X, AX| 0008,0063 IL, 
( 0020,206B )                  RET, 
( 0020,206C )   :X_trash    LEA, SI'| BO| [SI] 0FC B, 
( 0020,206F )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2071 )                  MOVI|X, AX| 0008,09D0 IL, 
( 0020,2076 )                  RET, 
( 0020,2077 )   :X_buffe    LEA, SI'| BO| [SI] 0FC B, 
( 0020,207A )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,207C )                  MOVI|X, AX| 0002,5300 IL, 
( 0020,2081 )                  RET, 
( 0020,2082 )   :X_cad    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2085 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2087 )                  MOVI|X, AX| 0008,09CD IL, 
( 0020,208C )                  RET, 
( 0020,208D )   :X_pcad    LEA, SI'| BO| [SI] 0FC B, 
( 0020,2090 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,2092 )                  MOVI|X, AX| 0008,09CE IL, 
( 0020,2097 )                  RET, 
( 0020,2098 )   :X_hsvv    LEA, SI'| BO| [SI] 0FC B, 
( 0020,209B )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,209D )                  MOVI|X, AX| 0008,07E4 IL, 
( 0020,20A2 )                  RET, 
( 0020,20A3 )   :X_displ    LEA, SI'| BO| [SI] 0FC B, 
( 0020,20A6 )                  MOV, X| F| AX'| ZO| [SI] 
( 0020,20A8 )                  MOVI|X, AX| 0008,0526 IL, 
( 0020,20AD )                  RET, 
( 0020,20AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,20BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,20CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,20DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,20EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,20FE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,210E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,211E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,212E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,213E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,214E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,215E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,216E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,217E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,218E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,219E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,21AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,21BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,21CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,21DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,21EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,21FE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,220E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,221E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,222E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,223E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,224E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,225E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,226E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,227E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,228E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,229E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,22AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,22BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,22CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,22DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,22EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,22FE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,230E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,231E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,232E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,233E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,234E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,235E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,236E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,237E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,238E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,239E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,23AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,23BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,23CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,23DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,23EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,23FE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,240E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,241E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,242E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,243E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,244E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,245E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,246E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,247E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,248E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,249E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,24AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,24BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,24CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,24DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,24EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,24FE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,250E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,251E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,252E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,253E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,254E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,255E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,256E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,257E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,258E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,259E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,25AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,25BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,25CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,25DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,25EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,25FE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,260E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,261E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,262E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,263E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,264E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,265E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,266E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,267E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,268E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,269E )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,26AE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,26BE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,26CE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,26DE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,26EE )                 db 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
( 0020,26FE )                 db 0 0 

( 0020,2700 )   :L0020,2700 names re rc r! rom 
( 0020,2710 )               names rs2 rkte rort0 ri3v 
( 0020,2720 )               names owoacs 

( 0020,2724 )   :L0020,2724   dl X_. 
( 0020,2728 )   :L0020,2728   dl 12 
( 0020,272C )   :L0020,272C   dl 0288 
( 0020,2730 )   :L0020,2730   dl 0 
( 0020,2734 )   :L0020,2734   dl 0 
( 0020,2738 )   :L0020,2738   dl 0 
( 0020,273C )   :L0020,273C   dl 0 
( 0020,2740 )   :L0020,2740   dl 0009,4C00 
( 0020,2744 )   :L0020,2744   dl 0 50 
( 0020,274C )   :L0020,274C   dl X_accept 
( 0020,2750 )   :L0020,2750   dl 0 
( 0020,2754 )   :L0020,2754   dl L0020,1BB0 
( 0020,2758 )   :L0020,2758   dl 0 
( 0020,275C )   :L0020,275C   dl 033D 
( 0020,2760 )   :L0020,2760   dl 028B 
( 0020,2764 )   :L0020,2764   dl L0020,0E03 
( 0020,2768 )   :L0020,2768   dl L0020,0FBD 
( 0020,276C )   :L0020,276C   dl 0A 
( 0020,2770 )   :L0020,2770   dl L0020,116D 
( 0020,2774 )   :L0020,2774   dl 00FF,FF00 
( 0020,2778 )   :L0020,2778   dl 1 
( 0020,277C )   :L0020,277C   dl L0020,06C1 
( 0020,2780 )   :L0020,2780   dl X_nul 
( 0020,2784 )   :L0020,2784   dl 1 
( 0020,2788 )   :L0020,2788   dl 0 
( 0020,278C )   :L0020,278C   dl 0 
( 0020,2790 )   :L0020,2790   dl L0020,05AE 
( 0020,2794 )   :L0020,2794   dl 6 
( 0020,2798 )   :L0020,2798   dl 5E 
( 0020,279C )   :L0020,279C   dl 0010,0000 
( 0020,27A0 )   :L0020,27A0   dl 0010,0000 
( 0020,27A4 )   :L0020,27A4   dl 0 
( 0020,27A8 )   :L0020,27A8   dl 0 
( 0020,27AC )   :L0020,27AC   dl 0 
( 0020,27B0 )   :L0020,27B0   dl 0 
( 0020,27B4 )   :ForthWords   dl 5E 
( 0020,27B8 )   :ForthMacros   dl 6 
( 0020,27BC )   :L0020,27BC   dl L0020,0861 L0020,06CE 
( 0020,27C4 )                 dl L0020,0782 
( 0020,27C8 )   :L0020,27C8   dl L0020,05E0 
( 0020,27CC )   :L0020,27CC   dl L0020,06FA 
( 0020,27D0 )   :L0020,27D0   dl L0020,069A 
( 0020,27D4 )   :L0020,27D4   dl L0020,06AA L0020,074A L0020,0768 X_nul 
( 0020,27E4 )                 dl X_nul X_nul L0020,064B X_nul 
( 0020,27F4 )                 dl X_nul X_nul 
( 0020,27FC )   :L0020,27FC   dl L0020,043E 
( 0020,2800 )   :L0020,2800   dl X_nul 
( 0020,2804 )   :L0020,2804   dl X_nul 
( 0020,2808 )   :L0020,2808   dl X_graph 
( 0020,280C )   :L0020,280C   dl L0020,0988 
( 0020,2810 )   :L0020,2810   dl 0003,0003 
( 0020,2814 )   :L0020,2814   dl 3 
( 0020,2818 )   :L0020,2818   dl 03F4 
( 0020,281C )   :L0020,281C   dl 0 4B00 
( 0020,2824 )   :L0020,2824   dl 01F0,0000 
( 0020,2828 )   :L0020,2828   dl 01F0,0000 
( 0020,282C )   :L0020,282C   dl 0 
( 0020,2830 )   :L0020,2830   dl F7DE 
( 0020,2834 )   :L0020,2834   dl 0 
( 0020,2838 )   :L0020,2838   dl 0 

( 0020,283C )   :L0020,283C names ; dup ?dup drop 
( 0020,284C )               names then begin _ _ 
( 0020,285C )               names _ _ _ _ 
( 0020,286C )               names _ _ _ _ 
( 0020,287C )               names _ _ _ _ 
( 0020,288C )               names _ _ _ _ 
( 0020,289C )               names _ _ _ _ 
( 0020,28AC )               names _ _ _ _ 
( 0020,28BC )               names _ _ _ _ 
( 0020,28CC )               names _ _ _ _ 
( 0020,28DC )               names _ _ _ _ 
( 0020,28EC )               names _ _ _ _ 
( 0020,28FC )               names _ _ _ _ 
( 0020,290C )               names _ _ _ _ 
( 0020,291C )               names _ _ _ _ 
( 0020,292C )               names _ _ _ _ 
( 0020,293C )               names _ _ _ _ 
( 0020,294C )               names _ _ _ _ 
( 0020,295C )               names _ _ _ _ 
( 0020,296C )               names _ _ _ _ 
( 0020,297C )               names _ _ _ _ 
( 0020,298C )               names _ _ _ _ 
( 0020,299C )               names _ _ _ _ 
( 0020,29AC )               names _ _ _ _ 
( 0020,29BC )               names _ _ _ _ 
( 0020,29CC )               names _ _ _ _ 
( 0020,29DC )               names _ _ _ _ 
( 0020,29EC )               names _ _ _ _ 
( 0020,29FC )               names _ _ _ _ 
( 0020,2A0C )               names _ _ _ _ 
( 0020,2A1C )               names _ _ _ _ 
( 0020,2A2C )               names _ _ _ _ 
( 0020,2A3C )               names _ _ _ _ 
( 0020,2A4C )               names _ _ 

( 0020,2A54 )   :L0020,2A54   dl X_; X_dup X_?dup X_drop 
( 0020,2A64 )                 dl X_then X_begin 0 0 
( 0020,2A74 )                 dl 0 0 0 0 
( 0020,2A84 )                 dl 0 0 0 0 
( 0020,2A94 )                 dl 0 0 0 0 
( 0020,2AA4 )                 dl 0 0 0 0 
( 0020,2AB4 )                 dl 0 0 0 0 
( 0020,2AC4 )                 dl 0 0 0 0 
( 0020,2AD4 )                 dl 0 0 0 0 
( 0020,2AE4 )                 dl 0 0 0 0 
( 0020,2AF4 )                 dl 0 0 0 0 
( 0020,2B04 )                 dl 0 0 0 0 
( 0020,2B14 )                 dl 0 0 0 0 
( 0020,2B24 )                 dl 0 0 0 0 
( 0020,2B34 )                 dl 0 0 0 0 
( 0020,2B44 )                 dl 0 0 0 0 
( 0020,2B54 )                 dl 0 0 0 0 
( 0020,2B64 )                 dl 0 0 0 0 
( 0020,2B74 )                 dl 0 0 0 0 
( 0020,2B84 )                 dl 0 0 0 0 
( 0020,2B94 )                 dl 0 0 0 0 
( 0020,2BA4 )                 dl 0 0 0 0 
( 0020,2BB4 )                 dl 0 0 0 0 
( 0020,2BC4 )                 dl 0 0 0 0 
( 0020,2BD4 )                 dl 0 0 0 0 
( 0020,2BE4 )                 dl 0 0 0 0 
( 0020,2BF4 )                 dl 0 0 0 0 
( 0020,2C04 )                 dl 0 0 0 0 
( 0020,2C14 )                 dl 0 0 0 0 
( 0020,2C24 )                 dl 0 0 0 0 
( 0020,2C34 )                 dl 0 0 0 0 
( 0020,2C44 )                 dl 0 0 0 0 
( 0020,2C54 )                 dl 0 0 0 0 
( 0020,2C64 )                 dl 0 0 

( 0020,2C6C )   :EncodedWords names boot warm pause macro 
( 0020,2C7C )               names forth c stop read 
( 0020,2C8C )               names write nc format show 
( 0020,2C9C )               names serve load here ?lit 
( 0020,2CAC )               names 3, 2, 1, , 
( 0020,2CBC )               names less jump pci devic 
( 0020,2CCC )               names accept pad erase copy 
( 0020,2CDC )               names mark empt emit digit 
( 0020,2CEC )               names 2emit . h. h.n 
( 0020,2CFC )               names cr space down edit 
( 0020,2D0C )               names e lm rm graph 
( 0020,2D1C )               names switch freeze text top 
( 0020,2D2C )               names keybo debu at +at 
( 0020,2D3C )               names xy fov fifo box 
( 0020,2D4C )               names line color octant sp 
( 0020,2D5C )               names last unpac blk curs 
( 0020,2D6C )               names word ekt abort h 
( 0020,2D7C )               names buffe offset tic winver 
( 0020,2D8C )               names aper vesa trash hsvv 
( 0020,2D9C )               names tsim cpoint words qkey 
( 0020,2DAC )               names digin qwert no-ret r? 
( 0020,2DBC )               names nul cad pcad displ 
( 0020,2DCC )               names actc +list itick lis 
( 0020,2DDC )               names +e _ 

( 0020,2DE4 )   :CodePointers   dl X_boot X_warm X_pause X_macro 
( 0020,2DF4 )                 dl X_forth X_c X_stop X_read 
( 0020,2E04 )                 dl X_write X_nc/tsim X_format X_show 
( 0020,2E14 )                 dl X_serve X_load X_here X_?lit 
( 0020,2E24 )                 dl X_3, X_2, X_1, X_, 
( 0020,2E34 )                 dl X_less X_jump X_pci X_devic 
( 0020,2E44 )                 dl X_accept X_pad X_erase X_copy 
( 0020,2E54 )                 dl X_mark X_empt X_emit X_digit 
( 0020,2E64 )                 dl X_2emit X_. X_h. X_h.n 
( 0020,2E74 )                 dl X_cr X_space X_down X_edit 
( 0020,2E84 )                 dl X_e X_lm X_rm X_graph 
( 0020,2E94 )                 dl X_switch X_freeze X_text X_top 
( 0020,2EA4 )                 dl X_keybo X_debu X_at X_+at 
( 0020,2EB4 )                 dl X_xy X_fov X_fifo X_box 
( 0020,2EC4 )                 dl X_line X_color X_octant X_sp 
( 0020,2ED4 )                 dl X_last X_unpac X_blk X_curs 
( 0020,2EE4 )                 dl X_word X_ekt X_abort X_h 
( 0020,2EF4 )                 dl X_buffe X_offset X_tic X_winver 
( 0020,2F04 )                 dl X_aper X_vesa X_trash X_hsvv 
( 0020,2F14 )                 dl X_nc/tsim X_cpoint X_words X_qkey 
( 0020,2F24 )                 dl X_digin X_qwert X_no-ret X_r? 
( 0020,2F34 )                 dl X_nul X_cad X_pcad X_displ 
( 0020,2F44 )                 dl X_actc X_+list X_itick X_lis 
( 0020,2F54 )                 dl X_+e 0 0 0 
( 0020,2F64 )                 dl 0 0 0 0 
( 0020,2F74 )                 dl 0 0 0 0 
( 0020,2F84 )                 dl 0 0 0 0 
( 0020,2F94 )                 dl 0 0 0 0 
( 0020,2FA4 )                 dl 0 0 0 0 
( 0020,2FB4 )                 dl 0 0 0 0 
( 0020,2FC4 )                 dl 0 0 0 0 
( 0020,2FD4 )                 dl 0 0 0 0 
( 0020,2FE4 )                 dl 0 0 0 0 
( 0020,2FF4 )                 dl 0 0 0 

( 0020,3000 )   :IconImages icons 
0 0000000000000000 0 0000000000000000 0 0000001111000000 0 0000000000000000 
0 0000000000000000 1 0000000000000000 2 0000001111000000 3 0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   0000000000000000   0000001111000000   0000000000000000 
  0000000000000000   0000000000000000   0011111111111100   0000000000000000 
  0000000000000000   0000000000000000   0011111111111100   0000000000000000 
  0000000000000000   1110001111111000   0011111111111100   0001111111111000 
  0000000000000000   1111011111111110   0000001111000000   0111111111111110 
  0000000000000000   1111111111111111   0000001111000000   0111111111111110 
  0000000000000000   1111110000000111   0000001111000000   1111100000011111 
  0000000000000000   1111100000000001   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111000000001111 
  0000000000000000   1111000000000000   0000001111000000   1111100000011111 
  0000000000000000   1111000000000000   0000001111000000   0111111111111110 
  0000000000000000   1111000000000000   0000001111000000   0111111111111110 
  0000000000000000   1111000000000000   0000001111000000   0001111111111000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000001111000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0001111111111000   0001111111111000   1110001111111000   0000000000000000 
  0111111111111110   0111111111111110   1111011111111110   0000001111000000 
  0111111111111110   0111111111111110   1111111111111110   0000001111000000 
  1111000000001111   0000000000011111   1111110000011111   0000001111000000 
  1111000000001111   0000000000001111   1111100000001111   0000001111000000 
  1111000000011111   0000000000001111   1111000000001111   0000001111000000 
  1111111111111110   0011111111111111   1111000000001111   0000001111000000 
  1111111111111100   0111111111111111   1111000000001111   0000001111000000 
  1111000000000000   1111100000001111   1111000000001111   0000001111000000 
  1111000000000000   1111000000001111   1111000000001111   0000001111000000 
  1111100000000000   1111000000011111   1111000000001111   0000001111000000 
  0111111111111110   0111111111111111   1111000000001111   0000001111000000 
  0111111111111110   0111111111111111   1111000000001111   0000001111000000 
  0001111111111000   0001111111110111   1111000000001111   0000001111000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

0 0000000000000000 0 0000000000000000 0 0000000000000000 0 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0001111111111000   1101110000111100   0001111111111000   1110000000000111 
  0111111111111110   1111111001111110   0111111111111110   1111000000001111 
  0111111111111110   1111111111111111   0111111111111110   1111100000011111 
  1111100000000010   1111111111111111   1111100000001111   0111110000111110 
  1111000000000000   1111001111001111   1111000000000001   0011111001111100 
  1111000000000000   1110000110000111   1111000000000000   0001111111111000 
  0111111111111100   1110000000000111   1111000000000000   0000111111110000 
  0011111111111110   1110000000000111   1111000000000000   0000011111100000 
  0000000000001111   1110000000000111   1111000000000000   0000011111000000 
  0000000000001111   1110000000000111   1111000000000001   0000111110000000 
  0100000000011111   1110000000000111   1111100000001111   0001111100000000 
  0111111111111110   1110000000000111   0111111111111110   0011111000000000 
  0111111111111110   1110000000000111   0111111111111110   0111110000000000 
  0001111111111000   1110000000000111   0001111111111000   1111100000000000 
  0000000000000000   0000000000000000   0000000000000000   1111000000000000 
  0000000000000000   0000000000000000   0000000000000000   1110000000000000 
  0000000000000000   0000000000000000   0000000000000000   1100000000000000 
  0000000000000000   0000000000000000   0000000000000000   1000000000000000 

0 0000011100000000 0 0000000000000000 0 0000000111110000 0 0000000000000000 
C 0000011110000000 D 0000000000000000 E 0000001111111000 F 0000000000000000 
  0000011110000000   0000000000000000   0000011110001000   0000000000000000 
  0000011110000000   0000000000000000   0000011110000000   0000000000000000 
  0000011110000000   0000000000000000   0011111111100000   0000000000000000 
  0000011110000000   0000000000000000   0011111111110000   0000000000000000 
  0000011110000000   0001111111100111   0011111111110000   1100000000000011 
  0000011110000000   0111111111110111   0000011110000000   1110000000000111 
  0000011110000000   0111111111111111   0000011110000000   1110000000000111 
  0000011110000000   1111100000011111   0000011110000000   1110000000000111 
  0000011110000000   1111000000001111   0000011110000000   1111000110001111 
  0000011110000000   1111000000001111   0000011110000000   0111000110001110 
  0000011110000000   1111000000001111   0000011110000000   0111000110001110 
  0000011110000000   1111000000001111   0000011110000000   0111101111011110 
  0000011110000000   1111100000011111   0000011110000000   0011101111011100 
  0000011110000000   0111111111111111   0000011110000000   0011111111111100 
  0000011111000000   0111111111111111   0000011110000000   0001111001111000 
  0000011111000000   0001111111111111   0000011110000000   0001111001111000 
  0000001111100000   0000000000001111   0000011110000000   0000110000110000 
  0000000111100000   0000000000001111   0000011110000000   0000110000110000 
  0000000000000000   0110000000011111   0000000000000000   0000000000000000 
  0000000000000000   0111111111111110   0000000000000000   0000000000000000 
  0000000000000000   0111111111111110   0000000000000000   0000000000000000 
  0000000000000000   0001111111111000   0000000000000000   0000000000000000 

1 0000000000001111 1 0000000000000000 1 0000000000000000 1 1111000000000000 
0 0000000000001111 1 0000000000000000 2 0000000000000000 3 1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0000000000001111   0000000000000000   0000000000000000   1111000000000000 
  0001111111101111   1110000000000111   1110001111111000   1111011111111000 
  0111111111111111   1110000000000111   1111011111111110   1111111111111110 
  0111111111111111   1111000000001111   1111111111111110   1111111111111110 
  1111100000011111   0111000000001110   1111111000011111   1111100000011111 
  1111000000001111   0111100000011110   1111110000001111   1111000000001111 
  1111000000001111   0011100000011100   1111100000001111   1111000000001111 
  1111000000001111   0011110000111100   1111000000001111   1111000000001111 
  1111000000001111   0001110000111000   1111000000001111   1111000000001111 
  1111000000001111   0001111001111000   1111100000011111   1111000000001111 
  1111000000001111   0000111001110000   1111111111111110   1111000000001111 
  1111100000011111   0000111111110000   1111111111111110   1111100000011111 
  0111111111111111   0000011111100000   1111011111111000   1111111111111110 
  0111111111111111   0000001111000000   1111000000000000   1110111111111110 
  0001111111101111   0000000110000000   1111000000000000   1110011111111000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 
  0000000000000000   0000000000000000   1111000000000000   0000000000000000 

1 1111000000000000 1 0000000000000000 1 0000000000000000 1 0000000000000000 
4 1111000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111000000000000   0000000000000000   0000000000000000   0000000000000000 
  1111001111111000   1111000000001111   1111000000001111   0001111111000111 
  1111011111111110   1111100000011111   1111000000001111   0111111111101111 
  1111111111111110   0111110000111110   1111000000001111   0111111111111111 
  1111110000011111   0011111001111100   1111000000001111   1111100000111111 
  1111100000001111   0001111111111000   1111000000001111   1111000000011111 
  1111000000001111   0000111111110000   1111000000001111   1111000000001111 
  1111000000001111   0000011111100000   1111000000001111   1111000000001111 
  1111000000001111   0000011111100000   1111000000001111   1111000000001111 
  1111000000001111   0000111111110000   1111000000001111   1111100000011111 
  1111000000001111   0001111111111000   1111000000001111   0111111111111111 
  1111000000001111   0011111001111100   1111100000011111   0111111111111111 
  1111000000001111   0111110000111110   0111111111111110   0001111111101111 
  1111000000001111   1111100000011111   0111111111111110   0000000000001111 
  1111000000001111   1111000000001111   0001111111111000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001111 
  0000000000000000   0000000000000000   0000000000000000   0000000000001110 

1 0001111111111000 1 0000000111100000 1 0001111111111000 1 0001111111111000 
8 0111111111111110 9 0000001111100000 A 0111111111111110 B 0111111111111110 
  0111111111111110   0000001111100000   0111111111111110   0111111111111110 
  1111100000011111   0000011111100000   1111000000011111   1111000000011111 
  1111000000001111   0000011111100000   0000000000001111   0000000000001111 
  1111000000001111   0000010111100000   0000000000001111   0000000000001111 
  1111000000001111   0000000111100000   0000000000001111   0000000000001111 
  1111000000001111   0000000111100000   0000000000001111   0000000000001111 
  1111000000001111   0000000111100000   0000000000011111   0000000000011111 
  1111000000001111   0000000111100000   0001111111111110   0000011111111110 
  1111000000001111   0000000111100000   0111111111111110   0000011111111100 
  1111000000001111   0000000111100000   0111111111111000   0000011111111110 
  1111000000001111   0000000111100000   1111100000000000   0000000000011111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111000000001111   0000000111100000   1111000000000000   0000000000001111 
  1111100000011111   0000000111100000   1111000000000000   1111000000011111 
  0111111111111110   0000000111100000   1111111111111111   0111111111111110 
  0111111111111110   0000000111100000   1111111111111111   0111111111111110 
  0001111111111000   0000000111100000   1111111111111111   0001111111111000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

1 1111000011110000 1 1111111111111111 1 0001111111111000 1 1111111111111111 
C 1111000011110000 D 1111111111111111 E 0111111111111110 F 1111111111111111 
  1111000011110000   1111111111111111   0111111111111110   1111111111111111 
  1111000011110000   1111000000000000   1111100000001111   0000000000000111 
  1111000011110000   1111000000000000   1111000000000000   0000000000001111 
  1111000011110000   1111000000000000   1111000000000000   0000000000011111 
  1111000011110000   1111000000000000   1111000000000000   0000000000111110 
  1111000011110000   1111000000000000   1111000000000000   0000000001111100 
  1111000011110000   1111000000000000   1111100000000000   0000000011111000 
  1111111111111111   1111111111111000   1111111111111000   0000000111110000 
  1111111111111111   1111111111111110   1111111111111110   0000001111100000 
  1111111111111111   1111111111111110   1111111111111110   0000011111000000 
  0000000011110000   0000000000011111   1111100000011111   0000111110000000 
  0000000011110000   0000000000001111   1111000000001111   0001111100000000 
  0000000011110000   0000000000001111   1111000000001111   0011111000000000 
  0000000011110000   0000000000001111   1111000000001111   0111110000000000 
  0000000011110000   1111000000011111   1111100000011111   1111100000000000 
  0000000011110000   0111111111111110   0111111111111110   1111000000000000 
  0000000011110000   0111111111111110   0111111111111110   1110000000000000 
  0000000011110000   0001111111111000   0001111111111000   1100000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

2 0001111111111000 2 0001111111111000 2 0000000001111000 2 0000000000000000 
0 0111111111111110 1 0111111111111110 2 0000000001111000 3 0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  1111100000011111   1111100000011111   0000000001111000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000000000000   0000000000000000 
  1111000000001111   1111000000001111   0000000001111000   0000000000000000 
  1111100000011111   1111100000011111   0000000001111000   0000000000000000 
  0111111111111110   0111111111111111   0000000001111000   0000000000000000 
  0011111111111100   0111111111111111   0000000001111000   0000000000000000 
  0111111111111110   0001111111101111   0000000001111000   0111111111111111 
  1111100000011111   0000000000001111   0000000001111000   0111111111111111 
  1111000000001111   0000000000001111   0000000001111000   1111111111111110 
  1111000000001111   0000000000001111   0000000001111000   1111111111111110 
  1111000000001111   0000000000001111   0000000001111000   0000000000000000 
  1111100000011111   1111000000011111   0000000001111000   0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  0111111111111110   0111111111111110   0000000001111000   0000000000000000 
  0001111111111000   0001111111111000   0000000001111000   0000000000000000 
  0000000000000000   0000000000000000   0001110011111000   0000000000000000 
  0000000000000000   0000000000000000   0001111111110000   0000000000000000 
  0000000000000000   0000000000000000   0000111111110000   0000000000000000 
  0000000000000000   0000000000000000   0000011111000000   0000000000000000 

2 1111000000000000 2 0000000000000000 2 0000000000000000 2 0000000000001111 
4 1111000000000000 5 0000000000000000 6 0000000000000000 7 0000000000011111 
  1111000000000000   0000000000000000   0000000000000000   0000000000011111 
  1111000000000000   0000000000000000   0000000000000000   0000000000111110 
  1111000000000000   0000000000000000   0000000000000000   0000000001111100 
  1111000000000000   0000000000000000   0000000000000000   0000000001111100 
  1111000000111100   0000000000000000   1111111111111111   0000000011111000 
  1111000011111100   0000000000000000   1111111111111111   0000000111110000 
  1111001111111100   0000000000000000   1111111111111111   0000000111110000 
  1111111111100000   0000000000000000   0000000000011111   0000001111100000 
  1111111110000000   0000000000000000   0000000000111111   0000011111000000 
  1111111100000000   0000000000000000   0000000011111110   0000011111000000 
  1111111100000000   0000000000000000   0000001111111000   0000111110000000 
  1111111111000000   0000000000000000   0000111111100000   0001111100000000 
  1111111111110000   0000011000000000   0011111110000000   0001111100000000 
  1111001111111100   0000111100000000   1111111000000000   0011111000000000 
  1111000011111111   0001111110000000   1111100000000000   0111110000000000 
  1111000000111111   0001111110000000   1111111111111111   0111110000000000 
  1111000000001111   0000111100000000   1111111111111111   1111100000000000 
  1111000000000011   0000011000000000   1111111111111111   1111100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

2 0000000000000000 2 0000000011110000 2 0000000110000000 2 0000000000000000 
8 0000000000000000 9 0000000011110000 A 0000001111000000 B 0000000000000000 
  0000000000000000   0000000111100000   0000001111000000   0000000000000000 
  0000011100000000   0000000111100000   0000011111100000   0000000000000000 
  0000111110000000   0000000111000000   0000011111100000   0000000000000000 
  0001111111000000   0000000111000000   0000011111100000   0000000000000000 
  0001111111000000   0000001110000000   0000011111100000   0000001111000000 
  0001111111000000   0000001110000000   0000011111100000   0000001111000000 
  0000111110000000   0000001100000000   0000001111000000   0000001111000000 
  0000011100000000   0000001100000000   0000001111000000   0000001111000000 
  0000000000000000   0000001000000000   0000000110000000   0000001111000000 
  0000000000000000   0000001000000000   0000000110000000   0111111111111110 
  0000000000000000   0000000000000000   0000000110000000   0111111111111110 
  0000011100000000   0000000000000000   0000000000000000   0111111111111110 
  0000111110000000   0000000000000000   0000000000000000   0111111111111110 
  0001111111000000   0000000000000000   0000000000000000   0000001111000000 
  0001111111000000   0000000000000000   0000001111000000   0000001111000000 
  0001111111000000   0000000000000000   0000001111000000   0000001111000000 
  0000111110000000   0000000000000000   0000001111000000   0000001111000000 
  0000011110000000   0000000000000000   0000001111000000   0000001111000000 
  0000001110000000   0000000000000000   0000000000000000   0000000000000000 
  0000011100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111000000000   0000000000000000   0000000000000000   0000000000000000 
  0001110000000000   0000000000000000   0000000000000000   0000000000000000 

2 0001111111111000 2 0000000000000000 2 0000000000000000 2 0001111111111000 
C 0111111111111110 D 0000000000000000 E 0000000000000000 F 0111111111111110 
  0111111111111110   0000000000000000   0000000000000000   0111111111111110 
  1111000000001111   0000000000000000   0000000000000000   1111000000001111 
  1110000000000111   0000000000000000   0000000000000000   0000000000000111 
  1110000000000111   0000000000000000   0000000000000000   0000000000000111 
  1110000111000111   0000000000000000   0000000000000000   0000000000001111 
  1110001111100111   0000100000110000   0000000000000000   0000000001111110 
  1110001111100111   0001110001111000   0000000000000000   0000000111111110 
  1110001111100111   0001111011110000   0000000000000000   0000000111111000 
  1110001111111111   0000111111100000   0000000000000000   0000001111100000 
  1110001111111110   0000011111000000   0000000000000000   0000001111000000 
  1110001111111110   0000001111100000   0000000000000000   0000001111000000 
  1110000111111000   0000011111110000   0000011100000000   0000000000000000 
  1110000000000000   0000111101111000   0000111110000000   0000000000000000 
  1110000000000000   0001111000111000   0001111111000000   0000000000000000 
  1111000000001111   0000110000010000   0001111111000000   0000001111000000 
  0111111111111110   0000000000000000   0001111111000000   0000001111000000 
  0111111111111110   0000000000000000   0000111111000000   0000001111000000 
  0001111111111000   0000000000000000   0000011111000000   0000001111000000 
  0000000000000000   0000000000000000   0000001110000000   0000000000000000 
  0000000000000000   0000000000000000   0000011100000000   0000000000000000 
  0000000000000000   0000000000000000   0000111000000000   0000000000000000 
  0000000000000000   0000000000000000   0001110000000000   0000000000000000 

3 1111111111110000 3 0000000000000000 3 0000000000000000 3 0000000000000000 
0 1111111111111100 1 0000000000000000 2 0001100000000000 3 0000000000000000 
  1111111111111110   0000000000000000   0001100000000000   0000000000000000 
  0111111111111110   0110111000000000   0111111000000000   0011111000000000 
  0011111111111111   0111111100000000   0111111000000000   0111111100000000 
  0001111111111111   0111000100000000   0001100000000000   0110001100000000 
  0000111111111111   0110000000000000   0001100000000000   0110001100000000 
  0000011111111111   0110000000000000   0001100000000000   0110001100000000 
  0000001111111111   0110000000000000   0001100000000000   0110001100000000 
  0000000111111111   0110000000000000   0001100000000000   0111111100000000 
  0000000011111111   0110000000000000   0001110000000000   0011111000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000011111111   0000000000000000   0000000000000000   0000000000000000 
  0000000111111111   0000000000000000   0000000000000000   0000000000000000 
  0000001111111111   0000000000000000   0000000000000000   0000000000000000 
  0000011111111111   0000000000000000   0000000000000000   0000000000000000 
  0000111111111111   0000000000000000   0000000000000000   0000000000000000 
  0001111111111111   0000000000000000   0000000000000000   0000000000000000 
  0011111111111111   0000000000000000   0000000000000000   0000000000000000 
  0111111111111110   0000000000000000   0000000000000000   0000000000000000 
  1111111111111110   0000000000000000   0000000000000000   0000000000000000 
  1111111111111100   0000000000000000   0000000000000000   0000000000000000 
  1111111111110000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000000000000000 3 0001100000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0001100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0011111000000000   0001111000000000   0110111000000000   0000000000000000 
  0111111100000000   0011111100000000   0111111100000000   0011100000000000 
  0110001100000000   0000001100000000   0111001100000000   0001100000000000 
  0111111100000000   0011111100000000   0110001100000000   0001100000000000 
  0111111000000000   0111111100000000   0110001100000000   0001100000000000 
  0110000000000000   0110001100000000   0110001100000000   0001100000000000 
  0111111100000000   0111111100000000   0110001100000000   0001100000000000 
  0011111000000000   0011101110000000   0110001100000000   0001110000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000000000000000 3 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0011111000000000   0110001100000000   0011111000000000   0110001100000000 
  0111111100000000   0111011100000000   0111111100000000   0110001100000000 
  0110000000000000   0111111100000000   0110000100000000   0110001100000000 
  0111111000000000   0110101100000000   0110000000000000   0110001100000000 
  0011111100000000   0110001100000000   0110000000000000   0111111100000000 
  0000001100000000   0110001100000000   0110000100000000   0011111100000000 
  0111111100000000   0110001100000000   0111111100000000   0000001100000000 
  0011111000000000   0110001100000000   0011111000000000   0100001100000000 
  0000000000000000   0000000000000000   0000000000000000   0111111100000000 
  0000000000000000   0000000000000000   0000000000000000   0011111000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

3 0000000000000000 3 0000000000000000 3 0000111000000000 3 0000000000000000 
C 0011100000000000 D 0000000000000000 E 0001101000000000 F 0000000000000000 
  0001100000000000   0000000000000000   0001100000000000   0000000000000000 
  0001100000000000   0011101100000000   0111111000000000   1110001110000000 
  0001100000000000   0111111100000000   0111111000000000   0110001100000000 
  0001100000000000   0110001100000000   0001100000000000   0110001100000000 
  0001100000000000   0110001100000000   0001100000000000   0110101100000000 
  0001100000000000   0111111100000000   0001100000000000   0111111100000000 
  0001100000000000   0011111100000000   0001100000000000   0111111100000000 
  0001100000000000   0000001100000000   0001100000000000   0111011100000000 
  0001110000000000   0100001100000000   0001100000000000   0110001100000000 
  0000000000000000   0111111100000000   0000000000000000   0000000000000000 
  0000000000000000   0011111000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0000001100000000 4 0000000000000000 4 0000000000000000 4 0110000000000000 
0 0000001100000000 1 0000000000000000 2 0000000000000000 3 0110000000000000 
  0000001100000000   0000000000000000   0000000000000000   0110000000000000 
  0011101100000000   0110001100000000   0110111000000000   0110111000000000 
  0111111100000000   0110001100000000   0111111100000000   0111111100000000 
  0110001100000000   0110001100000000   0110001100000000   0110001100000000 
  0110001100000000   0110001100000000   0110001100000000   0110001100000000 
  0110001100000000   0111011100000000   0110001100000000   0110001100000000 
  0110001100000000   0011111000000000   0110001100000000   0110001100000000 
  0111111100000000   0001110000000000   0111111100000000   0111111100000000 
  0011101100000000   0000100000000000   0110111000000000   0110111000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0110000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0110000000000000 4 0000000000000000 4 0000000000000000 4 0000000000000000 
4 0110000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0110000000000000   0000000000000000   0000000000000000   0000000000000000 
  0110111000000000   0110001100000000   0110001100000000   0011101100000000 
  0111111100000000   0111011100000000   0110001100000000   0111111100000000 
  0111001100000000   0011011000000000   0110001100000000   0110001100000000 
  0110001100000000   0001110000000000   0110001100000000   0110001100000000 
  0110001100000000   0001110000000000   0110001100000000   0110001100000000 
  0110001100000000   0011011000000000   0110001100000000   0110001100000000 
  0110001100000000   0111011100000000   0111111100000000   0111111100000000 
  0110001100000000   0110001100000000   0011111000000000   0011101100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000001100000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0011111000000000 4 0000110000000000 4 0011111000000000 4 0011111000000000 
8 0111111100000000 9 0001110000000000 A 0111111100000000 B 0111111100000000 
  0110001100000000   0011110000000000   0110001100000000   0110001100000000 
  0110001100000000   0000110000000000   0000001100000000   0000001100000000 
  0110001100000000   0000110000000000   0000011100000000   0000111100000000 
  0110001100000000   0000110000000000   0000111000000000   0000111100000000 
  0110001100000000   0000110000000000   0001110000000000   0000001100000000 
  0110001100000000   0000110000000000   0011100000000000   0110001100000000 
  0110001100000000   0000110000000000   0111000000000000   0110001100000000 
  0111111100000000   0011111100000000   0111111100000000   0111111100000000 
  0011111000000000   0011111100000000   0111111100000000   0011111000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

4 0000011000000000 4 0111111100000000 4 0011111000000000 4 0111111100000000 
C 0110011000000000 D 0111111100000000 E 0111111100000000 F 0111111100000000 
  0110011000000000   0110000000000000   0110001100000000   0000001100000000 
  0110011000000000   0110000000000000   0110000000000000   0000001100000000 
  0110011000000000   0111111000000000   0111111000000000   0000011100000000 
  0111111100000000   0111111100000000   0111111100000000   0000111000000000 
  0111111100000000   0000001100000000   0110001100000000   0001110000000000 
  0000011000000000   0000001100000000   0110001100000000   0001100000000000 
  0000011000000000   0110001100000000   0110001100000000   0001100000000000 
  0000011000000000   0111111100000000   0111111100000000   0001100000000000 
  0000011000000000   0011111000000000   0011111000000000   0001100000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0011111000000000 5 0011111000000000 5 0000011000000000 5 0000000000000000 
0 0111111100000000 1 0111111100000000 2 0000011000000000 3 0000000000000000 
  0110001100000000   0110001100000000   0000000000000000   0000000000000000 
  0110001100000000   0110001100000000   0000000000000000   0000000000000000 
  0111111100000000   0111111100000000   0000111000000000   0001111100000000 
  0111111100000000   0011111100000000   0000011000000000   0011111000000000 
  0110001100000000   0000001100000000   0000011000000000   0000000000000000 
  0110001100000000   0000001100000000   0000011000000000   0000000000000000 
  0110001100000000   0110001100000000   0000011000000000   0000000000000000 
  0111111100000000   0111111100000000   0000011000000000   0000000000000000 
  0011111000000000   0011111000000000   0000011000000000   0000000000000000 
  0000000000000000   0000000000000000   0110011000000000   0000000000000000 
  0000000000000000   0000000000000000   0111111000000000   0000000000000000 
  0000000000000000   0000000000000000   0011110000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0110000000000000 5 0000000000000000 5 0000000000000000 5 0000001100000000 
4 0110000000000000 5 0000000000000000 6 0000000000000000 7 0000011100000000 
  0110000000000000   0000000000000000   0000000000000000   0000011000000000 
  0110011000000000   0000000000000000   0000000000000000   0000111000000000 
  0110111000000000   0000000000000000   0111111100000000   0000110000000000 
  0111110000000000   0000000000000000   0111111100000000   0001110000000000 
  0111100000000000   0000000000000000   0000111000000000   0001100000000000 
  0111100000000000   0001100000000000   0001110000000000   0011100000000000 
  0111110000000000   0011110000000000   0011100000000000   0011000000000000 
  0110111000000000   0011110000000000   0111111100000000   0111000000000000 
  0110011100000000   0001100000000000   0111111100000000   0110000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0000000000000000 5 0000111100000000 5 0001100000000000 5 0000000000000000 
8 0000000000000000 9 0000111000000000 A 0001100000000000 B 0000000000000000 
  0001100000000000   0001110000000000   0011110000000000   0000000000000000 
  0011110000000000   0001100000000000   0011110000000000   0000000000000000 
  0011110000000000   0011000000000000   0011110000000000   0001100000000000 
  0001100000000000   0000000000000000   0001100000000000   0001100000000000 
  0000000000000000   0000000000000000   0001100000000000   0111111000000000 
  0001100000000000   0000000000000000   0000000000000000   0111111000000000 
  0011110000000000   0000000000000000   0000000000000000   0001100000000000 
  0011110000000000   0000000000000000   0001100000000000   0001100000000000 
  0001100000000000   0000000000000000   0001100000000000   0000000000000000 
  0011000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

5 0011111000000000 5 0000000000000000 5 0000000000000000 5 0011111000000000 
C 0111111100000000 D 0000000000000000 E 0000000000000000 F 0111111100000000 
  0110001100000000   0000000000000000   0000000000000000   0110001100000000 
  0110001100000000   0000000000000000   0000000000000000   0000011100000000 
  0110101100000000   0110011000000000   0000000000000000   0000111000000000 
  0110111100000000   0110011000000000   0000000000000000   0001110000000000 
  0110111000000000   0001100000000000   0000000000000000   0001100000000000 
  0110000000000000   0001100000000000   0001100000000000   0000000000000000 
  0110001100000000   0110011000000000   0011110000000000   0000000000000000 
  0111111100000000   0110011000000000   0011110000000000   0001100000000000 
  0011111000000000   0000000000000000   0001100000000000   0001100000000000 
  0000000000000000   0000000000000000   0011000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0111111000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
0 0111111100000000 1 0000000000000000 2 0000000000000000 3 0000000000000000 
  0011111100000000   0000000000000000   0000000000000000   0000000000000000 
  0001111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0000111100000000   0000000000000000   0000000000000000   0000000000000000 
  0001111100000000   0000000000000000   0000000000000000   0000000000000000 
  0011111100000000   0000000000000000   0000000000000000   0000000000000000 
  0111111100000000   0000000000000000   0000000000000000   0000000000000000 
  0111111000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

6 0000000000000000 6 0000000000000000 6 0000000000000000 6 0000000000000000 
C 0000000000000000 D 0000000000000000 E 0000000000000000 F 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
0 0000000000000000 1 0000000000000000 2 0000000000000000 3 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
4 0000000000000000 5 0000000000000000 6 0000000000000000 7 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
8 0000000000000000 9 0000000000000000 A 0000000000000000 B 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

7 0000000000000000 7 0000000000000000 7 0000000000000000 7 0000000000000000 
C 0000000000000000 D 0000000000000000 E 0000000000000000 F 0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 
  0000000000000000   0000000000000000   0000000000000000   0000000000000000 

( 0020,4800 )               D# 18 code{ 

:# ns 258
:# nblk 1440
:# nc 8 { cr }
 ( colorforth v3.4k1+ g144/1.10 chuck moore ) { cr }
 [ d# 20 load d# 22 load d# 24 load ] ( colors ) [ d# 28 load ] { cr }
 ( decompress ) [ mark d# 30 load restore empt ]
: env [ d# 34 ] winver 2* + ; [ env ] ( ironmental ) [ load d# 46 load
  d# 62 d# 4 loads d# 88 load ] { br }

: dump d# 48 load ; ( background dump )
: floppy d# 52 load ; ( format, archive, set video )
: icons d# 54 load ; ( edit chars )
: c-a-c d# 70 ; ( ascii )
: audit d# 90 load ; ( disk audit utility )
: png d# 168 load ; ( png file format )
: html d# 176 load ; ( html file write ) { br }
 ( blocks 0-143 are public domain software ) { cr }
 [ mark empty ] ( arrayforth ) [ d# 144 load ] }block

( 0020,4C00 )               D# 19 shadow{ 
 ( compile x86 colorforth )
: ns ( number of sectors compressed if neg, ) { cr }
 ( last compressed if pos. )
: nblk ( number of uncompressed blocks. )
: nc ( no. of compressed cylinders, deprecated ) { cr }
 [ these vars must be first things in block! ] { br }

: dump ( compile memory display background task )
: icons ( compile icon editor )
: png ( screen image to file )
: ---
: editor
: sct [ yrg* ] ( all-caps cap lower-case yellow red green * toggles shadow
  comment block )
: fj [ ludr ] ( find jump left up down right )
: .. [ -mc+ ] ( dec-block magenta cyan inc-block )
: x.i ( delete exit insert )
: . ( jump jumps between -edited- blocks )
: f ( finds next word from ) [ find word ] }block

( 0020,5000 )               D# 20 code{ 
 [ macro ]
: swap h# 0000,168B 2, H# C28B,0689 , ;
: 0 < ?dup > h# 0000,C031 2, ;
: if h# 0000,0074 2, here ;
: -if h# 0000,0079 2, here ;
: while ( n-nn ) < if > swap ;
: -while ( n-nn ) < -if > swap ;
: a < ?dup > h# 0000,C28B 2, ;
: a! ?lit if h# 0000,00BA 1, , ; then h# 0000,D08B 2, < drop > ;
: 2* h# 0000,E0D1 2, ; [ forth ]
: a, 2* 2* , ; [ macro ]
: @ ?lit if < ?dup > h# 0000,058B 2, a, ; then h# 0085,048B 3, 0 , ;
: ! ?lit if ?lit if h# 0000,05C7 2, swap a, , ; then h# 0000,0589 2, a,
  < drop > ; then < a! > h# 0095,0489 3, 0 , < drop > ;
: nip h# 0004,768D 3, ;
: + ?lit if h# 0000,0005 1, , ; then h# 0000,0603 2, < nip > ;
: or h# 0000,0633
: binary ?lit if swap d# 2 + 1, , ; then 2, < nip > ;
: and h# 0000,0623 < binary > ;
: u+ ?lit if h# 0000,0681 2, , ; then h# 0004,4601 3, < drop > ;
: ? ?lit h# 0000,00A9 1, , ;
: over < ?dup > h# 0004,468B 3, ; }block

( 0020,5400 )               D# 21 shadow{ 
 ( pentium macros' 1, 2, 3, , compile 1-4 bytes )
: drop ( lodsd, flags unchanged, why sp is in esi - in kernel )
: then ( fix address - in kernel )
: swap ( sp xchg )
: 0 ( 0 0 xor, macro 0 identical to number 0 )
: if ( jz, flags set, max 127 bytes, leave address )
: -if ( jns, same )
: a ( 2 0 mov, never used? )
: a! ( 0 2 mov, unoptimized )
: 2* ( shift left )
: a, ( compile word address )
: @/! ( fetch/store from/to word address, or eax )
: nip swap drop
: +/or/and ( number or sp with eax )
: u+ ( add to 2nd number, number or sp )
: ? ( test bits, set flags, literal only! )
: over ( sp 4 + @ ) }block

( 0020,5800 )               D# 22 code{ 
 ( macros )
: push ?lit if h# 0000,0068 1, , ; then h# 0000,0050 1, < drop > ;
: pop < ?dup > h# 0000,0058 1, ;
: - h# 0000,D0F7 2, ;
: *end swap
: end h# 0000,00EB
: loop 1, here - + 1, ;
: until h# 0000,0074 < loop > ;
: -until h# 0000,0079 < loop > ;
: for < push begin > ;
: *next swap
: next H# 7524,0CFF
: 0next , here - + 1, h# 0004,C483 3, ;
: -next H# 7924,0CFF < 0next > ;
: i < ?dup > h# 0024,048B 3, ;
: +! ?lit if ?lit if h# 0000,0581 2, swap a, , ; then h# 0000,0501 2,
  a, < drop > ; then < a! > h# 0095,0401 3, 0 , < drop > ;
: nop h# 0000,0090 1, ;
: align here - d# 3 and drop if < nop align > ; then ;
: or! < a! > h# 0095,0409 3, 0 , < drop > ;
: * h# 0006,AF0F 3, < nip > ;
: */ h# 0000,C88B 2, < drop > H# F9F7,2EF7 , < nip > ;
: /mod < swap > h# 0000,0099 1, H# 1689,3EF7 , ;
: / < /mod nip > ;
: mod < /mod drop > ; }block

( 0020,5C00 )               D# 23 shadow{ 

: push ( lit to sp; eax to sp )
: pop ( sp to eax )
: - ( ones-complement )
: begin -a ( current code address - byte )
: while a-aa ( if-escape from any structure usage example begin xxx while
  xxx next xxx then )
: for n ( push count onto return stack, ) begin
: *next aa-aa ( swap ) for ( and ) if ( addresses )
: next a ( decrement count, jnz to ) for, ( pop return stack when done
  )
: -next a ( same, jns - loop includes 0 )
: i -n ( copy loop index to data stack )
: *end aa-aa ( swap ) end ( and ) if ( addresses )
: end a ( jmp to ) begin
: +! na ( add to memory, 2 literals optimized )
: align ( next call to end on word boundary )
: or! na ( inclusive-or to memory, unoptimized )
: * mm-p ( 32-bit product )
: */ mnd-q ( 64-bit product, then quotient )
: /mod nd-rq ( remainder and quotient )
: / nd-q ( quotient )
: mod nd-r ( remainder ) }block

( 0020,6000 )               D# 24 code{ 
 ( compiled macros )
: 2/ h# 0000,F8D1 2, ;
: time < ?dup > h# 0000,310F 2, ;
: 7push h# 0000,0057 1, ;
: 7pop h# 0000,005F 1, ; [ forth ]
: @ @ ; { -cr }

: ! ! ; { -cr }

: + + ; { -cr }

: - - ;
: */ */ ; { -cr }

: * * ; { -cr }

: / / ; { -cr }

: 2/ 2/ ;
: dup dup ; { -cr }

: drop drop ; { -cr }

: nip nip ;
: or or ; ( arithmetic )
: negate - d# 1 + ;
: min less if drop ; then swap drop ;
: abs dup negate
: max less if swap then drop ;
: v+ ( vv-v ) push u+ pop + ; ( vector )
: loads ( bn ) for dup push load pop d# 2 + next drop ;
: writes ( acn ) for write next drop drop ;
: reads ( acn ) for read next drop drop ; }block

( 0020,6400 )               D# 25 shadow{ 

: 2/ ( arithmetic right shift )
: time -n ( pentium cycle counter, calibrate to actual clock rate )
: 7push/7pop ( save/restore save register 7, edi )
: @-drop ( these macros redefined in ) forth ( so they may be executed
  )
: negate n-n ( when you just cant use ) -
: min nn-n ( minimum )
: abs n-u ( absolute value )
: max nn-n ( maximum )
: v+ vv-v ( add 2-vectors )
: loads ( load successive blocks )
: nc -a ( number of cylinders booted and saved )
: writes ( address, cylinder, cylinder count )
: reads ( address, cylinder, count. ) [ floppy access note do not hit
  any keys while floppy is being written - wait for light to go out ]
  }block

( 0020,6800 )               D# 26 code{ 
 }block

( 0020,6C00 )               D# 27 shadow{ 
 }block

( 0020,7000 )               D# 28 code{ 
 ( colors etc )
: -offset ( n-n ) [ offset ] @ negate + ;
: block [ offset ] @ +
: blks h# 0000,0100 * ;
: wrtboot [ d# 0 block ] d# 0 d# 1 writes stop ;
: save [ d# 84 ] load ;
: white h# 00FF,FFFF color ;
: red h# 00FF,0000 color ;
: green h# 0000,FF00 color ;
: blue h# 0000,00FF color ;
: silver h# 00BF,BFBF color ;
: black d# 0 color ;
: 5* d# 5 for 2emit next ;
: cf d# 25 dup at red h# 0000,0001 h# 0000,0003 h# 0000,000C h# 0000,0003
  h# 0000,000A 5* green h# 0000,0014 h# 0000,0002 h# 0000,0001 h# 0000,0003
  h# 0000,000E 5* ;
: fill ( nan ) for over over ! d# 1 + next drop drop ;
: move ( sdn ) for over @ over ! d# 1 + d# 1 u+ next drop drop ;
: erase ( bn ) push d# 0 swap block pop blks fill ;
: copy ( n ) [ blk ] @ block over block d# 512 move [ blk ] ! ; }block

( 0020,7400 )               D# 29 shadow{ 

: block n-a ( block number to word address )
: wrtboot ( write boot and kernel )
: save ( write entire image to floppy )
: colors ( specified as rgb' 888 bits )
: at xy ( set current screen position - in kernel )
: box xy ( lower-right of colored rectangle - in kernel )
: 5* emit ( letters )
: cf ( display double-size colorforth )
: fill n an ( writes n into a cell string )
: move sdn ( copies a cell string from s to d )
: erase bn ( zeroes a string of blocks )
: copy n ( copies current editor block and its shadow to the given block
  ) }block

( 0020,7800 )               D# 30 code{ 
 ( decompress ) [ empt d# 32 load ]
: char ( -n ) 0 b! ( ?new ) d# 4 bits b d# 8 and drop if b d# 4 and drop
  if d# 3 bits d# 7 ; then d# 1 bits d# 5 ; then d# 4 b h# 0000,000F and
  drop if ; then
: eob ( n ) drop pop drop ;
: chars ( n-n ) char ?full c! 2*c b or chars ;
: word ( n ) d# 28 [ nb ] ! dup chars tbits ;
: short ( n ) d# 28 bits
: t, d# -4 [ nb ] ! b tbits ;
: literal ( n ) 0 b! d# 1 bits t,
: 32bits d# 16 bits d# 16 bits b , ;
: variable ( n ) word 32bits ;
: tag ( -n ) b h# 0000,000F and dup jump eob word literal word word literal
  short word short word word word variable short word short
: words ( ?new ) d# 4 bits tag words ;
: range ( ann ) over block [ h ] ! dup push erase [ aa ] ! 0 [ na ] !
  begin words [ h ] @ d# 256 + d# -256 and [ h ] ! next ;
: restore [ ns ] @ dup and -if abs [ ns ] ! d# 36 block d# 3000 block
  [ d# 18 blks nc @ d# -2 + * ] move [ d# 3000 block ] d# 36 [ nblk @
  d# -36 + ] range ; then drop ; }block

( 0020,7C00 )               D# 31 shadow{ 

: char ( examine high bits; shift 4, 5 or 7 bits )
: eob ( end of block )
: chars ( shift characters until 0 )
: word ( shift characters, then tag )
: short ( 28-bit value+tag )
: literal ( 1-bit base base, tag. value in next word )
: 32bits ( for values )
: variable ( word, value )
: tag ( vector )
: words ( examine tags )
: range ( process each block )
: move ( blocks 72 thru 1419 to 3000 )
: res ( restore compressed blocks ) }block

( 0020,8000 )               D# 32 code{ 
 ( decompress ) [ macro ] ( uses ebx )
: b < ?dup > h# 0000,C38B 2, ;
: b! h# 0000,D88B 2, < drop > ;
: c! h# 0000,C88B 2, < drop > ;
: 2*d h# 00C3,A50F 3, ;
: 2*c h# 0000,E0D3 2, ; [ forth ]
:# na 26
:# nb 9
:# h 67510272
:# an 0
:# aa 67933438
:# nz 4
: ?new [ na ] @ dup and drop if ; then
: new [ aa ] @ @ [ an ] ! d# 1 [ aa ] +! d# 32 [ na ] ! ;
: shift ( n-n ) dup negate dup [ nb ] +! [ na ] +! c! [ an ] @ 2*d 2*c
  [ an ] ! ;
: bits ( n ) ?new dup negate [ na ] @ + -if dup push + shift new pop negate
  shift ; then drop shift ;
: tbits ( nn ) [ nb ] @ d# 8 + c! 2*c or
: , [ h ] @ ! d# 1 [ h ] +! ;
: tz ( nn-n ) over [ nz ] ! dup negate push + b begin dup d# 1 and drop
  if drop drop pop drop [ nz ] @ ; then 2/ next b! dup [ nz ] @ - + -
  [ nb ] +! pop drop ;
: ?full ( n-n ) [ nb ] @ dup and -if tz dup push d# -4 + [ nb ] +! tbits
  0 dup pop dup - d# 29 + [ nb ] ! ; then drop ; }block

( 0020,8400 )               D# 33 shadow{ 

: b ( pop ebx, register 3, into eax )
: c! ( push eax into register 1, ecx )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: na ( bits remaining in source word )
: nb ( bits remaining in ebx )
: h ( destination address )
: , ( store at destination )
: ?new ( fetch new word if necessary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: tbits ( fill ebx with tag )
: ?full ( is there room in ebx? )
: bits ( shift bits into ebx. overflow into next word ) }block

( 0020,8800 )               D# 34 code{ 
 ( native system dependencies ) [ macro ]
: p@ < a! ?dup > h# 0000,00EC 1, ; [ forth ]
: key? h# 0000,0064 p@ d# 1 and drop if h# 0000,0060 p@ h# 0000,0080 and
  drop if ; then pop drop then ;
: clock [ d# 40 ] load ;
: altfrm ( -b ) [ aper @ d# 1024 d# 768 * d# -4 * + ] ;
: topram ( -b ) [ H# 3000,0000 ] ;
: !work ( n ) block d# 0 over [ d# 1 ] + @ [ d# 35 ] + [ d# 36 ] / writes
  stop ;
: @rest ( nn ) push [ d# 36 ] + block [ d# 2 ] pop reads stop ;
: @back ( n ) dup block d# 0 [ d# 2 ] reads dup [ d# 18 ] + block dup
  @ [ d# 18 block @ ] or drop if drop [ d# 78 ] @rest ; then dup [ d#
  1 ] + @ dup and -if nip abs [ d# 35 ] + [ d# 36 ] / [ d# -2 ] + @rest
  ; then drop drop [ d# 78 ] @rest ;
: !back ( n ) block d# 0 [ nblk ] @ [ d# 18 ] / writes stop ;
: @cyls ( acn ) reads stop ;
: screen d# 0 dup at d# 1024 d# 768 box ;
: utime ( -n ) d# 0 ; { br }

: serial ( -n ) d# 96 ; }block

( 0020,8C00 )               D# 35 shadow{ 

: key? ( exits calling defn if key struck )
: clock ( loads time of day suppt )
: altfrm ( byte addr of alternate frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads only
  active part of compressed ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color )
: utime ( null definition for now for compatability ) }block

( 0020,9000 )               D# 36 code{ 
 ( windows system dependencies )
: key? [ keych ] @ d# 0 or drop if pop drop ; then ;
: beep ; { -cr }

: clock d# 38 load ;
: topram { -cr }

: altfrm ( -b ) [ endram d# -4096 d# 768 * + ] ;
: !work ( n ) dup block [ d# 1 ] + @ [ d# 1 ] + 2/ wwork ;
: @back ( n ) dup d# 19 rback dup [ d# 18 ] + block dup @ [ d# 18 block
  @ ] or drop if drop [ d# 1440 ] rback ; then dup [ d# 1 ] + @ dup and
  -if nip abs [ d# 1 ] + 2/ rback ; then drop [ d# 3 ] + @ rback ;
: !back ( n ) [ nblk ] @ wback ;
: @cyls ( acn ) d# 3000 @back push [ d# 18 ] * [ d# 3000 ] + block swap
  pop [ d# 18 d# 256 * ] * move ;
: screen d# 0 dup at d# 868 for d# 0 d# 1024 line next d# 0 dup at ;
: serial ( -n ) d# 114 ;
: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 3 d# 0 d# 0 pop pop
  swap [ d# 4 ] * fcreate ;
:# flng 30 [ flng d# 4 * dup ]
: frd ( anh-n ) push push push [ d# 0 + ] pop pop swap pop fread
: frw? ( ok-n ) if drop [ flng ] @ then ;
: fwr ( anh-n ) push push push [ d# 0 + ] pop pop swap pop fwrite frw?
  ; { -cr }

: r/o [ H# 8000,0000 ] ;
: w/o [ H# 4000,0000 ] ; { -cr }

: r/w [ r/o w/o + ] ; }block

( 0020,9400 )               D# 37 shadow{ 

: key? ( exits calling defn if key struck )
: save ( writes full disk image )
: beep ( alert in hardsim )
: clock ( loads time of day suppt )
: altfrm ( byte adr of alt frame buffer )
: topram ( end ram avail for applications. )
: @back and !back ( read/wrt full disk to/from adr ) [ @back reads only
  active part of compressed, and only active part of straight disks with
  vars ]
: @cyls ( equiv to reads )
: screen ( fills screen with current color ) { br }

: fopen ( opens an existing win32 file given word adr of name and access
  code of ) r/o w/o ( or ) r/w. ( returns handle, indicators nz if it's
  good. )
: frd ( and ) fwr ( read and write on things with win32 handles. ) }block

( 0020,9800 )               D# 38 code{ 
 ( windows clock )
: sec ( -n ) utime [ d# 60 d# 60 * d# 24 * ] mod ;
: minute ( -n ) sec d# 60 / ; }block

( 0020,9C00 )               D# 39 shadow{ 

: utime ( returns unix time in sec since epoch 0000z fri 1/01/1970 )
: sec ( seconds since midnight needs unsigned mod by time we are all dead
  )
: min ( minutes past midnight ) }block

( 0020,A000 )               D# 40 code{ 
 ( native clock ) [ macro ] ( pentium timer )
: p@ < a! ?dup > h# 0000,00EC 1, ;
: p! < a! > h# 0000,00EE 1, < drop > ; [ forth ]
: ms d# 100000 * for next ;
: ca h# 0000,0070 p! h# 0000,0071 ;
: c@ ca p@ ;
: c! ca p! ;
: !bcd push d# 10 /mod d# 16 * + pop c! ;
: !hm d# 100 /mod d# 4 !bcd d# 2 !bcd 0 dup c! ;
: bcd c@ d# 16 /mod d# 10 * + ;
: sec0 d# 4 bcd d# 60 * d# 2 bcd + d# 60 * d# 0 bcd + ;
: sec sec0 d# 2 ms dup sec0 or drop if drop sec ; then ;
: minute sec d# 60 / ;
: hms sec d# 60 /mod d# 60 /mod d# 100 * + d# 100 * + ;
: ymd d# 9 bcd d# 100 * d# 8 bcd + d# 100 * d# 7 bcd + ;
: day d# 6 c@ d# -1 + ;
: hi d# 10 c@ h# 0000,0080 and drop if ; then hi ;
: lo d# 10 c@ h# 0000,0080 and drop if lo ; then ;
: cal hi lo time - hi lo time + ( 748 ) ;
: beep h# 0000,00B6 h# 0000,0043 p! h# 0000,00EE h# 0000,0042 p! 0 h#
  0000,0042 p! ( on ) h# 0000,0061 p@ d# 3 or h# 0000,0061 p! d# 50000000
  for next ( off ) h# 0000,0061 p@ d# 3 or h# 0000,0061 p! ; }block

( 0020,A400 )               D# 41 shadow{ 
 }block

( 0020,A800 )               D# 42 code{ 
 }block

( 0020,AC00 )               D# 43 shadow{ 
 }block

( 0020,B000 )               D# 44 code{ 

: def a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { br }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { br }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { br }
 a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 a a a a a a a a a a a a a a a { cr }
 }block

( 0020,B400 )               D# 45 shadow{ 
 }block

( 0020,B800 )               D# 46 code{ 
 ( logo, etc )
: list ( n ) [ blk ] @ [ blk d# 1 + ] ! [ blk ] ! lis ;
: logo show black screen d# 800 d# 710 blue box d# 600 d# 50 at d# 1024
  d# 620 red box d# 200 d# 100 at d# 700 d# 500 green box { 0000,024F
  } ( list ) text cf keyboard ;
: empty empt logo ;
: wait [ d# 10 d# 30 * ] for 7push pause 7pop next ;
: l [ blk ] @ load ; { br }
 [ d# 156 load ]
: watermark show black screen d# 16 center h# 0040,4060 color [ blk ]
  @ 4. +list keyboard ;
: edit ( n ) [ blk ] @ [ blk d# 1 + ] ! [ blk ] !
: e watermark +e ; { br }

: -kbd ( -t ) 7push pop dup and drop ; }block

( 0020,BC00 )               D# 47 shadow{ 
 ( logo, etc )
: logo ( displays colorforth logo )
: show ( background task executes following code repeatedly )
: keyboard ( displays keypad and stack )
: empty ( empty dictionary w/ empt display logo )
: wait ( while saving edi, in interrupt dead code artifact )
: list ( displays the given block without entering the editor. ) { br
  }

: -kbd ( returns true/nonzero flag if a word that calls it is being interpreted
  from a block as opposed to from the keyboard. use with caution from
  deep within an app that might have monkeyed with register { 0000,00EF
  } ) }block

( 0020,C000 )               D# 48 code{ 
 ( dump ) [ empty ]
:# x 67153136
:# y -79636688
: 5-8 d# 8 /mod d# 32 /mod d# 32 /mod h# 0000,0100 * + h# 0000,0100 *
  + h# 0000,0100 * swap d# 4 * + ;
: one dup @ dup 5-8 h. space h. space dup h. cr ;
: lines for one d# -1 + next drop ;
: dump [ x ] !
: r show black screen [ x ] @ d# 15 + d# 16 text lines keyboard ;
: it @ + @ dup h. space ;
: lines for white i [ x ] it i [ y ] it or drop if red then i . cr -next
  ;
: cmp show blue screen text d# 19 lines red [ x ] @ h. space [ y ] @ h.
  keyboard ;
: u d# 16
: +xy dup [ x ] +! [ y ] +! ;
: d d# -16 +xy ;
: ati H# F410,0000 ( ff7fc000 ) or ( agp graphics reg )
: byte d# 4 / dump ;
: fix for d# 0 over ! d# 1 + next ; [ dump ] }block

( 0020,C400 )               D# 49 shadow{ 
 ( does not say empty, compiles on top of application )
: x -a ( current address )
: one a-a ( line of display )
: lines an
: dump a ( background task continually displays memory --- takes address
  -- displays three cols with address on right contents in middle and-
  the left col is g18 instruction view )
: u ( increment address )
: d ( decrement )
: ati ( address of agp graphic registers )
: byte a ( byte address dump )
: fix an-a ( test word ) }block

( 0020,C800 )               D# 50 code{ 
 ( timing greg )
:# tmt 286630312
:# tmn -162350156
:# tmp 64245270
:# secs 0
: tmclr d# 0 [ tmt ] ! d# 0 [ tmn ] ! d# 0 [ tmp ] ! d# 0 [ secs ] ! ;
: tms ( a ) time - [ d# 1 ] + swap +! ;
: tme ( a ) time swap +! ;
: tare [ tmt ] tms pause [ tmt ] tme ;
: 0tare [ tmn ] tms switch [ tmn ] tme ;
: counter utime negate [ secs ] +! ;
: timer utime [ secs ] +! ; }block

( 0020,CC00 )               D# 51 shadow{ 
 }block

( 0020,D000 )               D# 52 code{ 
 ( format floppy ) [ empty ]
:# hd 1
:# ad 152338
: array pop 2/ 2/ ;
: com align array [ H# 1202,004D , h# 0000,006C 2, ]
: word ( n ) [ ad ] @ ! d# 1 [ ad ] +! ;
: sectors ( cs-c ) buffer [ ad ] ! d# 18 for over [ hd ] @ h# 0000,0100
  * + over d# 18 mod d# 1 + h# 0001,0000 * + h# 0200,0000 + word d# 1
  + next drop ;
: head ( ch-c ) dup [ hd ] ! h# 0000,0400 * H# 1202,004D + [ com ] ! dup
  2* - d# 1801 + sectors format ;
: cylinders ( n ) push [ com ] d# 0 pop for d# 0 head d# 1 head d# 1 +
  next ( stop ) drop drop ;
: format ( nc @ ) d# 80 cylinders stop ;
: archive [ d# 0 block ] d# 0 [ nc ] @ writes stop ;
: check [ d# 3000 block ] d# 0 [ nc ] @ reads stop ;
: ati H# 10CD,4123 [ vesa ] ! ; ( setup for ati video card )
: nvidia H# 10CD,4118 [ vesa ] ! ; ( for nvidia card then save ) }block

( 0020,D400 )               D# 53 shadow{ 

: format ( issue format command 30 cyl - in kernel )
: hd ( disk head )
: ad ( current address in ) buffer
: buffer ( usual floppy cylinder buffer )
: array ( return word address )
: com ( format command )
: word ( store word into command string )
: sectors ( build sector table )
: head ( build sectors for selected head )
: cylinders ( sectors advance 1 for each cylinder - to allow time for
  head step )
: format ( only desired cylinders to save time )
: bytes ( arguments for crc )
: archive ( verify save' compute crc, save, read-back, recompute crc -
  first 64 bytes used by floppy read/write -- the two crc numbers should
  be the same ! ) }block

( 0020,D800 )               D# 54 code{ 
 ( icons ) [ empty macro ]
: @w h# 0000,8B66 3, ;
: !w < a! > h# 0002,8966 3, < drop > ;
: *byte h# 0000,C486 2, ; [ forth ]
:# ic 53
:# cu 169
: sq [ xy ] @ h# 0001,0000 /mod d# 16 + swap d# 16 + box { cr }
 d# 17 d# 0 +at ;
: loc [ ic ] @ [ d# 16 d# 24 d# 8 */ ] * [ d# 12 block d# 4 * ] + ;
: 0/1 h# 0000,8000 ? if green sq ; then blue sq ;
: row dup @w *byte d# 16 for 0/1 2* next drop { cr }
 [ d# -17 d# 16 * ] d# 17 +at ;
: ikon loc d# 24 for row d# 2 + next drop ;
: adj d# 17 * swap ;
: cursor [ cu ] @ d# 16 /mod adj adj over over at { cr }
 red d# 52 u+ d# 52 + box ;
: line ( i-in ) for dup emit d# 1 + next ;
: set ( xy ) over lm at d# 0 d# 10 for d# 12 line cr next { cr }
 d# 8 line drop ;
: ok show black screen cursor d# 18 dup at ikon { cr }
 text [ ic ] @ . d# 400 d# 60 set keyboard ; [ d# 56 load ok h ] }block

( 0020,DC00 )               D# 55 shadow{ 
 ( draw big-bits icon )
: @w a-n ( fetch 16-bit word from byte address )
: !w na ( store same )
: *byte n-n ( swap bytes )
: ic -a ( current icon )
: cu -a ( cursor )
: sq ( draw small square )
: xy -a ( current screen position, set by ) at
: loc -a ( location of current icons bit-map )
: 0/1 n-n ( color square depending on bit 15 )
: row a-a ( draw row of icon )
: ikon ( draw big-bits icon )
: adj nn-nn ( magnify cursor position )
: cursor ( draw red box for cursor )
: ok ( background task to continually draw icon, icon number at top )
  }block

( 0020,E000 )               D# 56 code{ 
 ( edit character set application )
: +ic d# 1 [ ic ] +! ;
: -ic [ ic ] @ d# -1 + d# 0 max [ ic ] ! ;
: bit [ cu ] @ 2/ 2/ 2/ 2/ 2* loc + h# 0001,0000 [ cu ] @ h# 0000,000F
  and d# 1 + for 2/ next *byte ;
: toggle bit over @w or swap !w ;
: td toggle
: d d# 16
: wrap [ cu ] @ + [ d# 16 d# 24 * ] dup u+ /mod drop [ cu ] ! ;
: tu toggle
: u d# -16 wrap ;
: tr toggle
: r d# 1 wrap ;
: tl toggle
: l d# -1 wrap ;
: h pad nul nul accept nul tl tu td tr l u d r -ic nul nul +ic nul nul
  nul nul nul nul nul nul nul nul nul nul [ h# 0000,2500 , h# 0110,160C
  dup , , H# 2B00,0023 , d# 0 , d# 0 , d# 0 , ] }block

( 0020,E400 )               D# 57 shadow{ 
 ( edit icon ) }block

( 0020,E800 )               D# 58 code{ 
 ( lan ) [ empty h# 0000,03F8 d# 60 load init ]
: no block d# 4 * d# 1024 ;
: send no for dup 1@ xmit d# 1 + next drop ;
: receive no for rcv over 1! d# 1 + next drop ;
: no d# 18 [ d# 7 d# 18 * ] ;
: backup no for dup send d# 1 + next drop ;
: accept no for dup receive d# 1 + next drop ; }block

( 0020,EC00 )               D# 59 shadow{ 
 }block

( 0020,F000 )               D# 60 code{ 
 ( serial 3f8 2e8 1050 ) [ macro ]
: p@ < a! dup > h# 0000,00EC 1, ;
: p! < a! > h# 0000,00EE 1, < drop > ;
: 1@ h# 0000,008A 2, ;
: 1! < a! > h# 0000,0288 2, < drop > ; [ forth ]
: r [ d# 0 + ] + ;
: 9600 d# 12 ;
: 115200 d# 1 ;
: b/s h# 0000,0083 [ d# 3 r ] p! d# 115200 [ d# 0 r ] p! d# 0 [ d# 1 r
  ] p! d# 3 [ d# 3 r ] p! ;
: init b/s ( 16550 ) d# 1 [ d# 2 r ] p! d# 0 [ d# 4 r ] p! ;
: xmit ( n ) [ d# 5 r ] p@ h# 0000,0020 and drop if [ d# 0 r ] p! ; then
  ( pause ) xmit ;
: cts [ d# 6 r ] p@ h# 0000,0030 and h# 0000,0030 or drop if cts ; then
  xmit ;
: st [ d# 6 r ] p@
: xbits h# 0000,0030 and h# 0000,0010 / dup d# 1 and 2* 2* + 2/ ;
: st! [ d# 4 r ] p! ;
: ?rcv [ d# 5 r ] p@ d# 1 and drop if [ d# 0 r ] p@ then ;
: rcv ?rcv if ; then ( pause ) rcv ; }block

( 0020,F400 )               D# 61 shadow{ 

: p@ p-n ( fetch byte from port )
: p! np ( store byte to port )
: 1@ a-n ( fetch byte from byte address )
: 1! na ( store byte to byte address )
: r n-p ( convert relative to absolute port address. base port on stack
  at compile time. compiled as literal at yellow-green transition )
: 9600
: 115200 ( baud-rate divisors. these are names, not numbers )
: b/s ( set baud rate. edit to change )
: init ( initialize uart )
: xmit n ( wait for ready and transmit byte )
: cts n ( wait for clear-to-send then xmit )
: st -n ( fetch status byte )
: xbits n-n ( exchange status bits )
: st! n ( store control byte )
: ?rcv ( fetch byte if ready. set flag to be tested by ) if
: rcv -n ( wait for ready and fetch byte ) }block

( 0020,F800 )               D# 62 code{ 
 ( word search tcurs ) [ macro ]
: bt ( nm-n ) [ H# 068B,D08B ] , [ H# 0F04,768D ] , [ H# D21B,C2A3 ] ,
  ; [ forth ]
: t2 ( nn-nn ) d# 1 +
: t1 ( nn-nn ) d# 1 [ curs ] +!
: t0 ( nn-nn ) d# 1 + ;
: map ( nnn-nn ) h# 0000,000F and jump t0 t1 t2 t1 t1 t2 t1 t1 t1 t1 t1
  t1 t2 t1 t1 t1
: tcurs ( nn-n ) over block push d# -1 [ curs ] ! d# 0
: tcu1 ( nnn-n ) dup i + @ map over over negate + drop -if t1 drop drop
  pop drop ; then tcu1 ;
: -curs ( - ) [ curs ] @ d# -1 + d# 0 max [ curs ] ! ; [ here ]
: tpoint [ blk ] @ [ curs ] @ tcurs drop -curs ; [ cpoint ! ] }block

( 0020,FC00 )               D# 63 shadow{ 
 ( word search tcurs )
: bt ( returns nz and less if bit n of m is set. pops t to 2, bit test
  index t mask 2, 2-2-sbb to set nz if carry. )
: t2 nn-nn ( 2 cell - big nums, var )
: t1 nn-nn ( 1 cell )
: t0 nn-nn ( extensions, undefined )
: map end n wrd-end n ( inc n and maybe curs )
: tcurs blk offset-blk ( convert offset to tokens in curs )
: -curs - ( decrement curs to zero )
: tpoint - ( fix abort to point cursor correctly, except if last word
  in block ) }block

( 0021,0000 )               D# 64 code{ 
 ( word search )
:# fmask -16
:# fnn -403177453
:# fna 67146240
:# fbits 16530 [ d# 18 block fna ! ]
: tag? ( nm-n ) over h# 0000,000F and swap bt drop ;
: +shad ( a-a ) dup [ fna ] @ or d# 256 and + ;
: 1word ( -n ) word [ words ] @
: 1wz d# 2 less drop if drop ; then nip d# -1 + 1wz ;
: want? ( nm-n ) tag? if or ; then drop drop d# -1 ;
: find 1word h# 0000,5E9A
: fnd+ d# 18 block d# -16
: fnd ( nbam ) [ fmask ] ! [ fna ] ! [ fbits ] ! d# 16 or [ fnn ] !
: f [ fnn ] @ d# 16 or [ fna ] @ begin +shad [ nblk ] @ block less drop
  while over over @ [ fbits ] @ want? [ fmask ] @ and drop while d# 1
  + end then dup d# 1 + [ fna ] ! nip h# 0000,0100 /mod -offset swap tcurs
  edit ; then drop drop ;
: red? ( n-nm ) [ h# 0000,1008 ] tag? if [ h# 0000,4092 ] ; then [ h#
  0000,1008 ] ;
: def 1word [ h# 0000,1008 ] fnd+ ; [ here ekt d# 21 + ! ]
: fkc drop ( drop ) [ pcad ] @ @ [ h# 0000,0140 ] tag? if [ d# 32 ] /
  edit ; then red? fnd+ ( blk @ ) dup ; [ here ekt d# 22 + ! ]
: fk drop ( drop ) [ cad ] @ [ fna ] ! f ( blk @ ) dup ;
: from ( n- ) 1word swap [ h# 0000,5E9A ] swap block [ d# -16 ] fnd ;
: literal ( n- ) h# 0000,0020 * [ h# 0000,0140 ] d# 18 block [ d# -32
  ] fnd ; }block

( 0021,0400 )               D# 65 shadow{ 
 ( word search )
: tag? ( nz and less if bit in m indexed by tag of token n is 1. )
: +shad ( skips shadows if in one and skipping. )
: 1word -n ( return 1st cell of word from kbd. )
: find ( finds following short word, starting in block 18, regardless
  of color. )
: def ( finds only definitions. )
: f ( find next occurrence of word last found )
: fk ( 'f' key in edit keyboard. drops key and block number and behaves
  like f except continues search from current editor position in current
  kind of block src/shad. )
: fkc ( if word left of cursor is a number, list that block. if red or
  magenta definition, searches for references. otherwise searches for
  definitions. )
: from n- ( like find but start from block number )
: literal n- ( finds any equivalent literal ) }block

( 0021,0800 )               D# 66 code{ 
 ( editor recolor ) [ d# 8 display + @ d# 13 display + ! ]
: array pop 2/ 2/ + @ ; ( 1-4-9 2-5 8-6-15 )
: reclr align array { cr }
 [ d# 0 , d# 4 , d# 5 , d# 3 , d# 9 , d# 2 , d# 15 , d# 7 , ] { cr }
 [ d# 6 , d# 1 , d# 10 , d# 11 , d# 12 , d# 13 , d# 14 , d# 8 , ]
: wadr ( -a ) [ pcad ] @ [ blk ] @ max ; [ here ekt d# 20 + ! ]
: change wadr @ h# 0000,000F and reclr wadr @ h# FFFF,FFF0 and or wadr
  ! ; [ H# 220E,100A ekt d# 33 + ! ] }block

( 0021,0C00 )               D# 67 shadow{ 
 ( tags ) { cr }
 ( extend ) [ execute 32-bit ] ( define ) { cr }
 compile 32-bit [ 27-bit ] < immediate > { cr }
 27-bit ( comment cap caps ) { cr }
 ( variable address blue 27-bit ) { br }

: array ( fetch new tag )
: reclr ( table of color cycles )
: wadr -a ( address of word to left of cursor )
: change ( color of word to left of cursor )
: 220e100a ( 0a-c 10-d 0e-f 22-j ) }block

( 0021,1000 )               D# 68 code{ 
 ( blue words )
: -w@ ( -n ) 7push pop d# -1 + @ ;
: ?xqt -w@ d# -16 and itick if drop ; then push ;
: @lit -w@ d# 32 / ; [ here display d# 13 + ! ]
: tadr h# 00C0,C0C0 color @lit d# 3 h.n space ;
: blu h# 0000,00FF color
: type1 [ d# 9 display + @ d# 5 + ] push ;
: d14 [ d# 14 display + ] ; [ here d14 ! ]
: exb blu { 0000,002F } ( sp + @ push ) ?xqt ;
: tab ( n ) for space next ;
: indent cr d# 5 tab ;
: br cr cr ;
: sp/2 h# 000B,0000 [ xy ] +! ;
: d03 ( -a ) [ d# 3 display + ] ; [ here ]
: exr [ d03 @ ] nop [ d03 ] ! space red type1 ;
: -cr [ d# 0 + ] nop [ d03 ] ! ;
: seeb [ d14 ] @ [ d14 @ dup d# 5 + or ] or [ d14 ] ! ;
: ?seeb ( -t ) [ d14 ] @ [ d14 @ d# 5 + ] or drop ; [ seeb ] }block

( 0021,1400 )               D# 69 shadow{ 

: ?xqt ( executes the word just passed over if it exists in the dictionary.
  )
: @lit ( fetch 27-bit literal )
: tadr ( display target address )
: blu ( display blue word )
: d14 ( tag 14 display entry )
: exb ( display and execute blue word if found. )
: tab ( advance n spaces )
: indent ( 5 spaces )
: br ( blank line )
: s/2 ( halfspace for reports. )
: -cr ( suppress cr on next red word. )
: seeb ( toggle display of blue words )
: ?seeb ( set flag non-zero if blue words visible ) }block

( 0021,1800 )               D# 70 code{ 
 ( convert colorforth character to/from ascii ) [ macro ]
: 1@ h# 0000,008A 2, ; [ forth ]
: string pop ;
: cf-ii string [ H# 6F74,7200 , H# 696E,6165 , H# 7963,6D73 , H# 7766,676C
  , H# 6270,7664 , H# 7175,7868 , ] ( 336a7a6b ) [ H# 3332,3130 , H# 3736,3534
  , ] ( 2d313938 - 2d7a3938 ) [ H# 5F7A,3938 , ] ( 2f322e30 ) [ H# 2F6A,2E6B
  , ] ( 2b213a3b ) [ H# 2421,3A3B , H# 3F2C,2A40 , ]
: ch h# FFFF,FFF0 and unpack [ cf-ii ] + 1@ h# 0000,00FF and ;
: ii-cf string [ h# 0000,2A00 , ] ( 0 + ) [ h# 0000,002B , H# 2B2D,0000
  , H# 2725,232E , ] ( zjk 1b262224 ) [ H# 1B1A,1918 , H# 1F1E,1D1C ,
  H# 2829,2120 , H# 2F00,0000 , H# 3A43,355C , H# 3D3E,3440 , ] ( 02 484a3744
  kj ) [ H# 5452,3744 , H# 3336,393C , H# 3831,4742 , H# 3F41,4632 , ]
  ( 1 493b45 z ) [ h# 0056,3B45 , ] ( - ) [ H# 2300,0000 , H# 0A13,052C
  , H# 0D0E,0410 , ] ( 02 181a0714 kj ) [ H# 2422,0714 , h# 0306,090C
  , H# 0801,1712 , H# 0F11,1602 , ] ( 1 190b15 z ) [ h# 0026,0B15 , ]
: chc h# FFFF,FFE0 + [ ii-cf ] + 1@ h# 0000,00FF and ; }block

( 0021,1C00 )               D# 71 shadow{ 
 ( colorforth to ascii and ascii to colorforth ) [ to load, type c-a-c
  not d# 54 load ]
: cf-ii ( otr inae ycms wfgl bpvd quxh 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? cba@ gfed 02ih onml srqp wvut 1yx
  cba@ gfed 02ih onml srqp wvut 1yx )
: notice [ j and z transposed in cf-ii; - converts to underscore, + to
  dollar. ] }block

( 0021,2000 )               D# 72 code{ 
 ( convert cf character to/from ascii ) [ macro ]
: 1@ h# 0000,008A 2, ;
: 1! < a! > h# 0000,0288 2, < drop > ; [ forth ]
: string pop ;
: cf-ii align string [ H# 6F74,7200 , H# 696E,6165 , H# 7963,6D73 , H#
  7766,676C , H# 6270,7664 , H# 7175,7868 , H# 3332,3130 , H# 3736,3534
  , H# 2D6A,3938 , H# 2F7A,2E6B , H# 2B21,273B , H# 3F2C,2A40 , ]
: ch h# FFFF,FFF0 and unpack [ cf-ii ] + 1@ h# 0000,00FF and ;
: ii-cf string [ h# 0000,2A00 , h# 0000,002B , H# 2B2D,0000 , H# 2725,232E
  , H# 1B1A,1918 , H# 1F1E,1D1C , H# 2829,2120 , H# 2F00,0000 , H# 3A43,355C
  , H# 3D3E,3440 , H# 5452,3744 , H# 3336,393C , H# 3831,4742 , H# 3F41,4632
  , h# 0056,3B45 , H# 2300,0000 , H# 0A13,052C , H# 0D0E,0410 , H# 2422,0714
  , h# 0306,090C , H# 0801,1712 , H# 0F11,1602 , h# 0026,0B15 , ]
: chc h# FFFF,FFE0 + [ ii-cf ] + 1@ h# 0000,00FF and ;
: set1 H# 3D21,223A H# 3E2C,203C
: !8 ( nn- ) [ cf-ii h# 0000,002C + 2/ 2/ ] ! [ cf-ii h# 0000,0028 + 2/
  2/ ] ! ;
: set0 H# 2B21,273B H# 3F2C,2A40 !8 ; }block

( 0021,2400 )               D# 73 shadow{ 
 ( colorforth to ascii and ascii to colorforth )
: cf-ii ( otr inae ycms wfgl bpvd quxh 3210 7654 -j98 /z.k +!'; ?,*@ )
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ? cba@ gfed 02ih onml srqp wvut 1yx
  cba@ gfed 02ih onml srqp wvut 1yx )
: set1 ( modifies cf-ii table. ) { cr }
 ( ; to colon, ' to doublequote, + to equal, ) { cr }
 ( @ to lessthan, * to blank, ? to greaterthan )
: set0 ( converts back to ascii. ) }block

( 0021,2800 )               D# 74 code{ 
 ( pathname input ) [ d# 72 load set1 ]
: strng ( n-a ) pop + ;
: fnam ( n-a ) align strng [ here d# 80 + h ! ]
:# hld 8
: emt ( n- ) [ hld ] @ fnam 1! d# 1 [ hld ] +! ;
: +shan ch emt dup and if +shan ; then drop ; { br }

: ,src 7@+ @
: xx dup and if +shan 7@+ @ dup d# 15 and drop { cr }
 while then [ d# 0 ] and emt 7dec ; then xx ;
: named ( string ) d# 0 [ hld ] ! -kbd if ,src ; { cr }
 then ( keyboard ) d# 0 word d# 0 { cr }
 begin push dup and while end then drop { cr }
 begin pop dup and while +shan end then emt ; { cr }
 [ exit ] ( testing )
: ccc dup 1@ d# 255 and swap d# 1 + ; { cr }
 [ named ] ( //./a; ) }block

( 0021,2C00 )               D# 75 shadow{ 
 ( filename input )
: strng ( defines an array of bytes. )
: fnam ( is a zero terminated ascii string consisting of ) hld ( chars
  including the null. ) emt ( appends a character to this string. )
: +shan ( appends a shannon word to fnam. ) { br }

: named ( returns the byte address of a null terminated ascii string representing
  the following colorforth string, which may follow in either source code
  or in keyboard input. ) { br }

: inam ( accept filename input from keyboard, store zero terminated ascii
  string to fnam, and return byte address of fnam. ) }block

( 0021,3000 )               D# 76 code{ 
 ( index ) [ empty ] { cr }
 [ d# 72 load ] { cr }

:# hld 401 [ d# 0 hld ! ]
:# spot 2 [ d# 0 spot ! ]
: nxt ( a-an ) dup d# 1 + swap @ ;
: emit ( c ) [ spot ] @ [ d# -72 ] + drop -if [ hld ] @ [ d# 3000 block
  d# 4 * ] + 1! d# 1 [ hld ] +! d# 1 [ spot ] +! ; then drop ;
: space d# 32 emit ;
: crlf d# 0 [ spot ] ! d# 13 emit d# 10 emit ;
: digit ( n ) [ d# -10 ] + -if [ h# 0000,003A ] + emit ; then [ h# 0000,0041
  ] + emit ;
: .h ( n ) space [ d# -1 ] swap { cr }
 begin dup [ h# 0000,000F ] and swap 2/ 2/ 2/ 2/ { cr }
 H# 0FFF,FFFF and while end then drop { cr }
 [ d# 0 ] + -if drop d# 0 digit ; then
: spit [ d# 0 ] + -if drop ; then digit spit ;
: .d ( n ) space [ d# 0 ] + -if h# 0000,002D emit negate then [ d# -1
  ] swap begin [ d# 10 ] /mod dup and while end then { cr }
 drop spit ; { cr }
 [ d# 78 load ] }block

( 0021,3400 )               D# 77 shadow{ 
 ( index )
: hld ( place in file )
: spot ( in line )
: nxt ( fetch next word )
: emit ( ascii character, won't go past column { 0000,090F } )
: space ( written to file )
: crlf ( to file )
: digit ( hex digit to file )
: .h ( print hex number )
: .d ( decimal number ) }block

( 0021,3800 )               D# 78 code{ 
 ( index.1 )
: short ( n ) 2/ 2/ 2/ 2/ dup d# 1 and drop { cr }
 if 2/ .h ; then 2/ .d ;
: literal ( an-a ) push nxt pop h# 0000,0010 and drop { cr }
 if .h ; then .d ;
: word ( n ) space [ h# FFFF,FFF0 ] and
: cont ( n ) dup and if ch emit cont ; then drop ;
: variable ( an-a ) word nxt .d ;
: eol ( n ) drop pop drop pop drop drop ;
: tag ( a-a ) dup h# 0000,000F and jump cont word literal { cr }
 eol word literal short word short word { cr }
 word word variable short word short
: words ( n ) for nxt tag next drop ;
: index ( 1st lst+1 ) d# 0 [ hld ] ! over negate + 2/ { cr }
 for dup .d dup space block d# 10 words crlf { cr }
 [ d# 2 ] + next drop
: sav [ d# 3000 block d# 4 * ] olog [ hld ] @ wlog clog ; }block

( 0021,3C00 )               D# 79 shadow{ 
 ( index.1 )
: short ( number )
: literal ( long number )
: word ( text, not number )
: cont ( inuation word )
: variable ( name and value )
: eol ( red word means end of line )
: tag ( vector table )
: words ( print maximum n words or to eol )
: index [ first-block last+1 ] { cr }
 ( prints first line of each block in range ) { cr }
 ( to a log file ) [ in windows ] }block

( 0021,4000 )               D# 80 code{ 
 }block

( 0021,4400 )               D# 81 shadow{ 
 }block

( 0021,4800 )               D# 82 code{ 
 }block

( 0021,4C00 )               D# 83 shadow{ 
 }block

( 0021,5000 )               D# 84 code{ 
 ( compress ) [ empty d# 86 load ]
: short d# 4 rbits d# 28 bits ;
: literal d# 4 rbits 2/ 2/ 2/ 2/ d# 1 rbits
: 32bits drop d# 1 + dup @ d# 16 bits d# 16 bits ;
: variable 1word 32bits ;
: /whit ( n-n ) d# -16 and d# 9 or word ;
: tag ( an-an ) dup h# 0000,000F and jump cont word literal word word
  literal short word short word /whit /whit variable short word short
: words ( a ) dup @ dup and if tag drop d# 1 + words ; then d# 4 bits
  drop drop ;
: range ( nn-an ) here/4 here4 push new for dup block words d# 1 + next
  drop 0 d# 31 bits drop pop here4 over negate + ;
: !lng ( nw ) [ d# 127 ] + [ d# 128 ] / [ d# 72 ] + dup ( nsec ) [ d#
  0 ] block [ d# 1 ] + ! dup negate [ ns ] ! [ d# 35 ] + [ d# 36 ] / [
  nc ] ! ;
: sve 7push d# 36 [ nblk @ d# -36 + ] range ( an ) !lng drop 0 block [
  d# 3000 ] block [ d# 36 blks ] move [ d# 3000 ] !work [ ns ] @ abs [
  ns ] ! 7pop ; [ d# 3036 block d# 4 * h ! sve ] }block

( 0021,5400 )               D# 85 shadow{ 

: short ( tag, then 28bit value+base )
: literal ( tag, then base )
: 32bits ( from next word. 2 chunks )
: variable ( single word, then 32-bits )
: /whit ( replaces a word's tag with 9, making it a lowercase comment.
  )
: tag ( identify kind of word ) [ note /whit used for tags h# 0000,000A
  and h# 0000,000B to convert these deprecated capitalized comments to
  lower case. when all source of interest has been compressed at least
  once this may be removed. ]
: words ( scan thru block. 8 0s eob )
: range ( process blocks, number and count. 31 0s eof )
: sve ( compress blocks 72 thru 1419 )
: flop ( write floppy; save number of cylinders ) }block

( 0021,5800 )               D# 86 code{ 
 ( compress ) [ macro ] ( uses ebx )
: b < ?dup > h# 0000,C38B 2, ;
: c! h# 0000,C88B 2, < drop > ;
: 2*d h# 00C3,A50F 3, ;
: 2*c h# 0000,E0D3 2, ;
: 2/r h# 0000,C8D3 2, ; [ forth ]
:# nb 19
: here/4 here d# 3 and if 1, here/4 ; then drop ;
: here4 here 2/ 2/ ;
: new d# 32 [ nb ] ! ;
: shift ( nn-n ) dup negate [ nb ] +! c! 2*d 2*c ;
: rbits dup c! swap 2/r swap
: bits ( nn-n ) dup negate [ nb ] @ + -if dup push + shift b , new pop
  negate shift ; then drop shift ;
: char -if 2* -if 2/ d# 7 bits ; then 2/ H# 8000,0000 or d# 5 bits ; then
  d# 4 bits ;
: chars dup and if char chars ; then ;
: 1word d# 4 rbits chars d# 4 bits ;
: word ( an-an ) d# 4 rbits
: cont chars over d# 1 + @ dup and if h# 0000,000F and drop if d# 4 bits
  ; then ; then drop d# 4 bits ; }block

( 0021,5C00 )               D# 87 shadow{ 

: b ( pop ebx, register 3, into eax )
: c! ( push eax into register 1, ecx )
: 2*d ( shift ebx left by ecx. bits from eax )
: 2*c ( shift eax left by ecx )
: 2/r ( rotate eax right by ecx )
: nb ( number of bits remaining in word )
: here/4 ( align to word boundary )
: here4 ( word address in dictionary )
: new ( 32-bits in current word )
: shift ( eax into ebx, decrement ) nb
: rbits ( rotate bits to high-order position )
: bits ( shift bits into ebx; cross word boundary )
: char ( examine high bits. shift 4, 5 or 7 bits )
: chars ( shift all non-zero characters )
: 1word ( short word without continuation for variable )
: word ( shift tag, then characters )
: cont ( continue without tag ) }block

( 0021,6000 )               D# 88 code{ 
 ( display text ) [ macro ]
: 7@+ ( -a ) < ?dup > h# 0000,C78B 2, h# 0000,0047 1, ;
: 7dec h# 0000,004F 1, ;
: @ret ( -b ) < ?dup > h# 0024,048B 3, H# 0524,0483 , ;
: 4@ ( b-n ) h# 0000,008B 2, ; [ forth ]
: tick ( b-b ) dup [ d# 1 ] + 4@ + d# 5 + ;
: call h# 0000,00E8 { -cr }

: dst 1, @ret tick here d# 3 + - + , ;
: jmp h# 0000,00E9 dst ; { br }

: .shan ( n- ) dup and if unpack emit .shan ; then drop ; { -cr }

: +str ( a-a ) + ; [ macro ]
: ,lit ( n ) < ?dup > h# 0000,00B8 1, , ;
: strings ( i-a ) 7push pop < ,lit > jmp +str nop ;
: .' ( comment ) 7@+ @ d# -16 and < ,lit > call .shan nop ; [ forth ]
  { br }

: ' ( -b ) -kbd if 7@+ @ itick if abort then ; { cr }
 then tic ;
: execute ( b ) push ;
: eval ( a ) 7push [ d# 1 ] + push 7pop [ sp d# 1 + ] @ execute 7pop ;
  }block

( 0021,6400 )               D# 89 shadow{ 
 ( these definitions support text display and are used in other parts
  of okad as well. ) { br }

: 7@+ ( interpret only, returns adr of next word in block and skips over
  it ... 7-0-mov 7-inc )
: 7dec ( used to correct address after 7@+ )
: @ret ( fetch return address, skip bytes of code. )
: 4@ ( cell fetch on byte boundary )
: tick ( given adr of call instr, return tgt adr )
: call ( and ) jmp ( generate xfers to next word ) { br }

: .shan ( displays a shannon coded string )
: ,lit ( compiles a literal. )
: .' ( displays the following one-word comment. ) { br }

: strings ( starts an array of words in source. )
: ' ( interp only, returns next word's code addr. )
: execute ( is a call to the given routine adr. )
: eval ( interprets the source word whose address is given. ) }block

( 0021,6800 )               D# 90 code{ 
 ( disk audit utility ) [ empty d# 30 load ]
:# bias 0 { cr }

:# sep 3000 [ d# 3000 sep ! ]
:# head 1439 [ d# 1439 head ! ]
: +blocks ( sdn ) 2* ( bloks ; )
: bloks ( sdn ) push swap block swap block pop [ d# 256 ] * move ; { -cr
  }

: n18 ( i-a ) [ d# 3018 block ] + ;
: wipe [ blk ] @ d# 1 erase ( e ) lis ; { -cr }

: to ( n ) [ head ] ! ;
: obliterate ( lh ) over negate + erase ;
: matching ( sd ) less if swap then dup [ bias ] ! negate + [ sep ] !
  ;
: cast ( nm-n' ) dup push /mod d# 1 or pop * + ;
: other ( n-n' ) [ bias ] @ negate + [ sep ] @ cast [ bias ] @ + ;
: lesser ( n-n ) dup other min ; [ d# 92 load ]
: ?blk ( n-n?n+ ) lesser dup block over other block [ d# 256 ] for over
  @ over @ or drop if drop drop dup [ d# 1 ] + pop drop ; then [ d# 1
  ] + [ d# 1 ] u+ next drop drop [ d# 1 ] + ; { -cr }

: ?blks ( sn-? ) for ?blk next drop ;
: ?bin ( kernel ) d# 0 d# 12 ?blks ( icons ) d# 12 d# 6 ?blks ;
: unpk abs [ d# 1 n18 ] ! [ d# 3036 ] block [ d# 5000 ] block [ d# 1404
  ] blks move [ d# 5000 block ] d# 3036 [ d# 3 n18 ] @ [ d# -36 ] + range
  ;
: check [ d# 3000 ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or drop if
  ; then [ d# 1 n18 ] @ dup and -if unpk ; then drop ; }block

( 0021,6C00 )               D# 91 shadow{ 
 ( disk mgmt and reconciliation utility. )
: bloks ( copies n blocks from s to d, front to back so only moves overlap
  downward safely. )
: +blocks ( copies n blocks and their shadows. )
: obliterate ( wipes from block l to block h. )
: matching ( sets up to match s to d. )
: to ( sets block no. past end of source area. )
: other ( given a block number in one of the areas returns the corresponding
  block no. in the other area. )
: lesser ( given a block number returns the lesser of the pair it is a
  member of )
: ?blks ( scans a range of blks leaving nos of any differing blks on the
  stack. )
: ?bin ( scans the binary parts of okad disk. )
: check ( reads backup to { 0001,770F } and decompresses if appropriate
  ) }block

( 0021,7000 )               D# 92 code{ 
 ( compare )
: blink ( n ) dup other [ blk ] ! edit ;
: var ( nnxx-nnd ) push push d# 1 + d# 1 u+ pop pop
: *1 ( nnxx-nnd ) or ;
: *2 ( nnxx-nnd ) var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# 0000,000F and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1
  *1 *1 var *1 *1 *1
: +or ( nn-n ) over - and or ;
: ?nul ( nnxx-nnxx ) over over +or drop if ; then drop drop pop drop drop
  drop ;
: co ( naa-n ) over @ over @ ?nul tag drop if drop drop blink ; then d#
  1 + d# 1 u+ co ;
: com ( n-n ) dup block over other block co ;
: g blk @ lesser
: gg ( n ) [ head ] @ over - + drop -if drop ; then [ d# 1 ] + com gg
  ;
: v [ blk ] @ other edit ;
: give blk @ dup other d# 1 bloks ;
: take blk @ dup other swap d# 1 bloks ;
: check [ d# 3000 ] @back ;
: all d# 0 [ d# 3000 ] matching [ nblk ] @ [ d# -1 ] + to [ d# 17 ] gg
  ; }block

( 0021,7400 )               D# 93 shadow{ 

: blink ( displays the given block with its other set as the editor's
  'other' block )
: var ( compares a variable name, advancing pointers to skip its value.
  )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compares source cells given, true if diff, advancing ptrs and
  ignoring variable vals. )
: ?nul ( ends loop in co if nuls hit in both blks. )
: co ( does work of com given adrs of both blks. )
: com ( invokes editor to blink the given block if it differs from the
  other, otherwise returns. )
: g ( scans for diffs after current editor block. )
: v ( shows the other block )
: give ( writes current editor block over its twin )
: take ( writes twin over current editor block. )
: check ( reads backup to 3000 for matching. )
: all ( scans the whole usable area of the disk. ) }block

( 0021,7800 )               D# 94 code{ 
 }block

( 0021,7C00 )               D# 95 shadow{ 
 }block

( 0021,8000 )               D# 96 code{ 
 ( native async ) [ d# 96 orgn ! macro ]
: 1@ ( b-c ) h# 0000,008A 2, ;
: 1! ( cb ) < a! > h# 0000,0288 2, < drop > ;
: 2@ ( b-h ) h# 0000,8B66 3, ;
: 2! ( hb ) < a! > h# 0002,8966 3, < drop > ;
: 4@ ( b-n ) h# 0000,008B 2, ;
: 4! ( nb ) < a! > h# 0000,0289 2, < drop > ;
: swab ( h-h ) h# 0000,C486 2, ;
: swa4 ( n-n ) h# 0000,C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ;
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ;
: rez ( n ) h +! ;
: +or ( nn-n ) over - and or ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br
  }

:# act 0
:# vport 373
:# 0tg 1
:# 1tg 1
:# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] ! ; {
  br }
 ( ser ) [ d# 98 load d# 118 load ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load ] ( canon ) [ d# 138 load ] }block

( 0021,8400 )               D# 97 shadow{ 
 ( talk to chip via native rs232. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure given
  byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
  in dictionary. ) [ note that writing into such allocations invalidates
  nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. ) {
  br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021,8800 )               D# 98 code{ 
 ( async umbilical ) [ h# 0000,03F8 ] ( serial ) [ d# 60 load ]
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 16384 rez ]
:# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }

: @18 ( -n ) /str 4@ [ h# 0003,FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 0003,FFFF ] or [ h# 0000,0040 ] * [ h# 0000,0012 ] +
  /str 4! +wd ; { br }

: +sea ( -ok ) init d# 1 [ d# 0 ] + ;
: -sea ;
: reset [ d# 2 ] st! [ d# 100000 ] for next [ d# 0 ] st! ;
: tosea ( bn ) for dup 1@ xmit [ d# 1 ] + next drop ;
: insea ( w ) stream swap [ d# 3 ] * for { indent }
 rcv over 1! [ d# 1 ] + next drop ; }block

( 0021,8C00 )               D# 99 shadow{ 
 ( async data are 18 bits per 3 bytes. to chip word inverted, shifted
  up 6, '12' inserted, then sent low order byte first. from chip are tbd.
  ) { br }

: sport ( com port address )
: 4@ ( and ) 4! ( full cell on byte address. )
: +sea ( opens serial; true if good, handle in dh. )
: -sea ( closes the handle. )
: /sea ( resets the chip. )
: tosea ( transmits n bytes to chip. )
: insea ( receives w g18 words from the chip. ) { br }

: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be present!
  ) }block

( 0021,9000 )               D# 100 code{ 
 ( onspec usb interface ) [ d# 100 orgn ! macro ]
: 1@ ( b-c ) h# 0000,008A 2, ;
: 1! ( cb ) < a! > h# 0000,0288 2, < drop > ;
: 2@ ( b-h ) h# 0000,8B66 3, ;
: 2! ( hb ) < a! > h# 0002,8966 3, < drop > ;
: swab ( h-h ) h# 0000,C486 2, ;
: swa4 ( n-n ) h# 0000,C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ;
: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: bofs ( bw-b'b ) over + swap ;
: ofs ( bw-b'a ) bofs b-a ;
: create ( -a ) pop b-a ;
: rez ( n ) h +! ;
: +or ( nn-n ) over - and or ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br
  }

:# act 0
:# vport 325
:# 0tg 1
:# 1tg 1
:# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] ! ; {
  br }
 ( usb ) [ d# 102 d# 5 loads ] ( routes ) [ d# 112 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load ] ( canon ) [ d# 138 load ] }block

( 0021,9400 )               D# 101 shadow{ 
 ( talk to seaforth via onspec usb. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure given
  byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
  in dictionary. ) [ note that writing into such allocations invalidates
  nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. ) {
  br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021,9800 )               D# 102 code{ 
 ( find/open/close onspec )
: nam ( -a ) align create ( //./ ) [ H# 2F2E,2F2F , ] ( d' ) [ h# 0000,3A47
  , ]
: obuf ( -a ) align create [ d# 512 rez ]
:# len 100
: spq ( -a ) align create [ d# 0 , d# 0 , d# 0 , ]
: inq ( -ok ) [ len ] d# 512 obuf d# 12 spq h# 002D,1400 [ dh ] @ fioctl
  ; { br }

: -sea [ dh ] @ [ d# 0 ] + if fclose d# 0 then [ dh ] ! ;
: ?sea ( -t ) obuf dup [ d# 3 ] + @ b-a + dup @ [ H# 6641,4553 ] or swap
  [ d# 1 ] + @ [ H# 6874,726F ] or +or ?zero ;
: +sea ( -ok ) h# 0000,3A44 [ nam d# 1 + ] ! d# 20 for nam r/w fopen [
  dh ] ! if inq drop if ?sea if pop drop ; then drop then then -sea d#
  1 [ nam d# 1 + ] +! next d# 0 ; }block

( 0021,9C00 )               D# 103 shadow{ 

: nam ( pathname buffer )
: spq ( argument for inquiry )
: obuf ( buffer for inquiry return )
: len ( bytes returned from fioctl calls ) { br }

: inq ( makes device inquiry, returns true if ok )
: ?sea ( true with indic if reply vendor seaforth ) { cr }

: +sea ( finds a forthdrive. true if found, handle in dh. )
: -sea ( closes the handle. ) }block

( 0021,A000 )               D# 104 code{ 
 ( scsi operations )
: /sdb ( -n ) [ d# 28 d# 16 + d# 32 + d# 16 d# 1024 * + ] ; { br }

: sdb align create [ /sdb rez ] ( struc ) [ sdb a-b ]
: nsdb ( -b ) [ d# 2 bofs ] ; ( sstat ) [ d# 1 + d# 3 + ]
: ncdb ( -b ) [ d# 1 bofs ] ; ( nsns ) [ d# 1 + ]
: i/o ( -b ) [ d# 1 bofs ] ; [ d# 3 + ]
: ndata ( -a ) [ d# 4 ofs ] ;
: nto ( -a ) [ d# 4 ofs ] ;
: 'data ( -a ) [ d# 4 ofs ] ;
: 'sns ( -a ) [ d# 4 ofs ] ;
: cdb ( -b ) [ d# 16 bofs ] ; ( sns ) [ d# 32 + ]
: sdat ( -b ) [ d# 16 d# 1024 * bofs ] ; [ drop ] { br }

: !cdb ( an ) d# 0 sdb [ d# 28 d# 16 + d# 32 + b-a ] fill [ d# 28 d# 16
  + dup ] nsdb 2! [ dup ] 'sns ! [ d# 32 + ] 'data ! d# 20 [ nto ] ! dup
  [ ncdb ] 1! [ cdb b-a ] swap b-a move ;
: !xfer ( ni ) [ i/o ] 1! [ ndata ] ! ;
: /scsi ( -ok ) [ len ] /sdb sdb over over h# 0004,D004 [ dh ] @ fioctl
  ; }block

( 0021,A400 )               D# 105 shadow{ 

: /sdb ( total length of scsi structure, bytes ) { br }

: sdb ( scsi structure word adr unless -b )
: nsdb ( -b length in bytes thru cdb )
: ncdb ( -b length of cdb in bytes )
: i/o ( -b 0 out 1 in 2 no data )
: ndata ( -a length in bytes of data transfer )
: nto ( -a timeout in seconds )
: 'data ( -a offset in bytes to sdat )
: 'sns ( -a offset in bytes to sns )
: cdb ( -b scsi command )
: sdat ( -b scsi data ) { br }

: !cdb ( initializes sdb for cmd whose word adr and byte lng are given.
  data xfer params must be set before /scsi. )
: !xfer ( sets length in bytes and direction of data transfer. )
: /scsi ( executes scsi command returning api status not necessarily scsi
  status. ) }block

( 0021,A800 )               D# 106 code{ 
 ( onspec vendor unique ops )
: /lok ( f-ok ) push [ len ] d# 0 d# 0 d# 0 d# 0 pop [ dh ] @ fioctl ;
: lok [ h# 0009,0018 ] /lok drop ;
: -lok [ h# 0009,001C ] /lok drop ;
: scsi ( -ok lok ) /scsi ( -lok ) [ d# 0 ] + ; { br }

: /os align create [ h# 0000,FA20 , h# 0000,0000 , h# 0000,0000 2, ]
: wos align create [ h# 0000,FB20 , h# 0000,0000 , h# 0000,0000 2, ]
: wos! align create [ h# 0002,FB20 , h# 0000,0000 , h# 0000,0000 2, ]
: ros align create [ h# 0001,FB20 , h# 0000,0000 , h# 0000,0000 2, ]
: !nbits ( h ) swab [ cdb d# 7 + ] 2! ; { br }

: /sea ( -ok ) /os d# 10 !cdb d# 0 d# 2 !xfer scsi drop ;
: tosea ( wbo ) d# 10 !cdb !nbits 2* d# 0 !xfer scsi drop ;
: insea ( w ) ros d# 10 !cdb [ d# 18 ] * dup !nbits [ d# 14 ] + [ d# 16
  ] / 2* d# 1 !xfer scsi drop ;
: mute -lok -sea ; }block

( 0021,AC00 )               D# 107 shadow{ 

: lok ( and ) -lok ( perform the lock and unlock volume functions that
  are apparently required around a scsi command. )
: scsi ( executes a scsi passthrough command with proper lock protection.
  ) { br }
 ( onspec custom scsi command blocks- )
: /os ( cycles chip power and resets it. )
: wos ( writes synch to chip )
: wos! ( writes and leaves lines tristate. )
: ros ( reads synch from chip. )
: !nbits ( sets bit count field in command, limit 32 or 64k ) { br }

: /sea ( resets the chip. )
: tosea ( transmits w halfwords, b bits with op ) [ wos ] ( or ) [ wos!
  ] ( as you wish. )
: insea ( receives w g18 words from the sync boot node. the data in our
  memory are in onspec format both directions. )
: mute ( properly closes the handle. ) }block

( 0021,B000 )               D# 108 code{ 
 ( onspec bitstream )
:# bi 180 [ macro ]
: 4@ ( b-n ) h# 0000,008B 2, ;
: 4! ( nb ) < a! > h# 0000,0289 2, < drop > ;
: swah ( n-n ) h# 0000,00C1 1, h# 0000,10C8 2, ; [ forth ]
: lsh ( ni-n ) d# 0 + if for 2* next ; then drop ;
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ; { br }

: -stream d# 0 [ bi ] ! ;
: stream ( -wb ) [ bi ] @ dup [ d# 15 ] + [ d# 16 ] / swap ;
: /str ( -bi ) [ bi ] @ [ d# 16 ] /mod 2* [ sdat ] + swap - [ d# 15 ]
  + ; { cr }

: @18 ( -n ) /str push 4@ swah pop rsh [ h# 0003,FFFF ] and
: +wd d# 18 [ bi ] +! ;
: !18 ( n ) [ h# 0003,FFFF ] and /str swap push i 4@ swah push push i
  lsh h# FFFC,0000 pop lsh pop and or swah pop 4! +wd ; }block

( 0021,B400 )               D# 109 shadow{ 
 ( onspec data are a continuous stream of bits in consecutive bytes, left
  to right, except that bytes are swapped in halfcell units. cell fetched
  on any halfcell boundary and half-swapped has continuous bits running
  from hi to lo. ) { br }

: 4@ ( and ) 4! ( full cell on byte address. )
: lsh ( and ) rsh ( left and right arith shifts. )
: swah ( swaps hi and lo halfcells of a number. ) { br }

: -stream ( clears bit index ) bi ( in sdat buffer. )
: stream ( halfcells and bits within index. )
: /str ( cell addr, shift count for next 18. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be present!
  ) }block

( 0021,B800 )               D# 110 code{ 
 ( node { 0000,258F } sync boot frames )
: /frame ( nw xfr jmp ) -stream [ h# 0001,0000 ] + !18 !18 [ d# 1 ] +
  2/ ( words ) 2* ( actual { FFFF,FFEF } + ) !18 ;
: +frame ( wn ) for dup @ !18 [ d# 1 ] + next drop ;
: +ram ( w n node ) nn-n 2* [ h# 0000,8000 ] + block u+ for dup @ [ h#
  0001,5555 ] or !18 [ d# 1 ] + next drop ;
: !frame ( op ) push stream pop tosea ; { br }

: exec [ h# 0000,00B6 ] ;
: talk cold mute +sea if lok drop /sea h# 0000,0040 d# 0 [ exec ] /frame
  h# 0000,0000 h# 0000,0040 { 0000,022F } d# 300 +ram [ wos ] !frame (
  good ) ; then ( bad ) -sea ; { br }

: exch ( w n f n ) push push dup [ h# 0000,0002 ] + [ d# -2 ] and [ vport
  ] @ pop /frame [ vport ] @ [ h# 0001,2000 ] + !18 dup - [ h# 0000,0001
  ] and drop if [ vport ] @ [ h# 0001,0000 ] + !18 then +frame wos! !frame
  pop insea -stream ; { br }

: ok [ h# 0000,0018 ] ;
: fet [ h# 0000,001C ] ;
: stat [ h# 0000,0023 ] ;
: bstk [ h# 0000,0025 ] ; }block

( 0021,BC00 )               D# 111 shadow{ 
 ( boot frames begin with a 3 word header; ) { indent }
 100xx ( jump to xx when done ) { indent }
 ddd ( mem/port adr to store payload ) { indent }
 nnn ( transfer length ) { indent }
 [ nnn+1 * 2 ] ( words of payload )
: /frame ( heads a new given ) [ even ] ( words of payload, destination
  addr, final jump addr. )
: +frame ( appends words to payload. )
: +ram ( appends a string of code from binary produced by ) compile (
  for the given ) [ node. ]
: !frame ( transmits frame given ) [ wos ] ( or ) [ wos! ] { br }

: talk ( prepares chip for control thru node 19. )
: exch ( performs a transaction with target given addr and length of port
  stream, stream end action in node 19, and number of words reply. ) {
  br }

: ok ( stream end to simply ack completion; ) fet ( pumps one word from
  target; ) bstk ( shepherds stack dump; ) stat ( pumps ten. ) exec (
  is next boot frame. ) }block

( 0021,C000 )               D# 112 code{ 
 ( route lists )
: 0pa align create [ d# 300 , d# 400 , d# 17 , d# 27 , d# 37 , d# 36 ,
  d# 35 , d# 34 , d# 33 , d# 32 , d# 31 , d# 30 , d# 20 , d# 10 , d# -1
  , ] { br }

: 1pa align create [ d# 300 , d# 301 , d# 17 , d# 16 , d# 15 , d# 14 ,
  d# 13 , d# 12 , d# 11 , d# 21 , d# 22 , d# 23 , d# 24 , d# 25 , d# 26
  , d# -1 , ] { br }

: 2pa align create [ d# 300 , d# 200 , d# 17 , d# 7 , d# 6 , d# 5 , d#
  4 , d# 3 , d# 2 , d# 1 , d# 11 , d# 10 , d# 20 , d# 30 , d# 31 , d#
  32 , d# 33 , d# 34 , d# 35 , d# 36 , d# 37 , d# 27 , d# 26 , d# 25 ,
  d# 24 , d# 23 , d# 22 , d# 12 , d# 13 , d# 14 , d# 15 , d# 16 , d# 17
  , d# -1 , ] { br }
 }block

( 0021,C400 )               D# 113 shadow{ 

: 0pth 1pth 2pth ( are manually set route lists for using the north, south,
  and west ports of node 19. end list is marked by -1 ) { br }
 ( this block has plenty of extra room so that you may customize the available
  lists without changing the reference versions. ) }block

( 0021,C800 )               D# 114 code{ 
 ( windows async ) [ d# 114 orgn ! macro ]
: 1@ ( b-c ) h# 0000,008A 2, ; { -cr }

: 1! ( cb ) < a! > h# 0000,0288 2, < drop > ;
: 2@ ( b-h ) h# 0000,8B66 3, ; { -cr }

: 2! ( hb ) < a! > h# 0002,8966 3, < drop > ;
: 4@ ( b-n ) h# 0000,008B 2, ; { -cr }

: 4! ( nb ) < a! > h# 0000,0289 2, < drop > ;
: swab ( h-h ) h# 0000,C486 2, ;
: swa4 ( n-n ) h# 0000,C80F 2, ; [ forth ]
: a-b ( a-b ) 2* 2* ; { -cr }

: b-a ( b-a ) [ d# 3 ] + 2/ 2/ ;
: create ( -a ) pop b-a ; { -cr }

: rez ( n ) h +! ;
: +or ( nn-n ) over - and or ;
: ?zero ( n-n ) [ d# 0 ] or if dup or ; then ( - ) [ d# -1 ] or ; { br
  }

:# act 0
:# vport 373
:# 0tg 1
:# 1tg 1
:# 2tg 1
: cold d# 1 [ 0tg ] ! d# 1 [ 1tg ] ! d# 1 [ 2tg ] ! d# 0 [ act ] ! ; {
  br }
 ( ser ) [ d# 116 d# 2 loads ] ( routes ) [ d# 120 load ] { cr }
 ( generic ) [ d# 122 d# 6 loads ] ( panel ) [ d# 134 load ] { cr }
 ( user ) [ d# 136 load ] ( canon ) [ d# 138 load ] }block

( 0021,CC00 )               D# 115 shadow{ 
 ( talk to chip via onspec usb. ) { br }

: 1@ ( and ) 1! ( byte fetch and store, byte address. )
: 2@ ( and ) 2! ( halfcell fetch/store, byte adr. )
: swab ( and ) swa4 ( 2-way and 4-way byte swaps. )
: a-b ( and ) b-a ( convert cells to+from bytes. ) { br }

: bofs ( and ) ofs ( make byte and cell offset adrs in a structure given
  byte posn and byte width. )
: create ( used after ) [ align ] ( to exit with word adr of cell following
  in dictionary. ) [ note that writing into such allocations invalidates
  nearby instruction cache! ]
: rez ( allots n bytes in the dictionary. )
: +or ( inclusive or. )
: ?zero ( classical zero-equal returning 0 or -1 with indicators. ) {
  br }

: ntgt ( indices for active paths, 1 for adjacent. )
: act ( number of selected path, to which ) vport ( leads. )
: cold ( sets no active paths. )
: user ( test code before canonicals. ) }block

( 0021,D000 )               D# 116 code{ 
 ( async umbilical )
:# sport 18 [ d# 18 sport ! ]
: rsh ( ni-n ) d# 0 + if for 2/ next ; then drop ;
: sdat align create [ d# 24576 rez ]
:# bi 30
: -stream d# 0 [ bi ] ! ;
: stream ( -b ) [ sdat a-b ] ;
: /str ( -b ) [ bi ] @ [ stream ] + ; { br }

: @18 ( -n ) /str 4@ [ h# 0003,FFFF ] and
: +wd d# 3 [ bi ] +! ;
: !18 ( n ) [ h# 0003,FFFF ] or [ h# 0000,0040 ] * [ h# 0000,0012 ] +
  /str 4! +wd ; { br }

: snam ( -a ) align create ( //./ ) [ H# 2F2E,2F2F , ] ( com ) [ h# 006D,6F63
  , h# 0000,0000 , ]
: !nam [ sport ] @ d# 10 over - + drop -if d# 256 * d# 2560 /mod + h#
  0000,3000 + then h# 0000,0030 + snam a-b d# 7 + 4! ; [ !nam ]
: +sea ( -ok ) snam r/w fopen [ dh ] ! if d# 1 ; then d# 0 ;
: -sea [ dh ] @ [ d# 0 ] + if fclose d# 0 then [ dh ] ! ;
: ctl! ( n ) [ dh ] @ fesc drop ;
: reset [ d# 3 ] ctl! [ d# 500000 ] for next [ d# 4 ] ctl! ;
: tosea ( bn ) [ dh ] @ fwr drop ;
: insea ( w ) stream swap [ d# 3 ] * [ dh ] @ frd drop ; }block

( 0021,D400 )               D# 117 shadow{ 
 ( async data are 18 bits per 3 bytes. to chip word inverted, shifted
  up 6, '12' inserted, then sent low order byte first. from chip are tbd.
  ) { br }

: sport ( comp com port number )
: 4@ ( and ) 4! ( full cell on byte address. )
: snam ( null terminated string //./comx )
: !nam ( sets port number in snam. )
: +sea ( opens serial; true if good, handle in dh. )
: -sea ( closes the handle. )
: /sea ( resets the chip. )
: tosea ( transmits w halfwords, b bits with op ) [ wos ] ( or ) [ wos!
  ] ( as you wish. )
: insea ( receives w g18 words from the sync boot node. ) { br }

: -stream ( clears byte index ) bi ( in ) sdat ( buffer. )
: stream ( byte adr of buffer. )
: /str ( byte adr of next 18-bit slot in buff. ) { br }

: @18 ( returns the next 18 bits from the stream. )
: !18 ( appends 18 bits to the stream. no higher order bits may be present!
  ) }block

( 0021,D800 )               D# 118 code{ 
 ( node { 0000,588F } boot frames )
: wos ( -n ) d# 0 ;
: /frame ( nw xfr jmp ) -stream [ h# 0001,0000 ] + !18 !18 [ d# 1 ] +
  2/ ( words ) 2* ( actual { FFFF,FFEF } + ) !18 ;
: +frame ( wn ) for dup @ !18 [ d# 1 ] + next drop ;
: +ram ( w n node ) nn-n 2* [ h# 0000,8000 ] + block u+ for dup @ [ h#
  0001,5555 ] or !18 [ d# 1 ] + next drop ;
: !frame ( f ) drop stream [ bi ] @ tosea ; { br }

: exec [ h# 0000,00AE ] ;
: talk cold -sea +sea if drop reset h# 0000,0040 d# 0 [ exec ] /frame
  h# 0000,0000 h# 0000,0040 { 0000,042F } d# 708 +ram [ wos ] !frame (
  good ) ; then ( bad ) -sea ; { cr }

: exch ( w n f n ) push push dup [ h# 0000,0002 ] + [ d# -2 ] and [ vport
  ] @ pop /frame [ vport ] @ [ h# 0001,2000 ] + !18 dup - [ h# 0000,0001
  ] and drop if [ vport ] @ [ h# 0001,0000 ] + !18 then +frame [ wos ]
  !frame pop insea -stream ; { br }

: ok [ h# 0000,0012 ] ;
: fet [ h# 0000,0015 ] ;
: stat [ h# 0000,001B ] ;
: bstk [ h# 0000,001D ] ; }block

( 0021,DC00 )               D# 119 shadow{ 
 ( boot frames begin with a 3 word header; ) { indent }
 100xx ( jump to xx when done ) { indent }
 ddd ( mem/port adr to store payload ) { indent }
 nnn ( transfer length ) { indent }
 [ nnn+1 * 2 ] ( words of payload )
: /frame ( heads a new given ) [ even ] ( words of payload, destination
  addr, final jump addr. )
: +frame ( appends words to payload. )
: +ram ( appends a string of code from binary produced by ) compile (
  for the given ) [ node. ]
: !frame ( transmits frame given ) [ wos ] ( or ) [ wos! ] { br }

: talk ( prepares chip for control thru node 19. )
: exch ( performs a transaction with target given addr and length of port
  stream, stream end action in boot node, and number of words reply. )
  { cr }

: ok ( stream end to simply ack completion; ) fet ( pumps one word from
  target; ) bstk ( shepherds stack dump; ) stat ( pumps ten. ) exec (
  is next boot frame. ) }block

( 0021,E000 )               D# 120 code{ 
 ( node { 0000,588F } route lists )
: 0pa align create [ d# 708 , d# 707 , d# 706 , d# 705 , d# 704 , d# 703
  , d# 702 , d# 701 , d# 700 , d# 600 , d# 500 , d# 400 , d# 300 , d#
  200 , d# 100 , d# 0 , d# 1 , d# 2 , d# 3 , d# 4 , d# 5 , d# 6 , d# 7
  , d# 8 , d# 9 , d# 10 , d# 11 , d# 12 , d# 13 , d# 14 , d# 15 , d# 16
  , d# 17 , d# 117 , d# 217 , d# 317 , d# 417 , d# 517 , d# 617 , d# 717
  , d# 716 , d# 715 , d# 714 , d# 713 , d# 712 , d# 711 , d# 710 , d#
  709 , d# 708 , d# -1 , ]
: 1pa align create [ d# 708 , d# 608 , d# -1 , ]
: 2pa align create [ d# 708 , d# 709 , d# 710 , d# 711 , d# 712 , d# 713
  , d# 714 , d# 715 , d# 716 , d# 717 , d# 617 , d# 517 , d# 417 , d#
  317 , d# 217 , d# 117 , d# 17 , d# 16 , d# 15 , d# 14 , d# 13 , d# 12
  , d# 11 , d# 10 , d# 9 , d# 8 , d# 7 , d# 6 , d# 5 , d# 4 , d# 3 , d#
  2 , d# 1 , d# 0 , d# 100 , d# 101 , d# 102 , d# 103 , d# 104 , d# 105
  , d# 106 , d# 107 , d# 108 , d# 109 , d# 110 , d# 111 , d# 112 , d#
  113 , d# 114 , d# 115 , d# 116 , ] { cr }
 ( rest ) [ d# 140 load ] }block

( 0021,E400 )               D# 121 shadow{ 

: 0pth 1pth 2pth ( are manually set route lists for using the north, south,
  and west ports of node 19. end list is marked by -1 ) { br }
 ( this block has plenty of extra room so that you may customize the available
  lists without changing the reference versions. ) }block

( 0021,E800 )               D# 122 code{ 
 ( boot target adjacent )
: wall ( nn-i ) over over or [ d# 1 ] and drop if or [ d# 2 ] and ; then
  { 0000,014F } [ d# 100 ] / swap { 0000,014F } [ d# 100 ] / or [ d# 2
  ] and [ d# 1 ] + ; { br }

: do! align create ( @p+a!.@p+ ) [ h# 0000,4AB7 , ] { indent }
 [ h# 0000,0000 , h# 0000,0000 , ] ( !;;; ) [ h# 0000,B555 , ]
: do@ align create ( ...@p+ ) [ h# 0002,C9B7 , ] { indent }
 [ h# 0000,0000 , ] ( a!@!p+; ) [ h# 0002,BE35 , ]
: doi align create [ h# 0001,0000 , ]
: dopu align create ( @p+; ) [ h# 0000,5555 , h# 0000,0000 , ]
: dostk align create ( !p+dup-push!p+ ) [ h# 0000,CDBE , ] { br }

: aa@ ( a-n ) [ do@ d# 1 + ] ! do@ [ d# 3 ] fet [ d# 1 ] exch @18 ;
: aa! ( na ) [ do! d# 1 + ] ! [ do! d# 2 + ] ! do! [ d# 4 ] ok [ d# 1
  ] exch ;
: acall ( a ) [ h# 0001,0000 ] +
: ains ( w ) [ doi ] ! doi [ d# 1 ] ok [ d# 1 ] exch ;
: apsh ( n ) [ dopu d# 1 + ] ! dopu [ d# 2 ] ok [ d# 1 ] exch ;
: astk dostk [ d# 1 ] bstk [ d# 10 ] exch ; }block

( 0021,EC00 )               D# 123 shadow{ 
 ( this code supports boot node controlling one of its immediate neighbors
  directly. ) [ these all begin with focusing call and each must return!
  ] { cr }

: port ( returns port for 0-3 rdlu ndx, then edges )
: wall ( is index for port between two nodes ) { br }

: doxxx ( port execution templates for target. )
: aa@ ( fetches from memory or port in target onto our stack here. )
: aa! ( stores a value from our stack here to port or memory in target.
  )
: ains ( executes an arbitrary instruction word which must end by returning.
  )
: acall ( executes a target word which must return or jump to ports. )
: apsh ( pushes a number onto target stack. )
: astk ( queries target stack nondestructively. ) }block

( 0021,F000 )               D# 124 code{ 
 ( stream components )
:# 'pth 67522897
: nstream ( an-n'w ) swap [ 'pth ] ! [ d# -2 ] + -if [ d# 0 ] pop drop
  ; then ( pre ) [ d# 2 ] ;
: ?path ( i-n ) [ 'pth ] @ + @ ;
: side ( n-a ) [ 'pth ] @ + dup @ swap [ d# 1 ] + @ wall port ;
: /hdr ( w-w ) dup [ d# -2 ] and [ d# 0 ] side [ exec ] /frame ( pre )
  [ d# 0 ] side [ h# 0001,2000 ] + !18 [ d# -1 ] + dup [ d# 1 ] and drop
  if [ d# 0 ] side [ h# 0001,0000 ] + !18 then [ d# -1 ] + ; { br }

: +pump ( nw-nw ) [ d# -8 ] + ( @p+b!@p+@p+ ) [ h# 0000,4B17 ] !18 { cr
  }
 [ h# 0000,0001 ] side dup !18 dup [ h# 0001,0000 ] + !18 [ h# 0001,2000
  ] + !18 { cr }
 ( !b!b.@p+ ) [ h# 0000,9BB7 ] !18 ( w ) dup [ d# -1 ] + !18 { cr }
 ( dup-push-if ) [ h# 0002,4861 ] !18 ( @p+!b.unext ) [ h# 0000,5BB4 ]
  !18 ;
: +load ( w n nb nd ) push push ( @p+a!.@p+ ) [ h# 0000,4AB7 ] !18 ( a
  ) over !18 ( n ) [ d# -1 ] + !18 ( dup-push-if ) [ h# 0002,4861 ] !18
  { cr }
 ( @p+!+.unxt ) [ h# 0000,58B4 ] !18 pop pop +ram ;
: +post ( p @p+b!.@p+ ) [ h# 0000,4BB7 ] !18 [ d# 1 ] side !18 [ d# 0
  ] side !18 ( a!@p+push; ) [ h# 0002,BDBD ] !18 ( p ) !18 ; }block

( 0021,F400 )               D# 125 shadow{ 
 ( templates and load streams )
: 'pth ( current posn in path list of nodes. )
: nstream ( given addr of path tbl, nodes away, gives no of wire nodes
  and total stream length )
: ?path ( returns node number relative to current posn in selected path.
  )
: side ( gives adr of ) 0 ( near, ) 1 ( far side next node )
: /hdr ( starts a stream of given length; if odd, we leave out jump after
  waking 1st node. ) { br }

: +pump ( makes port pump thru next node; its ram load and init postamble
  must be out of w. )
: +load ( builds a program load from binary given node ram addr, word
  count, words to take from binary, and node number. caller must append
  any words not taken from binary. )
: +post ( follows a node's ram load to set b to out, a to in, and jump
  to ) p. }block

( 0021,F800 )               D# 126 code{ 
 ( umbilical plumbing )
: using ( nn ) wall port [ vport ] ! ;
: avail ( n-p ) nn-n idle ; { br }

: +path ( n'wn-n'w ) dup [ 'pth ] +! negate u+ ; { br }

: rip ( nw-nw ) [ d# 0 ] u+ if ( post ) [ d# -5 ] + +pump [ d# 1 ] +path
  rip [ d# -1 ] +path then [ d# 1 ] ?path avail +post ;
: rips ( an-n'w ) nstream over [ d# 13 ] * + [ d# 5 ] + /hdr rip
: hose ( nw ) drop drop d# 0 ?path d# 1 ?path using [ wos ] !frame ; {
  br }

: wire ( nw-nw ) [ d# 0 ] u+ if ( wire ) [ h# 0000,0016 d# 10 + negate
  ] + +pump [ d# 1 ] +path wire [ d# -1 ] +path ( wire ) h# 0000,0000
  [ h# 0000,0016 ] dup { 0000,00EF } d# 17 +load [ d# 0 ] side +post ;
  then ( last ) h# 0000,0000 [ h# 0000,0020 ] dup [ d# -1 ] + { 0000,00CF
  } d# 16 +load [ d# 1 ] side [ h# 0001,2000 ] + !18 [ d# 0 ] side +post
  ;
: wires ( an-n'w ) nstream over [ d# 18 ] ( lwire ) [ h# 0000,0016 + ]
  * + [ d# 10 ] ( llast ) [ h# 0000,0020 + ] + nop /hdr wire hose ; }block

( 0021,FC00 )               D# 127 shadow{ 
 ( this block creates and destroys umbilical wiring within the chip. )
  { br }

: using ( sets ) vport ( between given pair of nodes. )
: avail ( is idle pc val for given node. ) { br }

: +path ( steps ) pos ( to, ) neg ( away from target. ) { br }

: wires ( builds wire for path table ) [ a. ] ( entry zero is boot node.
  ) [ n ] ( is number of nodes away from boot in path; ) 0 ( no uut, )
  1 ( no wire, uut is meighbor, ) 2 ( neighbor is last guy, ) 3 [ n-2
  ] ( wire nodes then last guy. generates call at end of last guy pgm
  that last guy sends target for focus. )
: rips ( rips out a wire built by ) wire }block

( 0022,0000 )               D# 128 code{ 
 ( routing control )
: targets ( -a ) [ act ] @ align tbl [ 0tg , 1tg , 2tg , ]
: paths ( -a ) [ act ] @ align tbl [ 0pa , 1pa , 2pa , ] { br }

: path ( i ) [ act ] ! paths dup @ swap [ d# 1 ] + @ wall port [ vport
  ] ! ;
: node ( n ) [ d# 3 ] for i [ d# -1 ] + path paths targets @ + @ over
  or drop while next drop ; then pop drop drop ; { br }

: -hook ( i ) path targets @ [ d# 1 ] or drop if paths targets @ rips
  [ d# 1 ] targets ! then ;
: hook ( i n ) swap -hook [ d# 2 ] begin over over paths + @ or drop while
  dup paths + @ [ d# 0 ] + drop -if drop drop ; then [ d# 1 ] + end then
  dup targets ! paths swap wires drop ; { br }

: ?adj pop [ d# 1 ] + dup 4@ swap [ d# 4 ] + targets @ d# 1 or drop if
  push drop ; then + push ; }block

( 0022,0400 )               D# 129 shadow{ 
 ( these functions support route setup and selection for internal wiring.
  ) { br }

: targets ( table of target index variables. )
: paths ( table of route lists. ) { br }

: path ( selects active path ) [ i ] ( 0,1,2 )
: node ( selects path whose target is node ) [ n ] { br }

: -hook ( rips out any wiring on path ) [ i ]
: hook ( hooks up path ) [ i ] ( to node ) [ n ] ( ripping out any old
  wiring on that path. ) { br }

: ?adj ( executes following word and exits defn if selected path is to
  adjacent node, otherwise skips following word. ) }block

( 0022,0800 )               D# 130 code{ 
 ( target anywhere )
: dor! align create [ h# 0001,2005 , h# 0000,0000 , h# 0000,0000 , ]
: dor@ align create [ h# 0001,2000 , h# 0000,0000 , ]
: dori align create [ h# 0001,200A , h# 0000,0000 , ]
: dorp align create [ h# 0001,200D , h# 0000,0000 , ]
: dorst align create [ h# 0001,2010 , ]
: stak align create [ d# 40 rez ] { br }

: r@ ( a-n ) ?adj aa@ [ dor@ d# 1 + ] ! dor@ [ d# 2 ] fet [ d# 1 ] exch
  @18 ;
: r! ( na ) ?adj aa! [ dor! d# 1 + ] ! [ dor! d# 2 + ] ! dor! [ d# 3 ]
  ok [ d# 1 ] exch ;
: call ( a ) [ h# 0001,0000 ] +
: rins ( w ) ?adj ains [ dori d# 1 + ] ! dori [ d# 2 ] ok [ d# 1 ] exch
  ;
: lit' ( n ) ?adj apsh [ dorp d# 1 + ] ! dorp [ d# 2 ] ok [ d# 1 ] exch
  ;
: aupd astk
: @stk @18 ( s ) [ stak d# 1 + ] ! @18 ( t ) [ stak ] ! [ stak d# 2 +
  ] d# 8 for @18 over ! [ d# 1 ] + next drop ;
: upd ?adj aupd dorst [ d# 1 ] stat [ d# 10 ] exch @stk ;
: lit lit' upd ;
: boot ( a n nd ) nn-n swap push 2* d# 32768 + block over + swap begin
  over @ [ h# 0001,5555 ] or over r! [ d# 1 ] + [ d# 1 ] u+ next drop
  drop ; }block

( 0022,0C00 )               D# 131 shadow{ 
 ( these operations work on any target node. ) { br }

: dorx ( port templates for remote target. ) { br }

: r@ r! rins lit call ( are the specific names for the primitives using
  appropriate sequences for adjacent or remote target nodes. ) { br }

: boot ( loads code into current remote node from binary image for node
  ) [ nd ] ( from addr ) [ a ] ( in both image and ram for ) [ n ] ( words.
  ) }block

( 0022,1000 )               D# 132 code{ 
 ( remote instructions )
: compile recompile ;
: focus paths targets @ + dup @ swap d# -1 + @ wall port call ;
: virgin paths targets @ + @ avail call ; { br }

: rop ( n ) [ h# 0000,000A ] or [ d# 13 ] for 2* next ( ;s ) [ h# 0000,1555
  ] + rins upd ;
: @+ [ h# 0000,0009 ] rop ; { -cr }

: !+ [ h# 0000,000D ] rop ; { -cr }

: !b [ h# 0000,000E ] rop ;
: r+* [ h# 0000,0010 ] rop ;
: r2* [ h# 0000,0011 ] rop ; { -cr }

: r2/ [ h# 0000,0012 ] rop ;
: r- [ h# 0000,0013 ] rop ; { -cr }

: r+ [ h# 0000,0014 ] rop ;
: rand [ h# 0000,0015 ] rop ; { -cr }

: ror [ h# 0000,0016 ] rop ;
: rdrop [ h# 0000,0017 ] rop ; { -cr }

: rdup [ h# 0000,0018 ] rop ;
: rover [ h# 0000,001A ] rop ;
: ra! [ h# 0000,001F ] rop ; { -cr }

: ra@ [ h# 0000,001B ] rop ;
: rb! [ h# 0000,001E ] rop ; { br }

: io h# 0000,015D ; { -cr }

: data h# 0000,0141 ; { -cr }

: up h# 0000,0145 ;
: down h# 0000,0115 ; { -cr }

: left h# 0000,0175 ; { -cr }

: right h# 0000,01D5 ; }block

( 0022,1400 )               D# 133 shadow{ 
 ( single instruction words that may be executed by the target. these
  must end with return for s40 restriction compliance. ) { br }
 ( the following won't work on s40 due to bug 1. )
: r@p+ [ h# 0000,000C ] rop ;
: psh ( n ) r@p+ ( value ) rins ; }block

( 0022,1800 )               D# 134 code{ 
 ( indicator panel ) [ d# 135 load ] ( node stack / upd ) { .s br }
 ( path, via, hops, tgt - green selected ) { .pth br }
 ( mem dump / ?ram or ?rom ) { .ram }
 }block

( 0022,1C00 )               D# 135 shadow{ 
 ( code for panel )
: panel [ d# 134 ] list ;
: .s silver cr cr [ stak d# 6 + ] d# 4 for dup @ d# 5 h.n space [ d# 1
  ] + next [ d# -5 ] + cr d# 6 for dup @ d# 5 h.n space [ d# -1 ] + next
  drop ;
: ?color ( nn-nn ) over over or drop if silver ; then green ;
: .pth [ act ] @ cr d# 3 for cr i [ d# -1 ] + path [ act ] @ ?color .
  paths dup [ d# 1 ] + @ . targets @ dup . + @ . next path ; { br }

: /ram align create [ d# 64 a-b rez ]
: rsp ( n dup ) d# 1 and drop if sp/2 then ;
: .ram silver cr [ /ram ] d# 64 for i [ d# 7 ] and ?zero drop if cr space
  then i rsp dup @ d# 5 h.n i d# 1 and drop if space then [ d# 1 ] + next
  drop ; }block

( 0022,2000 )               D# 136 code{ 
 ( tester )
: ent d# 0 ;
: n6tst d# 0 d# 64 d# 6 boot ent call d# 0 r@ dup d# 123 + dup d# 0 r!
  d# 0 r@ or if abort then drop d# 0 r! ( upd ) ;
: rot ( n-n ) [ h# 0003,FFFF ] and 2* [ h# 0004,0000 ] /mod + ;
: sto ( n ) dup [ d# 63 ] for rot dup i r! -next drop { cr }
 [ d# 63 ] for rot i r@ over over or { indent }
 drop if i abort then drop -next drop ;
: pat ( n ) [ d# 18 ] for dup sto rot next drop ;
: ramtst d# 0 sto h# 0003,FFFF sto d# 1 pat h# 0003,FFFE pat ;
: one ( n ) d# 2 swap hook pause ( n6tst ) ramtst ;
: ?ok ( n-t ) [ 0pa @ nn-n ] or ;
: all ( n ) nn-n [ d# 1 ] + for i [ d# -1 ] + ?ok drop if i [ d# -1 ]
  + n-nn one then next ;
: !dac ( n i ) d# 2 swap hook h# 0000,0155 or io r! ;
: !dacs ( n ) dup d# 709 !dac dup d# 713 !dac dup d# 717 !dac dup d# 617
  !dac d# 117 !dac ;
: nn ( n-n ) d# -1 + dup !dacs ;
: ms d# 100000 * for next ;
: watch begin upd pause d# 1000 ms key? end ;
: ?ram d# 0
: suck ( a ) [ /ram ] d# 64 for over r@ over ! [ d# 1 ] + [ d# 1 ] u+
  next drop drop ;
: ?rom [ h# 0000,0080 ] suck ; }block

( 0022,2400 )               D# 137 shadow{ 
 ( this test routine tester loads and runs the code compiled for node
  6 on all other nodes except the root, stopping if a node crashes or,
  possibly, other failure criteria are met ) { br }

: one ( runs the test routine from node 6 compilation, entry point ) ent
  ( , on node ) [ n ] ( . aborts if we cannot write and read back memory.
  )
: all ( tries the test starting with node n and going down to node zero,
  skipping node 19. ) { br }

: watch ( displays live stack from current node. this and other interactive
  functions can be enabled in a running program by placing a definition
  like this in outer loop... )
: poll @b h# 0000,0200 and if up b! @b push ;' h# 0000,015D b! then drop
  ; { br }

: !dac ( sets given output value in node i )
: !dacs ( sets given value in all dacs. ) }block

( 0022,2800 )               D# 138 code{ 
 ( canonical words )
: @ ( a-n ) r@ ;
: ! ( na ) r! ; ( call lit upd rins boot !b already ok )
: +* r+* ;
: 2* r2* ;
: 2/ r2/ ;
: - r- ;
: + r+ ;
: and rand ;
: or ror ;
: drop rdrop ;
: dup rdup ;
: over rover ;
: a! ra! ;
: a ra@ ;
: b! rb! ; }block

( 0022,2C00 )               D# 139 shadow{ 
 ( the final step in loading the ide is to redefine the canonical forth
  words to operate on the target node. this is done as a separate step
  so that you may define any sort of exerciser before losing access to
  host colorforth words. ) }block

( 0022,3000 )               D# 140 code{ 
 ( node { 0000,588F } route lists contd ) { cr }
 [ d# 216 , d# 215 , d# 214 , d# 213 , d# 212 , d# 211 , ] { cr }
 [ d# 210 , d# 209 , d# 208 , d# 207 , d# 206 , d# 205 , ] { cr }
 [ d# 204 , d# 203 , d# 202 , d# 201 , d# 200 , ] { cr }
 [ d# 300 , d# 301 , d# 302 , d# 303 , d# 304 , d# 305 , ] { cr }
 [ d# 306 , d# 307 , d# 308 , d# 309 , d# 310 , d# 311 , ] { cr }
 [ d# 312 , d# 313 , d# 314 , d# 315 , d# 316 , ] { cr }
 [ d# 416 , d# 415 , d# 414 , d# 413 , d# 412 , d# 411 , ] { cr }
 [ d# 410 , d# 409 , d# 408 , d# 407 , d# 406 , d# 405 , ] { cr }
 [ d# 404 , d# 403 , d# 402 , d# 401 , d# 400 , ] { cr }
 [ d# 500 , d# 501 , d# 502 , d# 503 , d# 504 , d# 505 , ] { cr }
 [ d# 506 , d# 507 , d# 508 , d# 509 , d# 510 , d# 511 , ] { cr }
 [ d# 512 , d# 513 , d# 514 , d# 515 , d# 516 , ] { cr }
 [ d# 616 , d# 615 , d# 614 , d# 613 , d# 612 , d# 611 , ] { cr }
 [ d# 610 , d# 609 , d# 608 , d# 607 , d# 606 , d# 605 , ] { cr }
 [ d# 604 , d# 603 , d# 602 , d# 601 , d# 600 , ] { cr }
 [ d# 700 , d# 701 , d# 702 , d# 703 , d# 704 , d# 705 , ] { cr }
 [ d# 706 , d# 707 , d# 708 , d# -1 , ] }block

( 0022,3400 )               D# 141 shadow{ 
 }block

( 0022,3800 )               D# 142 code{ 
 }block

( 0022,3C00 )               D# 143 shadow{ 
 }block

( 0022,4000 )               D# 144 code{ 
 ( arrayforth tm and okad tools and designs ) { cr }
 ( copyright 2009-2010 greenarrays, inc. ) { cr }

:# first -1 [ d# -1 first ! ] { cr }

:# cur 23492085 ( config ) [ d# 148 load ] { br }

: .s ; ( defaults for blue words )
: .pth ;
: .ram ; { br }

: ray ( i-a ) pop 2/ 2/ + ;
:# ntbl 0 [ d# 0 ntbl ! ]
: aray ( n ) < align > call ray [ d# 4 ] * [ h ] +! ;
: uatbl ( i-a ) [ d# 1000 aray ]
: nil d# 0 [ ntbl ] ! ; { br }
 ( png screen capture ) [ png ] { cr }
 ( chip design ) [ d# 900 load ] }block

( 0022,4400 )               D# 145 shadow{ 
 ( main load block for okad2 applications )
: cur ( cursor position )
: first ( execution of hardsim. initializes least-squares variables )
  { br }

: ray ( defines i-a array usage ) align ray
: aray ( use after red to make ray of n cells )
: uatbl ( lists transistor table addresses of the devices so far found
  to be conducting current. )
: ntbl ( is number of active uatbl entries. )
: nil ( clears the table. ) }block

( 0022,4800 )               D# 146 code{ 
 }block

( 0022,4C00 )               D# 147 shadow{ 
 }block

( 0022,5000 )               D# 148 code{ 
 ( configuration blocks )
:# orgn 0 [ d# 0 orgn ! ]
: exit 7pop 7pop ;
: tbl ( i-n ) pop 2/ 2/ + @ ;
: assign ( a ) pop swap ! ;
: xqt ( a ) @ push ;
: cfuse d# 648 ; ( active ) [ cfuse load ]
: cfchip d# 650 ;
: cfpins d# 654 ;
: cfstart d# 656 ;
: cfpads d# 658 ;
: cfprobe d# 660 ;
: cfsim d# 662 ;
: cfstep d# 664 ;
: cfscale d# 666 ;
: cftape d# 756 ; ( tapeout default )
: readme [ cfuse block ] nop [ cfuse d# 18 / ] d# 2 @cyls ;
: tapeout [ cftape block ] nop [ cfuse block ] nop [ d# 36 d# 256 * ]
  move ;
: recompile d# 940 load [ orgn ] @ load lis ; }block

( 0022,5400 )               D# 149 shadow{ 
 ( names for blocks that are customized to configure tools while designing
  and testing. )
: cfuse ( two cylinders on cylinder boundary - 18 blocks plus shadows
  - actively loaded and used )
: cftape ( default image of config area under change control in base )
  { br }

: exit ( terminates interpretation of a block. )
: tbl ( self fetching cell array. usage' )
: squared ( i-n ) align tbl [ d# 0 , d# 1 , d# 4 , d# 9 , d# 16 , ]
: assign ( places addr of following code in the location given and exits
  current definition. )
: xqt ( calls the code whose adr is in the var given. ) }block

( 0022,5800 )               D# 150 code{ 
 ( redact okad disk ) [ audit ] { br }
 ( to arm this block, make ) { cr }
 ( this word white... ) [ exit ] { br }
 ( okad ) [ d# 146 d# 148 obliterate d# 190 cfuse obliterate cfpins d#
  890 obliterate ] { cr }
 ( chip ) [ d# 902 d# 940 obliterate d# 944 d# 1248 obliterate ] { br
  }
 ( type save to commit changes ) }block

( 0022,5C00 )               D# 151 shadow{ 
 ( load this block to redact an okad disk for public release or extensive
  programming. ) }block

( 0022,6000 )               D# 152 code{ 
 }block

( 0022,6400 )               D# 153 shadow{ 
 }block

( 0022,6800 )               D# 154 code{ 
 }block

( 0022,6C00 )               D# 155 shadow{ 
 }block

( 0022,7000 )               D# 156 code{ 
 ( big letters ) [ macro ]
: *byte h# 0000,C80F 2, ; [ forth ]
: clr [ aper d# 2 + ] ;
:# sz 14
:# cur 9462784 [ d# 14 sz ! ]
: ptab ( xy ) d# 1024 * + [ aper @ d# 4 / ] + [ cur ] ! ;
: center ( n ) [ sz ] @ d# -24 * d# 768 + 2/ ptab ;
: table d# 12 * [ d# 12 block ] + ;
: 1line ( a ) [ sz ] @ for [ clr ] @ over ! d# 1 + next drop ;
: pix ( a ) [ sz ] @ for dup 1line d# 1024 + next drop ;
: row ( an-an ) d# 16 for dup and -if over pix then [ sz ] @ u+ 2* next
  d# 1024 [ sz ] @ * [ sz ] @ d# -16 * + u+ ;
: !emit table [ cur ] @ d# 12 for over @ *byte row row drop d# 1 u+ next
  drop drop [ sz ] @ d# 18 * [ cur ] +! ;
: !digit d# 24 + !emit ;
: 2. ( nn ) /mod !digit !digit ;
: 4. ( n ) d# 100 /mod d# 10 2. d# 10 2. ; }block

( 0022,7400 )               D# 157 shadow{ 
 }block

( 0022,7800 )               D# 158 code{ 
 ( big clock ) [ empty d# 40 load d# 156 load ]
: hm sec d# 60 /
: sex ( n ) d# 60 /mod d# 100 mod d# 10 2. d# 10 2. ;
:# t0 32458
: ?beep if ; then beep ;
: till [ t0 ] @ sec negate + green -if negate red then ?beep sex ;
: set ( n ) d# 60 * sec + [ t0 ] !
: ok show black screen blue d# 0 center hm ( till ) ;
: run dup pause drop key? run ; [ ok run ] }block

( 0022,7C00 )               D# 159 shadow{ 
 }block

( 0022,8000 )               D# 160 code{ 
 ( compare ) [ empty d# 30 load ]
: n18 ( i-a ) [ d# 3018 block ] + ;
: unpk abs [ d# 1 n18 ] ! [ d# 3036 ] block [ d# 5000 ] block [ d# 1404
  ] blks move [ d# 5000 block ] d# 3036 [ d# 3 n18 ] @ [ d# -36 ] + range
  ;
: check [ d# 3000 ] @back [ d# 0 n18 ] @ [ d# 18 block @ ] or drop if
  ; then [ d# 1 n18 ] @ dup and -if unpk ; then drop ;
: blink dup d# 3000 + [ blk ] ! edit ;
: var push push d# 1 + d# 1 u+ pop pop
: *1 or ;
: *2 var push over @ over @ or pop + ;
: tag ( nn-n ) dup h# 0000,000F and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1
  *1 *1 var *1 *1 *1
: co ( naa-n ) d# 256 for over @ over @ tag drop if drop drop pop drop
  pop drop dup d# 2 u+ ( i ) pop swap blink ; then d# 1 + d# 1 u+ next
  drop drop ;
: com ( n ) dup block over d# 3000 + block co ;
: q ( nn ) for com d# 2 + next drop ;
: all d# 18 [ d# 1439 d# -18 + 2/ ] q ;
: old [ blk ] @ d# 3000 mod dup d# 3000 + [ blk ] ! copy ; }block

( 0022,8400 )               D# 161 shadow{ 

: check ( reads backup to { 0001,770F } and decompresses if appropriate
  )
: blink ( displays the given block with its other set as the editor's
  'other' block )
: var ( compares a variable name, advancing pointers to skip its value.
  )
: *1 ( compares garden variety words. )
: *2 ( compares large literals. )
: tag ( compare compares the two source cells given, returning true if
  they differ. ignores variable differences. )
: ?nul ( ends the loop in co when nuls are found in both blocks. )
: co ( given the addresses of the two blocks does the work of com. )
: com ( invokes editor to blink the given block if it differs from the
  other, leaving stack set to continue the scan by typing q. otherwise
  returns. )
: all ( scans the whole usable area of the disk. )
: q ( scans for differences given starting block and number of source
  blocks skipping shadows. )
: note! ( return stk probably grows! ) }block

( 0022,8800 )               D# 162 code{ 
 ( compare roms ) [ compile empty ]
:# x 887904
:# y 8913568
: old ( n-a ) d# 64 * d# 1420 block + ;
: new ( n-a ) 2* h# 0000,8000 + block h# 0000,0080 + ;
: spaces for space next ;
: 5-8 d# 8 /mod d# 32 /mod d# 32 /mod h# 0000,0100 * + h# 0000,0100 *
  + h# 0000,0100 * swap d# 4 * + ;
: it @ + @ dup 5-8 white h. space dup h# 0001,5555 or d# 5 silver h.n
  space ;
: lines for i [ x ] it i [ y ] it white or if red dup d# 5 h.n then drop
  space i d# 1 h.n cr -next ;
: u d# 16
: +xy dup [ x ] +! [ y ] +! ;
: d d# -16 +xy ;
: n d# 1 +
: see ( n-n ) dup old [ x ] ! dup new [ y ] ! show black screen text d#
  15 lines green [ x ] @ h. d# 7 spaces [ y ] @ h. keyboard ;
: b d# -1 + see ;
: diff ( n-n ) dup old over new d# 64 for over @ over @ or drop if drop
  drop pop drop pop drop see ; then d# 1 + d# 1 u+ next drop drop ;
: check d# 40
: more d# -1 + diff d# 0 or if more ; then drop show green screen keyboard
  ; }block

( 0022,8C00 )               D# 163 shadow{ 
 ( compare roms )
: . ( put t18 rom into blocks 1420ff )
: see n-n ( compare roms for node n )
: u ( up 16 words )
: d ( down 16 words )
: n ( next node )
: b ( back one node )
: diff ( compare up to 64 words, t18 binary vs g18 compile. total match
  gets green screen. first non-matching word causes a dump of that node.
  note the double pop drop in diff. don't run it as a command. )
: check ( run diff on all 40 nodes ) }block

( 0022,9000 )               D# 164 code{ 
 ( timing ) [ empty macro ]
: out h# 0000,E1E6 2, ; [ forth ]
: tare time - d# 1000 for next time + ;
: tare+ time - push d# 1000 for dup next c pop time + ;
: test tare time + - d# 1000 for out next time + ; ( next 3 loop 5.7 /next
  2 /swap 25 swap 7.2 ) [ macro ]
: c! h# 0000,C88B 2, < drop > here ;
: loop h# 0000,0049 1, h# 0000,0075 1, ( e2 ) here - + 1, ; [ forth ]
: try time - d# 1000 c! loop time + ; }block

( 0022,9400 )               D# 165 shadow{ 
 }block

( 0022,9800 )               D# 166 code{ 
 }block

( 0022,9C00 )               D# 167 shadow{ 
 }block

( 0022,A000 )               D# 168 code{ 
 ( png empty )
:# w 1024
:# hh 768
:# d 1
: frame { 03A0,001F } [ aper @ d# 4 / ] ; [ d# 172 load d# 174 load ]
: -crc ( a ) here over negate + crc .. ;
: here/4 ( -a ) here d# 3 and drop if d# 0 1, here/4 ; then here d# 2
  2/s ;
: bys ( nn-b ) .. here swap , ; { cr }
 ( pallettes ) [ d# 170 load ] { br }

: !png ( awh-an ) [ d ] @ / [ hh ] ! [ d ] @ / [ w ] ! here/4 swap H#
  474E,5089 , H# 0A1A,0A0D , ( ihdr ) H# 5244,4849 d# 13 bys [ w ] @ ..
  [ hh ] @ .. h# 0000,0304 , h# 0000,0000 1, -crc ( plte ) pallette (
  idat ) H# 5441,4449 d# 0 bys swap deflate -crc ( iend ) H# 444E,4549
  d# 0 bys -crc here/4 over negate + ; { br }

: 'at ( xy-a ) d# 1024 * + [ frame ] + ;
: full d# 1 [ d ] ! d# 0 dup 'at d# 1024 d# 768 !png ;
: png full wgds ; }block

( 0022,A400 )               D# 169 shadow{ 

: d ( is reduction factor ) }block

( 0022,A800 )               D# 170 code{ 
 ( pallettes )
: paper H# 4554,4C50 d# 48 bys { cr }
 h# 00FF,FFFF 3, h# 00C0,0000 3, h# 0000,C000 3, h# 00C0,C000 3, { cr
  }
 h# 0000,00C0 3, h# 00C0,00C0 3, h# 0000,C0C0 3, h# 0040,4040 3, { cr
  }
 h# 00C0,C0C0 3, h# 00FF,0000 3, h# 0000,FF00 3, h# 00FF,FF00 3, { cr
  }
 h# 0000,00FF 3, h# 00FF,00FF 3, h# 0000,FFFF 3, h# 0000,0000 3, -crc
  ; { br }

: crt H# 4554,4C50 d# 48 bys { cr }
 h# 0000,0000 3, h# 00C0,0000 3, h# 0000,C000 3, h# 00C0,C000 3, { cr
  }
 h# 0000,00C0 3, h# 00C0,00C0 3, h# 0000,C0C0 3, h# 0040,4040 3, { cr
  }
 h# 00C0,C0C0 3, h# 00FF,0000 3, h# 0000,FF00 3, h# 00FF,FF00 3, { cr
  }
 h# 0000,00FF 3, h# 00FF,00FF 3, h# 0000,FFFF 3, h# 00FF,FFFF 3, -crc
  ; { br }

: pallette ( paper ) crt ; }block

( 0022,AC00 )               D# 171 shadow{ 
 }block

( 0022,B000 )               D# 172 code{ 
 ( crc )
:# ad1 23534
:# ad2 64494 [ macro ] { br }

: 2/s ?lit h# 0000,E8C1 2, 1, ; { -cr }

: 1@ h# 0000,008A 2, ; [ forth ]
: bit ( n-n ) d# 1 ? if d# 1 2/s H# EDB8,8320 or ; { indent }
 then d# 1 2/s ;
: ,crc ( nn ) for dup d# 8 for bit next , { indent }
 d# 1 + next drop ;
: table ( -a ) align array [ d# 0 d# 256 ,crc ]
: crc ( bn-n ) d# -1 swap for over 1@ over or h# 0000,00FF and table swap
  d# 8 2/s or d# 1 u+ next - nip ; { br }

: +adl ( n ) h# 0000,00FF and [ ad1 ] @ + dup [ ad2 ] @ +
: adl! [ ad2 ] ! [ ad1 ] ! ;
: +mod [ ad1 ] @ d# 65521 mod [ ad2 ] @ d# 65521 mod adl! ; }block

( 0022,B400 )               D# 173 shadow{ 

: 2/s ( shift right by literal )
: 1@ ( fetch byte, address in eax )
: array ( return word address in dictionary )
: bit ( process 1 bit with standard 32-bit crc )
: fill ( construct crc table for bytes )
: table ( said table )
: crc ( compute crc for a byte string )
: ad1/ad2 ( adler checksums )
: +adl ( add a byte to both checksums )
: adl! ( store checksums )
: +mod ( truncate checksums ) }block

( 0022,B800 )               D# 174 code{ 
 ( lz77 ) [ macro ] { -cr }

: *byte h# 0000,C486 2, ;
: !bx < a! > h# 0000,0289 2, < drop > ; [ forth ] { br }

: *bys dup d# 16 2/s *byte swap h# 0000,FFFF and *byte h# 0001,0000 *
  + ; { -cr }

: .. *bys , ;
: 0/1 h# 0000,0080 ? if h# 0000,007E and h# 0000,007E or drop if d# 7
  ; then h# 0000,000F ; then d# 0 and ; { -cr }

: +or over - and or ;
: 4b dup 0/1 h# 0000,0009 and over d# 8 2/s 0/1 h# 0000,000A and +or swap
  d# 16 2/s 0/1 h# 0000,000C and +or ;
: pix dup @ [ d ] @ u+ 4b ;
: row 1, dup [ w ] @ 2/ dup d# 1 + dup 2, - 2, d# 0 dup 1, +adl for pix
  d# 16 * push pix pop or dup 1, +adl next drop +mod [ d ] @ d# 1024 *
  + ; { br }

: deflate h# 0000,0178 2, d# 1 d# 0 adl! [ hh ] @ d# -1 + for d# 0 row
  next d# 1 row drop [ ad2 ] @ *byte 2, [ ad1 ] @ *byte 2, here over d#
  4 + negate + *bys over d# -4 + !bx ; }block

( 0022,BC00 )               D# 175 shadow{ 

: 0/1 ( 0, f or 7 for dark, bright or dim ) }block

( 0022,C000 )               D# 176 code{ 
 ( cf-html ) [ empty d# 74 load ] { cr }

:# pad 271638528 [ d# 3000 block d# 4 * pad ! ] { cr }

:# hld 271672321 [ pad @ hld ! d# 178 d# 6 loads ]
: estyle ,link ,t1cr ( cfhtml.css '? ) ;
: .hdr [ pad ] @ [ hld ] ! ,t1cr ( @html? @head? ) istyle { cr }
 ( estyle ) ,t1cr ( @/head? @body? @table? ) ;
: .blk ( n ) d# 0 [ pos ] ! crlf ,t1 ( @td? ) { cr }
 dup even? if dup .dec ,t1cr ( *list ) then { cr }
 .cr block ,t1 ( @code ) d# 0 [ class ] ! d# 0 [ --cr ] ! { cr }
 begin @+ dup and while .token end then { cr }
 [ class ] @ eq? if ,t1 ( ? ) then drop drop { cr }
 begin -eol? while .nb end then .cr { cr }
 ,t1 ( @/code? ) .cr ,t1cr ( @/td? ) ;
: .sep ,t1 ( @td? ) .nb .nb ,t1 ( @/td? ) ;
: .blks ( first last+2 ) over negate + 2/ for { cr }
 ,t1 ( @tr? ) dup d# 1 or .blk .sep dup .blk { cr }
 ,t1cr ( @/tr? ) [ d# 2 ] + next drop ;
: .tlr ,t1cr ( @/table? @/body? @/html? ) sav ;
: .html ( first last+2 ) .hdr .blks .tlr ; { cr }
 [ named ] ( cf.html ) }block

( 0022,C400 )               D# 177 shadow{ 
 ( colorforth to html utility ) { br }
 ( the html is created between ) [ pad ] ( and ) [ hld ] { cr }
 ( by ) .html ( and its factors ) .hdr .blks ( and ) .tlr ( , then written
  to the file last ) [ named ] ( . ) { br }
 ( uncomment ) estyle ( in ) .hdr ( to use an external ) { cr }
 ( stylesheet, maybe for printing. ) { br }
 ( pairs of blocks are formatted 2-up using html tables, with the odd/even
  blocks used to invoke ) [ .html ] ( or ) [ .blks ] ( displayed on the
  right. 'n list' is shown above the even block. ) { br }
 [ d# 176 d# 188 .html ] ( puts shadows on left, while ) { cr }
 [ d# 177 d# 189 .html ] ( puts them on the right. ) { br }
 [ seeb ] ( toggles blue-word visibility. ) { br }
 ( the last line of each block is filled ) { cr }
 ( with ) nbsp ( for column alignment. the ) [ class ] @ { cr }
 ( line closes the ) < code > ( tag of an empty block. ) }block

( 0022,C800 )               D# 178 code{ 
 ( generate html details ) { cr }

: eq? ( nn-n ) over or if drop d# -1 then - ( nz? ; )
: nz? ( n ) dup and drop ;
: even? ( n ) h# 0000,0001 or h# 0000,0001 and drop ; { br }

: @+ ( a-an ) dup d# 1 + swap @ ;
: @tag ( a-at ) dup @ h# 0000,000F and ; { br }

: sc h# 0000,003B ( semicolon )
: ch, ( c ) [ hld ] @ 1! d# 1 [ hld ] +! ;
: lb h# 0000,007B ( left-brace ) ch, ;
: rb sc h# 0000,007D ( right-brace ) ch,
: crlf d# 13 ch, d# 10 ch, ; { br }

: ,token ( n ) ch if ch, ,token ; then drop drop ;
: ,word ( a-a ) begin @+ ,token @tag drop until ; { cr }
 ( loop ) begin ,word
: ,comments ( a ) @tag d# 9 or drop until drop ; [ macro ] { cr }

: ,t ( words ) 7push pop < ,lit > call ,comments nop ;
: ,trb ( words ) < ,t > call rb nop ;
: ,t1 ( words ) call set1 < ,t > call set0 nop ;
: ,t1cr ( words ) < ,t1 > call crlf nop [ forth ] }block

( 0022,CC00 )               D# 179 shadow{ 

: eq? { -cr }

: nz? { -cr }

: diff? { -cr }

: even? ( leave only flags ) { cr }

: @+ { -cr }

: @tag ( are common factors ) { br }
 ( the following words generate ascii text only for html tags and source
  formatting; it will not be visible in the html display. ) { br }

: sc { -cr }

: ch, { -cr }

: lb { -cr }

: rb { -cr }

: crlf ( punctuation output ) { br }
 ( the macros enable in-line output from the ) { cr }
 ( standard cf-ascii table using ) [ set0 ] ( default or the extended
  table using ) [ set1 ] { br }

: ,token ( output ascii characters for one token )
: ,word ( output a token and any extension tokens )
: ,comments ( output contiguous comment words ) { br }

: ,t ( output from current set, don't change set. )
: ,trb ,t ( output followed by ) rb
: ,t1 ( output from ) set1 ( , return to ) set0 ( at end )
: ,t1cr ,t1 ( output followed by ) crlf }block

( 0022,D000 )               D# 180 code{ 
 ( translate text and numbers )
:# pos 0
: -bol? [ pos ] @ nz? ;
: -eol? [ pos ] @ d# 46 or drop ;
: .cr ,t1 ( @br? ) d# 0 [ pos ] ! ; { cr }
 ( loop ) begin .cr { -cr }

: emit ( c ) ch, d# 1 [ pos ] +! ;
: .ch ( c ) -eol? until emit ;
: .sp -eol? if -bol? if h# 0000,0020 emit ; then then ;
: .2sp .sp ( .nb ; )
: .nb h# 0000,0026 ( ampersand ) .ch ,t ( nbsp ) sc ; { br }

: .sp.tn ( n ) .sp ( .tn ; )
: .tn ( n ) ch if .ch .tn ; then drop drop ; { br }

: .hd ( n ) [ d# -10 ] + -if [ h# 0000,003A ] + .ch ; then [ h# 0000,0041
  ] + .ch ;
: .dec ( n ) .sp [ d# 0 ] + -if h# 0000,002D .ch negate then [ d# -1 ]
  swap begin [ d# 10 ] /mod dup and while end then drop
: spit ( -1 ... ) begin .hd [ d# 0 ] + -until drop ; { br }

: hd ( n-nn ) dup [ h# 0000,000F ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n ) .sp [ d# -1 ] swap begin hd H# 0FFF,FFFF and while end then
  drop spit ;
: .3hex ( n ) hd hd hd drop .sp .hd .hd .hd ; }block

( 0022,D400 )               D# 181 shadow{ 

:# pos 0 ( character display ) [ pos ] ( ition in line )
: -bol? { -cr }

: -eol? ( test position )
: .cr ( visible crlf )
: emit ( visible character )
: .ch { -cr }

: .sp { -cr }

: .2sp { -cr }

: .nb ( quirky characteristics ) { cr }
 < note > [ .sp ] ( does nothing at left margin ) { cr }
 < note > [ .ch ] ( does ) [ .cr ] ( after 46th character ) { cr }
 < note > [ .2sp ] ( takes only one space at left margin ) { cr }
 < note > [ .nb ] ( takes only one character position. ) { br }

: .tn { -cr }

: .sp.tn ( display a token. ) { br }

: .hd { -cr }

: hd { -cr }

: spit ( are number-output factors )
: .dec { -cr }

: .hex { -cr }

: .3hex ( display numbers ) }block

( 0022,D800 )               D# 182 code{ 
 ( translate cf token details ) { cr }

:# class 763363337
:# --cr 0
: ,class ( a ) @ [ class ] @ over or drop ( diff? ) if { cr }
 [ class ] @ nz? if ,t1 ( @/code? @code ) then { cr }
 ,t1 ( *class+ ) dup [ class ] ! ,token ,t1 ( ? ) ; { cr }
 then drop ; [ macro ]
: ,c 7push pop < ,lit > call ,class nop ; [ forth ] { br }

: .quirks ( n ) [ --cr ] @ nz? if .2sp drop d# 0 [ --cr ] ! ; { cr }
 then ( class ) nz? if -bol? if .cr then then ;
: .space -eol? if .nb then ;
: .indent .cr d# 4 for .nb next ; { br }

: .blue ( n ) H# 9080,000E ( cr ) eq? if .cr drop ; { cr }
 then H# E721,000E ( -cr ) eq? if d# 1 [ --cr ] ! drop ; { cr }
 then H# 8625,920E ( space ) eq? if .space drop ; { cr }
 then H# 76C0,8C4E ( indent ) eq? if .indent drop ; { cr }
 then H# C620,000E ( br ) eq? if .cr .cr then drop ; }block

( 0022,DC00 )               D# 183 shadow{ 

:# class 0 ( current class ) { cr }

:# --cr 0 ( true suppresses ) [ cr ] ( before next red word ) { cr }

: ,class { -cr }

: ,c ( class defining words, cf style ) { br }

: .quirks ( handle the spacing before red words ) { br }

: .space ( blue spaces are ignored at eol! )
: .indent { 0000,008F } ( + html leading space ) { br }

: .blue ( generate most of the blue-word effects ) }block

( 0022,E000 )               D# 184 code{ 
 ( translate cf tokens )
: sh? ( n-n ) 2/ 2/ 2/ 2/ dup 2/ swap d# 1 and drop ;
: lh? ( an-an ) push @+ pop h# 0000,0010 and drop ; { br }

: .t1 ( n ) ,c ( t1 ) .sp.tn ;
: .t2 ( an-a ) lh? if ,c ( h2 ) .hex ; then ,c ( d2 ) .dec ;
: .t3 ( n ) [ class ] @ ,c ( t3 ) .quirks ( .sp.tn ) .tn ;
: .t4 ( n ) ,c ( t4 ) .sp.tn ;
: .t5 ( an-a ) lh? if ,c ( h5 ) .hex ; then ,c ( d5 ) .dec ;
: .t6 ( n ) sh? if ,c ( h6 ) .hex ; then ,c ( d6 ) .dec ;
: .t7 ( n ) ,c ( t7 ) .sp.tn ;
: .t8 ( n ) sh? if ,c ( h8 ) .hex ; then ,c ( d8 ) .dec ;
: .t9 ( n ) ,c ( t9 ) .sp.tn ;
: .ta ( n ) ,c ( ta ) .sp.tn ;
: .tb ( n ) ,c ( tb ) .sp.tn ;
: .tc ( an-a ) ,c ( tc ) .sp.tn ,c ( dc ) @+ .dec ;
: .td ( n ) sh? ,c ( hd ) .3hex ;
: .te ( n ) ,c ( te ) ?seeb if dup .sp.tn then .blue ;
: .tf ( n ) sh? if ,c ( hf ) .hex ; then ,c ( df ) .dec ; { br }

: .token ( an-a ) dup h# 0000,000F and jump { cr }
 .tn .t1 .t2 .t3 .t4 .t5 .t6 .t7 { cr }
 .t8 .t9 .ta .tb .tc .td .te .tf }block

( 0022,E400 )               D# 185 shadow{ 

: sh? ( extract short number, true flag if hex )
: lh? ( extract long number, true flag if hex ) { br }
 ( tag ------- cf class ------- html class ) { cr }
 < .t0 > ( extension token ........ ) < same as last >
: .t1 ( execute word ........... ) [ t1 ]
: .t2 ( execute long number .... ) [ h2, d2 ]
: .t3 ( define word ........... ) { -cr }

: t3
: .t4 ( compile word ........... ) t4
: .t5 ( compile long number .... ) h5, d5
: .t6 ( compile short number ... ) h6, d6
: .t7 ( compile macro .......... ) < t7 >
: .t8 ( execute short number ... ) [ h8, d8 ]
: .t9 ( lowercase text comment . t9 )
: .ta ( capitalized text comment ta ) < deprecated >
: .tb ( uppercase text comment . tb ) < deprecated >
: .tc ( variable ............... )
:# tc 0 dc
: .td ( target address ......... hd )
: .te ( editor command ......... ) < te >
: .tf ( short number comment ... hf, df ) { br }

: .token ( translate tag-by-tag ) { indent }
 < note > ( address may be incremented ) }block

( 0022,E800 )               D# 186 code{ 
 ( stylesheet details and file output )
: vat ,t ( *vertical-align; top ) sc ;
: bcw crlf ,t ( *background-color; white ) sc ;
: wsn crlf ,t ( *white-space; nowrap ) sc ;
: fo ,t ( *font- ) ;
: ffm crlf fo { indent }
 ,t ( family; lucida*console,monospace ) sc ;
: fwb crlf fo ,t ( weight; bold ) sc ;
: fz fo ,t ( size; ) ;
: fc lb ,t ( *color; ) h# 0000,0023 ( sharp ) ch, ;
: fsi sc fo ,t ( style; italic ) rb ;
: tt sc ,t ( *text-transform; ) ; { br }

: ,link ,t1 ( @link *rel+stylesheet ) { indent }
 ,t1 ( *type+'text/css' *href+' ) ; { br }

: fopen ( af-h ) push push d# 0 d# 32 ( exist ) d# 2 d# 0 d# 0 { indent
  }
 pop pop swap fcreate ;
: sav [ d# 0 fnam ] w/o fopen dup push { indent }
 [ pad ] @ dup negate [ hld ] @ + pop { indent }
 fwr drop fclose ; }block

( 0022,EC00 )               D# 187 shadow{ 

: vat { -cr }

: bcw { -cr }

: wsn { -cr }

: fo { -cr }

: ffm { -cr }

: fwb { -cr }

: fz { -cr }

: fc { -cr }

: fsi { -cr }

: tt { cr }
 ( space-saving factors of internal stylesheet ) { br }

: ,link ( most of the external stylesheet link ) { br }

: fopen { -cr }

: sav ( open, write, close html file ) { cr }
 < note > ( byte addresses throughout ) }block

( 0022,F000 )               D# 188 code{ 
 ( internal stylesheet )
: istyle ,t1cr ( @style*type+'text/css'? ) set1 { cr }
 ,t ( td ) lb vat bcw wsn ffm fwb fz ,trb ( x-large ) ,t ( code ) lb fz
  ,t ( large ) tt ,trb ( lowercase ) { cr }
 ,t ( .t1 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .h2 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d2 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t3 ) fc ,trb ( ff0000 ) { cr }
 ,t ( .t4 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h5 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d5 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .h6 ) fc ,t ( 009900 ) fsi { cr }
 ,t ( .d6 ) fc ,trb ( 00cc00 ) { cr }
 ,t ( .t7 ) fc ,trb ( 00cccc ) { cr }
 ,t ( .h8 ) fc ,t ( aa7700 ) fsi { cr }
 ,t ( .d8 ) fc ,trb ( ddaa00 ) { cr }
 ,t ( .t9 ) fc ,trb ( 444444 ) { cr }
 ,t ( .ta ) fc ,t ( 000000 ) tt ,trb ( capitalize ) { cr }
 ,t ( .tb ) fc ,t ( 000000 ) tt ,trb ( uppercase ) { cr }
 ,t ( .tc ) fc ,trb ( ff00ff ) { cr }
 ,t ( .dc ) fc ,trb ( 00ff00 ) { cr }
 ,t ( .hd ) fc ,t ( bbbbbb ) fsi { cr }
 ,t ( .te ) fc ,trb ( 0000ff ) { cr }
 ,t ( .hf ) fc ,t ( 777777 ) fsi { cr }
 ,t ( .df ) fc ,trb ( 444444 ) ,t1cr ( @/style? ) ; }block

( 0022,F400 )               D# 189 shadow{ 

: istyle ( internal styles are aimed toward ) { cr }
 ( providing code examples for stand-alone use in other documents. although
  it's black-on-white, it faithfully displays the colorforth screen. )
  { br }
 ( some cf-html rendering tests ) { br }
 [ load D# 2147483647 H# 8000,0000 ]
: t1 ; D# 2147483646 H# 8000,0001 d# 87 h# 0000,0057 < ?lit > [ d# 87
  h# 0000,0057 ] ( rtoeani rtos ascii )
:# var 123 { cr -cr }

: quirky { 0000,00BD } { indent { 0000,0AEF } { 0000,0AFF } }
 [ d# -87 ] ( end ) [ h# 0000,0000 ] h# 0000,0000 { 0000,001F } }block

( 0022,F800 )               D# 190 code{ 
 }block

( 0022,FC00 )               D# 191 shadow{ 
 }block

( 0023,0000 )               D# 192 code{ 
 }block

( 0023,0400 )               D# 193 shadow{ 
 }block

( 0023,0800 )               D# 194 code{ 
 }block

( 0023,0C00 )               D# 195 shadow{ 
 }block

( 0023,1000 )               D# 196 code{ 
 }block

( 0023,1400 )               D# 197 shadow{ 
 }block

( 0023,1800 )               D# 198 code{ 
 }block

( 0023,1C00 )               D# 199 shadow{ 
 }block

( 0023,2000 )               D# 200 code{ 
 }block

( 0023,2400 )               D# 201 shadow{ 
 }block

( 0023,2800 )               D# 202 code{ 
 }block

( 0023,2C00 )               D# 203 shadow{ 
 }block

( 0023,3000 )               D# 204 code{ 
 }block

( 0023,3400 )               D# 205 shadow{ 
 }block

( 0023,3800 )               D# 206 code{ 
 }block

( 0023,3C00 )               D# 207 shadow{ 
 }block

( 0023,4000 )               D# 208 code{ 
 }block

( 0023,4400 )               D# 209 shadow{ 
 }block

( 0023,4800 )               D# 210 code{ 
 }block

( 0023,4C00 )               D# 211 shadow{ 
 }block

( 0023,5000 )               D# 212 code{ 
 }block

( 0023,5400 )               D# 213 shadow{ 
 }block

( 0023,5800 )               D# 214 code{ 
 }block

( 0023,5C00 )               D# 215 shadow{ 
 }block

( 0023,6000 )               D# 216 code{ 
 }block

( 0023,6400 )               D# 217 shadow{ 
 }block

( 0023,6800 )               D# 218 code{ 
 }block

( 0023,6C00 )               D# 219 shadow{ 
 }block

( 0023,7000 )               D# 220 code{ 
 }block

( 0023,7400 )               D# 221 shadow{ 
 }block

( 0023,7800 )               D# 222 code{ 
 }block

( 0023,7C00 )               D# 223 shadow{ 
 }block

( 0023,8000 )               D# 224 code{ 
 }block

( 0023,8400 )               D# 225 shadow{ 
 }block

( 0023,8800 )               D# 226 code{ 
 }block

( 0023,8C00 )               D# 227 shadow{ 
 }block

( 0023,9000 )               D# 228 code{ 
 }block

( 0023,9400 )               D# 229 shadow{ 
 }block

( 0023,9800 )               D# 230 code{ 
 }block

( 0023,9C00 )               D# 231 shadow{ 
 }block

( 0023,A000 )               D# 232 code{ 
 }block

( 0023,A400 )               D# 233 shadow{ 
 }block

( 0023,A800 )               D# 234 code{ 
 }block

( 0023,AC00 )               D# 235 shadow{ 
 }block

( 0023,B000 )               D# 236 code{ 
 }block

( 0023,B400 )               D# 237 shadow{ 
 }block

( 0023,B800 )               D# 238 code{ 
 }block

( 0023,BC00 )               D# 239 shadow{ 
 }block

( 0023,C000 )               D# 240 code{ 
 }block

( 0023,C400 )               D# 241 shadow{ 
 }block

( 0023,C800 )               D# 242 code{ 
 }block

( 0023,CC00 )               D# 243 shadow{ 
 }block

( 0023,D000 )               D# 244 code{ 
 }block

( 0023,D400 )               D# 245 shadow{ 
 }block

( 0023,D800 )               D# 246 code{ 
 }block

( 0023,DC00 )               D# 247 shadow{ 
 }block

( 0023,E000 )               D# 248 code{ 
 }block

( 0023,E400 )               D# 249 shadow{ 
 }block

( 0023,E800 )               D# 250 code{ 
 }block

( 0023,EC00 )               D# 251 shadow{ 
 }block

( 0023,F000 )               D# 252 code{ 
 }block

( 0023,F400 )               D# 253 shadow{ 
 }block

( 0023,F800 )               D# 254 code{ 
 }block

( 0023,FC00 )               D# 255 shadow{ 
 }block

( 0024,0000 )               D# 256 code{ 
 }block

( 0024,0400 )               D# 257 shadow{ 
 }block

( 0024,0800 )               D# 258 code{ 
 }block

( 0024,0C00 )               D# 259 shadow{ 
 }block

( 0024,1000 )               D# 260 code{ 
 }block

( 0024,1400 )               D# 261 shadow{ 
 }block

( 0024,1800 )               D# 262 code{ 
 }block

( 0024,1C00 )               D# 263 shadow{ 
 }block

( 0024,2000 )               D# 264 code{ 
 }block

( 0024,2400 )               D# 265 shadow{ 
 }block

( 0024,2800 )               D# 266 code{ 
 }block

( 0024,2C00 )               D# 267 shadow{ 
 }block

( 0024,3000 )               D# 268 code{ 
 }block

( 0024,3400 )               D# 269 shadow{ 
 }block

( 0024,3800 )               D# 270 code{ 
 }block

( 0024,3C00 )               D# 271 shadow{ 
 }block

( 0024,4000 )               D# 272 code{ 
 }block

( 0024,4400 )               D# 273 shadow{ 
 }block

( 0024,4800 )               D# 274 code{ 
 }block

( 0024,4C00 )               D# 275 shadow{ 
 }block

( 0024,5000 )               D# 276 code{ 
 }block

( 0024,5400 )               D# 277 shadow{ 
 }block

( 0024,5800 )               D# 278 code{ 
 }block

( 0024,5C00 )               D# 279 shadow{ 
 }block

( 0024,6000 )               D# 280 code{ 
 }block

( 0024,6400 )               D# 281 shadow{ 
 }block

( 0024,6800 )               D# 282 code{ 
 }block

( 0024,6C00 )               D# 283 shadow{ 
 }block

( 0024,7000 )               D# 284 code{ 
 }block

( 0024,7400 )               D# 285 shadow{ 
 }block

( 0024,7800 )               D# 286 code{ 
 }block

( 0024,7C00 )               D# 287 shadow{ 
 }block

( 0024,8000 )               D# 288 code{ 
 }block

( 0024,8400 )               D# 289 shadow{ 
 }block

( 0024,8800 )               D# 290 code{ 
 }block

( 0024,8C00 )               D# 291 shadow{ 
 }block

( 0024,9000 )               D# 292 code{ 
 }block

( 0024,9400 )               D# 293 shadow{ 
 }block

( 0024,9800 )               D# 294 code{ 
 }block

( 0024,9C00 )               D# 295 shadow{ 
 }block

( 0024,A000 )               D# 296 code{ 
 }block

( 0024,A400 )               D# 297 shadow{ 
 }block

( 0024,A800 )               D# 298 code{ 
 }block

( 0024,AC00 )               D# 299 shadow{ 
 }block

( 0024,B000 )               D# 300 code{ 
 }block

( 0024,B400 )               D# 301 shadow{ 
 }block

( 0024,B800 )               D# 302 code{ 
 }block

( 0024,BC00 )               D# 303 shadow{ 
 }block

( 0024,C000 )               D# 304 code{ 
 }block

( 0024,C400 )               D# 305 shadow{ 
 }block

( 0024,C800 )               D# 306 code{ 
 }block

( 0024,CC00 )               D# 307 shadow{ 
 }block

( 0024,D000 )               D# 308 code{ 
 }block

( 0024,D400 )               D# 309 shadow{ 
 }block

( 0024,D800 )               D# 310 code{ 
 }block

( 0024,DC00 )               D# 311 shadow{ 
 }block

( 0024,E000 )               D# 312 code{ 
 }block

( 0024,E400 )               D# 313 shadow{ 
 }block

( 0024,E800 )               D# 314 code{ 
 }block

( 0024,EC00 )               D# 315 shadow{ 
 }block

( 0024,F000 )               D# 316 code{ 
 }block

( 0024,F400 )               D# 317 shadow{ 
 }block

( 0024,F800 )               D# 318 code{ 
 }block

( 0024,FC00 )               D# 319 shadow{ 
 }block

( 0025,0000 )               D# 320 code{ 
 }block

( 0025,0400 )               D# 321 shadow{ 
 }block

( 0025,0800 )               D# 322 code{ 
 }block

( 0025,0C00 )               D# 323 shadow{ 
 }block

( 0025,1000 )               D# 324 code{ 
 }block

( 0025,1400 )               D# 325 shadow{ 
 }block

( 0025,1800 )               D# 326 code{ 
 }block

( 0025,1C00 )               D# 327 shadow{ 
 }block

( 0025,2000 )               D# 328 code{ 
 }block

( 0025,2400 )               D# 329 shadow{ 
 }block

( 0025,2800 )               D# 330 code{ 
 }block

( 0025,2C00 )               D# 331 shadow{ 
 }block

( 0025,3000 )               D# 332 code{ 
 }block

( 0025,3400 )               D# 333 shadow{ 
 }block

( 0025,3800 )               D# 334 code{ 
 }block

( 0025,3C00 )               D# 335 shadow{ 
 }block

( 0025,4000 )               D# 336 code{ 
 }block

( 0025,4400 )               D# 337 shadow{ 
 }block

( 0025,4800 )               D# 338 code{ 
 }block

( 0025,4C00 )               D# 339 shadow{ 
 }block

( 0025,5000 )               D# 340 code{ 
 }block

( 0025,5400 )               D# 341 shadow{ 
 }block

( 0025,5800 )               D# 342 code{ 
 }block

( 0025,5C00 )               D# 343 shadow{ 
 }block

( 0025,6000 )               D# 344 code{ 
 }block

( 0025,6400 )               D# 345 shadow{ 
 }block

( 0025,6800 )               D# 346 code{ 
 }block

( 0025,6C00 )               D# 347 shadow{ 
 }block

( 0025,7000 )               D# 348 code{ 
 }block

( 0025,7400 )               D# 349 shadow{ 
 }block

( 0025,7800 )               D# 350 code{ 
 }block

( 0025,7C00 )               D# 351 shadow{ 
 }block

( 0025,8000 )               D# 352 code{ 
 }block

( 0025,8400 )               D# 353 shadow{ 
 }block

( 0025,8800 )               D# 354 code{ 
 }block

( 0025,8C00 )               D# 355 shadow{ 
 }block

( 0025,9000 )               D# 356 code{ 
 }block

( 0025,9400 )               D# 357 shadow{ 
 }block

( 0025,9800 )               D# 358 code{ 
 }block

( 0025,9C00 )               D# 359 shadow{ 
 }block

( 0025,A000 )               D# 360 code{ 
 }block

( 0025,A400 )               D# 361 shadow{ 
 }block

( 0025,A800 )               D# 362 code{ 
 }block

( 0025,AC00 )               D# 363 shadow{ 
 }block

( 0025,B000 )               D# 364 code{ 
 }block

( 0025,B400 )               D# 365 shadow{ 
 }block

( 0025,B800 )               D# 366 code{ 
 }block

( 0025,BC00 )               D# 367 shadow{ 
 }block

( 0025,C000 )               D# 368 code{ 
 }block

( 0025,C400 )               D# 369 shadow{ 
 }block

( 0025,C800 )               D# 370 code{ 
 }block

( 0025,CC00 )               D# 371 shadow{ 
 }block

( 0025,D000 )               D# 372 code{ 
 }block

( 0025,D400 )               D# 373 shadow{ 
 }block

( 0025,D800 )               D# 374 code{ 
 }block

( 0025,DC00 )               D# 375 shadow{ 
 }block

( 0025,E000 )               D# 376 code{ 
 }block

( 0025,E400 )               D# 377 shadow{ 
 }block

( 0025,E800 )               D# 378 code{ 
 }block

( 0025,EC00 )               D# 379 shadow{ 
 }block

( 0025,F000 )               D# 380 code{ 
 }block

( 0025,F400 )               D# 381 shadow{ 
 }block

( 0025,F800 )               D# 382 code{ 
 }block

( 0025,FC00 )               D# 383 shadow{ 
 }block

( 0026,0000 )               D# 384 code{ 
 }block

( 0026,0400 )               D# 385 shadow{ 
 }block

( 0026,0800 )               D# 386 code{ 
 }block

( 0026,0C00 )               D# 387 shadow{ 
 }block

( 0026,1000 )               D# 388 code{ 
 }block

( 0026,1400 )               D# 389 shadow{ 
 }block

( 0026,1800 )               D# 390 code{ 
 }block

( 0026,1C00 )               D# 391 shadow{ 
 }block

( 0026,2000 )               D# 392 code{ 
 }block

( 0026,2400 )               D# 393 shadow{ 
 }block

( 0026,2800 )               D# 394 code{ 
 }block

( 0026,2C00 )               D# 395 shadow{ 
 }block

( 0026,3000 )               D# 396 code{ 
 }block

( 0026,3400 )               D# 397 shadow{ 
 }block

( 0026,3800 )               D# 398 code{ 
 }block

( 0026,3C00 )               D# 399 shadow{ 
 }block

( 0026,4000 )               D# 400 code{ 
 }block

( 0026,4400 )               D# 401 shadow{ 
 }block

( 0026,4800 )               D# 402 code{ 
 }block

( 0026,4C00 )               D# 403 shadow{ 
 }block

( 0026,5000 )               D# 404 code{ 
 }block

( 0026,5400 )               D# 405 shadow{ 
 }block

( 0026,5800 )               D# 406 code{ 
 }block

( 0026,5C00 )               D# 407 shadow{ 
 }block

( 0026,6000 )               D# 408 code{ 
 }block

( 0026,6400 )               D# 409 shadow{ 
 }block

( 0026,6800 )               D# 410 code{ 
 }block

( 0026,6C00 )               D# 411 shadow{ 
 }block

( 0026,7000 )               D# 412 code{ 
 }block

( 0026,7400 )               D# 413 shadow{ 
 }block

( 0026,7800 )               D# 414 code{ 
 }block

( 0026,7C00 )               D# 415 shadow{ 
 }block

( 0026,8000 )               D# 416 code{ 
 }block

( 0026,8400 )               D# 417 shadow{ 
 }block

( 0026,8800 )               D# 418 code{ 
 }block

( 0026,8C00 )               D# 419 shadow{ 
 }block

( 0026,9000 )               D# 420 code{ 
 }block

( 0026,9400 )               D# 421 shadow{ 
 }block

( 0026,9800 )               D# 422 code{ 
 }block

( 0026,9C00 )               D# 423 shadow{ 
 }block

( 0026,A000 )               D# 424 code{ 
 }block

( 0026,A400 )               D# 425 shadow{ 
 }block

( 0026,A800 )               D# 426 code{ 
 }block

( 0026,AC00 )               D# 427 shadow{ 
 }block

( 0026,B000 )               D# 428 code{ 
 }block

( 0026,B400 )               D# 429 shadow{ 
 }block

( 0026,B800 )               D# 430 code{ 
 }block

( 0026,BC00 )               D# 431 shadow{ 
 }block

( 0026,C000 )               D# 432 code{ 
 }block

( 0026,C400 )               D# 433 shadow{ 
 }block

( 0026,C800 )               D# 434 code{ 
 }block

( 0026,CC00 )               D# 435 shadow{ 
 }block

( 0026,D000 )               D# 436 code{ 
 }block

( 0026,D400 )               D# 437 shadow{ 
 }block

( 0026,D800 )               D# 438 code{ 
 }block

( 0026,DC00 )               D# 439 shadow{ 
 }block

( 0026,E000 )               D# 440 code{ 
 }block

( 0026,E400 )               D# 441 shadow{ 
 }block

( 0026,E800 )               D# 442 code{ 
 }block

( 0026,EC00 )               D# 443 shadow{ 
 }block

( 0026,F000 )               D# 444 code{ 
 }block

( 0026,F400 )               D# 445 shadow{ 
 }block

( 0026,F800 )               D# 446 code{ 
 }block

( 0026,FC00 )               D# 447 shadow{ 
 }block

( 0027,0000 )               D# 448 code{ 
 }block

( 0027,0400 )               D# 449 shadow{ 
 }block

( 0027,0800 )               D# 450 code{ 
 }block

( 0027,0C00 )               D# 451 shadow{ 
 }block

( 0027,1000 )               D# 452 code{ 
 }block

( 0027,1400 )               D# 453 shadow{ 
 }block

( 0027,1800 )               D# 454 code{ 
 }block

( 0027,1C00 )               D# 455 shadow{ 
 }block

( 0027,2000 )               D# 456 code{ 
 }block

( 0027,2400 )               D# 457 shadow{ 
 }block

( 0027,2800 )               D# 458 code{ 
 }block

( 0027,2C00 )               D# 459 shadow{ 
 }block

( 0027,3000 )               D# 460 code{ 
 }block

( 0027,3400 )               D# 461 shadow{ 
 }block

( 0027,3800 )               D# 462 code{ 
 }block

( 0027,3C00 )               D# 463 shadow{ 
 }block

( 0027,4000 )               D# 464 code{ 
 }block

( 0027,4400 )               D# 465 shadow{ 
 }block

( 0027,4800 )               D# 466 code{ 
 }block

( 0027,4C00 )               D# 467 shadow{ 
 }block

( 0027,5000 )               D# 468 code{ 
 }block

( 0027,5400 )               D# 469 shadow{ 
 }block

( 0027,5800 )               D# 470 code{ 
 }block

( 0027,5C00 )               D# 471 shadow{ 
 }block

( 0027,6000 )               D# 472 code{ 
 }block

( 0027,6400 )               D# 473 shadow{ 
 }block

( 0027,6800 )               D# 474 code{ 
 }block

( 0027,6C00 )               D# 475 shadow{ 
 }block

( 0027,7000 )               D# 476 code{ 
 }block

( 0027,7400 )               D# 477 shadow{ 
 }block

( 0027,7800 )               D# 478 code{ 
 }block

( 0027,7C00 )               D# 479 shadow{ 
 }block

( 0027,8000 )               D# 480 code{ 
 }block

( 0027,8400 )               D# 481 shadow{ 
 }block

( 0027,8800 )               D# 482 code{ 
 }block

( 0027,8C00 )               D# 483 shadow{ 
 }block

( 0027,9000 )               D# 484 code{ 
 }block

( 0027,9400 )               D# 485 shadow{ 
 }block

( 0027,9800 )               D# 486 code{ 
 }block

( 0027,9C00 )               D# 487 shadow{ 
 }block

( 0027,A000 )               D# 488 code{ 
 }block

( 0027,A400 )               D# 489 shadow{ 
 }block

( 0027,A800 )               D# 490 code{ 
 }block

( 0027,AC00 )               D# 491 shadow{ 
 }block

( 0027,B000 )               D# 492 code{ 
 }block

( 0027,B400 )               D# 493 shadow{ 
 }block

( 0027,B800 )               D# 494 code{ 
 }block

( 0027,BC00 )               D# 495 shadow{ 
 }block

( 0027,C000 )               D# 496 code{ 
 }block

( 0027,C400 )               D# 497 shadow{ 
 }block

( 0027,C800 )               D# 498 code{ 
 }block

( 0027,CC00 )               D# 499 shadow{ 
 }block

( 0027,D000 )               D# 500 code{ 
 }block

( 0027,D400 )               D# 501 shadow{ 
 }block

( 0027,D800 )               D# 502 code{ 
 }block

( 0027,DC00 )               D# 503 shadow{ 
 }block

( 0027,E000 )               D# 504 code{ 
 }block

( 0027,E400 )               D# 505 shadow{ 
 }block

( 0027,E800 )               D# 506 code{ 
 }block

( 0027,EC00 )               D# 507 shadow{ 
 }block

( 0027,F000 )               D# 508 code{ 
 }block

( 0027,F400 )               D# 509 shadow{ 
 }block

( 0027,F800 )               D# 510 code{ 
 }block

( 0027,FC00 )               D# 511 shadow{ 
 }block

( 0028,0000 )               D# 512 code{ 
 }block

( 0028,0400 )               D# 513 shadow{ 
 }block

( 0028,0800 )               D# 514 code{ 
 }block

( 0028,0C00 )               D# 515 shadow{ 
 }block

( 0028,1000 )               D# 516 code{ 
 }block

( 0028,1400 )               D# 517 shadow{ 
 }block

( 0028,1800 )               D# 518 code{ 
 }block

( 0028,1C00 )               D# 519 shadow{ 
 }block

( 0028,2000 )               D# 520 code{ 
 }block

( 0028,2400 )               D# 521 shadow{ 
 }block

( 0028,2800 )               D# 522 code{ 
 }block

( 0028,2C00 )               D# 523 shadow{ 
 }block

( 0028,3000 )               D# 524 code{ 
 }block

( 0028,3400 )               D# 525 shadow{ 
 }block

( 0028,3800 )               D# 526 code{ 
 }block

( 0028,3C00 )               D# 527 shadow{ 
 }block

( 0028,4000 )               D# 528 code{ 
 }block

( 0028,4400 )               D# 529 shadow{ 
 }block

( 0028,4800 )               D# 530 code{ 
 }block

( 0028,4C00 )               D# 531 shadow{ 
 }block

( 0028,5000 )               D# 532 code{ 
 }block

( 0028,5400 )               D# 533 shadow{ 
 }block

( 0028,5800 )               D# 534 code{ 
 }block

( 0028,5C00 )               D# 535 shadow{ 
 }block

( 0028,6000 )               D# 536 code{ 
 }block

( 0028,6400 )               D# 537 shadow{ 
 }block

( 0028,6800 )               D# 538 code{ 
 }block

( 0028,6C00 )               D# 539 shadow{ 
 }block

( 0028,7000 )               D# 540 code{ 
 }block

( 0028,7400 )               D# 541 shadow{ 
 }block

( 0028,7800 )               D# 542 code{ 
 }block

( 0028,7C00 )               D# 543 shadow{ 
 }block

( 0028,8000 )               D# 544 code{ 
 }block

( 0028,8400 )               D# 545 shadow{ 
 }block

( 0028,8800 )               D# 546 code{ 
 }block

( 0028,8C00 )               D# 547 shadow{ 
 }block

( 0028,9000 )               D# 548 code{ 
 }block

( 0028,9400 )               D# 549 shadow{ 
 }block

( 0028,9800 )               D# 550 code{ 
 }block

( 0028,9C00 )               D# 551 shadow{ 
 }block

( 0028,A000 )               D# 552 code{ 
 }block

( 0028,A400 )               D# 553 shadow{ 
 }block

( 0028,A800 )               D# 554 code{ 
 }block

( 0028,AC00 )               D# 555 shadow{ 
 }block

( 0028,B000 )               D# 556 code{ 
 }block

( 0028,B400 )               D# 557 shadow{ 
 }block

( 0028,B800 )               D# 558 code{ 
 }block

( 0028,BC00 )               D# 559 shadow{ 
 }block

( 0028,C000 )               D# 560 code{ 
 }block

( 0028,C400 )               D# 561 shadow{ 
 }block

( 0028,C800 )               D# 562 code{ 
 }block

( 0028,CC00 )               D# 563 shadow{ 
 }block

( 0028,D000 )               D# 564 code{ 
 }block

( 0028,D400 )               D# 565 shadow{ 
 }block

( 0028,D800 )               D# 566 code{ 
 }block

( 0028,DC00 )               D# 567 shadow{ 
 }block

( 0028,E000 )               D# 568 code{ 
 }block

( 0028,E400 )               D# 569 shadow{ 
 }block

( 0028,E800 )               D# 570 code{ 
 }block

( 0028,EC00 )               D# 571 shadow{ 
 }block

( 0028,F000 )               D# 572 code{ 
 }block

( 0028,F400 )               D# 573 shadow{ 
 }block

( 0028,F800 )               D# 574 code{ 
 }block

( 0028,FC00 )               D# 575 shadow{ 
 }block

( 0029,0000 )               D# 576 code{ 
 }block

( 0029,0400 )               D# 577 shadow{ 
 }block

( 0029,0800 )               D# 578 code{ 
 }block

( 0029,0C00 )               D# 579 shadow{ 
 }block

( 0029,1000 )               D# 580 code{ 
 }block

( 0029,1400 )               D# 581 shadow{ 
 }block

( 0029,1800 )               D# 582 code{ 
 }block

( 0029,1C00 )               D# 583 shadow{ 
 }block

( 0029,2000 )               D# 584 code{ 
 }block

( 0029,2400 )               D# 585 shadow{ 
 }block

( 0029,2800 )               D# 586 code{ 
 }block

( 0029,2C00 )               D# 587 shadow{ 
 }block

( 0029,3000 )               D# 588 code{ 
 }block

( 0029,3400 )               D# 589 shadow{ 
 }block

( 0029,3800 )               D# 590 code{ 
 }block

( 0029,3C00 )               D# 591 shadow{ 
 }block

( 0029,4000 )               D# 592 code{ 
 }block

( 0029,4400 )               D# 593 shadow{ 
 }block

( 0029,4800 )               D# 594 code{ 
 }block

( 0029,4C00 )               D# 595 shadow{ 
 }block

( 0029,5000 )               D# 596 code{ 
 }block

( 0029,5400 )               D# 597 shadow{ 
 }block

( 0029,5800 )               D# 598 code{ 
 }block

( 0029,5C00 )               D# 599 shadow{ 
 }block

( 0029,6000 )               D# 600 code{ 
 }block

( 0029,6400 )               D# 601 shadow{ 
 }block

( 0029,6800 )               D# 602 code{ 
 }block

( 0029,6C00 )               D# 603 shadow{ 
 }block

( 0029,7000 )               D# 604 code{ 
 }block

( 0029,7400 )               D# 605 shadow{ 
 }block

( 0029,7800 )               D# 606 code{ 
 }block

( 0029,7C00 )               D# 607 shadow{ 
 }block

( 0029,8000 )               D# 608 code{ 
 }block

( 0029,8400 )               D# 609 shadow{ 
 }block

( 0029,8800 )               D# 610 code{ 
 }block

( 0029,8C00 )               D# 611 shadow{ 
 }block

( 0029,9000 )               D# 612 code{ 
 }block

( 0029,9400 )               D# 613 shadow{ 
 }block

( 0029,9800 )               D# 614 code{ 
 }block

( 0029,9C00 )               D# 615 shadow{ 
 }block

( 0029,A000 )               D# 616 code{ 
 }block

( 0029,A400 )               D# 617 shadow{ 
 }block

( 0029,A800 )               D# 618 code{ 
 }block

( 0029,AC00 )               D# 619 shadow{ 
 }block

( 0029,B000 )               D# 620 code{ 
 }block

( 0029,B400 )               D# 621 shadow{ 
 }block

( 0029,B800 )               D# 622 code{ 
 }block

( 0029,BC00 )               D# 623 shadow{ 
 }block

( 0029,C000 )               D# 624 code{ 
 }block

( 0029,C400 )               D# 625 shadow{ 
 }block

( 0029,C800 )               D# 626 code{ 
 }block

( 0029,CC00 )               D# 627 shadow{ 
 }block

( 0029,D000 )               D# 628 code{ 
 }block

( 0029,D400 )               D# 629 shadow{ 
 }block

( 0029,D800 )               D# 630 code{ 
 }block

( 0029,DC00 )               D# 631 shadow{ 
 }block

( 0029,E000 )               D# 632 code{ 
 }block

( 0029,E400 )               D# 633 shadow{ 
 }block

( 0029,E800 )               D# 634 code{ 
 }block

( 0029,EC00 )               D# 635 shadow{ 
 }block

( 0029,F000 )               D# 636 code{ 
 }block

( 0029,F400 )               D# 637 shadow{ 
 }block

( 0029,F800 )               D# 638 code{ 
 }block

( 0029,FC00 )               D# 639 shadow{ 
 }block

( 002A,0000 )               D# 640 code{ 
 }block

( 002A,0400 )               D# 641 shadow{ 
 }block

( 002A,0800 )               D# 642 code{ 
 }block

( 002A,0C00 )               D# 643 shadow{ 
 }block

( 002A,1000 )               D# 644 code{ 
 }block

( 002A,1400 )               D# 645 shadow{ 
 }block

( 002A,1800 )               D# 646 code{ 
 }block

( 002A,1C00 )               D# 647 shadow{ 
 }block

( 002A,2000 )               D# 648 code{ 
 ( active config global )
:# fov 2
:# cuco 700
:# testb 0
:# ps/ 4 [ d# 4 ps/ ! ]
:# sim 1 [ d# 1 sim ! ]
:# dh 0 [ d# 0 dh ! ] { br }

: compile [ d# 940 ] load ;
: tether { -cr }

: te [ d# 944 ] load ;
: simrec ; ( default nop )
: logger winver drop if [ d# 554 ] d# 3 loads then ;
: -tape [ d# 1 ] d# 1 and ; [ qwerty seeb ] }block

( 002A,2400 )               D# 649 shadow{ 
 ( these parameters are globally resident and should not be overloaded.
  use ) [ warm ] ( after changing any but variables marked hot. )
: sim ( is ) 0 ( for full hi lvl integrator, ) 1 ( for faster hand coded,
  ) 2 ( for fastest partial sim, ) 3 ( no sim for tare. )
: fov ( abstract display scale )
: ps/ ( picosec per display step in hardsim )
: dh ( holds drive handle we are responsible for. )
: testb ( nonzero to enable testbeds. )
: compile ( compiles rom for layout and ram for optional initialization
  via ) [ pram ] ( in hardsim. )
: simrec ( defined here as nop in case not loaded )
: logger ( compiles log file generator in windows systems )
: -tape ( the ) [ yellow ] ( literal must be 0 for tapeout, 1 for testing.
  )
: saying [ qwerty ] ( at the end of the block enables the qwerty keyboard
  mode till next boot. ) }block

( 002A,2800 )               D# 650 code{ 
 ( cfchip definition active )
: 6row 600n 601n 602n 603n 604n 605n 606n 607n 608n 609n 610n 611n 612n
  613n 614n 615n 616n 617n ;
: 5row 500n 501n 502n 503n 504n 505n 506n 507n 508n 509n 510n 511n 512n
  513n 514n 515n 516n 517n ;
: 4row 400n 401n 402n 403n 404n 405n 406n 407n 408n 409n 410n 411n 412n
  413n 414n 415n 416n 417n ;
: 3row 300n 301n 302n 303n 304n 305n 306n 307n 308n 309n 310n 311n 312n
  313n 314n 315n 316n 317n ;
: 2row 200n 201n 202n 203n 204n 205n 206n 207n 208n 209n 210n 211n 212n
  213n 214n 215n 216n 217n ;
: 1row 100n 101n 102n 103n 104n 105n 106n 107n 108n 109n 110n 111n 112n
  113n 114n 115n 116n 117n ; }block

( 002A,2C00 )               D# 651 shadow{ 
 ( define chip to lay out, loaded from 998 )
: 3..0row ( lay out all the nodes. comment those you do not wish to work
  with; make active nodes green. make sure cuco numbers a valid node that
  you are laying out before doing extract )
: chip ( top-level gds cell )
: chip0 ( octagon before global - well before wc )
: warnings ( nodes 3 or 5 require 4. ) { cr }
 ( change ) offset ( to reflect offset ) }block

( 002A,3000 )               D# 652 code{ 
 ( cfchip definition { 0000,004F } active )
: 7row 700n 701n 702n 703n 704n 705n 706n 707n 708n 709n 710n 711n 712n
  713n 714n 715n 716n 717n ;
: 0row 000n 001n 002n 003n 004n 005n 006n 007n 008n 009n 010n 011n 012n
  013n 014n 015n 016n 017n ;
: logo poly cpr m1 cpr m2 cpr m3 cpr m4 cpr ;
: chip0 power octagon dummy global pcps 0row 1row 2row 3row 4row 5row
  6row 7row ;
: chip seal origin v chip0 d# 120 [ gy d# -169 + ] v logo ; }block

( 002A,3400 )               D# 653 shadow{ 
 ( define chip to lay out, loaded from 998 )
: 3..0row ( lay out all the nodes. comment those you do not wish to work
  with; make active nodes green. make sure cuco numbers a valid node that
  you are laying out before doing extract )
: chip ( top-level gds cell )
: chip0 ( octagon before global - well before wc )
: warnings ( nodes 3 or 5 require 4. ) { cr }
 ( change ) offset ( to reflect offset ) }block

( 002A,3800 )               D# 654 code{ 
 }block

( 002A,3C00 )               D# 655 shadow{ 
 }block

( 002A,4000 )               D# 656 code{ 
 }block

( 002A,4400 )               D# 657 shadow{ 
 }block

( 002A,4800 )               D# 658 code{ 
 }block

( 002A,4C00 )               D# 659 shadow{ 
 }block

( 002A,5000 )               D# 660 code{ 
 }block

( 002A,5400 )               D# 661 shadow{ 
 }block

( 002A,5800 )               D# 662 code{ 
 }block

( 002A,5C00 )               D# 663 shadow{ 
 }block

( 002A,6000 )               D# 664 code{ 
 }block

( 002A,6400 )               D# 665 shadow{ 
 }block

( 002A,6800 )               D# 666 code{ 
 }block

( 002A,6C00 )               D# 667 shadow{ 
 }block

( 002A,7000 )               D# 668 code{ 
 }block

( 002A,7400 )               D# 669 shadow{ 
 }block

( 002A,7800 )               D# 670 code{ 
 }block

( 002A,7C00 )               D# 671 shadow{ 
 }block

( 002A,8000 )               D# 672 code{ 
 }block

( 002A,8400 )               D# 673 shadow{ 
 }block

( 002A,8800 )               D# 674 code{ 
 }block

( 002A,8C00 )               D# 675 shadow{ 
 }block

( 002A,9000 )               D# 676 code{ 
 }block

( 002A,9400 )               D# 677 shadow{ 
 }block

( 002A,9800 )               D# 678 code{ 
 }block

( 002A,9C00 )               D# 679 shadow{ 
 }block

( 002A,A000 )               D# 680 code{ 
 }block

( 002A,A400 )               D# 681 shadow{ 
 }block

( 002A,A800 )               D# 682 code{ 
 }block

( 002A,AC00 )               D# 683 shadow{ 
 }block

( 002A,B000 )               D# 684 code{ 
 }block

( 002A,B400 )               D# 685 shadow{ 
 }block

( 002A,B800 )               D# 686 code{ 
 }block

( 002A,BC00 )               D# 687 shadow{ 
 }block

( 002A,C000 )               D# 688 code{ 
 }block

( 002A,C400 )               D# 689 shadow{ 
 }block

( 002A,C800 )               D# 690 code{ 
 }block

( 002A,CC00 )               D# 691 shadow{ 
 }block

( 002A,D000 )               D# 692 code{ 
 }block

( 002A,D400 )               D# 693 shadow{ 
 }block

( 002A,D800 )               D# 694 code{ 
 }block

( 002A,DC00 )               D# 695 shadow{ 
 }block

( 002A,E000 )               D# 696 code{ 
 }block

( 002A,E400 )               D# 697 shadow{ 
 }block

( 002A,E800 )               D# 698 code{ 
 }block

( 002A,EC00 )               D# 699 shadow{ 
 }block

( 002A,F000 )               D# 700 code{ 
 }block

( 002A,F400 )               D# 701 shadow{ 
 }block

( 002A,F800 )               D# 702 code{ 
 }block

( 002A,FC00 )               D# 703 shadow{ 
 }block

( 002B,0000 )               D# 704 code{ 
 }block

( 002B,0400 )               D# 705 shadow{ 
 }block

( 002B,0800 )               D# 706 code{ 
 }block

( 002B,0C00 )               D# 707 shadow{ 
 }block

( 002B,1000 )               D# 708 code{ 
 }block

( 002B,1400 )               D# 709 shadow{ 
 }block

( 002B,1800 )               D# 710 code{ 
 }block

( 002B,1C00 )               D# 711 shadow{ 
 }block

( 002B,2000 )               D# 712 code{ 
 }block

( 002B,2400 )               D# 713 shadow{ 
 }block

( 002B,2800 )               D# 714 code{ 
 }block

( 002B,2C00 )               D# 715 shadow{ 
 }block

( 002B,3000 )               D# 716 code{ 
 }block

( 002B,3400 )               D# 717 shadow{ 
 }block

( 002B,3800 )               D# 718 code{ 
 }block

( 002B,3C00 )               D# 719 shadow{ 
 }block

( 002B,4000 )               D# 720 code{ 
 }block

( 002B,4400 )               D# 721 shadow{ 
 }block

( 002B,4800 )               D# 722 code{ 
 }block

( 002B,4C00 )               D# 723 shadow{ 
 }block

( 002B,5000 )               D# 724 code{ 
 }block

( 002B,5400 )               D# 725 shadow{ 
 }block

( 002B,5800 )               D# 726 code{ 
 }block

( 002B,5C00 )               D# 727 shadow{ 
 }block

( 002B,6000 )               D# 728 code{ 
 }block

( 002B,6400 )               D# 729 shadow{ 
 }block

( 002B,6800 )               D# 730 code{ 
 }block

( 002B,6C00 )               D# 731 shadow{ 
 }block

( 002B,7000 )               D# 732 code{ 
 }block

( 002B,7400 )               D# 733 shadow{ 
 }block

( 002B,7800 )               D# 734 code{ 
 }block

( 002B,7C00 )               D# 735 shadow{ 
 }block

( 002B,8000 )               D# 736 code{ 
 }block

( 002B,8400 )               D# 737 shadow{ 
 }block

( 002B,8800 )               D# 738 code{ 
 }block

( 002B,8C00 )               D# 739 shadow{ 
 }block

( 002B,9000 )               D# 740 code{ 
 }block

( 002B,9400 )               D# 741 shadow{ 
 }block

( 002B,9800 )               D# 742 code{ 
 }block

( 002B,9C00 )               D# 743 shadow{ 
 }block

( 002B,A000 )               D# 744 code{ 
 }block

( 002B,A400 )               D# 745 shadow{ 
 }block

( 002B,A800 )               D# 746 code{ 
 }block

( 002B,AC00 )               D# 747 shadow{ 
 }block

( 002B,B000 )               D# 748 code{ 
 }block

( 002B,B400 )               D# 749 shadow{ 
 }block

( 002B,B800 )               D# 750 code{ 
 }block

( 002B,BC00 )               D# 751 shadow{ 
 }block

( 002B,C000 )               D# 752 code{ 
 }block

( 002B,C400 )               D# 753 shadow{ 
 }block

( 002B,C800 )               D# 754 code{ 
 }block

( 002B,CC00 )               D# 755 shadow{ 
 }block

( 002B,D000 )               D# 756 code{ 
 }block

( 002B,D400 )               D# 757 shadow{ 
 }block

( 002B,D800 )               D# 758 code{ 
 }block

( 002B,DC00 )               D# 759 shadow{ 
 }block

( 002B,E000 )               D# 760 code{ 
 }block

( 002B,E400 )               D# 761 shadow{ 
 }block

( 002B,E800 )               D# 762 code{ 
 }block

( 002B,EC00 )               D# 763 shadow{ 
 }block

( 002B,F000 )               D# 764 code{ 
 }block

( 002B,F400 )               D# 765 shadow{ 
 }block

( 002B,F800 )               D# 766 code{ 
 }block

( 002B,FC00 )               D# 767 shadow{ 
 }block

( 002C,0000 )               D# 768 code{ 
 }block

( 002C,0400 )               D# 769 shadow{ 
 }block

( 002C,0800 )               D# 770 code{ 
 }block

( 002C,0C00 )               D# 771 shadow{ 
 }block

( 002C,1000 )               D# 772 code{ 
 }block

( 002C,1400 )               D# 773 shadow{ 
 }block

( 002C,1800 )               D# 774 code{ 
 }block

( 002C,1C00 )               D# 775 shadow{ 
 }block

( 002C,2000 )               D# 776 code{ 
 }block

( 002C,2400 )               D# 777 shadow{ 
 }block

( 002C,2800 )               D# 778 code{ 
 }block

( 002C,2C00 )               D# 779 shadow{ 
 }block

( 002C,3000 )               D# 780 code{ 
 }block

( 002C,3400 )               D# 781 shadow{ 
 }block

( 002C,3800 )               D# 782 code{ 
 }block

( 002C,3C00 )               D# 783 shadow{ 
 }block

( 002C,4000 )               D# 784 code{ 
 }block

( 002C,4400 )               D# 785 shadow{ 
 }block

( 002C,4800 )               D# 786 code{ 
 }block

( 002C,4C00 )               D# 787 shadow{ 
 }block

( 002C,5000 )               D# 788 code{ 
 }block

( 002C,5400 )               D# 789 shadow{ 
 }block

( 002C,5800 )               D# 790 code{ 
 }block

( 002C,5C00 )               D# 791 shadow{ 
 }block

( 002C,6000 )               D# 792 code{ 
 }block

( 002C,6400 )               D# 793 shadow{ 
 }block

( 002C,6800 )               D# 794 code{ 
 }block

( 002C,6C00 )               D# 795 shadow{ 
 }block

( 002C,7000 )               D# 796 code{ 
 }block

( 002C,7400 )               D# 797 shadow{ 
 }block

( 002C,7800 )               D# 798 code{ 
 }block

( 002C,7C00 )               D# 799 shadow{ 
 }block

( 002C,8000 )               D# 800 code{ 
 }block

( 002C,8400 )               D# 801 shadow{ 
 }block

( 002C,8800 )               D# 802 code{ 
 }block

( 002C,8C00 )               D# 803 shadow{ 
 }block

( 002C,9000 )               D# 804 code{ 
 }block

( 002C,9400 )               D# 805 shadow{ 
 }block

( 002C,9800 )               D# 806 code{ 
 }block

( 002C,9C00 )               D# 807 shadow{ 
 }block

( 002C,A000 )               D# 808 code{ 
 }block

( 002C,A400 )               D# 809 shadow{ 
 }block

( 002C,A800 )               D# 810 code{ 
 }block

( 002C,AC00 )               D# 811 shadow{ 
 }block

( 002C,B000 )               D# 812 code{ 
 }block

( 002C,B400 )               D# 813 shadow{ 
 }block

( 002C,B800 )               D# 814 code{ 
 }block

( 002C,BC00 )               D# 815 shadow{ 
 }block

( 002C,C000 )               D# 816 code{ 
 }block

( 002C,C400 )               D# 817 shadow{ 
 }block

( 002C,C800 )               D# 818 code{ 
 }block

( 002C,CC00 )               D# 819 shadow{ 
 }block

( 002C,D000 )               D# 820 code{ 
 }block

( 002C,D400 )               D# 821 shadow{ 
 }block

( 002C,D800 )               D# 822 code{ 
 }block

( 002C,DC00 )               D# 823 shadow{ 
 }block

( 002C,E000 )               D# 824 code{ 
 }block

( 002C,E400 )               D# 825 shadow{ 
 }block

( 002C,E800 )               D# 826 code{ 
 }block

( 002C,EC00 )               D# 827 shadow{ 
 }block

( 002C,F000 )               D# 828 code{ 
 }block

( 002C,F400 )               D# 829 shadow{ 
 }block

( 002C,F800 )               D# 830 code{ 
 }block

( 002C,FC00 )               D# 831 shadow{ 
 }block

( 002D,0000 )               D# 832 code{ 
 }block

( 002D,0400 )               D# 833 shadow{ 
 }block

( 002D,0800 )               D# 834 code{ 
 }block

( 002D,0C00 )               D# 835 shadow{ 
 }block

( 002D,1000 )               D# 836 code{ 
 }block

( 002D,1400 )               D# 837 shadow{ 
 }block

( 002D,1800 )               D# 838 code{ 
 }block

( 002D,1C00 )               D# 839 shadow{ 
 }block

( 002D,2000 )               D# 840 code{ 
 }block

( 002D,2400 )               D# 841 shadow{ 
 }block

( 002D,2800 )               D# 842 code{ 
 }block

( 002D,2C00 )               D# 843 shadow{ 
 }block

( 002D,3000 )               D# 844 code{ 
 }block

( 002D,3400 )               D# 845 shadow{ 
 }block

( 002D,3800 )               D# 846 code{ 
 }block

( 002D,3C00 )               D# 847 shadow{ 
 }block

( 002D,4000 )               D# 848 code{ 
 }block

( 002D,4400 )               D# 849 shadow{ 
 }block

( 002D,4800 )               D# 850 code{ 
 }block

( 002D,4C00 )               D# 851 shadow{ 
 }block

( 002D,5000 )               D# 852 code{ 
 }block

( 002D,5400 )               D# 853 shadow{ 
 }block

( 002D,5800 )               D# 854 code{ 
 }block

( 002D,5C00 )               D# 855 shadow{ 
 }block

( 002D,6000 )               D# 856 code{ 
 }block

( 002D,6400 )               D# 857 shadow{ 
 }block

( 002D,6800 )               D# 858 code{ 
 }block

( 002D,6C00 )               D# 859 shadow{ 
 }block

( 002D,7000 )               D# 860 code{ 
 }block

( 002D,7400 )               D# 861 shadow{ 
 }block

( 002D,7800 )               D# 862 code{ 
 }block

( 002D,7C00 )               D# 863 shadow{ 
 }block

( 002D,8000 )               D# 864 code{ 
 }block

( 002D,8400 )               D# 865 shadow{ 
 }block

( 002D,8800 )               D# 866 code{ 
 }block

( 002D,8C00 )               D# 867 shadow{ 
 }block

( 002D,9000 )               D# 868 code{ 
 }block

( 002D,9400 )               D# 869 shadow{ 
 }block

( 002D,9800 )               D# 870 code{ 
 }block

( 002D,9C00 )               D# 871 shadow{ 
 }block

( 002D,A000 )               D# 872 code{ 
 }block

( 002D,A400 )               D# 873 shadow{ 
 }block

( 002D,A800 )               D# 874 code{ 
 }block

( 002D,AC00 )               D# 875 shadow{ 
 }block

( 002D,B000 )               D# 876 code{ 
 }block

( 002D,B400 )               D# 877 shadow{ 
 }block

( 002D,B800 )               D# 878 code{ 
 }block

( 002D,BC00 )               D# 879 shadow{ 
 }block

( 002D,C000 )               D# 880 code{ 
 }block

( 002D,C400 )               D# 881 shadow{ 
 }block

( 002D,C800 )               D# 882 code{ 
 }block

( 002D,CC00 )               D# 883 shadow{ 
 }block

( 002D,D000 )               D# 884 code{ 
 }block

( 002D,D400 )               D# 885 shadow{ 
 }block

( 002D,D800 )               D# 886 code{ 
 }block

( 002D,DC00 )               D# 887 shadow{ 
 }block

( 002D,E000 )               D# 888 code{ 
 }block

( 002D,E400 )               D# 889 shadow{ 
 }block

( 002D,E800 )               D# 890 code{ 
 ( ga144 chrt .18 design specific )
: gdsnos [ d# 440 ] ;
: nnx { 0000,010F } [ d# 18 ] ; { -cr }

: nny { 0000,008F } [ d# 8 ] ; { -cr }

: nns [ nnx nny * ] ;
: nnc ( nns ) [ nns d# 1 + ] ;
: nn-n ( n-n { 0000,014F } ) [ d# 100 ] /mod [ nnx ] * + ;
: n-nn ( n-n ) [ nnx ] /mod { 0000,014F } [ d# 100 ] * + ; { br }

: gapl [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d#
  20 d# 2 * + ] ;
: gapr [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d#
  24 d# 2 * + ] ;
: gapb [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d#
  28 d# 2 * + ] ;
: gapt [ d# 2 ] ( strap ) [ d# 5 + ] ( pwr ) [ d# 0 + ] ( chans ) [ d#
  18 d# 2 * + ] ;
: ray0 ( -xy ) gapl [ d# 199 ] + gapb [ d# 199 ] + ;
: rayn ( -xy ) nnx [ d# 350 ] * nny [ d# 759 ] * d# -1 + ray0 v+ ; { br
  }

: gx [ rayn drop gapr + d# 199 + ] ;
: gy [ rayn nip gapt + d# 199 + ] ; { br }

: origin { 0000,148F } { 0000,0B2F } d# 26 d# 26 ;
: cx [ origin drop d# 2 * gx + d# 2 + ] ;
: cy [ origin nip d# 2 * gy + d# 2 + ] ;
: -cx [ cx negate ] ; { -cr }

: cx*y [ cx cy * ] ; { br }

: gfx [ d# 8 ] ; { -cr }

: gfy [ d# 16 ] ; }block

( 002D,EC00 )               D# 891 shadow{ 

: gdsnos ( block for gds layer numbers )
: nnx ( and nny number of nodes/row and /column )
: nnc ( number of nodes compiled )
: nn-n ( and ) n-nn ( convert yx notation to and from linear node numbers
  )
: gapl, r, b, t ( distance in tiles between inner edge of padring bus
  and outer edge of core pwr )
: ray0 ( and ) rayn ( are gxy relative phys origin and upper right corner
  of node array. source of constants is ) [ xtab ] ( and ) [ ytab. ]
: gx ( and ) gy ( bounds of pad ring. ) [ always remember to check ] global
  [ reset wiring when size or placement of node array or pad ring are
  changed! ]
: cx ( and ) cy ( bounds of seal ring. )
: -cx ( negative tiles/row )
: origin ( origin of 'die' i.e. pad ring within seal ring. c coords rel
  to seal; g rel to 'die' )
: gfx ( and ) gfy ( fill cell grid ) }block

( 002D,F000 )               D# 892 code{ 
 ( ga144 pads, ports and resets ) { br }

: port ( i-pa ) align tbl [ h# 0000,01D5 , h# 0000,0115 , h# 0000,0175
  , h# 0000,0145 , h# 0000,0195 , h# 0000,0185 , h# 0000,01B5 , h# 0000,01A5
  , ]
: idle ( n-p ) [ nnx ] /mod [ nny d# -1 + ] mod [ d# 1 ] min [ d# 4 ]
  + swap [ nnx d# -1 + ] mod [ d# 1 ] min 2* + port ;
: rstadr align tbl [ h# 0000,00AA , h# 0000,0195 , h# 0000,0185 , h# 0000,01B5
  , h# 0000,01A5 , ]
: rstdef strings ( p0aa p13f p12f p11f p10f )
: ?rst ( pa-i ) [ d# 4 ] for dup i rstadr or while drop -next abort then
  drop drop pop ; }block

( 002D,F400 )               D# 893 shadow{ 

: port ( returns port for 0-3 rdlu then edges )
: idle ( is idle p value for given node. )
: rstadr ( and ) rstdef ( number values and white names of p straps rom,
  corn, side, top/bot, mid. )
: ?rst ( returns index of valid reset or aborts. ) }block

( 002D,F800 )               D# 894 code{ 
 ( ga144 node types ) { br }

: laid [ nns aray ] { -cr }

: resets [ nns aray ]
: kinds [ nns aray ] { br }

: 0's ( n ) for d# 0 , next ;
: +roms ( -ia ) align ray [ nns 0's ]
: iz ( nn i ) swap nn-n +roms ! ; { cr }
 [ d# 701 d# 2 iz d# 705 d# 10 iz d# 708 d# 6 iz ] { indent }
 [ d# 709 d# 14 iz d# 713 d# 14 iz d# 717 d# 14 iz ] { cr }
 [ d# 117 d# 14 iz d# 617 d# 14 iz ] { cr }
 [ d# 1 d# 2 iz d# 200 d# 18 iz d# 300 d# 4 iz ] { cr }
 ( eforth ) [ d# 105 d# 20 iz d# 106 d# 20 iz ] ( sdram... ) { cr }
 [ d# 7 d# 20 iz d# 8 d# 20 iz d# 9 d# 20 iz d# 107 d# 20 iz d# 108 d#
  20 iz ]
: @rom ( nn-n ) nn-n +roms @ [ d# 22 ] less if drop [ d# 1418 ] + ; then
  drop [ d# 100 ] mod [ d# 1301 ] + ; { br }

: bedtab ( -serbed ) [ cuco ] @ nn-n kinds @ ;
: ?serbed [ testb ] @ d# 0 or drop if bedtab ; then d# 0 ; }block

( 002D,FC00 )               D# 895 shadow{ 

: laid ( nz if node laid out )
: resets ( index of reset address )
: kinds ( kind for testbeds )
: +roms ( and ) @rom ( are here only as temporary kludges. we will eventually
  load a table from the node defns for default kind and prom source. )
: +roms ( array indexed by linear node number returning code number for
  rom load block. )
: iz ( sets node ) [ nn ] ( to use rom load block ) [ n ] ( codes- 0-arith
  2-serdes 4-syncboot 6-async 10-spi 14-analog 18-1wire )
: @rom ( returns block number for production rom code applicable to the
  given node. )
: ?serbed ( 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers
  for ) [ cuco ] ( if ) [ testb ] ( nz. ) }block

( 002E,0000 )               D# 896 code{ 
 }block

( 002E,0400 )               D# 897 shadow{ 
 }block

( 002E,0800 )               D# 898 code{ 
 }block

( 002E,0C00 )               D# 899 shadow{ 
 }block

( 002E,1000 )               D# 900 code{ 
 ( okad tools compile is in cfuse )
: softsim { -cr }

: so d# 942 load ;
: tile d# 910 load ; ( layout tiles ) [ d# 146 load ]
: place { -cr }

: pl tile ( layout and display )
: flat { -cr }

: fl d# 912 load ; ( 2d display )
: cover d# 914 load ;
: gds d# 916 load ; ( construct gds file )
: @gds d# 918 load ; ( display gds )
: ?gds d# 920 load ; ( examine gds )
: extract { -cr }

: ex d# 922 load ; ( build tables )
: hardsim { -cr }

: ha d# 924 load ; ( integrate i and v )
: hilo d# 926 load ; ( mark nets above vdd/2 )
: lite d# 928 load ;
: lit d# 908 load ;
: pram d# 934 load ;
: calc d# 930 load ; ( tsmc calculation app )
: prism d# 932 load ; ( tsmc spectrum ) [ d# 890 d# 3 loads ] ( design
  specific ) [ mark empty ] }block

( 002E,1400 )               D# 901 shadow{ 
 ( design load block for okad2 applications )
: ex
: extract ( netlist for simulation and go into )
: flat ( view of layout - keys )
: .
: .... [ ludr ] ( big left up down right )
: .432 [ ludr ] ( toggle metal 2-4 , move ludr )
: .... [ +g1- ] ( zoom in, toggle gates, toggle metal1, zoom out )
: . ( exit flat view or simulator with ) [ space e space ] ( to enter
  block editor and get new key menu on bottum right )
: ha
: hardsim ( virtual scope ) [ g ] n ( go till number ) [ h ] ( go till
  key ) [ b ] ( go 1000 counts , exit with ) [ e ]
: gds ( consruct gds file image and display )
: @gds ( view file records )
: ?gds
: lite ( brighten the net pointed to - metal-1 )
: lit ( brighten an additional net ) }block

( 002E,1800 )               D# 902 code{ 
 }block

( 002E,1C00 )               D# 903 shadow{ 
 }block

( 002E,2000 )               D# 904 code{ 
 }block

( 002E,2400 )               D# 905 shadow{ 
 }block

( 002E,2800 )               D# 906 code{ 
 }block

( 002E,2C00 )               D# 907 shadow{ 
 }block

( 002E,3000 )               D# 908 code{ 
 }block

( 002E,3400 )               D# 909 shadow{ 
 }block

( 002E,3800 )               D# 910 code{ 
 }block

( 002E,3C00 )               D# 911 shadow{ 
 }block

( 002E,4000 )               D# 912 code{ 
 }block

( 002E,4400 )               D# 913 shadow{ 
 }block

( 002E,4800 )               D# 914 code{ 
 }block

( 002E,4C00 )               D# 915 shadow{ 
 }block

( 002E,5000 )               D# 916 code{ 
 }block

( 002E,5400 )               D# 917 shadow{ 
 }block

( 002E,5800 )               D# 918 code{ 
 }block

( 002E,5C00 )               D# 919 shadow{ 
 }block

( 002E,6000 )               D# 920 code{ 
 }block

( 002E,6400 )               D# 921 shadow{ 
 }block

( 002E,6800 )               D# 922 code{ 
 }block

( 002E,6C00 )               D# 923 shadow{ 
 }block

( 002E,7000 )               D# 924 code{ 
 }block

( 002E,7400 )               D# 925 shadow{ 
 }block

( 002E,7800 )               D# 926 code{ 
 }block

( 002E,7C00 )               D# 927 shadow{ 
 }block

( 002E,8000 )               D# 928 code{ 
 }block

( 002E,8400 )               D# 929 shadow{ 
 }block

( 002E,8800 )               D# 930 code{ 
 }block

( 002E,8C00 )               D# 931 shadow{ 
 }block

( 002E,9000 )               D# 932 code{ 
 }block

( 002E,9400 )               D# 933 shadow{ 
 }block

( 002E,9800 )               D# 934 code{ 
 }block

( 002E,9C00 )               D# 935 shadow{ 
 }block

( 002E,A000 )               D# 936 code{ 
 }block

( 002E,A400 )               D# 937 shadow{ 
 }block

( 002E,A800 )               D# 938 code{ 
 }block

( 002E,AC00 )               D# 939 shadow{ 
 }block

( 002E,B000 )               D# 940 code{ 
 ( g18 compiler ) [ empty c ] { cr }
 [ d# 0 d# 0 laid nns fill d# 0 d# 0 kinds nns fill ] { br }
 [ d# 1400 load ] { br }

: reset ( a ) ?rst [ com ] @ resets ! ;
: kind ( n ) [ com ] @ kinds ! ;
: node ( nn ) nn-n nns mod dup [ com ] ! { cr }
 n-nn @rom load ;
: bin ( nn ) d# 0 memory swap nn-n [ com ] ! d# 0 memory d# 512 move ;
  { br }

: program d# 1380 load [ nns d# -1 + ] for i [ com ] ! { cr }
 i idle reset i n-nn @rom load -next { cr }
 ( special rom's ) [ d# 1304 ] load { cr }
 -tape drop if [ d# 1300 ] load then ; { br }
 [ d# 1402 d# 6 loads target program empty ] }block

( 002E,B400 )               D# 941 shadow{ 
 ( compiles all relevant g18 code. ) { br }

: laid ( is cleared for setting as nodes laid out )
: resets ( is set to default multiport executes for all nodes and may
  be overridden in source code using ) reset
: kinds ( is set to default testbed none and may be overridden with )
  kind ( to 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers
  )
: program ( compile code for multicomputers. always compiles standard
  rom; if not tapeout, the load block at { 0000,A28F } defines test environment
  which may be in rom, ram, or both. ) { br }

: node ( starts random compilation for node ) [ nn ] ( by compiling node
  ) [ nn's ] ( rom )
: bin ( saves the binary just generated in the bin for node ) [ nn, ]
  ( which must be outside chip { 0000,000F } { 0000,000F } . ) }block

( 002E,B800 )               D# 942 code{ 
 ( g18 simulator ) [ compile empty ] { cr }
 [ d# 1272 d# 11 loads ] { cr }
 [ d# 1256 d# 2 loads ] ( testbed ) { cr }
 [ d# 1260 d# 4 loads ] ( memory instructions ) { cr }
 [ d# 1270 load ] ( show pins ) { cr }
 [ d# 1250 load ] ( 4x8 window on 8x18 ) { cr }
 [ d# 1294 d# 3 loads ] ( display keyboard initialization ) { cr }
 [ reset lefts rights downs ups ] ( /asynch ) { cr { 0000,155F } { 0000,582F
  } }
 ( boots { 0000,155F } { 0000,588F } boots { 0000,000F } { 0000,190F }
  boots ) { cr { 0000,000F } { 0000,258F } }
 ( boots { 0000,000F } { 0000,25CF } boots { 0000,000F } { 0000,25EF }
  boots ) [ d# 0 d# 0 boots ] { cr }
 [ ok h ] }block

( 002E,BC00 )               D# 943 shadow{ 
 }block

( 002E,C000 )               D# 944 code{ 
 }block

( 002E,C400 )               D# 945 shadow{ 
 }block

( 002E,C800 )               D# 946 code{ 
 }block

( 002E,CC00 )               D# 947 shadow{ 
 }block

( 002E,D000 )               D# 948 code{ 
 }block

( 002E,D400 )               D# 949 shadow{ 
 }block

( 002E,D800 )               D# 950 code{ 
 }block

( 002E,DC00 )               D# 951 shadow{ 
 }block

( 002E,E000 )               D# 952 code{ 
 }block

( 002E,E400 )               D# 953 shadow{ 
 }block

( 002E,E800 )               D# 954 code{ 
 }block

( 002E,EC00 )               D# 955 shadow{ 
 }block

( 002E,F000 )               D# 956 code{ 
 }block

( 002E,F400 )               D# 957 shadow{ 
 }block

( 002E,F800 )               D# 958 code{ 
 }block

( 002E,FC00 )               D# 959 shadow{ 
 }block

( 002F,0000 )               D# 960 code{ 
 }block

( 002F,0400 )               D# 961 shadow{ 
 }block

( 002F,0800 )               D# 962 code{ 
 }block

( 002F,0C00 )               D# 963 shadow{ 
 }block

( 002F,1000 )               D# 964 code{ 
 }block

( 002F,1400 )               D# 965 shadow{ 
 }block

( 002F,1800 )               D# 966 code{ 
 }block

( 002F,1C00 )               D# 967 shadow{ 
 }block

( 002F,2000 )               D# 968 code{ 
 }block

( 002F,2400 )               D# 969 shadow{ 
 }block

( 002F,2800 )               D# 970 code{ 
 }block

( 002F,2C00 )               D# 971 shadow{ 
 }block

( 002F,3000 )               D# 972 code{ 
 }block

( 002F,3400 )               D# 973 shadow{ 
 }block

( 002F,3800 )               D# 974 code{ 
 }block

( 002F,3C00 )               D# 975 shadow{ 
 }block

( 002F,4000 )               D# 976 code{ 
 }block

( 002F,4400 )               D# 977 shadow{ 
 }block

( 002F,4800 )               D# 978 code{ 
 }block

( 002F,4C00 )               D# 979 shadow{ 
 }block

( 002F,5000 )               D# 980 code{ 
 }block

( 002F,5400 )               D# 981 shadow{ 
 }block

( 002F,5800 )               D# 982 code{ 
 }block

( 002F,5C00 )               D# 983 shadow{ 
 }block

( 002F,6000 )               D# 984 code{ 
 }block

( 002F,6400 )               D# 985 shadow{ 
 }block

( 002F,6800 )               D# 986 code{ 
 }block

( 002F,6C00 )               D# 987 shadow{ 
 }block

( 002F,7000 )               D# 988 code{ 
 }block

( 002F,7400 )               D# 989 shadow{ 
 }block

( 002F,7800 )               D# 990 code{ 
 }block

( 002F,7C00 )               D# 991 shadow{ 
 }block

( 002F,8000 )               D# 992 code{ 
 }block

( 002F,8400 )               D# 993 shadow{ 
 }block

( 002F,8800 )               D# 994 code{ 
 }block

( 002F,8C00 )               D# 995 shadow{ 
 }block

( 002F,9000 )               D# 996 code{ 
 }block

( 002F,9400 )               D# 997 shadow{ 
 }block

( 002F,9800 )               D# 998 code{ 
 }block

( 002F,9C00 )               D# 999 shadow{ 
 }block

( 002F,A000 )               D# 1000 code{ 
 }block

( 002F,A400 )               D# 1001 shadow{ 
 }block

( 002F,A800 )               D# 1002 code{ 
 }block

( 002F,AC00 )               D# 1003 shadow{ 
 }block

( 002F,B000 )               D# 1004 code{ 
 }block

( 002F,B400 )               D# 1005 shadow{ 
 }block

( 002F,B800 )               D# 1006 code{ 
 }block

( 002F,BC00 )               D# 1007 shadow{ 
 }block

( 002F,C000 )               D# 1008 code{ 
 }block

( 002F,C400 )               D# 1009 shadow{ 
 }block

( 002F,C800 )               D# 1010 code{ 
 }block

( 002F,CC00 )               D# 1011 shadow{ 
 }block

( 002F,D000 )               D# 1012 code{ 
 }block

( 002F,D400 )               D# 1013 shadow{ 
 }block

( 002F,D800 )               D# 1014 code{ 
 }block

( 002F,DC00 )               D# 1015 shadow{ 
 }block

( 002F,E000 )               D# 1016 code{ 
 }block

( 002F,E400 )               D# 1017 shadow{ 
 }block

( 002F,E800 )               D# 1018 code{ 
 }block

( 002F,EC00 )               D# 1019 shadow{ 
 }block

( 002F,F000 )               D# 1020 code{ 
 }block

( 002F,F400 )               D# 1021 shadow{ 
 }block

( 002F,F800 )               D# 1022 code{ 
 }block

( 002F,FC00 )               D# 1023 shadow{ 
 }block

( 0030,0000 )               D# 1024 code{ 
 }block

( 0030,0400 )               D# 1025 shadow{ 
 }block

( 0030,0800 )               D# 1026 code{ 
 }block

( 0030,0C00 )               D# 1027 shadow{ 
 }block

( 0030,1000 )               D# 1028 code{ 
 }block

( 0030,1400 )               D# 1029 shadow{ 
 }block

( 0030,1800 )               D# 1030 code{ 
 }block

( 0030,1C00 )               D# 1031 shadow{ 
 }block

( 0030,2000 )               D# 1032 code{ 
 }block

( 0030,2400 )               D# 1033 shadow{ 
 }block

( 0030,2800 )               D# 1034 code{ 
 }block

( 0030,2C00 )               D# 1035 shadow{ 
 }block

( 0030,3000 )               D# 1036 code{ 
 }block

( 0030,3400 )               D# 1037 shadow{ 
 }block

( 0030,3800 )               D# 1038 code{ 
 }block

( 0030,3C00 )               D# 1039 shadow{ 
 }block

( 0030,4000 )               D# 1040 code{ 
 }block

( 0030,4400 )               D# 1041 shadow{ 
 }block

( 0030,4800 )               D# 1042 code{ 
 }block

( 0030,4C00 )               D# 1043 shadow{ 
 }block

( 0030,5000 )               D# 1044 code{ 
 }block

( 0030,5400 )               D# 1045 shadow{ 
 }block

( 0030,5800 )               D# 1046 code{ 
 }block

( 0030,5C00 )               D# 1047 shadow{ 
 }block

( 0030,6000 )               D# 1048 code{ 
 }block

( 0030,6400 )               D# 1049 shadow{ 
 }block

( 0030,6800 )               D# 1050 code{ 
 }block

( 0030,6C00 )               D# 1051 shadow{ 
 }block

( 0030,7000 )               D# 1052 code{ 
 }block

( 0030,7400 )               D# 1053 shadow{ 
 }block

( 0030,7800 )               D# 1054 code{ 
 }block

( 0030,7C00 )               D# 1055 shadow{ 
 }block

( 0030,8000 )               D# 1056 code{ 
 }block

( 0030,8400 )               D# 1057 shadow{ 
 }block

( 0030,8800 )               D# 1058 code{ 
 }block

( 0030,8C00 )               D# 1059 shadow{ 
 }block

( 0030,9000 )               D# 1060 code{ 
 }block

( 0030,9400 )               D# 1061 shadow{ 
 }block

( 0030,9800 )               D# 1062 code{ 
 }block

( 0030,9C00 )               D# 1063 shadow{ 
 }block

( 0030,A000 )               D# 1064 code{ 
 }block

( 0030,A400 )               D# 1065 shadow{ 
 }block

( 0030,A800 )               D# 1066 code{ 
 }block

( 0030,AC00 )               D# 1067 shadow{ 
 }block

( 0030,B000 )               D# 1068 code{ 
 }block

( 0030,B400 )               D# 1069 shadow{ 
 }block

( 0030,B800 )               D# 1070 code{ 
 }block

( 0030,BC00 )               D# 1071 shadow{ 
 }block

( 0030,C000 )               D# 1072 code{ 
 }block

( 0030,C400 )               D# 1073 shadow{ 
 }block

( 0030,C800 )               D# 1074 code{ 
 }block

( 0030,CC00 )               D# 1075 shadow{ 
 }block

( 0030,D000 )               D# 1076 code{ 
 }block

( 0030,D400 )               D# 1077 shadow{ 
 }block

( 0030,D800 )               D# 1078 code{ 
 }block

( 0030,DC00 )               D# 1079 shadow{ 
 }block

( 0030,E000 )               D# 1080 code{ 
 }block

( 0030,E400 )               D# 1081 shadow{ 
 }block

( 0030,E800 )               D# 1082 code{ 
 }block

( 0030,EC00 )               D# 1083 shadow{ 
 }block

( 0030,F000 )               D# 1084 code{ 
 }block

( 0030,F400 )               D# 1085 shadow{ 
 }block

( 0030,F800 )               D# 1086 code{ 
 }block

( 0030,FC00 )               D# 1087 shadow{ 
 }block

( 0031,0000 )               D# 1088 code{ 
 }block

( 0031,0400 )               D# 1089 shadow{ 
 }block

( 0031,0800 )               D# 1090 code{ 
 }block

( 0031,0C00 )               D# 1091 shadow{ 
 }block

( 0031,1000 )               D# 1092 code{ 
 }block

( 0031,1400 )               D# 1093 shadow{ 
 }block

( 0031,1800 )               D# 1094 code{ 
 }block

( 0031,1C00 )               D# 1095 shadow{ 
 }block

( 0031,2000 )               D# 1096 code{ 
 }block

( 0031,2400 )               D# 1097 shadow{ 
 }block

( 0031,2800 )               D# 1098 code{ 
 }block

( 0031,2C00 )               D# 1099 shadow{ 
 }block

( 0031,3000 )               D# 1100 code{ 
 }block

( 0031,3400 )               D# 1101 shadow{ 
 }block

( 0031,3800 )               D# 1102 code{ 
 }block

( 0031,3C00 )               D# 1103 shadow{ 
 }block

( 0031,4000 )               D# 1104 code{ 
 }block

( 0031,4400 )               D# 1105 shadow{ 
 }block

( 0031,4800 )               D# 1106 code{ 
 }block

( 0031,4C00 )               D# 1107 shadow{ 
 }block

( 0031,5000 )               D# 1108 code{ 
 }block

( 0031,5400 )               D# 1109 shadow{ 
 }block

( 0031,5800 )               D# 1110 code{ 
 }block

( 0031,5C00 )               D# 1111 shadow{ 
 }block

( 0031,6000 )               D# 1112 code{ 
 }block

( 0031,6400 )               D# 1113 shadow{ 
 }block

( 0031,6800 )               D# 1114 code{ 
 }block

( 0031,6C00 )               D# 1115 shadow{ 
 }block

( 0031,7000 )               D# 1116 code{ 
 }block

( 0031,7400 )               D# 1117 shadow{ 
 }block

( 0031,7800 )               D# 1118 code{ 
 }block

( 0031,7C00 )               D# 1119 shadow{ 
 }block

( 0031,8000 )               D# 1120 code{ 
 }block

( 0031,8400 )               D# 1121 shadow{ 
 }block

( 0031,8800 )               D# 1122 code{ 
 }block

( 0031,8C00 )               D# 1123 shadow{ 
 }block

( 0031,9000 )               D# 1124 code{ 
 }block

( 0031,9400 )               D# 1125 shadow{ 
 }block

( 0031,9800 )               D# 1126 code{ 
 }block

( 0031,9C00 )               D# 1127 shadow{ 
 }block

( 0031,A000 )               D# 1128 code{ 
 }block

( 0031,A400 )               D# 1129 shadow{ 
 }block

( 0031,A800 )               D# 1130 code{ 
 }block

( 0031,AC00 )               D# 1131 shadow{ 
 }block

( 0031,B000 )               D# 1132 code{ 
 }block

( 0031,B400 )               D# 1133 shadow{ 
 }block

( 0031,B800 )               D# 1134 code{ 
 }block

( 0031,BC00 )               D# 1135 shadow{ 
 }block

( 0031,C000 )               D# 1136 code{ 
 }block

( 0031,C400 )               D# 1137 shadow{ 
 }block

( 0031,C800 )               D# 1138 code{ 
 }block

( 0031,CC00 )               D# 1139 shadow{ 
 }block

( 0031,D000 )               D# 1140 code{ 
 }block

( 0031,D400 )               D# 1141 shadow{ 
 }block

( 0031,D800 )               D# 1142 code{ 
 }block

( 0031,DC00 )               D# 1143 shadow{ 
 }block

( 0031,E000 )               D# 1144 code{ 
 }block

( 0031,E400 )               D# 1145 shadow{ 
 }block

( 0031,E800 )               D# 1146 code{ 
 }block

( 0031,EC00 )               D# 1147 shadow{ 
 }block

( 0031,F000 )               D# 1148 code{ 
 }block

( 0031,F400 )               D# 1149 shadow{ 
 }block

( 0031,F800 )               D# 1150 code{ 
 }block

( 0031,FC00 )               D# 1151 shadow{ 
 }block

( 0032,0000 )               D# 1152 code{ 
 }block

( 0032,0400 )               D# 1153 shadow{ 
 }block

( 0032,0800 )               D# 1154 code{ 
 }block

( 0032,0C00 )               D# 1155 shadow{ 
 }block

( 0032,1000 )               D# 1156 code{ 
 }block

( 0032,1400 )               D# 1157 shadow{ 
 }block

( 0032,1800 )               D# 1158 code{ 
 }block

( 0032,1C00 )               D# 1159 shadow{ 
 }block

( 0032,2000 )               D# 1160 code{ 
 }block

( 0032,2400 )               D# 1161 shadow{ 
 }block

( 0032,2800 )               D# 1162 code{ 
 }block

( 0032,2C00 )               D# 1163 shadow{ 
 }block

( 0032,3000 )               D# 1164 code{ 
 }block

( 0032,3400 )               D# 1165 shadow{ 
 }block

( 0032,3800 )               D# 1166 code{ 
 }block

( 0032,3C00 )               D# 1167 shadow{ 
 }block

( 0032,4000 )               D# 1168 code{ 
 }block

( 0032,4400 )               D# 1169 shadow{ 
 }block

( 0032,4800 )               D# 1170 code{ 
 }block

( 0032,4C00 )               D# 1171 shadow{ 
 }block

( 0032,5000 )               D# 1172 code{ 
 }block

( 0032,5400 )               D# 1173 shadow{ 
 }block

( 0032,5800 )               D# 1174 code{ 
 }block

( 0032,5C00 )               D# 1175 shadow{ 
 }block

( 0032,6000 )               D# 1176 code{ 
 }block

( 0032,6400 )               D# 1177 shadow{ 
 }block

( 0032,6800 )               D# 1178 code{ 
 }block

( 0032,6C00 )               D# 1179 shadow{ 
 }block

( 0032,7000 )               D# 1180 code{ 
 }block

( 0032,7400 )               D# 1181 shadow{ 
 }block

( 0032,7800 )               D# 1182 code{ 
 }block

( 0032,7C00 )               D# 1183 shadow{ 
 }block

( 0032,8000 )               D# 1184 code{ 
 }block

( 0032,8400 )               D# 1185 shadow{ 
 }block

( 0032,8800 )               D# 1186 code{ 
 }block

( 0032,8C00 )               D# 1187 shadow{ 
 }block

( 0032,9000 )               D# 1188 code{ 
 }block

( 0032,9400 )               D# 1189 shadow{ 
 }block

( 0032,9800 )               D# 1190 code{ 
 }block

( 0032,9C00 )               D# 1191 shadow{ 
 }block

( 0032,A000 )               D# 1192 code{ 
 }block

( 0032,A400 )               D# 1193 shadow{ 
 }block

( 0032,A800 )               D# 1194 code{ 
 }block

( 0032,AC00 )               D# 1195 shadow{ 
 }block

( 0032,B000 )               D# 1196 code{ 
 }block

( 0032,B400 )               D# 1197 shadow{ 
 }block

( 0032,B800 )               D# 1198 code{ 
 }block

( 0032,BC00 )               D# 1199 shadow{ 
 }block

( 0032,C000 )               D# 1200 code{ 
 }block

( 0032,C400 )               D# 1201 shadow{ 
 }block

( 0032,C800 )               D# 1202 code{ 
 }block

( 0032,CC00 )               D# 1203 shadow{ 
 }block

( 0032,D000 )               D# 1204 code{ 
 }block

( 0032,D400 )               D# 1205 shadow{ 
 }block

( 0032,D800 )               D# 1206 code{ 
 }block

( 0032,DC00 )               D# 1207 shadow{ 
 }block

( 0032,E000 )               D# 1208 code{ 
 }block

( 0032,E400 )               D# 1209 shadow{ 
 }block

( 0032,E800 )               D# 1210 code{ 
 }block

( 0032,EC00 )               D# 1211 shadow{ 
 }block

( 0032,F000 )               D# 1212 code{ 
 }block

( 0032,F400 )               D# 1213 shadow{ 
 }block

( 0032,F800 )               D# 1214 code{ 
 }block

( 0032,FC00 )               D# 1215 shadow{ 
 }block

( 0033,0000 )               D# 1216 code{ 
 }block

( 0033,0400 )               D# 1217 shadow{ 
 }block

( 0033,0800 )               D# 1218 code{ 
 }block

( 0033,0C00 )               D# 1219 shadow{ 
 }block

( 0033,1000 )               D# 1220 code{ 
 }block

( 0033,1400 )               D# 1221 shadow{ 
 }block

( 0033,1800 )               D# 1222 code{ 
 }block

( 0033,1C00 )               D# 1223 shadow{ 
 }block

( 0033,2000 )               D# 1224 code{ 
 }block

( 0033,2400 )               D# 1225 shadow{ 
 }block

( 0033,2800 )               D# 1226 code{ 
 }block

( 0033,2C00 )               D# 1227 shadow{ 
 }block

( 0033,3000 )               D# 1228 code{ 
 }block

( 0033,3400 )               D# 1229 shadow{ 
 }block

( 0033,3800 )               D# 1230 code{ 
 }block

( 0033,3C00 )               D# 1231 shadow{ 
 }block

( 0033,4000 )               D# 1232 code{ 
 }block

( 0033,4400 )               D# 1233 shadow{ 
 }block

( 0033,4800 )               D# 1234 code{ 
 }block

( 0033,4C00 )               D# 1235 shadow{ 
 }block

( 0033,5000 )               D# 1236 code{ 
 }block

( 0033,5400 )               D# 1237 shadow{ 
 }block

( 0033,5800 )               D# 1238 code{ 
 }block

( 0033,5C00 )               D# 1239 shadow{ 
 }block

( 0033,6000 )               D# 1240 code{ 
 }block

( 0033,6400 )               D# 1241 shadow{ 
 }block

( 0033,6800 )               D# 1242 code{ 
 }block

( 0033,6C00 )               D# 1243 shadow{ 
 }block

( 0033,7000 )               D# 1244 code{ 
 }block

( 0033,7400 )               D# 1245 shadow{ 
 }block

( 0033,7800 )               D# 1246 code{ 
 }block

( 0033,7C00 )               D# 1247 shadow{ 
 }block

( 0033,8000 )               D# 1248 code{ 
 ( smtm test ) [ h# 0000,0032 org ]
: go a! h# 0001,557F !b h# 0001,556A !b . pop @p+ { indent }
 ( ' ) @p+ dup 2/ . ( ' ) a ! ! h# 0000,0043 for { indent }
 h# 0000,003F !+ . unext { indent }
 ( ' ) 2* a! push . ( ' ' ) begin @p+ !+ . unext ( ' ) { indent }
 ( ' ) @p+ push ; ( ' ) ! warm ; { cr { 0000,025F } }
 [ h# 0000,002A org ]
: r @p+ go ; r---
: d @p+ go ; -d--
: l @p+ go ; --l-
: u @p+ go ; ---u { cr }
 [ d# 0 org ]
: path d u d u d u d r d u d u d u d l path ; }block

( 0033,8400 )               D# 1249 shadow{ 
 }block

( 0033,8800 )               D# 1250 code{ 
 ( show all nodes in miniature )
: window [ xorg ] @ d# 22 * d# 608 + [ yorg ] @ negate d# 4 + { indent
  }
 d# 30 * d# 28 + over over at push [ d# 8 d# 22 * ] + { indent }
 pop [ d# 4 d# 30 * ] + blue box ;
: .node ( n ) nn-n [ com ] ! ?red d# 48 emit ;
: line ( n ) cr d# 17 for dup .node d# 1 + -next drop ;
: .all window d# 610 d# 0 tab d# 7 for i d# 100 * line { indent }
 -next ; { br }
 [ exit ] ( help debugging multiport read/write )
: .pt ( a ) [ pt ] ! port @ h. cr pend @ h. cr ;
: .nd nn-n [ com ] ! { indent }
 red right .pt green down .pt { indent }
 red left .pt green up .pt cr { indent }
 white es @ h. cr clu @ h. ;
: .all d# 610 d# 0 tab d# 705 .nd d# 800 d# 0 tab d# 708 .nd ; }block

( 0033,8C00 )               D# 1251 shadow{ 

: window ( paint a blue box behind the visible ) { indent }
 ( part of the array )
: .node ( pacman char for each node, ) { indent }
 ( red if active and silver if asleep )
: line ( draw one line of { 0000,024F } nodes )
: .all ( move to upper right corner ) { indent }
 ( and draw all { 0000,010F } lines of the array ) { br }

: .pt ( show port and pend for one direction )
: .nd ( show ports and pends for all four )
: .all ( alternate display for debugging ports ) }block

( 0033,9000 )               D# 1252 code{ 
 [ html named ] ( softsim.html ) [ .hdr ] { cr }
 [ d# 1252 d# 1254 .blks ] ( this print screen ) { cr }
 [ d# 942 d# 944 .blks ] ( load block ) { cr }
 [ d# 1272 d# 1294 .blks ] { cr }
 [ d# 1256 d# 1260 .blks ] ( testbed ) { cr }
 [ d# 1260 d# 1268 .blks ] ( memory instructions ) { cr }
 [ d# 1270 d# 1272 .blks ] ( show pins ) { cr }
 [ d# 1250 d# 1252 .blks ] ( 4x8 window on 8x18 ) { cr }
 [ d# 1294 d# 1300 .blks ] ( screen/kbd initialization ) { cr }
 [ .tlr ] ( blocks from softsim load screen in { 0000,75CF } ) }block

( 0033,9400 )               D# 1253 shadow{ 
 [ d# 1252 load ] ( makes an html listing of ) { cr }
 ( the softsim application ) }block

( 0033,9800 )               D# 1254 code{ 
 ( testbed bootstream ) { br }
 [ nns n-nn node d# 0 org ] ( test boot stream ) { cr { 003C,07DF } }
 [ h# 0000,B56B , { 003C,07DF } h# 0000,B56B , { 0000,005F } h# 0001,5557
  , ] { cr { 0024,07FF } }
 [ h# 0000,756A , { 0024,07DF } h# 0000,756B , ] ( comma uses pattern
  ) }block

( 0033,9C00 )               D# 1255 shadow{ 
 }block

( 0033,A000 )               D# 1256 code{ 
 ( spi serial testbed ) { cr }

:# clk 0
:# spbit 1359544320
:# btcnt 33 [ d# 33 btcnt ! ] { cr }
 [ nns com ! d# 0 me d# 18 * spbit ! d# 0 clk ! ] { cr }

: ?bit [ btcnt ] @ d# -1 + d# 0 max dup [ btcnt ] ! { indent }
 dup and drop if pop drop ; then ;
: bitn ( n-nn ) dup @ swap over d# 1 + swap ! { indent }
 d# 18 /mod @n swap ;
: bit17 [ spbit ] bitn for 2* -next
: io! ( n ) 2/ h# 0002,0000 and ios @n { indent }
 h# 0001,FFFF and or ios !n ;
: spi [ d# 705 nn-n ] nop [ com ] ! [ clk ] @ ioc @ { indent }
 d# 1 and dup [ clk ] ! or drop { indent }
 if [ clk ] @ dup and drop if ; then { indent }
 ?bit bit17 then ; }block

( 0033,A400 )               D# 1257 shadow{ 
 ( spi testbed )
: clk ( state of clock pin last time )
: spbit ( 'bit' address of incoming data ) { cr }
 ( note stream code is at node { 0000,000F } )
: btcnt ( count output bits at beginning )
: ?bit ( count down to zero but no further ) { cr }
 ( and pop out of calling word until zero reached )
: bitn ( change 'bit' address to word address and bit count ... increment
  bit address ... ) { cr }
 ( @ from word address leaving bit count on top )
: bit17 ( shift current bit into ) [ almost ] ( bit 17 and )
: io! ( insert bit into ios )
: spi ( execute during each step for spi testbed ) }block

( 0033,A800 )               D# 1258 code{ 
 ( async serial testbed )
: asport [ d# 708 nn-n ] nop [ com ] ! up [ pt ] ! ;
: table pop 2/ 2/ ;
: up708 align table [ d# 0 , ] { cr }
 [ d# 708 nn-n com ! up pt ! pend , ]
: /asynch asport [ up708 ] dest ! ;
: ?wake ios @ 2* h# 0004,0000 and { indent }
 ioc @ d# 7 2*s h# 0004,0000 and or { indent }
 asport dest @ ! ;
: sta h# 0004,0000 io! ;
: sto d# 0 io! ; { cr }

:# sbit 1360871424
:# ss -1
:# baud 200 { cr }
 [ d# 200 baud ! d# -1 ss ! nns com ! d# 0 me d# 18 * sbit ! ]
: timing h# 0002,D000 [ ss ] @ d# 30 mod for 2* next io! ; { cr }

: data [ sbit ] bitn d# -18 + - for 2* -next io! ;
: dat [ ss ] @ d# 30 mod d# -7 + drop { indent }
 -if timing ; then data ;
: bit17 d# 1 [ ss ] +! [ ss ] @ d# 10 mod jump { indent }
 sta dat dat dat dat dat dat dat dat sto
: asynch [ time ] @ [ baud ] @ or drop if ( clear wrq ) { indent }
 asport d# 0 dest @ ! ; then { indent }
 d# 4000 [ baud ] +! [ d# 708 nn-n ] nop [ com ] ! { indent }
 bit17 ?wake ; }block

( 0033,AC00 )               D# 1259 shadow{ 
 ( async serial testbed )
: table ( help to )
: up708 ( create an up port for node { 0000,588F } )
: /asynch ( init up dest register for { 0000,588F } )
: ?wake ( wake on pin )
: sta ( rt bit )
: sto ( p bit ) { cr }
 sbit ( stream pointer node { 0000,000F } ) { cr }
 ss ( stream counter ) { cr }
 baud ( bit timer )
: timing ( six bit preamble )
: data ( lsb first )
: dat ( time for data, not start or stop )
: bit17 ( insert next bit into io register )
: asynch ( execute during each step for testbed ) }block

( 0033,B000 )               D# 1260 code{ 
 ( softsim memory access )
: rwb ( nai-n ) mem @ [ rrq wrq or ] and swap / or ;
: mkios ios @ h# 0002,01FF and h# 0000,0008 right rwb { indent }
 h# 0000,0020 down rwb h# 0000,0080 left rwb h# 0000,0200 up rwb { indent
  }
 ios ! ;
: /ios ios @ h# 0001,FE00 and ioc @ { indent }
 dup 2* and h# 0002,002A and or ios ! ;
: ?ios dup h# 0000,015D or drop if ; then { indent }
 drop ios @ +t set pop drop ;
: ?ioc dup h# 0000,015D or drop if ; then { indent }
 drop -t ioc ! set /ios pop drop ; }block

( 0033,B400 )               D# 1261 shadow{ 
 ( softsim memory access )
: rwb ( read write bits shifted from port to ios )
: mkios ( make ios using rwb )
: /ios ( set pins in ios to low unless ioc says ) { cr }
 ( output high. testbed can override this. )
: ?ios ( reads ios register as a special case, ) { cr }
 ( testbed should put appropriate pin data ) { cr }
 ( into ios. )
: ?ioc ( reads ioc then initializes ios with ) { cr }
 ( reasonable default values. testbed can plug ) { cr }
 ( in more appropriate values. ) }block

( 0033,B800 )               D# 1262 code{ 
 ( softsim ports )
: rpt ( -m ) right [ pt ] ! h# 0000,0080 ;
: dpt ( -m ) down [ pt ] ! h# 0000,0040 ;
: lpt ( -m ) left [ pt ] ! h# 0000,0020 ;
: upt ( -m ) up [ pt ] ! h# 0000,0010 ;
: active ( m ) [ ad ] @ h# 0000,0050 or and drop ;
: @part ( pm-p ) active if port @ +or then ;
: get ( -p ) h# 0000,0000 rpt @part dpt @part lpt @part { indent }
 upt @part h# 0000,0003 slp ! ;
: !part ( pm-p ) active if dup pend ! then ;
: put ( p ) rpt !part dpt !part lpt !part upt !part { indent }
 drop ;
: -both ( p-p ) dup es ! [ ad ] @ clu ! { indent }
 [ rrq wrq or ] over over and or drop ;
: -slot d# -1 slot +! d# 0 slp ! ; { br }

: @comm get -both if drop -slot [ rrq ] put ; then { indent }
 h# 0003,FFFF and +t h# 0000,0000 put ;
: !comm get -both if drop -slot t @ [ wrq ] or put { indent }
 ; then drop -t drop h# 0000,0000 put ;
: @inst get -both if drop h# 0000,0000 slp ! [ rrq ] put ; { indent }
 then h# 0003,FFFF and ir ! h# 0000,0000 slot ! h# 0000,0000 put ; }block

( 0033,BC00 )               D# 1263 shadow{ 
 ( softsim ports )
: rpt { -cr }

: dpt { -cr }

: lpt { -cr }

: upt { cr }
 ( set ) [ pt ] ( and leave mask )
: active ( mask off ) [ ad ] ( to see if port is active )
: @part
: get ( accumulate values of active ports )
: !part
: put ( store accumulated value into pend ) { cr }
 ( for each active port )
: -both ( save ) [ pt ] ( and ) [ ad ] ( for later display and ) { cr
  }
 ( set flag if not both read and write requested )
: -slot ( node is sleeping so arrange for ) { cr }
 ( instruction to be executed again next time ) { br }

: @comm ( multiport fetch )
: !comm ( multiport store )
: @inst ( multiport instruction fetch ) { cr }
 }block

( 0033,C000 )               D# 1264 code{ 
 ( softsim memory )
: bus? ( a ) dup [ ad ] ! h# 0000,0100 and drop { indent }
 if [ ad ] @ h# 0000,00F0 and h# 0000,0050 or drop then ;
: !p pc @3 bus? if !comm ; then { indent }
 d# 2 cnt [ ad ] @ p+
: !x ( a ) -t swap mem ! set ;
: @a ar @n ?ios
: @ab bus? if @comm ; then d# 2 cnt [ ad ] @
: @x ( a ) mem @ +t set ;
: @b b @3 ?ios @ab ;
: @+ ar @n ?ios bus? if @comm ; { indent }
 then d# 2 cnt [ ad ] @ a+ @x ;
: !a ar @n ?ioc
: !ab bus? if !comm ; then d# 2 cnt [ ad ] @ !x ;
: !b b @3 ?ioc !ab ;
: !+ ar @n ?ioc bus? if !comm ; { indent }
 then d# 2 cnt [ ad ] @ a+ !x ;
: @p pc @3 bus? if @comm ; then { indent }
 d# 2 cnt [ ad ] @ p+ @x ; { br }

: +pc pc @3 bus? if @inst ; then { indent }
 [ ad ] @ p+ mem @ ir ! d# 0 slot ! set ; { cr }
 }block

( 0033,C400 )               D# 1265 shadow{ 
 ( softsim memory )
: bus? ( is address a bus register ? )
: @x/!x a ( common to fetch/store ) { cr }
 ?ios ( in the fetches reads the ios register ) { cr }
 ( as a special case when appropriate ) { cr }
 ?ioc ( in the stores writes the ioc register ) { cr }
 ( as a special case when appropriate ) { br }

: @p ( fetching or storing memory or ports )
: @a
: @+
: !a
: !b
: !+
: @p { br }

: +pc ( fetch the next instruction word from ) { cr }
 ( memory or a port ) }block

( 0033,C800 )               D# 1266 code{ 
 ( softsim execute )
:# fast 1000
:# gap 1000 [ d# 1 gap ! ] { cr }
 ( instruction jump table )
: inst ( n ) d# 1 slot +! h# 0000,001F and jump ret ex jmp call ur+ jr+
  jz jns @p @+ @b @a !p !+ !b !a +* 2*x 2/x -x +x andx orx t! t@ r@ s@
  a@ nul r! b! a!x
: s0 ir @ d# 13 2/s inst ;
: s1 ir @ d# 8 2/s inst ;
: s2 ir @ d# 3 2/s inst ;
: s3 ir @ 2* 2* inst ;
: s4 cl @ dup and drop -if +pc ; then ;
: tick [ com ] ! d# -1 cl +! slot @ jump s0 s1 s2 s3 s4
: bus mem dup d# 1 or @ over h# 0000,000F or @ @ +or swap ! ;
: buses right bus down bus left bus up bus ; { br }

: step d# 1 [ time ] +! [ nns d# -1 + ] for i tick -next { indent }
 [ nns d# -1 + ] for i [ com ] ! buses mkios -next { indent }
 ( spi asynch ) ;
: quick [ gap ] @ for step next ;
: go quick pause key? go ;
: faster [ fast ] @ [ gap ] @ d# 1 or drop if { indent }
 drop d# 1 then [ gap ] ! ; }block

( 0033,CC00 )               D# 1267 shadow{ 

: fast ( number of quick steps in fast mode )
: gap ( number of steps in current mode )
: inst ( increment slot jump to 1 of ) { cr { 0000,040F } }
 ( instructions )
: s0-s3 ( execute instruction from slot 0-3 )
: s4 ( fetch next instruction word )
: tick ( execute 1 clock cycle )
: bus ( merge pending and dest to bus register )
: buses ( bus on each of four ports )
: step tick ( for each computer )
: quick gap ( steps before stopping to display )
: go ( quick display until keypress )
: faster ( toggle fast and slow modes for go ) }block

( 0033,D000 )               D# 1268 code{ 
 }block

( 0033,D400 )               D# 1269 shadow{ 
 }block

( 0033,D800 )               D# 1270 code{ 
 ( softsim pins )
: out silver ioc
: pn. @n swap / h# 0000,0001 and digit ;
: in blue ios pn. ;
: p17. ( n ) [ com ] ! d# -14 [ xy ] +! h# 0002,0000
: pin. ioc @ over and drop if 2/ out ; then in ;
: p5. h# 0000,0020 pin. ;
: p3. h# 0000,0008 pin. ;
: p1. h# 0000,0002 pin. ; { br }

: 1pin ( n ) nn-n loc p17. ;
: 2pins ( n ) nn-n loc p17. p1. ;
: 4pins ( n ) nn-n loc p17. p5. p3. p1. ;
: pins. [ d# 1 ] 2pins [ d# 701 ] 2pins [ d# 705 ] 4pins { indent }
 [ d# 708 ] 2pins [ d# 715 ] 1pin [ d# 517 ] 1pin { indent }
 [ d# 417 ] 1pin [ d# 317 ] 1pin [ d# 217 ] 1pin { indent }
 [ d# 8 ] 4pins [ d# 100 ] 1pin [ d# 200 ] 1pin { indent }
 [ d# 300 ] 2pins [ d# 500 ] 1pin [ d# 600 ] 1pin ; }block

( 0033,DC00 )               D# 1271 shadow{ 
 ( softsim pins )
: out ( outputs are silver )
: pn. ( factored behavior )
: in ( inputs are blue )
: p17. ( sets com, moves cursor, always first )
: pin. ( factored behavior of each pin )
: p5. ( p17. has already set com )
: p3.
: p1. { br }

: 1pin ( some nodes have one pin )
: 2pins ( some have two )
: 4pins ( spi at least has four )
: pins. ( display io pins on all nodes ) { cr }
 ( used in ok ) { br }
 ( testbed must set ios ) }block

( 0033,E000 )               D# 1272 code{ 
 ( softsim registers and memory ) { cr }

:# ad 405
:# com 54
:# pt 325
:# time 87000 [ d# 0 time ! macro ]
: 2/s ?lit h# 0000,F8C1 2, 1, ;
: 2*s ?lit h# 0000,E0C1 2, 1, ; [ forth ]
: +or ( nn ) over - and or ;
: me [ com ] @ 2* h# 0000,8000 + block + ;
: mem h# 0000,01FF and h# 0000,0100 ? if dup h# 0000,015D or drop { indent
  }
 if h# 0000,0155 or h# 0000,0010 / ( 8,4,2,1 ) h# 0000,0120 or { indent
  }
 then then h# 0000,01BF and me ; ( 120-12e used )
: port [ pt ] @ mem ;
: pend port d# 1 or ;
: dest port h# 0000,000F or ; { br }

: right h# 0000,01D5 ;
: down h# 0000,0115 ;
: left h# 0000,0175 ;
: up h# 0000,0145 ;
: rrq h# 0008,0000 ;
: wrq h# 0004,0000 ; }block

( 0033,E400 )               D# 1273 shadow{ 
 ad ( dress ) com ( puter ) pt ( port ) time
: 2/s n ( shift right n bits )
: 2*s n ( shift left n bits )
: +or ( inclusive or )
: me ( convert memory offset to pentium address )
: mem ( convert register address ) { br }

: port ( return port address for current ) [ pt ]
: pend ( convert port to 'pending' address )
: dest ( convert port to 'destination' which ) { cr }
 ( points to neighbor with shared port ) { br }

: right ( unconverted port addresses )
: down
: left
: up { br }

: rrq ( read request bit )
: wrq ( write request bit ) }block

( 0033,E800 )               D# 1274 code{ 
 ( softsim registers and memory )
: r h# 0000,0100 me ;
: ar h# 0000,0101 me ; ( a register )
: b h# 0000,0102 me ;
: pc h# 0000,0103 me ;
: ir h# 0000,0104 me ;
: t h# 0000,0105 me ;
: s h# 0000,0106 me ;
: ss d# 7 and h# 0000,0107 me + ;
: rs d# 7 and h# 0000,010F me + ;
: slot h# 0000,0117 me ;
: rp h# 0000,0118 me ;
: sp h# 0000,0119 me ;
: cl h# 0000,011A me ;
: ph h# 0000,011B me ;
: es h# 0000,011C me ;
: clu h# 0000,011D me ;
: slp h# 0000,011E me ;
: ioc h# 0000,0130 me ; ( write only )
: ios h# 0000,0131 me ; ( read only ) }block

( 0033,EC00 )               D# 1275 shadow{ 
 ( registers and 'node variables' )
: ar ( a register. cannot be named a because ) { cr }
 ( pentium macro takes precedence )
: slot ( current instruction slot 0-4 )
: rp,sp ( stack pointers )
: ss ( 8 stack registers )
: rs ( 8 stack registers )
: cl ( clock counted down to time memory access )
: ph ( clock counted up to time instruction )
: es ( used in debugging )
: clu ( used in debugging )
: slp ( mark a node as asleep )
: ioc ( write only, use with testbed )
: ios ( read only, also used with testbed ) }block

( 0033,F000 )               D# 1276 code{ 
 ( softsim display )
:# 'e/2 270075789
: cr/2 cr d# -14 [ xy ] +! ;
: emit/2 ( c ) [ 'e/2 ] xqt ;
: +e/2 [ 'e/2 ] assign [ d# 48 ] + [ xy ] @ swap emit { indent }
 h# 000B,0000 + [ xy ] ! ; [ +e/2 ]
: -e/2 [ 'e/2 ] assign drop ;
: ?adr ( a ) [ d# -8 ] + -if -e/2 then { indent }
 [ d# 4 ] + drop if ; then +e/2 ;
: 'ops align strings ( ; ex jmp cal unx nxt if -if @p @+ @b @ !p !+ !b
  ! +* 2* 2/ - + and or drp dup pop ovr a . psh b! a! fet )
: op@ ( i ) 'ops @ [ d# -16 ] and { indent }
 begin dup and while unpack emit/2 { indent }
 end then drop sp/2 ;
: opc. ( i ) slot @ [ d# 4 ] and drop if drop d# 32 then op@ ;
: ops. ( n ) [ d# 4 ] * [ d# 3 ] for [ d# 32 ] /mod next { indent }
 [ d# 4 ] for dup op@ ?adr next +e/2 ; }block

( 0033,F400 )               D# 1277 shadow{ 
 ( softsim display )
: cr/2 ( half carriage return )
: emit/2 ( half space emit )
: +e/2 ( set emit/2 to perform half emit )
: -e/2 ( set emit/2 to drop the character )
: ?adr ( used to avoid displaying an address ) { cr }
 ( field as random opcodes )
: 'ops ( a string of opcode names for decompiler )
: op@ ( lookup and type an opcode string )
: opc. ( when slot is 4 display 'fet' )
: ops. ( given an instruction word, display the ) { cr }
 ( opcodes ) }block

( 0033,F800 )               D# 1278 code{ 
 ( softsim display )
:# base 16
: digits ( i-n ) align tbl [ d# 24 , d# 25 , d# 26 , d# 27 , d# 28 , d#
  29 , d# 30 , d# 31 , d# 32 , d# 33 , ] { cr }
 [ d# 5 , d# 19 , d# 10 , d# 16 , d# 4 , d# 14 , ]
: digit ( i ) digits emit/2 ;
: .n ( nc ) dup push d# -1 + { indent }
 for [ base ] @ /mod next pop for digit next ;
: hex d# 16 [ base ] ! ;
: dec d# 10 [ base ] ! ; { br }

:# nod 56
:# nod2 57
: switch [ nod ] @ [ nod2 ] @ [ nod ] ! [ nod2 ] ! ;
: wake? silver slp @ d# 3 and drop ;
: blue h# 0040,40FF color ;
: ?white wake? if white then ;
: ?green wake? if green then ;
: ?blue wake? if blue then ;
: ?red wake? if red then ;
: me? [ com ] @ [ nod ] @ or drop { indent }
 if [ h# 0080,8080 ] color ; then ?red ; }block

( 0033,FC00 )               D# 1279 shadow{ 
 ( softsim display )
: base ( radix for small character number display )
: digits ( table of character values )
: digit ( display digit as small character )
: .n ( display ) c ( digits of ) n ( in the current ) [ base ]
: hex ( change ) [ base ] ( to hex )
: dec ( change ) [ base ] ( to decimal )
: nod nod2 ( focus on two nodes )
: switch ( swap focus nodes )
: wake? ( a node is awake if ) slp ( is { 0000,006F } )
: ?white
: ?green
: ?blue
: ?red ( change to named color if awake )
: me? ( red if this node number has focus ) }block

( 0034,0000 )               D# 1280 code{ 
 ( softsim display )
:# xorg 3
:# yorg 4 { cr }

: out? ( xy ) over over +or push over d# -8 + { indent }
 over d# -4 + and - pop +or drop ;
: loc ( n-n ) dup [ nnx ] /mod [ xorg ] @ negate { indent }
 [ yorg ] @ negate v+ out? { indent }
 -if drop drop drop pop drop ; then { indent }
 - d# 4 + d# 176 * swap d# 72 * swap { indent }
 d# 22 dup v+ over lm at ;
: tab ( xy ) over lm at ; { br }

: @n @ h# 0001,5555 or ;
: !n swap h# 0001,5555 or swap ! ;
: @3 @ h# 0000,03FF and h# 0000,0155 or ;
: !3 swap h# 0000,0155 or swap ! ;
: 10bit [ h# 0000,03FF ] and ;
: 8bit [ h# 0000,00FF ] and ;
: 3bit [ d# 7 ] and pc ( @ ) @3 [ d# 7 - ] and or ;
: adr slot @ jump 10bit 10bit 8bit 3bit nul }block

( 0034,0400 )               D# 1281 shadow{ 
 ( softsim display )
: xorg { -cr }

: yorg ( upper left corner of display ) { br }

: out? ( decide whether node is off screen )
: loc [ n ] ( calculate screen position of node )
: tab [ xy ] ( move cursor and set left margin ) { br }

: @n { -cr }

: !n { -cr }

: @3 { -cr }

: !3 { cr }
 ( fetch and store from memory, changing ) { cr }
 ( from pattern to number ) { br }

: 10bit { -cr }

: 8bit { -cr }

: 3bit
: adr ( isolate the address field in an inst ) }block

( 0034,0800 )               D# 1282 code{ 
 ( softsim display )
:# off 64
: u d# 16
: ud [ off ] @ + h# 0000,00FF and [ off ] ! ;
: d d# -16 ud ;
: the [ nod ] @ [ com ] ! ; { br }

: array pop 2/ 2/ + @ ;
: div align array [ h# 0010,0000 , h# 0000,8000 , h# 0000,0400 , h# 0000,0020
  , d# 1 , ]
: cin ir @ h# 0000,0080 * d# 1 + slot @ div / h# 0000,001F and ; { br
  }

: ar. ar @n d# 5 .n cr/2 ;
: br. b @3 d# 3 .n ;
: rqs. ios @ d# 9 2/s h# 0000,00FF and h# 0000,0002 .n ;
: ioc. ioc @n d# 5 .n cr/2 ;
: ios. ios @n d# 5 .n cr/2 ;
: ir. ir @n d# 5 .n cr/2 ;
: tr. t @n d# 5 .n cr/2 ;
: sr. s @n d# 5 .n cr/2 ;
: rr. r @n d# 5 .n cr/2 ;
: pc. pc @3 hex d# 3 .n cr/2 ;
: sl. slot @ digit ;
: op. cin opc. cr/2 ;
: cl. cl @ d# 0 max d# 3 min digit ; }block

( 0034,0C00 )               D# 1283 shadow{ 
 ( softsim display )
: u
: ud
: d ( manipulate the memory dump offset )
: the ( make focus node the current node ) { br }

: array { -cr }

: div { -cr }

: cin { cr }
 ( isolate current opcode from inst word ) { br }

: ar. { -cr }

: br. { -cr }

: ioc. { -cr }

: ios.
: ir. { -cr }

: tr. { -cr }

: sr. { -cr }

: rr.
: pc. { -cr }

: sl. { -cr }

: op. { -cr }

: cl. { cr }
 ( building blocks for the 2d display, com. ) }block

( 0034,1000 )               D# 1284 code{ 
 ( softsim display )
: -sp/2 [ h# 000B,0000 negate ] nop [ xy ] +! ;
: place dup [ com ] ! n-nn me? dec -sp/2 d# 3 .n ; { br }

: com. ( n ) loc place ?white pc. ?blue cl. { indent }
 ?white sl. ?green op. ?white ir. { indent }
 ?blue ioc. ios. ?red rr. ?green { indent }
 tr. sr. ?white ar. blue rqs. ?white br. ; { br }

: mem. ( xy ) tab hex d# 15 for i [ off ] @ h# 0000,00BF and + { indent
  }
 dup white d# 2 .n sp/2 mem @ dup { indent }
 h# 0001,5555 or green d# 5 .n sp/2 { indent }
 white ops. cr/2 -next ; { br }

: stack sp @ d# 8 for dup ss @n d# 5 .n cr/2 { indent }
 d# -1 + next drop ;
: return rp @ d# 8 for d# 1 + dup rs @n d# 5 .n { indent }
 cr/2 next drop ;
: stacks ( xy ) tab hex white return { indent }
 red rr. green tr. sr. white stack ; }block

( 0034,1400 )               D# 1285 shadow{ 
 ( softsim display )
: -sp/2 ( half backspace )
: place ( identify current computer on 2d display )
: com. [ n ] ( display computer n )
: mem. [ xy ] ( memory dump of focus ) [ nod ] ( at xy )
: stack
: return
: stacks ( full stack dump of focus ) [ nod ] ( at xy ) }block

( 0034,1800 )               D# 1286 code{ 
 ( softsim execute ) { cr }

: cnt ( n ) ph @ or drop if d# 1 ph +! { indent }
 d# -1 slot +! pop drop ; then d# 0 ph ! ;
: set4 h# 0000,0004 slot !
: set d# 2 cl ! ; { br }

: /+/ ( nim-n ) push over + over or pop and or ;
: inc ( n-n ) [ ad ] @ h# 0000,0100 and drop if ; then d# 1 h# 0000,003F
  /+/ ;
: a+ ar @n inc ar !n ;
: p+ pc @3 inc pc !3 ; }block

( 0034,1C00 )               D# 1287 shadow{ 
 ( softsim execute )
: cnt ( count down for memory access )
: set4 ( go to slot { 0000,008F } and )
: set ( set ) [ cl ] ( to time memory prefetch ) { br }

: /+/ [ nim-n ] ( add ) i ( to ) n ( affecting only bits ) { cr }
 ( within ) m
: inc ( increment current address if not ) { cr }
 ( a port address )
: a+ ( increment the a register )
: p+ ( increment the p register ) }block

( 0034,2000 )               D# 1288 code{ 
 ( softsim execute )
: +t ( n ) t @ s @ sp @ d# 1 + dup sp ! ss ! s ! t ! ;
: -t ( -n ) t @ s @ t ! sp @ dup ss @ s ! { indent }
 d# -1 + sp ! ;
: +r ( n ) r @ rp @ d# 1 + dup rp ! rs ! r ! ;
: -r ( -n ) r @ rp @ dup rs @ r ! d# -1 + rp ! ;
: t@ t @n ;
: t! t !n ;
: bin -t h# 0001,5555 or t@ ; { br }

: -x t @ h# 0003,FFFF or t ! ;
: 2*x t@ 2* h# 0003,FFFF and t! ;
: sx dup h# 0002,0000 and 2* or ;
: +* t@ sx ar @n { indent }
 d# 1 ? if push s @n + pop { indent }
 then 2/ over d# 1 and drop { indent }
 if h# 0002,0000 or then ar !n 2/ t! ; }block

( 0034,2400 )               D# 1289 shadow{ 
 ( softsim execute )
: +t n ( push onto data stack )
: -t -n ( pop from data stack )
: +r n ( push onto return stack )
: -r -n ( pop from return stack )
: t! ( write t as number )
: t@ ( read t as number )
: bin ( prepare for a binary operation ) { br }
 ( some instructions named with terminal ) { cr }
 ( x to avoid pentium conflict ) { br }

: -x ( - )
: 2*x ( 2* )
: sx ( sign extend )
: +* ( multiply step ) }block

( 0034,2800 )               D# 1290 code{ 
 ( softsim execute )
:# cy 8192
: 2/x t@ sx 2/ t! ;
: orx bin or t! ;
: andx bin and t! ;
: +x bin + pc @ h# 0000,0200 and drop { indent }
 if d# 0 [ cy ] @ h# 0004,0000 and drop { indent }
 if d# 1 or then + dup [ cy ] ! then { indent }
 h# 0003,FFFF and t! ;
: t! -t drop ;
: r@ -r +t ;
: a@ ar @ +t ;
: t@ t @ +t ;
: s@ s @ +t ;
: b! -t h# 0000,03FF and b ! ;
: r! -t +r ;
: a!x d# 0 cnt -t ar ! ; }block

( 0034,2C00 )               D# 1291 shadow{ 
 ( softsim execute )
: 2/x ( 2/ )
: orx ( or )
: andx ( and )
: +x ( + )
: t! ( drop )
: r@ ( pop )
: a@ ( a )
: t@ ( dup )
: s@ ( over )
: b!
: r! ( push )
: a!x ( a! ) }block

( 0034,3000 )               D# 1292 code{ 
 ( softsim execute )
: call pc @ +r
: jmp ir @n adr dup pc !3 set4 h# 0000,0100 and { indent }
 drop if d# 0 cl ! then ;
: jz h# 0003,FFFF
: jc t @n and drop if set4 ; then jmp ;
: jns h# 0002,0000 jc ;
: ret -r h# 0000,03FF and pc ! set4 ;
: jr+ r @n d# -1 + dup r !n dup and drop { indent }
 -if -r drop set4 ; then jmp ;
: ur+ r @n d# -1 + dup r !n dup and drop { indent }
 -if -r drop ; then d# 0 slot ! ;
: ex pc @ -r pc ! +r set4 ; }block

( 0034,3400 )               D# 1293 shadow{ 
 ( softsim execute )
: call ( call through i )
: jmp ( jump through i )
: jz ( if )
: jc
: jns ( -if )
: ret ( ; jump through r )
: jr+ ( next )
: ur+ ( unext )
: ex ( call through r ) }block

( 0034,3800 )               D# 1294 code{ 
 ( softsim display )
:# wind? -1
: nod. ( xy ) tab dec [ nod ] @ n-nn red d# 3 .n ;
: ofst d# 320 ;
: .wind [ wind? ] @ dup and drop if .all ; then { indent }
 switch d# 610 d# 22 the stacks { indent }
 d# 690 d# 22 nod. d# 690 d# 52 the mem. { indent }
 switch ; { br }

: ok show black screen text { indent }
 [ nns d# -1 + ] for i com. -next .wind { indent }
 d# 610 [ d# 22 ofst + ] the stacks { indent }
 d# 690 [ d# 22 ofst + ] nod. { indent }
 d# 690 [ d# 52 ofst + ] the mem. { indent }
 d# 610 d# 680 tab [ time ] @ . cr [ gap ] @ . { indent }
 pins. ( debug ) keyboard ; { br }

: lw d# -1
: +xorg ( n ) [ xorg ] @ + d# 0 max [ nnx d# -8 + ] min [ xorg ] ! ;
: rw d# 1 +xorg ;
: uw d# 1
: +yorg ( n ) [ yorg ] @ + d# 0 max [ nny d# -4 + ] min [ yorg ] ! ;
: dw d# -1 +yorg ;
: wtog [ wind? ] @ dup and if dup or [ wind? ] ! ; then { indent }
 - [ wind? ] ! ; }block

( 0034,3C00 )               D# 1295 shadow{ 
 ( softsim display )
: nod. ( show current node in red at ) [ xy ]
: ofst ( offset to second focus node )
: .wind ( show 4*8 window in 8*18 ) { cr }
 ( or extra focus node ) { br }

: ok ( the default 2d display ) { br }

: lw ( move display window left )
: +xorg ( factored move in x axis )
: rw ( move display window right )
: uw ( move display window up )
: +yorg ( factored move in y axis )
: dw ( move display window down )
: wtog ( toggle window display ) }block

( 0034,4000 )               D# 1296 code{ 
 ( softsim keyboard handler )
: n! ( n ) nn-n d# 0 max [ nns { FFFF,FFEF } ] ( + ) min [ nod ] ! ;
: fr d# 1
: +nod [ nod ] @ + n-nn n! ;
: fl d# -1 +nod ;
: fu [ nnx ] nop
: ++nod [ nod ] @ over +nod swap over + { indent }
 [ nod ] @ or drop if [ nod ] ! ; then drop ;
: fd [ nnx negate ] ++nod ;
: +gap d# 1
: +g ( n ) [ fast ] @ + d# 0 max dup [ fast ] ! [ gap ] ! ;
: ++gap d# 100 +g ;
: -gap d# -1 +g ;
: --gap d# -100 +g ; { br }

: h pad nul nul accept nul { cr }
 lw uw dw rw fl fu fd fr switch u d wtog { cr }
 ++gap +gap nul nul nul faster go quick { cr }
 --gap -gap nul nul { indent }
 [ h# 0000,2500 , h# 0110,160C , h# 0110,160C , ] { indent }
 [ H# 0F10,1603 , h# 0000,2B2B , H# 080D,0E00 , h# 0000,2323 , ] }block

( 0034,4400 )               D# 1297 shadow{ 
 ( softsim display )
: n! ( change focus node ) [ nod ]
: fr ( focus right )
: +nod ( factored horizontal move )
: fl ( focus left )
: fu ( focus up )
: ++nod ( factored vertical move )
: fd ( focus down )
: +gap ( add { 0000,002F } to gap and fast )
: +g ( factored add to gap and fast )
: ++gap ( add { 0000,0C8F } to gap and fast )
: -gap ( add { FFFF,FFEF } to gap and fast )
: --gap ( add { FFFF,F38F } to gap and fast )
: h ( keyboard handler ) { indent }
 [ ++ ] ( fastest faster ) { indent }
 [ fgs ] ( fast go step ) { indent }
 [ -- ] ( slowest slower ) { cr indent }
 [ ludr ] ( left up down right ) [ window ] { indent }
 [ ludr ] ( left up down right ) [ focus ] { indent }
 [ oudw ] ( other up down window ) [ memory dump ] { cr indent }
 [ . ] ( quit ) }block

( 0034,4800 )               D# 1298 code{ 
 ( softsim reset )
:# limbo 0 [ h# 0000,0000 limbo ! ]
: unp ( n-a ) d# 10 /mod nn-n [ com ] ! { indent }
 h# 0000,0010 * h# 0000,0010 or h# 0000,0155 or mem ;
: , unp swap unp over over h# 0000,000E or ! swap h# 0000,000E or ! ;
: row ( n ) [ nnx ] for dup dup [ d# 100 d# 10 * ] + , d# 10 + { indent
  }
 next drop ;
: ups d# 1001 row d# 3001 row d# 5001 row ;
: downs d# 4 row d# 2004 row d# 4004 row d# 6004 row ;
: col ( n ) [ nny ] for dup dup d# 10 + , [ d# 100 d# 10 * ] + { indent
  }
 next drop ;
: lefts d# 12 col d# 32 col d# 52 col d# 72 col { indent }
 d# 92 col d# 112 col d# 132 col d# 152 col ;
: rights d# 8 col d# 28 col d# 48 col d# 68 col { indent }
 d# 88 col d# 108 col d# 128 col d# 148 col d# 168 col ;
: boots ( an ) nn-n [ com ] ! h# 0000,0155 or pc ! ;
: un! for d# 0 over ! d# 1 + next drop ;
: /dest ( a { FFFF,FFEF } ) [ limbo ] swap [ pt ] ! dest ! { indent }
 d# 0 dup port ! pend ! ;
: rese r h# 0000,0031 un! [ h# 0000,00A9 h# 0000,0155 or ] pc ! d# 4 slot
  ! { indent }
 0 dup cl ! ph ! d# -1 es ! { indent }
 d# 0 dup ioc ! ios ! h# 0000,0003 slp ! { indent }
 left /dest up /dest right /dest { indent }
 down /dest [ h# 0000,015D h# 0000,0155 or ] b ! ;
: reset drop d# 0 [ nns d# -1 + ] for i [ com ] ! rese -next ; }block

( 0034,4C00 )               D# 1299 shadow{ 
 ( co-ordinate shared register ports )
: unp ( unpacks a number with computer in hundreds digits and bus in units
  digit. returns address of pending bus content, which becomes bus content
  on next clock tick. )
: , ( given a pair of numbers describing endpoints of a bus. stores address
  of each in memory of other computer. writing to bus register updates
  register at other end. )
: 127 ( f or' destination )
: 12b
: 12d
: 12e
: 129 ( 1 or' pending )
: 125
: 123
: 120
: 128 ( bus 8 right )
: 124 ( bus 4 down )
: 122 ( bus 2 left )
: 121 ( bus 1 up )
: boots ( change execution address )
: reset ( initialize some registers , ) { cr }
 ( execute from idle ) }block

( 0034,5000 )               D# 1300 code{ 
 ( test code for chip ) { br }
 ( custom code ) [ d# 1302 load ] ( exit ) { br }
 ( ide serial ) [ d# 708 node d# 1372 load ] { indent }
 ( sync ) [ d# 300 node d# 1374 load ] { indent }
 ( wire ) [ d# 17 node d# 1376 load ] { indent }
 ( end ) [ d# 16 node d# 1378 load ] { br }
 ( smtm test ) [ d# 0 node d# 1248 load exit ] { br }
 ( */ exerciser ) [ d# 402 node d# 1354 load ] { indent }
 [ d# 401 node d# 1356 load d# 400 node d# 1358 load ] { cr }
 ( serdes ) [ d# 1 node d# 1360 load d# 701 node d# 1362 load ] { cr }
 ( spi flash write ) [ d# 702 node d# 1364 load ] { cr }
 ( ana ) [ d# 715 node d# 1366 load d# 717 node d# 1368 load ] { cr }
 }block

( 0034,5400 )               D# 1301 shadow{ 
 ( this block is loaded to compile test code for any desired nodes. write
  *nnn node* either here before loading a node's source, or in the source
  itself. the *node* phrase compiles the appropriate rom for the given
  node so that test code may reference the rom. ) { br }
 ( things like ide and common tests are loaded here, and this base code
  is presently assigned up at the top of this area just below 1380. to
  simplify base maintenance, please use { 0000,A2CF } for your own testing
  and load it from here. when we begin using personal space above { 0000,B40F
  } your own tests can go there. ) }block

( 0034,5800 )               D# 1302 code{ 
 ( custom test code ) }block

( 0034,5C00 )               D# 1303 shadow{ 
 ( this load block, and the following { 0000,032F } source/shadow pairs,
  are yours to do with as you please! ) }block

( 0034,6000 )               D# 1304 code{ 
 ( eforth rom code ) { br }
 ( sdram addr ) [ d# 9 node d# 1320 load ] { indent }
 ( ctrl ) [ d# 8 node d# 1322 load ] ( ram ) { indent }
 ( data ) [ d# 7 node d# 1324 load ] { indent }
 ( idle ) [ d# 108 node d# 1326 load ] { indent }
 ( user ) [ d# 107 node d# 1328 load ] { br }
 ( eforth stack ) [ d# 106 node d# 1310 d# 2 loads ] { indent }
 ( bitsy ) [ d# 105 node d# 1306 d# 2 loads ] { br }
 }block

( 0034,6400 )               D# 1305 shadow{ 
 ( load block for rom resident sdram and eforth in the ga144. loaded by
  { 0000,758F } even for tapeout. ) }block

( 0034,6800 )               D# 1306 code{ 
 ( e4 bitsy 1of2 ) { cr }
 [ h# 0000,00AA org ]
: rp-- ( a-a' ) { 0000,155D } d# -1 . + ;
: bs@ { -cr }

: 'else ( a-w ) { 0000,159D } { indent }
 @p+ !b !b . ( ' ) @p+ x@ ( ' ) { indent }
 @p+ !b @b ; ( ' ) . . . !p+ ( ' )
: rp@ ( ri-ri ) { 0000,161D } over rp--
: pshbs ( w- ) { 0000,163D } @p+ !b !b ; ( ' ) @p+ pshw ( ' )
: 'r@ ( ri-ri ) { 0000,167D } over rp--
: @w ( a- ) { 0000,169D } bs@ pshbs ;
: rfrom ( ri-r'i ) { 0000,16DD } over rp-- over over @w ;
: popbs ( -w ) { 0000,173D } @p+ !b @b ; ( ' ) !p+ pops ( ' )
: pshr ( aw-a ) { 0000,177D } { indent }
 @p+ !b !b dup ( ' ) @p+ . . @p+ ( ' ) { indent }
 !b @p+ !b . ( ' ) x! ( ' )
: rp++ { -cr }

: ip++ ( a-a' ) { 0000,17FD } d# 1 . + ;
: tor ( ri-r'i ) { 0000,183D } push popbs pshr pop ;
: rp! ( i-ri ) { 0000,189D } push popbs rp++ pop ; { br }

: 'con ( ra-r'i ) { 0000,18FD } bs@
: 'var ( ra-r'i ) { 0000,191D } dup pshbs
: 'exit ( rx-r'i ) { 0000,193D } drop rp-- dup bs@ ; }block

( 0034,6C00 )               D# 1307 shadow{ 
 ( e4 bitsy shadow 1of2 )
: rp-- ( internal )
: x@ ( internal ) { -cr }

: 'else ( eforth microcode )
: rp@ ( eforth microcode )
: pshw ( internal )
: 'r@ ( eforth microcode )
: @w ( internal )
: rfrom ( eforth microcode )
: popw ( internal )
: pshr ( internal )
: rp++ ( internal ) { -cr }

: ip++ ( internal )
: tor ( eforth microcode )
: rp! ( internal )
: 'con ( eforth microcode )
: 'var ( eforth microcode )
: 'exit ( eforth microcode ) }block

( 0034,7000 )               D# 1308 code{ 
 ( e4 bitsy 2of2 ) { br }
 { 0000,197D } begin dup 2* -if { indent }
 ( code.s-xt ) drop !b ahead [ swap ] then { indent }
 ( code.r-xt ) drop push ;' { cr }

: bitsy { 0000,19DD } then dup bs@ push ip++
: xxt { 0000,1A1D } pop -until { indent }
 ( list-xt ) push pshr pop bitsy ; { br }
 ( execute )
: 'ex { 0000,1A7D } ( xt-- ) popbs push xxt ;
: 'lit { 0000,1ABD } ( --w ) dup bs@ push ip++ pop pshbs ;
: 'if { 0000,1B1D } ( f-- ) popbs if { indent }
 drop ip++ ; then drop 'else ; { br }
 { 0000,1B9D } [ exit ] ( start is run in ide )
: start right a! ( terminal ) left b! ( stack ) { indent }
 d# -32 d# 0 ( rp.ip ) bitsy ; }block

( 0034,7400 )               D# 1309 shadow{ 
 ( e4 bitsy 2of2 shadow )
: 'con ( runtime constant )
: 'var ( runtime variable )
: 'exit ( runtime end call ) { br }

: btc ( label e4 interpreter ) { cr }
 ( bitsy main interpreter entry )
: xxt ( internal ) { br }

: 'ex ( runtime execute )
: 'lit ( runtime literal )
: 'if ( runtime conditional branch ) { cr }

: @io ( return the serial bit delay )
: !io ( init serial 0-autobps n-fixedbps )
: t!io ( internal )
: tx! ( transmit one character )
: ttx! ( internal )
: trx? ( internal )
: rx? ( test recieved char - 0 if no char else 18bit inverted char ) }block

( 0034,7800 )               D# 1310 code{ 
 ( e4 stack 1of2 ) { cr }
 [ h# 0000,003C org ]
: xa@ ( a- ) { 0000,079D } @p+ !b !b ; ( ' ) @p+ sd@ ( ' )
: xa! ( a- ) { 0000,07DD } @p+ !b !b ; ( ' ) @p+ sd! ( ' ) { cr }
 { 0000,081D } [ h# 0000,00AA org ]
: 'c@ { -cr }

: '@ { -cr }

: x@ ( a-w ) { 0000,155D } xa@ @b ;
: sp++ { -cr }

: char+ { -cr }

: cell+
: 1+ ( w-w' ) { 0000,159D } d# 1 . + ;
: popt ( p-xp't ) { 0000,15DD } dup sp++ over x@ ;
: sp-- { -cr }

: char- { -cr }

: cell-
: 1- ( w-w' ) { 0000,161D } d# -1 . + ;
: psht ( pt-p' ) { 0000,165D } push sp-- pop over
: x! ( wa- ) { 0000,169D } xa! !b ;
: 'c! { -cr }

: '! ( pwa-p'st ) { 0000,16DD } x!
: popts ( p-p'st ) { 0000,16FD } popt
: pops ( pt-p'st ) { 0000,171D } push popt pop ;
: pshs ( pst-p't ) { 0000,175D } push psht pop ;
: page@ ( pst-p'tw ) { 0000,179D } @p+ !b @b . ( ' ) dup !p+ ; ( ' )
: pshw ( pstw-p'tw ) { 0000,17DD } push pshs pop ;
: page! ( ptw-p'st ) { 0000,181D } @p+ !b !b . ( ' ) drop @p+ ; ( ' )
  pops ;
: sp@ { 0000,187D } ( -a ) pshs psht dup pops ;
: sp! { 0000,18DD } ( a- ) pshs popts ; }block

( 0034,7C00 )               D# 1311 shadow{ 
 ( e4 stack 1of2 shadow )
: 'c@ ( runtime c@ )
: '@ ( runtime @ )
: x@ ( inline external ram )
: sp++ ( increment data stack pointer )
: char+ ( increment address by char size )
: cell+ ( increment address by cell size )
: 1+ ( increment by one )
: popt ( internal )
: sp-- ( decrement data stack pointer )
: char- ( decrement address by char size )
: cell- ( decrement address by cell size )
: 1- ( decrement by one )
: psht ( internal )
: x!
: 'c! ( runtime c! )
: '! ( runtime ! )
: popts ( internal )
: pops ( internal )
: pshs ( internal )
: page@ ( inline external ram )
: pshw ( inline external ram )
: page! ( inline external ram ) }block

( 0034,8000 )               D# 1312 code{ 
 ( e4 stack 2of2 )
: 'drop { 0000,191D } ( w- ) drop pops ;
: 'over { 0000,193D } ( ww-www ) over pshw ;
: 'dup { 0000,195D } ( w-ww ) dup pshw ;
: 'swap { 0000,197D } ( ab-ba ) over push push drop pop pop ;
: '2/ { 0000,19BD } ( w-w ) 2/ ; { -cr }

: '2* { 0000,19DD } ( w-w ) 2* ;
: um+ { 0000,19FD } ( uu-uc ) over or -if { indent }
 { 0000,1A1D } over or . + -if
: 'nc { 0000,1A5D } ( -0 ) dup dup or ;
: 'cy { 0000,1A7D } ( -1 ) then d# 1 ; { indent }
 { 0000,1ABD } then over or -if + 'cy ; then + 'nc ;
: zless { 0000,1B1D } ( n-f ) -if dup or - ; then dup or ;
: 'or { 0000,1B7D } ( ww-w ) over - and
: 'xor { 0000,1B9D } ( ww-w ) or pops ;
: 'and { 0000,1BBD } ( ww-w ) and pops ;
: negate { 0000,1BDD } ( w-w ) 1-
: invert ( w-w' ) { 0000,1BFD } begin ( . ) - ;
: zeq ( w-f ) { 0000,1C1D } until dup or ;
: '+ ( pww-p'sw' ) { 0000,1C5D } + pops ; { 0000,1C7D } ( exit )
: swap- { 0000,1C7D } ( ww-w ) - . + - pops ; { 0000,1CBD } { br }
 { 0000,1CBD } [ exit ] ( start is run in ide )
: start right b! ( sdram ) { cr }
 d# 0 dup dup ( sp.s.t ) --l- ; ( bitsy ) }block

( 0034,8400 )               D# 1313 shadow{ 
 ( e4 stack 2of2 shadow )
: pshw ( internal )
: sp@ ( get data stack pointer )
: sp! ( set data stack pointer )
: 'drop ( runtime drop )
: 'over ( runtime over )
: 'dup ( runtime dup )
: 'swap ( runtime swap )
: zless ( runtime zero less )
: um+ ( add with carry )
: 'nc ( no carry is 0 )
: 'cy ( carry set is 1 )
: 'xor ( runtime exclusive or )
: 'and ( runtime and )
: 'or ( runtime inclusive or )
: negate ( runtime negate )
: invert ( runtime invert )
: zeq ( runtime zero equals )
: '+ ( runtime + )
: '2/ ( runtime 2/ )
: '2* ( runtime 2* ) }block

( 0034,8800 )               D# 1314 code{ 
 ( e4th bitsy ) { br }

: @io { 0000,063D } ( --u ) @p+ ! @ . ( ' ) push t'@io ( ' ) pshw ; {
  cr }
 ( init io device 0-autobps n-fixedbps )
: !io { 0000,069D } ( u-- ) popw
: t!io { 0000,06BD } ( u- ) @p+ ! ! ; ( ' ) @p+ t'!io ; ( ' )
: tx! { 0000,06FD } ( c-- ) popw
: ttx! { 0000,071D } ( c- ) @p+ ! ! ; ( ' ) @p+ - ; ( ' )
: trx? { 0000,075D } ( -c'0 ) @p+ ! @ ; ( ' ) !p+ t'rx? ; ( ' )
: rx? { 0000,079D } ( --c'0 ) trx? pshw ; }block

( 0034,8C00 )               D# 1315 shadow{ 
 }block

( 0034,9000 )               D# 1316 code{ 
 ( e4 terminal 1of2 - serial i/o ) { br }

: getchar { 0000,001D } ( delay in'0 f - delay -char f ) push over 2/
  for . unext .. ( middle of start-bit ) { cr }
 d# 7 for ( 8-data bits ) { indent }
 over for . unext .. { indent }
 h# 0001,FFFF @b ( middle +/- ) { indent }
 over - and push and pop or { cr }
 2/ next { cr }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .. h# 0000,00FF and - dup { cr }
 begin drop @b -until drop pop ; { br }

: putchar { 0000,027D } ( delay in'0 c - delay in'0 ) { cr }
 push over pop { cr }
 2* h# 0003,FE00 dup push - and pop or { cr }
 d# 10 for ( 1-start, 8-data, 2-stop bits ) { indent }
 d# 2 over over 2/ and or !b { indent }
 over for . unext .. { cr }
 2/ next drop drop ; { 0000,043D } }block

( 0034,9400 )               D# 1317 shadow{ 
 ( note. both tx and rx are completely in stock rs232 polarity, i.e. mark
  lo space hi, data low start low. ultimately we need to invert the whole
  thing for compatibility with s40 boot node conventions but for testing
  purposes we will leave it as is and invert the rs232 board. ) { br }

: getchar ( called after seeing leading edge of start bit. returns clean
  inverted character. ) { br }

: putchar ( takes a dirty octet of data and transmits it as startbit,
  eight data bits no parity one stop bit. ) }block

( 0034,9800 )               D# 1318 code{ 
 ( e4 terminal 2of2 - bitsy commands ) { br }

: baud { 0000,043D } ( 0-d ) - push ( space is 0'0000.0100'1 ) { cr }
 { 0000,045D } begin @b - -until ( at start-bit ) { cr }
 { 0000,047D } begin @b -until ( at 1-bit ) { cr }
 { 0000,049D } begin @b zif then - . -until ( at 0-bits ) { cr }
 { 0000,04DD } begin @b zif then . -until ( at stop-bit ) { cr }
 pop - ( n ) dup 2/ . + ( 1.5n ) ; { br }

: @io { 0000,055D } ( delay - delay in'0 0 ) { indent }
 pop a! push dup or baud ! { indent }
 pop pop dup dup or ; { indent }
 begin baud
: !io { 0000,05FD } ( delay in'0 u - delay 0 0 ) { indent }
 until ( abandon old values )
: rx? { 0000,061D } ( delay - delay 0 0 ) d# 0 dup ; { br }

: terminal { 0000,065D } ( delay in'0 x ) { cr }
 begin drop @b - -if getchar then { indent }
 - 2* 2* -if drop .. r--- ( bitsy ) then { cr }
 -until ( delay in'0 -c ) - putchar dup terminal ; { 0000,079D } }block

( 0034,9C00 )               D# 1319 shadow{ 

: @io ( return the serial bit delay ) { br }

: !io ( sets nonzero baud rate delay over garbage. if zero, waits for
  a space character to autobaud with. ) { br }

: rx? ( test for received char ) { br }

: tx! ( send one character ) { br }

: terminal ( polling loop for character receive or send ) }block

( 0034,A000 )               D# 1320 code{ 
 ( sdram address-bus ) { cr }
 ( copy command to address bus ) { br }
 [ h# 0000,00AA org ]
: cmd ( c- ) { 0000,155D } h# 0003,D555 ( nop.xxx ) !b .. { indent }
 @ ( sleeps ) !b cmd ; { br }
 { 0000,15BD } [ exit ] ( start is run in ide )
: start right a! data b! cmd ; }block

( 0034,A400 )               D# 1321 shadow{ 
 }block

( 0034,A800 )               D# 1322 code{ 
 ( sdram control-pins ) { cr }
 ( each word runs the requested rise..fall cycle 12+11 ticks per cycle
  is a 42ns period ) { cr }
 [ h# 0000,0000 org ]
: nooop ( rfr-rfr ) { 0000,001D } ( 'nooop' ) . .. !b { indent }
 .. over over .. . . !b ;
: rcol1 ( rf-rfrf ) { 0000,009D } . . !b { indent }
 .. h# 0000,002B .. !b ( transfer ) { indent }
 . h# 0000,022E .. . . !b ; { cr }
 { 0000,015D } [ h# 0000,0010 org ] ( 8-word page accessible to down port
  )
: cmmd ( rfr-rfr ) { 0000,021D } ( '@p+ ! cmmd' ) !b { indent }
 .. over over .. . . !b ;
: rcol ( rfr-rfr ) { 0000,027D } ( '@p+ ! rcol' ) !b { indent }
 over over .. rcol1 ;
: wcol ( rfr-rfr ) { 0000,02BD } ( '@p+ ! wcol' ) !b { indent }
 h# 0002,003E h# 0002,002E .. !b { indent }
 .. h# 0003,022B .. !b ( transfer ) { indent }
 h# 0003,023B !b .. . . !b { indent }
 h# 0002,002E .. !b h# 0000,002B !b ( recover ) { indent }
 .. over over .. . . !b ; { br }
 { 0000,047D } [ exit ] ( start is run in ide )
: start right a! io b! h# 0000,002E ( cmd-fall ) -d-- ; }block

( 0034,AC00 )               D# 1323 shadow{ 
 }block

( 0034,B000 )               D# 1324 code{ 
 ( sdram data-bus ) { br }
 ( db@ isn't used with 7j chip! ) { cr }
 [ h# 0000,00AA org ] ( called with 'db@' '...!p+' )
: db@ ( -w ) { 0000,155D } @ ; ( wakeup when data ready ) { br }
 ( db! called with '@p+ db!' )
: db! ( w- ) { 0000,157D } h# 0001,5555 !b ( .. set output state ) { indent
  }
 ! ( wakeup when data taken )
: inpt { 0000,15BD } h# 0001,4555 !b ; ( restore input state ) { br }
 { 0000,15FD } [ exit ] ( start is run in ide )
: start up a! io b! down push inpt ; }block

( 0034,B400 )               D# 1325 shadow{ 
 }block

( 0034,B800 )               D# 1326 code{ 
 ( sdram idle-loop ) { cr }
 [ h# 0000,00AA org ]
: noop ( - ) { 0000,155D } @p+ ! ; ( ' ) nooop ( ' )
: cmd ( c- ) { 0000,159D } h# 0000,5A48 ! ! ; ( '@p+ ! cmmd' ) { cr }

: idle ( m-m ) { 0000,15DD } @p+ ! .. ( ' ) nooop ( ' ) h# 0000,8003 cmd
  noop d# 120 for ( 7.8us 42ns/ 5- is 181 ) { indent }
 @p+ ! .. ( ' ) nooop ( ' ) { indent }
 begin { 0000,16FD } @b and if { indent }
 ( ... ) @ .. @ ! ! ( user to ctrl ) { indent }
 ( ... ) *next idle ; { 0000,179D } { indent }
 then drop { cr }
 next @p+ ! .. ( ' ) nooop ( ' ) idle ; { cr }

: init ( m-m ) { 0000,181D } ( run only at power-up/reset ) { indent }
 d# 4761 for ( 200us 42ns/ 1- ) noop next { indent }
 noop h# 0001,0400 ( pre.all ) cmd noop { indent }
 h# 0000,8001 ( rfr.123 ) cmd noop noop { indent }
 h# 0000,8002 ( rfr.123 ) cmd noop noop { indent }
 h# 0000,0021 ( std.mode ) cmd noop noop { indent }
 h# 0000,4000 ( ext.mode ) cmd noop idle ; { br }
 { 0000,1B1D } [ exit ] ( start is run in ide )
: start h# 0000,0135 ( '-dl- ) a! io b! { cr }
 h# 0000,0800 ( n13w? ) dup dup dup dup dup dup { cr }
 dup dup dup init ; }block

( 0034,BC00 )               D# 1327 shadow{ 
 }block

( 0034,C000 )               D# 1328 code{ 
 ( sdram user interface ) { cr }
 [ h# 0000,00AA org ] ( user cmds+data from/to up or right )
: a2rc ( pa-pbc ) { 0000,155D } dup ( 2* 16mw ) push 2/ ( 32mw ) { cr
  }
 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ -if
: row! ( pr-pbc ) { 0000,15FD } h# 0000,7FFF ( row.mask ) and dup .. {
  cr }
 h# 0001,8000 ( activate ) or .. ! h# 0000,5A48 ! .. ( '@p+ ! cmmd' )
  h# 0000,6000 ( bank.mask ) and pop .. h# 0000,03FF ( col.mask ) and
  ; then over + row! ;
: sd@ ( pa-p ) { 0000,177D } a2rc h# 0002,8400 ( read+pre ) or or { cr
  }
 ! h# 0000,5A4B ! .. ( '@p+ ! rcol' ) down b! .. { cr }
 @p+ !b @b ( ' ) @ !p+ .. ( ' ) pop b! !b ;
: sd! ( pa-p ) { 0000,18BD } a2rc h# 0002,0400 ( write+pre ) or or { cr
  }
 ! h# 0000,5A4D ! .. ( '@p+ ! wcol' ) pop b! @b .. { cr }
 down b! .. @p+ !b !b ; ( ' ) @p+ db! ( ' )
: poll ( ru-ru ) { 0000,19FD } io b! @b { cr }
 2* 2* -if push over .. r--- over pop then { cr }
 h# 0000,0800 and . if push .. ---u pop then { cr }
 drop poll ; { br }
 { 0000,1B9D } [ exit ] ( start is run in ide )
: start left ! d# 0 d# 0 ( r.u ) poll ; }block

( 0034,C400 )               D# 1329 shadow{ 
 ( configure for sdram wiring as follows ) { cr }
 2* ( 16mw ) push ( 2/ 32mw ) [ for d# 16 mw wiring ] { cr }
 ( 2* 16mw push ) 2/ ( 32mw ) [ for 32. ] }block

( 0034,C800 )               D# 1330 code{ 
 }block

( 0034,CC00 )               D# 1331 shadow{ 
 }block

( 0034,D000 )               D# 1332 code{ 
 }block

( 0034,D400 )               D# 1333 shadow{ 
 }block

( 0034,D800 )               D# 1334 code{ 
 }block

( 0034,DC00 )               D# 1335 shadow{ 
 }block

( 0034,E000 )               D# 1336 code{ 
 }block

( 0034,E400 )               D# 1337 shadow{ 
 }block

( 0034,E800 )               D# 1338 code{ 
 }block

( 0034,EC00 )               D# 1339 shadow{ 
 }block

( 0034,F000 )               D# 1340 code{ 
 }block

( 0034,F400 )               D# 1341 shadow{ 
 }block

( 0034,F800 )               D# 1342 code{ 
 }block

( 0034,FC00 )               D# 1343 shadow{ 
 }block

( 0035,0000 )               D# 1344 code{ 
 }block

( 0035,0400 )               D# 1345 shadow{ 
 }block

( 0035,0800 )               D# 1346 code{ 
 }block

( 0035,0C00 )               D# 1347 shadow{ 
 }block

( 0035,1000 )               D# 1348 code{ 
 }block

( 0035,1400 )               D# 1349 shadow{ 
 }block

( 0035,1800 )               D# 1350 code{ 
 }block

( 0035,1C00 )               D# 1351 shadow{ 
 }block

( 0035,2000 )               D# 1352 code{ 
 }block

( 0035,2400 )               D# 1353 shadow{ 
 }block

( 0035,2800 )               D# 1354 code{ 
 ( hardware multiply test ) [ d# 0 org +cy ]
: clc { 0000,401D } dup dup or dup . + drop ;
: d2* ( hl-hl ) { 0000,405D } dup . + push dup . + pop ;
: um+ ( hln-hl ) { 0000,40BD } . + push dup dup or . + pop ; { 0000,411D
  } [ -cy ]
: h* ( nu-hl ) { 0000,011D } dup a! dup or d# 17 for +* unext a ;
: abs ( n-n ) { 0000,019D } -if
: neg ( n-n ) { 0000,01BD } - d# 1 . + then ; { 0000,021D } [ +cy ]
: u/mod ( hld-rq ) { 0000,421D } clc neg
: -u/mod { 0000,425D } a! d# 17 push begin begin dup . + push dup . +
  dup a . + -if drop pop *next dup . + ; then over or or pop next dup
  . + ; { 0000,43DD } [ -cy ]
: try { 0000,43DD } right b! ( ba ) @b @b h* ( r ) @b um+ ( a ) @b u/mod
  ( b ) !b ( r ) !b try ; { 0000,44DD } }block

( 0035,2C00 )               D# 1355 shadow{ 

: h* ( is simplest multiply; first arg is a signed number and second,
  the multiplier, is a full { 0000,024F } bit unsigned number. )
: try ( slaves this node to another by the port given. it expects to receive
  numbers b a r and calculates b*a+r then receives a and returns b and
  r. the multiply is done using the h* here which is why b is signed and
  a is unsigned. ) }block

( 0035,3000 )               D# 1356 code{ 
 ( soft multiply test ) [ d# 0 org +cy ]
: clc { 0000,401D } dup dup or dup . + drop ;
: d2* ( hl-hl ) { 0000,405D } dup . + push dup . + pop ;
: um+ ( hln-hl ) { 0000,40BD } . + push dup dup or . + pop ;
: u* ( nn-hl ) { 0000,411D } a! clc dup push dup or dup pop d# 17 for
  begin push d2* a -if 2* a! pop dup push . + push d# 0 . + pop pop *next
  drop ; then 2* a! pop next drop ; { 0000,433D } [ -cy ]
: abs ( n-n ) { 0000,033D } -if
: neg ( n-n ) { 0000,035D } - d# 1 . + then ;
: *. ( ff-f ) { 0000,03BD } over over or push abs swap abs u* d2* d2*
  drop pop -if drop neg ; then drop ; { 0000,04DD } [ +cy ]
: u/mod ( hld-rq ) { 0000,44DD } clc neg
: -u/mod { 0000,451D } a! d# 17 push begin begin dup . + push dup . +
  dup a . + -if drop pop *next dup . + ; then over or or pop next dup
  . + ; { 0000,467D } ( -cy )
: try { 0000,467D } right b! @b @b u* @b um+ @b u/mod !b !b try ; { 0000,475D
  } }block

( 0035,3400 )               D# 1357 shadow{ 
 }block

( 0035,3800 )               D# 1358 code{ 
 ( multiply exerciser ) [ h# 0000,0000 org ]
: dec ( n-n ) d# -1 . + ;
: +or ( nn-n ) over - and or ;
: try ( abr-ab bad ) { 0000,009D } right a! ( 12033 ! ) push dup ! over
  ! pop dup ! push over ! dup @ or @ pop or +or ;
: test ( abr-abr ) dup push try if pop ; then drop pop
: poll @b h# 0000,0200 and if up b! @b push ;' io b! then drop
: run ( abr-abr ) { 0000,035D } if dec test ; then drop if dec over dec
  test ; then drop dec if ( -1 ) h# 0001,FFFF over dec test ; then drop
  h# 0000,600D ; { 0000,053D }
: go { 0000,053D } io b! ( 20000 ) h# 0001,FFFF ( -1 ) h# 0001,FFFF over
  dec run ; { br }

: -u/mod ( old ) { 0000,05FD } a! d# 17 push dup . begin begin { cr }
 + push dup . + dup a . + -if drop pop dup *next + ; then over or or pop
  dup next + ; { 0000,079D } }block

( 0035,3C00 )               D# 1359 shadow{ 

: try ( exercises slave node given a test vector. for the hardware version
  a is unsigned and b is signed. but the divide is unsigned so b is limited
  to the largest positive number. ) }block

( 0035,4000 )               D# 1360 code{ 
 ( serdes test ) [ h# 0000,00AA org ] data a! h# 0003,FFFE dup ! up a!
  begin @ drop unext ( rdlu ) [ d# 0 org ]
: try io b! h# 0002,0000 !b h# 0000,0147 a! d# 0 d# 10000 for d# 1 + dup
  a! next ;
: start @ io b!
: test h# 0002,AAAA @b or ! test . . . . down a! . . start }block

( 0035,4400 )               D# 1361 shadow{ 
 }block

( 0035,4800 )               D# 1362 code{ 
 ( serdes test { 0000,004F } ) [ h# 0000,00AA org ] data a! h# 0003,3333
  dup ! up a! h# 0002,0000 !b begin dup . . . . . . . . . . . . . . .
  . . . . . . ! unext . . . . . . . }block

( 0035,4C00 )               D# 1363 shadow{ 
 }block

( 0035,5000 )               D# 1364 code{ 
 ( spi flash writer michael + greg 2.1 ) [ d# 0 org ]
: 2o ( dw-dw' ) { 0000,001D } obit 2* obit ;
: wait ( dw-dw ) { 0000,005D } select dup begin drop @b -until drop select
  ;
: 2cmd ( dw-d ) { 0000,00DD } select 8obits
: cmd ( dw-d ) select
: !8 ( dw-d ) 8obits drop ;
: set ( -d ) { 0000,017D } io b! ( fast ) d# 5 ;
: fet ( ah al-d ) { 0000,01DD } push push set ( read ) h# 0000,0C00 cmd
  pop !8 pop 8obits !8 ;
: +wr ( -d ) { 0000,029D } set ( wren+wrsr ) h# 0000,1804 2cmd { indent
  }
 ( hi8 zero ) dup !8 ( ebsy ) h# 0001,C000 cmd ;
: aaip ( d-d ) { 0000,035D } h# 0002,B400 wait !8 ;
: x8p ( hln-d asrc ) { 0000,03BD } +wr ( wren+aaip ) h# 0000,1AB4 2cmd
  { cr }
 drop push push push set pop !8 pop 8obits { cr }
 !8 ahead begin aaip [ swap ] then d# 7 for { indent }
 pop dup push push @+ { indent }
 begin 2o 2* next push aaip pop { indent }
 d# 7 pop dup push or push { indent }
 begin 2o 2* next drop next next { cr }
 ( wrdi+dbsy ) h# 0000,1200 wait 2cmd rdl- ; { 0000,073D }
: ers { 0000,073D } +wr ( wren+eras ) h# 0000,1980 2cmd dup select ; {
  0000,07BD } }block

( 0035,5400 )               D# 1365 shadow{ 
 }block

( 0035,5800 )               D# 1366 code{ 
 ( take adc data ) [ d# 0 org ]
: sam+ ( -n ) { 0000,001D { 0000,2ABF } } h# 0000,2155 { 000C,2ABF }
: s+- ( k-n ) io b! !b up b! !b @b ;
: sam- ( -n ) { 0000,00DD { 0001,2ABF } } h# 0000,2955 { 000D,2ABF } s+-
  ; { br }

: sam { 0000,011D } h# 0000,0020 a! sam+ sam- d# 11 2* for { cr }
 push sam+ dup - pop . + ( !+ ) push { cr }
 push sam- dup - pop . + pop + !+ next ; { 0000,02DD } { br }
 [ exit ] sam+ drop }block

( 0035,5C00 )               D# 1367 shadow{ 
 ( this block supports taking of data manually for a/d transfer function.
  to use it, put a/d in the desired mode by editing the constants in sam+
  and - then set desired voltage and execute sam. you will find a sequence
  of samples stored in ram at { 0000,040F } ) { br }
 ( original version sampled each half cycle of the incoming clock. ) }block

( 0035,6000 )               D# 1368 code{ 
 ( generate dac waves ) [ d# 0 org ]
: dly { 0000,001D } d# 100 for unext ;
: sano ( n-n ) h# 0003,FFDF and ; h# 0000,0010 or ;
: tri ( n ) { 0000,00FD } push h# 0000,0155 d# 0 begin { cr }
 d# 510 for over or dup sano !b { indent }
 dly over or d# 1 . + next { cr }
 d# 510 for over or dup sano !b { indent }
 dly over or d# -1 . + next next drop drop ;
: try { 0000,039D } io b!
: sing { 0000,03DD } d# 1000 tri
: poll { 0000,041D } @b h# 0000,2000 and if down b! @b push ;' io b! then
  drop sing ;
: haul { 0000,053D } io b! d# -1 dup push dup push dup push dup push dup
  push dup push dup push dup push push h# 0000,0155 h# 0000,00AA over
  over over over over over ( / ) dup dup
: spin { 0000,06DD } begin !b ( . . ) unext ( !b !b !b !b !b !b !b !b
  ) spin ; { 0000,06FD } [ exit ] { cr }
 h# 0000,0155 h# 0000,01D5 h# 0000,0055 h# 0000,00D5 h# 0000,00AA h# 0000,00D5
  h# 0000,0055 h# 0000,01D5 ( / ) }block

( 0035,6400 )               D# 1369 shadow{ 
 }block

( 0035,6800 )               D# 1370 code{ 
 }block

( 0035,6C00 )               D# 1371 shadow{ 
 }block

( 0035,7000 )               D# 1372 code{ 
 ( ide via async boot ) [ d# 0 org ]
: obit ( dwn-dw ) { 0000,001D } !b over push delay ;
: word ( dw-d ) { 0000,005D } leap drop leap drop leap drop drop ;
: obyt ( dw-dwx ) { 0000,00DD } then then then d# 3 obit drop d# 7 for
  dup d# 1 and d# 3 or obit drop 2/ next d# 2 obit ;
: -out { 0000,023D } ser-exec ( rdl- ) ; { 0000,025D } { br }

: ok { 0000,025D } h# 0003,1416 word -out ;
: fet { 0000,02BD } d# 0
: pump ( n ) for @+ word next -out ;
: stat { 0000,037D } d# 9 pump ;
: bstk { 0000,03BD } @ push .. @ word pop dup push word .. ( @p+.push
  ) h# 0000,49BA ! d# 7 .. dup push ! .. @p+ ! .. ( /+ ) begin !p+ . .
  unext .. begin @ word .. next .. @p+ ! pop .. ( /+ ) pop @p+ ; .. !
  -out ; { 0000,059D } }block

( 0035,7400 )               D# 1373 shadow{ 
 }block

( 0035,7800 )               D# 1374 code{ 
 ( ide via sync boot ) [ d# 0 org ]
: 1bit ( wx-w'x ) drop -if d# 3 ahead [ swap ] then d# 2 { cr }
 then !b 2* dup ;
: word ( w ) { 0000,00DD } d# 8 dup for begin drop @b -until 1bit begin
  drop @b - -until 1bit next drop drop ;
: +out ( x ) { 0000,01FD } begin drop @b - -until drop d# 3 !b ;
: -out ( x ) { 0000,027D } begin drop @b -until { cr }
 drop d# 2 !b d# 1 !b ser-exec ; { br }

: ok { 0000,031D } dup +out h# 0003,1416 word dup -out ;
: fet { 0000,039D } d# 0
: pump ( n ) dup +out for @+ word next dup -out ;
: stat { 0000,047D } d# 9 pump ;
: bstk { 0000,04BD } +out @ dup push . @ word word ( / @p+.push ) h# 0000,49BA
  ! d# 7 . ( / ) dup push ! . ( / ) @p+ ! . . ( /+ ) begin !p+ . . unext
  ( / ) begin @ word ( / ) next ( / ) @p+ ! pop . ( /+ ) pop @p+ ; ( /
  ) ! -out ; { 0000,069D } }block

( 0035,7C00 )               D# 1375 shadow{ 
 }block

( 0035,8000 )               D# 1376 code{ 
 ( ide wire node ) [ d# 0 org ]
: fet { 0000,001D } @p+ !b @ . fet !b @b ! ; { 0000,007D } [ d# 5 org
  ]
: sto { 0000,00BD } @p+ !b @ . sto !b @ !b ; { 0000,011D } [ h# 0000,000A
  org ]
: ins { 0000,015D } @p+ !b @ . ins !b ; { 0000,01BD } [ h# 0000,000D org
  ]
: psh { 0000,01BD } @p+ !b @ . psh !b ; { 0000,021D } [ h# 0000,0010 org
  ]
: stk { 0000,021D } @p+ !b . . stk d# 9 for @b ! unext ; { cr }
 { 0000,02BD } }block

( 0035,8400 )               D# 1377 shadow{ 
 }block

( 0035,8800 )               D# 1378 code{ 
 ( ide last guy ) [ h# 0000,001E org ]
: focus ( i0 ) { 0000,03DD } @p+ !b !b ; ( / ) focus ; [ d# 0 org ]
: fet { 0000,001D } @p+ focus ( /+ ) @p+ a! @ !p+ ( / ) @ !b @b @p+ (
  /+ ) ; ( / ) !b ! ;
: sto { 0000,00BD } @p+ focus ( /+ ) @p+ a! . @p+ ( / ) @ !b @ . ( / )
  !b @p+ !b ; ( /+ ) ! ;
: ins { 0000,015D } @ focus ; ( / ) ins ins
: psh { 0000,01BD } @p+ focus ( /+ ) @p+ ; ( / ) @ !b ;
: stk { 0000,021D } @p+ focus ( /+ ) !p+ dup push !p+ ( / ) @b @b ! dup
  ( / ) ! ( @p+.push ) h# 0000,49BA !b d# 7 ( / ) dup push !b . ( / )
  @p+ !b ( /+ ) begin !p+ . . unext ( / ) begin @b ! unext . ( / ) @p+
  !b !b ; ( /+ ) pop @p+ ; { cr }
 ( if past size-2 not ok- ) { 0000,039D } }block

( 0035,8C00 )               D# 1379 shadow{ 
 }block

( 0035,9000 )               D# 1380 code{ 
 ( common ) { cr }
 [ h# 0000,01D5 org ] { -cr }

: r--- { cr }
 [ h# 0000,0115 org ] { -cr }

: -d-- { cr }
 [ h# 0000,0175 org ] { -cr }

: --l- { cr }
 [ h# 0000,0145 org ] { -cr }

: ---u { cr }
 [ h# 0000,01A5 org ] { -cr }

: rdlu ( right down left up ) { cr }
 [ h# 0000,01B5 org ] { -cr }

: rdl- ( right down left ) { cr }
 [ h# 0000,0185 org ] { -cr }

: rd-u ( right down up ) { cr }
 [ h# 0000,0195 org ] { -cr }

: rd-- ( right down ) }block

( 0035,9400 )               D# 1381 shadow{ 
 }block

( 0035,9800 )               D# 1382 code{ 
 ( polynomial approximation )
: poly ( xn-xy ) pop a! push @+ a begin { indent }
 push *. pop a! @+ + a next push ; }block

( 0035,9C00 )               D# 1383 shadow{ 

: poly ( xn-xy ) { cr }
 ( evaluation of chebyshev polynomials using ) { cr }
 ( the horner scheme. ) { br }
 ( x is the input value. n is the length of ) { cr }
 ( the coefficient table minus 2. coefficient ) { cr }
 ( table follows inline, and execution ) { cr }
 ( continues after the final table entry. x is ) { cr }
 ( left on the stack under the result, y. ) { br }
 ( for example... )
: cos ( f-f' ) { cr }
 ( hart 3300 ) { cr }
 ( -0.0043 0.0794 -0.6459 0.5708 ) { indent }
 2* 2* . triangle dup *. d# 2 poly { indent }
 [ d# -281 , d# 5203 , d# -42329 , d# 37407 , ] { indent }
 push drop pop *. + ; }block

( 0035,A000 )               D# 1384 code{ 
 ( interpolate )
: interp ( ims-v ) dup push push over { indent }
 begin 2/ unext a! { indent }
 and push @+ dup @+ - . + - { indent }
 pop a! dup dup or { indent }
 begin +* unext push drop pop . + ; }block

( 0035,A400 )               D# 1385 shadow{ 

: interp ( ims-v ) { cr }
 ( to determine values for m and s ... ) { cr }
 ( let l be number of meaningful input bits. ) { cr }
 ( let n be power of 2 where 2**n + 1 is the ) { cr }
 ( number of table entries. ) { br }
 ( s equals l-n-1 ) { cr }
 ( m equals 2** l-n - 1 ) { br }
 ( so for example if you have an 8 bit adc, ) { cr }
 ( l equals 8. let n equal 2 for a 5 entry table. the table is expected
  to be at address 0, ) { cr }
 ( so to represent 0 to 1800 millivolts... ) { br }
 [ 0 org 0 , 450 , 900 , 1350 , 1800 , ] { cr }

: mv ( i-n ) h# 0000,003F 5 interp ; { br }
 [ d# 0 mv ] ( gives ) [ d# 0 ] { cr }
 [ d# 128 mv ] ( gives ) [ d# 900 ] { cr }
 [ d# 256 mv ] ( gives ) [ d# 1800 ] { cr }
 ( and intermediate values are interpolated. ) }block

( 0035,A800 )               D# 1386 code{ 
 ( fir or iir filter )
: taps ( yxc-y'x' ) pop a! push begin { indent }
 @+ @ push a push *.17 pop a! { indent }
 push !+ pop . + pop next @ a! ; }block

( 0035,AC00 )               D# 1387 shadow{ 

: taps ( yxc-y'x' ) { cr }
 ( for example... ) { br }

: fir ( yx-y'x' ) d# 15 taps [ d# -53 , d# 0 , d# 2276 , d# 0 , d# 382
  , d# 0 , d# -1706 , d# 0 , d# -1158 , d# 0 , d# 2014 , d# 0 , d# 2406
  , d# 0 , d# -1977 , d# 0 , d# -4206 , d# 0 , d# 1289 , d# 0 , d# 6801
  , d# 0 , d# 678 , d# 0 , d# -11109 , d# 0 , d# -6250 , d# 0 , d# 23531
  , d# 0 , d# 54145 , d# 0 , ] { br }
 ( 16 taps, 16 coefficients with intermediate ) { cr }
 ( storage interleaved. ) }block

( 0035,B000 )               D# 1388 code{ 
 ( routing; called with 'a relay' )
: relay ( a ) pop a! @+ push @+ zif { indent }
 drop ahead ( done ) [ swap ] then { indent }
 pop over push @p+ ( ' ) a relay ( ' ) { indent }
 !b !b !b begin @+ !b unext
: done then a push a! ; }block

( 0035,B400 )               D# 1389 shadow{ 
 ( relay moves a port executable packet down ) { cr }
 ( a sequence of nodes linked by their b ) { cr }
 ( registers. the packet consists of a 1-cell ) { cr }
 ( index, a 1-cell count ) [ less one ] ( of body ) { cr }
 ( size, and the body cells. ) { br }
 ( a packet ) [ may ] ( be started from memory within ) { cr }
 ( a node, or it may simply be fed to a port. ) { br }
 ( relay assumes that b points to the next ) { cr }
 ( node in the chain. uses one return stack ) { cr }
 ( location and four data stack locations. ) { cr }
 ( it must be at the same location in every ) { cr }
 ( node. ) }block

( 0035,B800 )               D# 1390 code{ 
 ( multiply )
: *.17 ( a b - a a*b ) a! d# 16 push dup dup or { indent }
 begin +* unext - +* a -if { indent }
 drop - 2* ; then drop 2* - ; }block

( 0035,BC00 )               D# 1391 shadow{ 

: *.17 ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. note that the definition of ) *. { cr }
 ( contains a call to this word. ) { br }
 ( 17 bit fractions --- s.i ffff ffff ffff ffff ) }block

( 0035,C000 )               D# 1392 code{ 
 ( lshift rshift )
: lsh push begin 2* unext ;
: rsh push begin 2/ unext ; }block

( 0035,C400 )               D# 1393 shadow{ 
 }block

( 0035,C800 )               D# 1394 code{ 
 ( triangle )
: triangle ( x-y call with; 2* 2* triangle ) { indent }
 h# 0001,0000 over -if drop . + ; then { indent }
 drop - . + - ; }block

( 0035,CC00 )               D# 1395 shadow{ 

: triangle ( assuming an angle expressed as a ) { cr }
 ( 16 bit fraction of a revolution, ) { cr }
 [ 2* 2* triangle ] ( produces a triangle wave ) { cr }
 ( approximation to the cosine of that angle. ) }block

( 0035,D000 )               D# 1396 code{ 
 ( fractional multiply )
: *. { 0000,16FD } ( f1 f2 - f1 f1*f2 ) *.17 { indent }
 a 2* -if drop - 2* - ; then { indent }
 drop 2* ; }block

( 0035,D400 )               D# 1397 shadow{ 

: *. ( multiplies a fraction by a fraction, ) { cr }
 ( giving a fraction, or an integer by a ) { cr }
 ( fraction, giving an integer. note that f1 ) { cr }
 ( is left in s to be ignored, dropped, or ) { cr }
 ( reused. ) { br }
 ( 16 bit fractions --- si. ffff ffff ffff ffff ) }block

( 0035,D800 )               D# 1398 code{ 
 ( divide ) { cr }
 [ +cy ] { 0000,5A7D } ( enter ea mode )
: clc dup dup or dup . + drop ;
: --u/mod clc
: -u/mod ( hld-rq ) a! d# 17 push begin begin { indent }
 dup . + . push dup . + { indent }
 dup a . + -if { indent }
 drop pop *next dup . + ; then { indent }
 over or or . pop next dup . + ; { cr }
 [ -cy ] { 0000,1C3D } ( exit ea mode ) }block

( 0035,DC00 )               D# 1399 shadow{ 

: clc ( clears the carry bit for addition in ) { cr }
 ( ea mode. ) { br }
 ( the following defines u/mod in ram ... ) { cr }

: u/mod ( hld-rq ) - d# 1 . + --u/mod ; { br }
 ( if the divisor is a constant, just negate ) { cr }
 ( it at edit or compile time. ) }block

( 0035,E000 )               D# 1400 code{ 
 ( g18 compiler )
:# h 28
:# ip 27
:# slot 4
:# call? 0
:# cal 270080062
:# com 16 [ macro ]
: !7 h# 00BD,0489 3, h# FFFF,FFFC , < drop > ;
: 2*s ?lit h# 0000,E0C1 2, 1, ;
: call ( nn ) < ?dup > h# 0000,00B8 1, , h# 0000,00E9 1, [ cal ] @ here
  d# 3 + - + , ; [ forth ]
: swap swap ;
: eras ( an ) push h# 0000,61FC ( call a9 ) swap block pop blks fill ;
: memory ( n-a ) [ h# 0000,0240 - ] and [ com ] @ 2* h# 0000,8000 + block
  + ; [ h# 0000,8000 nnc d# 2 * eras ]
: org ( n ) dup [ h ] ! [ ip ] !
: break d# 4 [ slot ] ! ;
: o ( n ) d# 6 for d# 10 /mod next d# 6 for d# 8 * + next
: p, ( n ) [ h ] @ memory ! [ h ] @ d# 1 over + over or h# 0000,007F and
  or [ h ] ! ;
: s4 [ h ] @ [ ip ] ! d# 13 2*s dup [ call? ] ! p, d# 1 [ slot ] ! ;
: s0 d# 13 2*s
: sn dup [ call? ] ! [ ip ] @ memory +! d# 1 [ slot ] +! ;
: s1 d# 8 2*s sn ;
: s2 d# 3 2*s sn ;
: s3 dup d# 3 and drop if d# 7 sn s4 ; then d# 4 / sn ;
: i, [ slot ] @ jump s0 s1 s2 s3 s4 }block

( 0035,E400 )               D# 1401 shadow{ 
 ( g18 target compiler ) [ includes support for g18 addressing see d#
  1404 ]
: h ( address of next available word in target memory here )
: ip ( address of current instruction word )
: slot ( next available instruction slot )
: call? ( was last instruction a call ? )
: call a ( compile a call )
: eras ( fills g18 memory with call 155 number )
: 2*s n ( shift left n bits )
: memory n-a ( host address for target memory )
: org n ( set current target memory location )
: break ( break in emulator only )
: p, n ( compile pattern into target memory )
: s0-s4 ( assemble opcode into slot 0-3 )
: i, ( assemble opcode into next slot *note** simple code jump table using
  ) [ jump ] }block

( 0035,E800 )               D# 1402 code{ 
 ( target )
: cnt 2/ d# -1 + ;
: defer ( -b ) pop ;
: execute ( b ) push ;
: f! ( bn ) [ sp ] + ! ;
: f@ ( n-b ) [ sp ] + @ ;
: class ( b ) [ last d# 1 + ] ! ;
: empty empt
: host d# 0 class [ d# 6 f@ ] nop [ d# 4 f@ ] nop [ d# 13 f@ ] nop
: functions ( bbb ) d# 13 f! d# 4 f! d# 6 f! ;
: . h# 0000,001C i, ; ( nop )
: hhere here ;
: .. [ slot ] @ d# 4 or drop if . .. ; then d# 0 [ call? ] ! ;
: here .. [ h ] @ h# 0000,03FF and ; [ hhere ]
: report here d# 32 * [ d# 13 d# 16 + ] + !7 ;
: c18 ( b ) d# 1 f@ [ d# 0 + ] functions ;
: +cy here h# 0000,0200 over - and or org ;
: -cy here [ h# 0000,0200 - ] and org ;
: await [ com ] @ idle [ cal ] @ execute ; }block

( 0035,EC00 )               D# 1403 shadow{ 

: defer -a ( byte address of the compiled code that follows -- used for
  forward referencing )
: execute a ( code at this address )
: f! an ( store address of code executed when a word with this function
  is interpreted )
: f@ n-a ( fetch address of function code )
: class a ( store address of code to be executed for each word subsequently
  defined )
: empty ( redefine empty to restore altered functions )
: host ( change context back to colorforth )
: functions aa ( store functions in kernel specific way )
: c18 ( save green word and number functions. set green short-number to
  n, compile to call. target words are executed to assemble instructions
  )
: . ( nop used to fill instruction words )
: nops ( fills rest of word with nops )
: here -a ( starts new instruction word. leaves target address as number
  )
: await ( generates call to node's idle ports. ) }block

( 0035,F000 )               D# 1404 code{ 
 ( g18 jump instructions )
: 9same ( axa-ax ) push over pop - or [ h# 0000,0200 ] and drop ;
: j3 .
: j0 i, [ ip ] @ memory +! break ;
: j1 [ h ] @ 9same if over h# 0000,0100 and drop if swap h# 0000,00FF
  and swap j0 ; then then . . j3 ;
: j2 over h# 0000,0155 or [ h ] @ or h# 0000,03F8 and drop if . j3 ; then
  swap d# 7 and swap j0 ;
: -adr ( an ) swap h# 0000,0155 or swap [ slot ] @ jump j0 j1 j2 j3 j0
: adr ( n-n ) [ slot ] @ d# 3 or drop if i, [ ip ] @ d# 8 * [ h ] @ [
  ip ] @ negate + + d# 8 * [ slot ] @ + break ; then . adr ;
: @h ( n-a ) d# 8 /mod + ;
: f3 ( an ) over h# 0000,0155 or over @h or h# 0000,02F8 and drop if abort
  ; then swap d# 7 and swap d# 8 / memory +! ;
: f2 dup @h 9same if over h# 0000,0100 and drop if swap h# 0000,00FF and
  swap
: f1 d# 8 / memory +! ; then then abort ;
: then ( n ) here h# 0000,0155 or swap d# 8 /mod swap jump f1 f1 f2 f3
  }block

( 0035,F400 )               D# 1405 shadow{ 
 [ the g18 uses adr bit d# 9 for mode; d# 8 for i/o; d# 7 for rom. incrementer
  maintains bits 0-6, rest are left alone except for return and slot d#
  0 jumps. ] { br }

: 9same ( is true if the two addresses match in bit 9 - the extended arithmetic
  mode bit. )
: -adr an ( assembles jump to known address )
: adr n-a ( assembles forward jump in slot 0,1,2. value left on stack
  is instr addr * 64 + here-ip + slot. )
: @h ( given that vlue value / 8 returns p at time the jump executes.
  )
: then a ( insert address for forward jump ) }block

( 0035,F800 )               D# 1406 code{ 
 ( complex instructions )
: def defer here < call > ;
: call defer ( a ) d# 3 -adr ; [ call cal ! ]
: ; [ call? ] @ dup h# 0000,6000 or drop if dup h# 0000,0300 or drop if
  dup h# 0000,0018 or drop if d# 0 and i, break ; then then then dup 2/
  and negate [ ip ] @ memory +! ;
: -if ( -a ) d# 7 adr ;
: if ( -a ) d# 6 adr ;
: -until ( a ) d# 7 -adr ;
: until ( a ) d# 6 -adr ;
: -while ( a-aa ) d# 7 adr swap ;
: while ( a-aa ) d# 6 adr swap ;
: zif ( -a ) d# 5 adr ;
: *next ( aa-a ) swap
: next ( a ) d# 5 -adr ;
: unext ( a ) d# 4 i, drop ;
: n defer d# 8 f@ execute
: lit d# 8 i, h# 0003,FFFF and ( ok in slot 3 )
: , ( n ) h# 0001,5555 or p, ;
: for h# 0000,001D i,
: begin here ;
: ahead ( -a ) d# 2 adr ;
: end ( a ) d# 2 -adr ;
: leap ( -a ) d# 3 adr ; }block

( 0035,FC00 )               D# 1407 shadow{ 

: def -a ( deferred to class. executed for every target definition to
  compile host code that compiles target call )
: call a ( compile target call )
: ; ( will be executed as a target word. the pentium macro has precedence
  while compiling )
: if/-if ( leaves address of jump on stack )
: -until a ( jump if positive to ) begin
: zif ( forward ) next ( decrements r and jumps if r! else pops and falls
  thru )
: next/for
: n ( executed for green short-numbers. all 18-bit target numbers are
  short. executes white short-number to put interpreted number on stack.
  then assembles literal instruction with number in next location. inverted
  for rom )
: , n ( compile number into target memory )
: ?lit -n ( retrieve previously compiled number )
: begin -a ( starts new instruction word. leaves properly formatted target
  address )
: ahead ( compiles fwd ref jump resolve w/then )
: leap ( like ahead but compiles a call ) }block

( 0036,0000 )               D# 1408 code{ 
 ( instructions )
: target n c18 def class ;
: ex { -cr }

: ;' d# 1 i, break ;
: rx
: @p { -cr }

: @p+ d# 8 i, ;
: @+ d# 9 i, ;
: @b h# 0000,000A i, ;
: @ h# 0000,000B i, ;
: !p { -cr }

: !p+ h# 0000,000C i, ;
: !+ h# 0000,000D i, ;
: !b h# 0000,000E i, ;
: ! h# 0000,000F i, ; }block

( 0036,0400 )               D# 1409 shadow{ 
 ( words being redefined for the target computer. these host words can
  no longer be executed. although pentium macros take precedence during
  compilation, they will no longer be used. )
: g18 ( instructions )
: 0 ( ; ) ....8 ( n ) ..10 ( +* ) ..18 ( dup )
: 1 ( ;' ) ...9 ( @+ ) .11 ( 2* ) ..19 ( pop )
: 2 ( j ) ....a ( @b ) .12 ( 2/ ) ..1a ( over )
: 3 ( call ) .b ( @ ) ..13 ( - ) ...1b ( a )
: 4 ( unext ) c ( !p+ ) 14 ( + ) ...1c ( . )
: 5 ( next ) .d ( !+ ) .15 ( and ) .1d ( push )
: 6 ( if ) ...e ( !b ) .16 ( or ) ..1e ( b! )
: 7 ( -if ) ..f ( ! ) ..17 ( drop ) 1f ( a! ) }block

( 0036,0800 )               D# 1410 code{ 
 ( port literals and constants )
: right [ h# 0000,01D5 ] lit ; ( 0101111111 register bits )
: down [ h# 0000,0115 ] lit ; ( 0110111111 )
: left [ h# 0000,0175 ] lit ; ( 0111011111 )
: up [ h# 0000,0145 ] lit ; ( 0111101111 )
: warp [ h# 0000,0157 ] lit ; ( 0101010111 )
: io h# 0000,015D lit ; ( 0111110111 )
: data h# 0000,0141 lit ; ( 0111101011 port calls )
: center h# 0000,01A5 lit ;
: top h# 0000,01B5 lit ;
: side h# 0000,0185 lit ;
: corner h# 0000,0195 lit ;
: /mod /mod ;
: spispeed d# 497 ( 0 ) lit ; [ h# 0000,0000 ] ( 24-bit adrs ) [ d# 4
  * d# 262144 /mod ] ( al ah ) [ h# 0000,0003 ] ( read cmd ) [ d# 256
  * + d# 4 * ]
: spicmd ( c.ah ) [ d# 0 + ] lit ;
: spiadr ( al ) [ d# 0 + ] lit ; }block

( 0036,0C00 )               D# 1411 shadow{ 
 }block

( 0036,1000 )               D# 1412 code{ 
 ( more instructions )
: +* h# 0000,0010 i, ; ( slot 3 ok )
: 2* h# 0000,0011 i, ;
: 2/ h# 0000,0012 i, ;
: - h# 0000,0013 i, ;
: + h# 0000,0014 i, ; ( slot 3 ok )
: and h# 0000,0015 i, ;
: or h# 0000,0016 i, ; ( exclusive-or )
: drop h# 0000,0017 i, ;
: dup h# 0000,0018 i, ; ( slot 3 ok )
: pop h# 0000,0019 i, ;
: over h# 0000,001A i, ;
: a h# 0000,001B i, ;
: push h# 0000,001D i, ;
: b! h# 0000,001E i, ;
: a! h# 0000,001F i, ; }block

( 0036,1400 )               D# 1413 shadow{ 

: o ( replaces top-of-stack with 0. g18 instructions can't be used in
  macros - forth macros take precedence ) }block

( 0036,1800 )               D# 1414 code{ 
 }block

( 0036,1C00 )               D# 1415 shadow{ 
 }block

( 0036,2000 )               D# 1416 code{ 
 }block

( 0036,2400 )               D# 1417 shadow{ 
 }block

( 0036,2800 )               D# 1418 code{ 
 ( math rom anywhere ) [ d# 0 kind ] { br }
 [ h# 0000,00A1 org ] { cr }
 { 0000,143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000,153D } { -cr }

: warm await ; { br }
 [ h# 0000,00B0 org ] { cr }
 { 0000,161D } [ d# 1390 load ] ( multiply ) { cr }
 { 0000,16FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 0000,179D } [ d# 1386 load ] ( taps ) { cr }
 { 0000,189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 0000,19DD } [ d# 1394 load ] ( triangle ) { cr }
 { 0000,1A7D } [ d# 1398 load ] ( -u/mod ) { br }
 [ h# 0000,00AA org ] { cr }
 { 0000,155D } [ d# 1382 load ] ( polynomial approximation ) { cr }
 { 0000,161D } }block

( 0036,2C00 )               D# 1419 shadow{ 
 }block

( 0036,3000 )               D# 1420 code{ 
 ( serdes boot top/bot ) [ d# 6 kind h# 0000,00AA reset ] { br }
 [ h# 0000,00A1 org ] { cr }
 { 0000,143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000,153D } { -cr }

: warm await ; { cr }

: cold { 0000,155D } h# 0000,3141 a! h# 0003,FFFE dup ! rdlu cold ; {
  br }
 { 0000,161D } [ d# 1390 load ] ( multiply ) { cr }
 { 0000,16FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 0000,179D } [ d# 1386 load ] ( taps ) { cr }
 { 0000,189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 0000,19DD } [ d# 1394 load ] ( triangle ) { cr }
 { 0000,1A7D } [ d# 1398 load ] ( -u/mod ) { cr }
 { 0000,1C3D } }block

( 0036,3400 )               D# 1421 shadow{ 
 }block

( 0036,3800 )               D# 1422 code{ 
 ( sync serial boot side ) [ d# 2 kind h# 0000,00AA reset ] { cr { 0000,17FF
  } }
 [ h# 0000,00BE org ] { -cr }

: sget { cr }
 [ h# 0000,00A1 org ] { cr }
 { 0000,143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000,153D } { -cr }

: warm await ; { cr }

: cold { 0000,155D } h# 0000,31A5 a! @ @b . . -if ( 0pin ) { cr }
 h# 0003,FD85 ( 'rd-u 3fc00 + ) dup push dup begin { cr }
 drop @b . -if ( /pin ) *next [ swap ] then { cr }
 h# 0000,0185 ( 'rd-u ) push drop push ; then
: ser-exec { 0000,16DD } ( x-x ) sget push sget a! sget
: ser-copy { 0000,173D } push zif ; then { cr }
 begin sget ( push sget pop !+ ) !+ next ;
: sget { 0000,17DD } ( -w ) dup leap leap
: 6in { 0000,181D } then then leap leap
: 2in { 0000,185D } then then 2* 2* dup begin { cr }
 . drop @b . - -until - d# 2 and dup begin { cr }
 . drop @b . . -until d# 2 and 2/ or or ; { br }
 { 0000,199D } [ d# 1390 load ] ( multiply ) { cr }
 { 0000,1A7D } [ d# 1386 load ] ( taps ) { cr }
 { 0000,1B7D } [ d# 1394 load ] ( triangle ) { cr }
 { 0000,1C1D } }block

( 0036,3C00 )               D# 1423 shadow{ 
 ( sync serial boot side ) { br }
 ( ser-copy reads one word per loop and the loop counter is the actual
  number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

( 0036,4000 )               D# 1424 code{ 
 ( async serial boot top/bot ) [ d# 1 kind h# 0000,00AA reset ] { cr {
  0000,19FF } }
 [ h# 0000,00CB org ] { -cr }

: 18ibits { cr }
 [ h# 0000,00A1 org ] { cr }
 { 0000,143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000,153D } { -cr }

: warm await ;
: cold { 0000,155D } h# 0000,31A5 ( 'rdlu ) a! @ @b .. -if
: ser-exec { 0000,15DD } ( x-d ) 18ibits drop push . { cr }
 18ibits drop a! . 18ibits
: ser-copy { 0000,167D } ( xnx-d ) drop push zif ; then begin { cr }
 18ibits drop ( push . 18ibits drop pop . !+ ) !+ ( . ) next ; then drop
  h# 0000,01B5 ( 'rdl- ) push push ;
: wait { 0000,177D } ( x ) begin . drop @b -until . drop ;
: sync { 0000,17DD } ( x-delay ) dup dup wait or - push begin @b . -if
  . drop *next rdl- ; then . drop pop - 2/ ;
: start { 0000,18BD } ( delay word - delay word b ) { cr }
 dup wait over dup 2/ . + push
: delay { 0000,191D } ( nw-nwb ) { cr }
 begin @b . -if then . drop next @b ; { br }
 { 0000,197D } [ d# 1426 load ] ( 18ibits ) { cr }
 { 0000,1B3D } [ d# 1392 load ] ( lsh rsh ) { cr }
 { 0000,1BBD } }block

( 0036,4400 )               D# 1425 shadow{ 
 ( async serial boot top/bot ) { br }
 ( ser-copy reads one word per loop and the loop counter is the actual
  number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

( 0036,4800 )               D# 1426 code{ 
 ( more async serial )
: 18ibits { 0000,197D } ( x - delay word x ) { indent }
 sync sync dup start leap ( 2bits ) leap
: byte { 0000,1A1D } then drop start leap
: 4bits { 0000,1A5D } then leap
: 2bits { 0000,1A7D } then then leap
: 1bit { 0000,1A9D } ( nwb-nwb ) then { indent }
 push 2/ pop over or { indent }
 h# 0002,0000 and or over push delay ; { cr }
 { 0000,1B3D } }block

( 0036,4C00 )               D# 1427 shadow{ 
 }block

( 0036,5000 )               D# 1428 code{ 
 ( spi boot top/bot ) [ d# 4 kind h# 0000,00AA reset host ]
: --- [ h# 0000,002A ] lit ;
: --+ [ h# 0000,002B ] lit ;
: +-- [ h# 0000,003A ] lit ;
: +-+ [ h# 0000,003B ] lit ;
: -++ [ h# 0000,002F ] lit ; [ target ] { cr }
 [ h# 0000,00A1 org d# 1388 load ] ( relay ) { br }
 [ h# 0000,00C2 org ]
: 8obits ( dw-dw' ) d# 7 for leap ( obit ) 2* *next ;
: ibit { 0000,18FD } ( dw-dw' ) { indent }
 @b . -if drop - 2* ; then drop 2* - ;
: half { 0000,195D } ( dwc-dw ) !b over for . . unext ;
: select { 0000,199D } ( dw-dw ) -++ half --+ half ;
: obit { 0000,1A1D } ( dw-dw ) then { indent }
 -if +-- half +-+ half ; then
: rbit { 0000,1ABD } ( dw-dw ) --- half --+ half ;
: 18ibits { 0000,1B3D } ( d-dw ) dup d# 17 for rbit ibit - next ; { cr
  }

: u2/ 2/ h# 0001,FFFF and ; { cr }
 [ h# 0000,00A9 org ] { cr }
 { 0000,153D } { -cr }

: warm await ; { cr }
 { 0000,155D } [ d# 1430 load ] ( the rest ) { cr }
 { 0000,183D } }block

( 0036,5400 )               D# 1429 shadow{ 
 }block

( 0036,5800 )               D# 1430 code{ 
 ( more spi )
: cold { 0000,155D } @b - .. [ h# 0000,01B5 ] ( 'rdl- ) -until { indent
  }
 spispeed spiadr push spicmd
: spi-boot { 0000,161D } ( dly adrh . adrl - dly x ) { indent }
 select 8obits 8obits { indent }
 drop pop . 8obits 8obits
: spi-exec { 0000,16DD } ( dx-dx ) drop 18ibits { indent }
 h# 0001,E000 . + [ h# 0000,01B5 ] ( 'rdl- ) -until { indent }
 push 18ibits a! 18ibits
: spi-copy { 0000,179D } ( dn-dx ) push zif ; then begin { indent }
 18ibits ( push 18ibits pop !+ ) !+ next dup ; { 0000,183D } ( was { 0000,185F
  } ) }block

( 0036,5C00 )               D# 1431 shadow{ 
 ( more spi ) { br }
 ( spi-copy reads one word per loop and the loop counter is the actual
  number of words being ) { cr }
 ( sent ie a count of zero means no words sent ) }block

( 0036,6000 )               D# 1432 code{ 
 ( analog ) [ d# 0 kind ] { br }
 [ h# 0000,00A1 org ] { cr }
 { 0000,143D } [ d# 1388 load ] ( relay ) { cr }
 { 0000,153D } { -cr }

: warm await ; { br }
 [ h# 0000,00B0 org ] { cr }
 { 0000,161D } [ d# 1390 load ] ( multiply ) { cr }
 { 0000,16FD } [ d# 1396 load ] ( fractional multiply ) { cr }
 { 0000,179D } [ d# 1434 load ] ( -dac ) { cr }
 { 0000,189D } [ d# 1384 load ] ( interpolate ) { cr }
 { 0000,19DD } [ d# 1394 load ] ( triangle ) { cr }
 { 0000,1A7D } [ d# 1398 load ] ( -u/mod ) { br }
 [ h# 0000,00AA org ] { cr }
 { 0000,155D } [ d# 1382 load ] ( polynomial approximation ) { cr }
 { 0000,161D } }block

( 0036,6400 )               D# 1433 shadow{ 
 }block

( 0036,6800 )               D# 1434 code{ 
 ( dac )
: -dac ( legacy entry name below )
: dac27 { 0000,179D } ( mcpaw-mcp ) dup push push { indent }
 over pop - . + push push h# 0000,0155 { indent }
 pop over or a { indent }
 begin unext !b . { indent }
 begin unext !b !b ; }block

( 0036,6C00 )               D# 1435 shadow{ 
 }block

( 0036,7000 )               D# 1436 code{ 
 ( 1-wire ) [ d# 3 kind h# 0000,00AA org ] { br }
 [ h# 0000,009E org ]
: rcv ( s-sn ) { 0000,13DD } a push dup dup a! d# 17 for begin
: bit { 0000,143D } @ drop @b -if { indent }
 drop - 2* - *next pop a! ; then { indent }
 drop 2* next pop a! ; { 0000,151D } { br }
 [ h# 0000,00A9 org ]
: warm { 0000,153D } await ;
: cold { 0000,155D } left center a! . io b! { indent }
 dup dup h# 0000,00B7 ( rest ) dup push push d# 16 push { indent }
 @ drop @b [ h# 0000,0185 ] ( side ) -until { indent }
 drop a! . bit ; { 0000,16FD } ( rest ) { indent }
 push rcv a! rcv push zif ; then { indent }
 begin rcv !+ next ; { 0000,17DD } { br }
 { 0000,17DD } [ d# 1394 load ] ( triangle { 0000,00AF } ) { cr }
 { 0000,187D } [ d# 1390 load ] ( multiply *.17 { 0000,00EF } ) { cr }
 { 0000,195D } [ d# 1396 load ] ( fractional multiply *. { 0000,00AF }
  ) { cr }
 { 0000,19FD { 0000,AD0F } } ( load interpolate interp { 0000,014F } )
  { cr }
 { 0000,19FD } [ d# 1398 load ] ( -u/mod { 0000,01CF } ) { cr }
 { 0000,1BDD } ( equals { 0000,13DF } ) }block

( 0036,7400 )               D# 1437 shadow{ 
 }block

( 0036,7800 )               D# 1438 code{ 
 ( null rom anywhere ) [ d# 0 kind ] { br }
 [ h# 0000,00A9 org ] { cr }
 ( warm ) { 0000,153D } await ; }block

( 0036,7C00 )               D# 1439 shadow{ 
 ( default code for null rom, or for special rom to be loaded out of sequence.
  ) { br }

: warm ( is assumed by crawlers, and is also the destination of the call
  instruction that rom is initialized with. ) [ avoid clobbering this
  word since steven's test code will not work in its absence. ] }block


( 0036,8000 )               
