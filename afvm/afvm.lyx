#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass literate-article
\begin_preamble
\input{afvmConfig.tex}
\end_preamble
\use_default_options true
\begin_modules
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics dvips
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\rightmargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
ArrayForth Virtual Machine Generator
\end_layout

\begin_layout Standard
\noindent
\align center
Copyright © 2002,2003,2005,2007,2008 Free Software Foundation, Inc.
\begin_inset Newline newline
\end_inset

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.3 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is included in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:GNU-Free-Documentation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="none" valignment="top" width="0">
<column alignment="none" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Software Version
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Date
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="none" valignment="top" bottomline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
projectVersion
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
projectDate
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Make sure the afvmConfig.tex file is setup properly before exporting to PDF.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Vmgen documentation
\end_layout

\begin_layout Standard
This documentation is for Vmgen (version 0.7.9-20120209, November 17, 2011),
 the virtual machine interpreter generator.
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Vmgen is a tool for writing efficient interpreters.
 It takes a simple virtual machine description and generates efficient C
 code for dealing with the virtual machine code in various ways (in particular,
 executing it).
 The run-time efficiency of the resulting interpreters is usually within
 a factor of 10 of machine code produced by an optimizing compiler.
\end_layout

\begin_layout Standard
The interpreter design strategy supported by Vmgen is to divide the interpreter
 into two parts:
\end_layout

\begin_layout Itemize
The front end takes the source code of the language to be implemented, and
 translates it into virtual machine code.
 This is similar to an ordinary compiler front end; typically an interpreter
 front-end performs no optimization, so it is relatively simple to implement
 and runs fast.
\end_layout

\begin_layout Itemize
The virtual machine interpreter executes the virtual machine code.
\end_layout

\begin_layout Standard
Such a division is usually used in interpreters, for modularity as well
 as for efficiency.
 The virtual machine code is typically passed between front end and virtual
 machine interpreter in memory, like in a load-and-go compiler; this avoids
 the complexity and time cost of writing the code to a file and reading
 it again.
\end_layout

\begin_layout Standard
A virtual machine (VM) represents the program as a sequence of VM instructions,
 following each other in memory, similar to real machine code.
 Control flow occurs through VM branch instructions, like in a real machine.
\end_layout

\begin_layout Standard
In this setup, Vmgen can generate most of the code dealing with virtual
 machine instructions from a simple description of the virtual machine instructi
ons (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Input-File-Format"

\end_inset

), in particular:
\end_layout

\begin_layout Description
VM
\begin_inset space ~
\end_inset

instruction
\begin_inset space ~
\end_inset

execution
\end_layout

\begin_layout Description
VM
\begin_inset space ~
\end_inset

code
\begin_inset space ~
\end_inset

generation Useful in the front end.
\end_layout

\begin_layout Description
VM
\begin_inset space ~
\end_inset

code
\begin_inset space ~
\end_inset

decompiler Useful for debugging the front end.
\end_layout

\begin_layout Description
VM
\begin_inset space ~
\end_inset

code
\begin_inset space ~
\end_inset

tracing Useful for debugging the front end and the VM interpreter.
 You will typically provide other means for debugging the user's programs
 at the source level.
\end_layout

\begin_layout Description
VM
\begin_inset space ~
\end_inset

code
\begin_inset space ~
\end_inset

profiling Useful for optimizing the VM interpreter with superinstructions
 (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-profiler"

\end_inset

).
\end_layout

\begin_layout Standard
To create parts of the interpretive system that do not deal with VM instructions
, you have to use other tools (e.g., bison) and/or hand-code them.
\end_layout

\begin_layout Standard
Vmgen supports efficient interpreters though various optimizations, in particula
r
\end_layout

\begin_layout Itemize
Threaded code
\end_layout

\begin_layout Itemize
Caching the top-of-stack in a register
\end_layout

\begin_layout Itemize
Combining VM instructions into superinstructions
\end_layout

\begin_layout Itemize
Replicating VM (super)instructions for better BTB prediction accuracy (not
 yet in vmgen-ex, but already in Gforth).
\end_layout

\begin_layout Standard
As a result, Vmgen-based interpreters are only about an order of magnitude
 slower than native code from an optimizing C compiler on small benchmarks;
 on large benchmarks, which spend more time in the run-time system, the
 slowdown is often less (e.g., the slowdown of a Vmgen-generated JVM interpreter
 over the best JVM JIT compiler we measured is only a factor of 2-3 for
 large benchmarks; some other JITs and all other interpreters we looked
 at were slower than our interpreter).
\end_layout

\begin_layout Standard
VMs are usually designed as stack machines (passing data between VM instructions
 on a stack), and Vmgen supports such designs especially well; however,
 you can also use Vmgen for implementing a register VM (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Register-Machines"

\end_inset

) and still benefit from most of the advantages offered by Vmgen.
\end_layout

\begin_layout Standard
There are many potential uses of the instruction descriptions that are not
 implemented at the moment, but we are open for feature requests, and we
 will consider new features if someone asks for them; so the feature list
 above is not exhaustive.
\end_layout

\begin_layout Subsection
Why interpreters?
\end_layout

\begin_layout Standard
Interpreters are a popular language implementation technique because they
 combine all three of the following advantages:
\end_layout

\begin_layout Itemize
Ease of implementation
\end_layout

\begin_layout Itemize
Portability
\end_layout

\begin_layout Itemize
Fast edit-compile-run cycle
\end_layout

\begin_layout Standard
Vmgen makes it even easier to implement interpreters.
\end_layout

\begin_layout Standard
The main disadvantage of interpreters is their run-time speed.
 However, there are huge differences between different interpreters in this
 area: the slowdown over optimized C code on programs consisting of simple
 operations is typically a factor of 10 for the more efficient interpreters,
 and a factor of 1000 for the less efficient ones (the slowdown for programs
 executing complex operations is less, because the time spent in libraries
 for executing complex operations is the same in all implementation strategies).
\end_layout

\begin_layout Standard
Vmgen supports techniques for building efficient interpreters.
\end_layout

\begin_layout Subsection
Concepts
\end_layout

\begin_layout Itemize
Front end and VM interpreter: Modularizing an interpretive system
\end_layout

\begin_layout Itemize
Data handling: Stacks, registers, immediate arguments
\end_layout

\begin_layout Itemize
Dispatch: From one VM instruction to the next
\end_layout

\begin_layout Subsubsection
Front end and VM interpreter
\end_layout

\begin_layout Standard
Interpretive systems are typically divided into a front end that parses
 the input language and produces an intermediate representation for the
 program, and an interpreter that executes the intermediate representation
 of the program.
\end_layout

\begin_layout Standard
For efficient interpreters the intermediate representation of choice is
 virtual machine code (rather than, e.g., an abstract syntax tree).
 Virtual machine (VM) code consists of VM instructions arranged sequentially
 in memory; they are executed in sequence by the VM interpreter, but VM
 branch instructions can change the control flow and are used for implementing
 control structures.
 The conceptual similarity to real machine code results in the name virtual
 machine.
 Various terms similar to terms for real machines are used; e.g., there are
 VM registers (like the instruction pointer and stack pointer(s)), and the
 VM instruction consists of an opcode and immediate arguments.
\end_layout

\begin_layout Standard
In this framework, Vmgen supports building the VM interpreter and any other
 component dealing with VM instructions.
 It does not have any support for the front end, apart from VM code generation
 support.
 The front end can be implemented with classical compiler front-end techniques,
 supported by tools like flex and bison.
\end_layout

\begin_layout Standard
The intermediate representation is usually just internal to the interpreter,
 but some systems also support saving it to a file, either as an image file,
 or in a full-blown linkable file format (e.g., JVM).
 Vmgen currently has no special support for such features, but the information
 in the instruction descriptions can be helpful, and we are open to feature
 requests and suggestions.
\end_layout

\begin_layout Subsubsection
Data handling
\end_layout

\begin_layout Standard
Most VMs use one or more stacks for passing temporary data between VM instructio
ns.
 Another option is to use a register machine architecture for the virtual
 machine; we believe that using a stack architecture is usually both simpler
 and faster.
\end_layout

\begin_layout Standard
However, this option is slower or significantly more complex to implement
 than a stack machine architecture.
\end_layout

\begin_layout Standard
Vmgen has special support and optimizations for stack VMs, making their
 implementation easy and efficient.
\end_layout

\begin_layout Standard
You can also implement a register VM with Vmgen (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Register-Machines"

\end_inset

), and you will still profit from most Vmgen features.
\end_layout

\begin_layout Standard
Stack items all have the same size, so they typically will be as wide as
 an integer, pointer, or floating-point value.
 Vmgen supports treating two consecutive stack items as a single value,
 but anything larger is best kept in some other memory area (e.g., the heap),
 with pointers to the data on the stack.
\end_layout

\begin_layout Standard
Another source of data is immediate arguments VM instructions (in the VM
 instruction stream).
 The VM instruction stream is handled similar to a stack in Vmgen.
\end_layout

\begin_layout Standard
Vmgen has no built-in support for, nor restrictions against garbage collection.
 If you need garbage collection, you need to provide it in your run-time
 libraries.
 Using reference counting is probably harder, but might be possible (contact
 us if you are interested).
\end_layout

\begin_layout Subsubsection
Dispatch
\end_layout

\begin_layout Standard
Understanding this section is probably not necessary for using Vmgen, but
 it may help.
 You may want to skip it now, and read it if you find statements about dispatch
 methods confusing.
\end_layout

\begin_layout Standard
After executing one VM instruction, the VM interpreter has to dispatch the
 next VM instruction (Vmgen calls the dispatch routine ‘
\family typewriter
\series bold
NEXT
\family default
\series default
’).
 Vmgen supports two methods of dispatch:
\end_layout

\begin_layout Description
switch
\begin_inset space ~
\end_inset

dispatch In this method the VM interpreter contains a giant switch statement,
 with one case for each VM instruction.
 The VM instruction opcodes are represented by integers (e.g., produced by
 an 
\family typewriter
\series bold
enum
\family default
\series default
) in the VM code, and dispatch occurs by loading the next opcode, switching
 on it, and continuing at the appropriate 
\family typewriter
\series bold
case
\family default
\series default
; after executing the VM instruction, the VM interpreter jumps back to the
 dispatch code.
\end_layout

\begin_layout Description
threaded
\begin_inset space ~
\end_inset

code This method represents a VM instruction opcode by the address of the
 start of the machine code fragment for executing the VM instruction.
 Dispatch consists of loading this address, jumping to it, and incrementing
 the VM instruction pointer.
 Typically the threaded-code dispatch code is appended directly to the code
 for executing the VM instruction.
 Threaded code cannot be implemented in ANSI C, but it can be implemented
 using GNU C's labels-as-values extension.
\end_layout

\begin_layout Standard
Threaded code can be twice as fast as switch dispatch, depending on the
 interpreter, the benchmark, and the machine.
\end_layout

\begin_layout Subsection
Invoking Vmgen
\end_layout

\begin_layout Standard
The usual way to invoke Vmgen is as follows:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
vmgen inputfile
\end_layout

\begin_layout Standard
Here 
\family typewriter
\series bold
inputfile
\family default
\series default
 is the VM instruction description file, which usually ends in 
\family typewriter
\series bold
.vmg
\family default
\series default
.
 The output filenames are made by taking the basename of 
\family typewriter
\series bold
inputfile
\family default
\series default
 (i.e., the output files will be created in the current working directory)
 and replacing 
\family typewriter
\series bold
.vmg
\family default
\series default
 with 
\family typewriter
\series bold
-vm.i
\family default
\series default
, 
\family typewriter
\series bold
-disasm.i
\family default
\series default
, 
\family typewriter
\series bold
-gen.i
\family default
\series default
, 
\family typewriter
\series bold
-labels.i
\family default
\series default
, 
\family typewriter
\series bold
-profile.i
\family default
\series default
, and 
\family typewriter
\series bold
-peephole.i
\family default
\series default
.
 E.g., 
\family typewriter
\series bold
vmgen hack/foo.vmg
\family default
\series default
 will create 
\family typewriter
\series bold
foo-vm.i
\family default
\series default
, 
\family typewriter
\series bold
foo-disasm.i
\family default
\series default
, 
\family typewriter
\series bold
foo-gen.i
\family default
\series default
, 
\family typewriter
\series bold
foo-labels.i
\family default
\series default
, 
\family typewriter
\series bold
foo-profile.i
\family default
\series default
 and 
\family typewriter
\series bold
foo-peephole.i
\family default
\series default
.
\end_layout

\begin_layout Standard
The command-line options supported by Vmgen are
\end_layout

\begin_layout Description
--help
\end_layout

\begin_layout Description
-h Print a message about the command-line options
\end_layout

\begin_layout Description
--version
\end_layout

\begin_layout Description
-v Print version and exit
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Itemize
Example overview
\end_layout

\begin_layout Itemize
Using profiling to create superinstructions
\end_layout

\begin_layout Subsubsection
Example overview
\end_layout

\begin_layout Standard
There are two versions of the same example for using Vmgen: 
\family typewriter
\series bold
vmgen-ex
\family default
\series default
 and 
\family typewriter
\series bold
vmgen-ex2
\family default
\series default
 (you can also see Gforth as example, but it uses additional (undocumented)
 features, and also differs in some other respects).
 The example implements 
\family typewriter
\series bold
mini
\family default
\series default
, a tiny Modula-2-like language with a small JavaVM-like virtual machine.
\end_layout

\begin_layout Standard
The difference between the examples is that 
\family typewriter
\series bold
vmgen-ex
\family default
\series default
 uses many casts, and 
\family typewriter
\series bold
vmgen-ex2
\family default
\series default
 tries to avoids most casts and uses unions instead.
 In the rest of this manual we usually mention just files in 
\family typewriter
\series bold
vmgen-ex
\family default
\series default
; if you want to use unions, use the equivalent file in 
\family typewriter
\series bold
vmgen-ex2
\family default
\series default
.
\end_layout

\begin_layout Standard
You can build the example by 
\family typewriter
\series bold
cd
\family default
\series default
ing into the example's directory, and then typing 
\family typewriter
\series bold
make
\family default
\series default
; you can check that it works with 
\family typewriter
\series bold
make check
\family default
\series default
.
 You can run run 
\family typewriter
\series bold
mini
\family default
\series default
 programs like this:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
./mini fib.mini
\end_layout

\begin_layout Standard
To learn about the options, type 
\family typewriter
\series bold
./mini -h
\family default
\series default
.
\end_layout

\begin_layout Subsubsection
Using profiling to create superinstructions
\begin_inset CommandInset label
LatexCommand label
name "sub:Using-profiling-to"

\end_inset


\end_layout

\begin_layout Standard
I have not added rules for this in the 
\family typewriter
\series bold
Makefile
\family default
\series default
 (there are many options for selecting superinstructions, and I did not
 want to hardcode one into the 
\family typewriter
\series bold
Makefile
\family default
\series default
), but there are some supporting scripts, and here's an example:
\end_layout

\begin_layout Standard
Suppose you want to use 
\family typewriter
\series bold
fib.mini
\family default
\series default
 and 
\family typewriter
\series bold
test.mini
\family default
\series default
 as training programs, you get the profiles like this:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
make fib.prof test.prof
\end_layout

\begin_layout Standard
It takes a few seconds and then you can aggregate these profiles with 
\family typewriter
\series bold
stat.awk
\family default
\series default
:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
awk -f stat.awk fib.prof test.prof
\end_layout

\begin_layout Standard
The result contains lines like:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
2 16 36910041 loadlocal lit
\end_layout

\begin_layout Standard
This means that the sequence 
\family typewriter
\series bold
loadlocal lit
\family default
\series default
 statically occurs a total of 16 times in 2 profiles, with a dynamic execution
 count of 36910041.
\end_layout

\begin_layout Standard
The numbers can be used in various ways to select superinstructions.
 E.g., if you just want to select all sequences with a dynamic execution count
 exceeding 10000, you would use the following pipeline:
\end_layout

\begin_layout Scrap
<<profile-fib-test>>=
\begin_inset Newline newline
\end_inset

make fib.prof test.prof
\begin_inset Newline newline
\end_inset

awk -f stat.awk fib.prof test.prof| 
\backslash

\begin_inset Newline newline
\end_inset

awk '$3>=10000'| #select sequences 
\backslash

\begin_inset Newline newline
\end_inset

fgrep -v -f peephole-blacklist| #eliminate wrong instructions 
\backslash

\begin_inset Newline newline
\end_inset

awk -f seq2rule.awk| #transform sequences into superinstruction rules 
\backslash

\begin_inset Newline newline
\end_inset

sort -k 3 >mini-super.vmg #sort sequences
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The file 
\family typewriter
\series bold
peephole-blacklist
\family default
\series default
 contains all instructions that directly access a stack or stack pointer
 (for mini: 
\family typewriter
\series bold
call
\family default
\series default
, 
\family typewriter
\series bold
return
\family default
\series default
); the sort step is necessary to ensure that prefixes precede larger superinstru
ctions.
\end_layout

\begin_layout Standard
Now you can create a version of mini with superinstructions by just saying
 ‘
\family typewriter
\series bold
make
\family default
\series default
’
\end_layout

\begin_layout Subsection
Input File Format
\begin_inset CommandInset label
LatexCommand label
name "sub:Input-File-Format"

\end_inset


\end_layout

\begin_layout Standard
Vmgen takes as input a file containing specifications of virtual machine
 instructions.
 This file usually has a name ending in 
\family typewriter
\series bold
.vmg
\family default
\series default
.
\end_layout

\begin_layout Standard
Most examples are taken from the example in 
\family typewriter
\series bold
vmgen-ex
\family default
\series default
.
\end_layout

\begin_layout Itemize
Input File Grammar
\end_layout

\begin_layout Itemize
Simple instructions
\end_layout

\begin_layout Itemize
Superinstructions
\end_layout

\begin_layout Itemize
Store Optimization
\end_layout

\begin_layout Itemize
Register Machines: How to define register VM instructions
\end_layout

\begin_layout Subsubsection
Input File Grammar
\end_layout

\begin_layout Standard
The grammar is in EBNF format, with 
\family typewriter
\series bold
a|b
\family default
\series default
 meaning “a or b”, 
\family typewriter
\series bold
{c}
\family default
\series default
 meaning 0 or more repetitions of c and 
\family typewriter
\series bold
[d]
\family default
\series default
 meaning 0 or 1 repetitions of d.
\end_layout

\begin_layout Standard
Vmgen input is not free-format, so you have to take care where you put newlines
 (and, in a few cases, white space).
\end_layout

\begin_layout Description
description: {instruction|comment|eval-escape|c-escape}
\end_layout

\begin_layout Description
instruction: simple-inst|super-inst
\end_layout

\begin_layout Description
simple-inst: ident '(' stack-effect ')' newline c-code newline newline
\end_layout

\begin_layout Description
stack-effect: {ident} '--' {ident}
\end_layout

\begin_layout Description
super-inst: ident '=' ident {ident}
\end_layout

\begin_layout Description
comment: '
\backslash
 ' text newline
\end_layout

\begin_layout Description
eval-escape: '
\backslash
E ' text newline
\end_layout

\begin_layout Description
c-escape: '
\backslash
C ' text newline
\end_layout

\begin_layout Standard
Note that the 
\backslash
s in this grammar are meant literally, not as C-style encodings for non-printabl
e characters.
\end_layout

\begin_layout Standard
There are two ways to delimit the C code in simple-inst:
\end_layout

\begin_layout Itemize
If you start it with a ‘
\family typewriter
\series bold
{
\family default
\series default
’ at the start of a line (i.e., not even white space before it), you have
 to end it with a ‘
\family typewriter
\series bold
}
\family default
\series default
’ at the start of a line (followed by a newline).
 In this case you may have empty lines within the C code (typically used
 between variable definitions and statements).
\end_layout

\begin_layout Itemize
You do not start it with ‘
\family typewriter
\series bold
{
\family default
\series default
’.
 Then the C code ends at the first empty line, so you cannot have empty
 lines within this code.
\end_layout

\begin_layout Standard
The text in 
\family typewriter
\series bold
comment
\family default
\series default
, 
\family typewriter
\series bold
eval-escape
\family default
\series default
 and 
\family typewriter
\series bold
c-escape
\family default
\series default
 must not contain a newline.
 
\family typewriter
\series bold
Ident
\family default
\series default
 must conform to the usual conventions of C identifiers (otherwise the C
 compiler would choke on the Vmgen output), except that idents in 
\family typewriter
\series bold
stack-effect
\family default
\series default
 may have a stack prefix (for stack prefix syntax, see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Eval-escapes"

\end_inset

).
\end_layout

\begin_layout Standard
The 
\family typewriter
\series bold
c-escape
\family default
\series default
 passes the text through to each output file (without the ‘
\family typewriter
\series bold

\backslash
C
\family default
\series default
’).
 This is useful mainly for conditional compilation (i.e., you write ‘
\family typewriter
\series bold

\backslash
C #if ...
\family default
\series default
’ etc.).
\end_layout

\begin_layout Standard
In addition to the syntax given in the grammer, Vmgen also processes sync
 lines (lines starting with ‘
\family typewriter
\series bold
#line
\family default
\series default
’), as produced by ‘
\family typewriter
\series bold
m4 -s
\family default
\series default
’ and similar tools.
 This allows associating C compiler error messages with the original source
 of the C code.
\end_layout

\begin_layout Scrap
<<M4>>=
\begin_inset Newline newline
\end_inset

M4=m4 -s #recommended if supported
\begin_inset Newline newline
\end_inset

#M4=m4
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Vmgen understands a few extensions beyond the grammar given here, but these
 extensions are only useful for building Gforth.
 You can find a description of the format used for Gforth in 
\family typewriter
\series bold
prim
\family default
\series default
.
\end_layout

\begin_layout Paragraph
Eval escapes
\begin_inset CommandInset label
LatexCommand label
name "par:Eval-escapes"

\end_inset


\end_layout

\begin_layout Standard
The text in 
\family typewriter
\series bold
eval-escape
\family default
\series default
 is Forth code that is evaluated when Vmgen reads the line.
 You will normally use this feature to define stacks and types.
\end_layout

\begin_layout Standard
If you do not know (and do not want to learn) Forth, you can build the text
 according to the following grammar; these rules are normally all Forth
 you need for using Vmgen:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
text: stack-decl|type-prefix-decl|stack-prefix-decl|set-flag
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
stack-decl: 'stack ' ident ident ident
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
type-prefix-decl: 's" ' string '" ' ('single'|'double') ident 'type-prefix'
 ident
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
stack-prefix-decl: ident 'stack-prefix' string
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
set-flag: ('store-optimization'|'include-skipped-insts') ('on'|'off')
\end_layout

\begin_layout Standard
Note that the syntax of this code is not checked thoroughly (there are many
 other Forth program fragments that could be written in an 
\family typewriter
\series bold
eval-escape
\family default
\series default
).
\end_layout

\begin_layout Standard
A stack prefix can contain letters, digits, or ‘
\family typewriter
\series bold
:
\family default
\series default
’, and may start with an ‘
\family typewriter
\series bold
#
\family default
\series default
’; e.g., in Gforth the return stack has the stack prefix ‘
\family typewriter
\series bold
R:
\family default
\series default
’.
 This restriction is not checked during the stack prefix definition, but
 it is enforced by the parsing rules for stack items later.
\end_layout

\begin_layout Standard
If you know Forth, the stack effects of the non-standard words involved
 are:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
stack ( "name" "pointer" "type" -- ) ( name execution: -- stack )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
type-prefix ( addr u item-size stack "prefix" -- )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
single ( -- item-size )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
double ( -- item-size )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
stack-prefix ( stack "prefix" -- )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
store-optimization ( -- addr )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
include-skipped-insts ( -- addr )
\end_layout

\begin_layout Standard
An 
\family typewriter
\series bold
item-size
\family default
\series default
 takes three cells on the stack.
\end_layout

\begin_layout Subsubsection
Simple instructions
\end_layout

\begin_layout Standard
We will use the following simple VM instruction descriptions as examples:
\end_layout

\begin_layout Scrap
<<simple-instructions>>=
\begin_inset Newline newline
\end_inset


\backslash
 simple VM instructions:
\begin_inset Newline newline
\end_inset

add ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1+i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

sub ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1-i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

mul ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1*i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

and ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1 & i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

or ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1 | i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

lessthan ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1<i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

equals ( i1 i2 -- i )
\begin_inset Newline newline
\end_inset

i = i1==i2;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

not ( i1 -- i2 )
\begin_inset Newline newline
\end_inset

i2 = !i1;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

negate ( i1 -- i2 )
\begin_inset Newline newline
\end_inset

i2 = -i1;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<lit>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

drop ( i -- )
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

print ( i -- )
\begin_inset Newline newline
\end_inset

printf("%ld
\backslash
n", i);
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The first line specifies the name of the VM instruction (e.g.
 
\family typewriter
\series bold
sub
\family default
\series default
) and its stack effect (e.g.
 
\family typewriter
\series bold
i1 i2 -- i
\family default
\series default
).
 The rest of the description is just plain C code.
\end_layout

\begin_layout Standard
The stack effect specifies that sub pulls two integers from the data stack
 and puts them in the C variables 
\family typewriter
\series bold
i1
\family default
\series default
 and 
\family typewriter
\series bold
i2
\family default
\series default
 (with the rightmost item (
\family typewriter
\series bold
i2
\family default
\series default
) taken from the top of stack; intuition: if you push 
\family typewriter
\series bold
i1
\family default
\series default
, then 
\family typewriter
\series bold
i2
\family default
\series default
 on the stack, the resulting stack picture is 
\family typewriter
\series bold
i1 i2
\family default
\series default
) and later pushes one integer (
\family typewriter
\series bold
i
\family default
\series default
) on the data stack (the rightmost item is on the top afterwards).
\end_layout

\begin_layout Standard
How do we know the type and stack of the stack items? Vmgen uses prefixes,
 similar to Fortran; in contrast to Fortran, you have to define the prefix
 first:
\end_layout

\begin_layout Scrap
<<type-prefix>>=
\begin_inset Newline newline
\end_inset


\backslash
 type prefix definitions:
\begin_inset Newline newline
\end_inset


\backslash
E s" Cell"   single data-stack type-prefix i
\begin_inset Newline newline
\end_inset


\backslash
E s" char *" single data-stack type-prefix a
\begin_inset Newline newline
\end_inset


\backslash
E s" Inst *" single data-stack type-prefix target
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This defines the prefix 
\family typewriter
\series bold
i
\family default
\series default
 to refer to the type 
\family typewriter
\series bold
Cell
\family default
\series default
 (defined as 
\family typewriter
\series bold
long
\family default
\series default
 in 
\family typewriter
\series bold
mini.h
\family default
\series default
) and, by default, to the 
\family typewriter
\series bold
data-stack
\family default
\series default
.
 It also specifies that this type takes one stack item (
\family typewriter
\series bold
single
\family default
\series default
).
 The type prefix is part of the variable name.
\end_layout

\begin_layout Standard
Before we can use 
\family typewriter
\series bold
data-stack
\family default
\series default
 in this way, we have to define it:
\end_layout

\begin_layout Scrap
<<stack-definitions>>=
\begin_inset Newline newline
\end_inset


\backslash
 stack definitions:
\begin_inset Newline newline
\end_inset


\backslash
E stack data-stack sp Cell
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This line defines the stack data-stack, which uses the stack pointer 
\family typewriter
\series bold
sp
\family default
\series default
, and each item has the basic type 
\family typewriter
\series bold
Cell
\family default
\series default
; other types have to fit into one or two Cells (depending on whether the
 type is single or double wide), and are cast from and to Cells on accessing
 the data-stack with type cast macros (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-engine"

\end_inset

).
 By default, stacks grow towards lower addresses in Vmgen-erated interpreters
 (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Stack-growth-direction"

\end_inset

).
\end_layout

\begin_layout Standard
We can override the default stack of a stack item by using a stack prefix.
 E.g., consider the following instruction:
\end_layout

\begin_layout Scrap
<<lit>>=
\begin_inset Newline newline
\end_inset

lit ( #i -- i )
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
The VM instruction 
\family typewriter
\series bold
lit
\family default
\series default
 takes the item 
\family typewriter
\series bold
i
\family default
\series default
 from the instruction stream (indicated by the prefix 
\family typewriter
\series bold
#
\family default
\series default
), and pushes it on the (default) data stack.
 The stack prefix is not part of the variable name.
 Stack prefixes are defined like this:
\end_layout

\begin_layout Scrap
<<stack-prefix>>=
\begin_inset Newline newline
\end_inset


\backslash
 stack prefix definitions
\begin_inset Newline newline
\end_inset


\backslash
E inst-stream stack-prefix #
\begin_inset Newline newline
\end_inset


\backslash
E data-stack  stack-prefix S:
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This definition defines that the stack prefix 
\family typewriter
\series bold
#
\family default
\series default
 specifies the “stack” 
\family typewriter
\series bold
inst-stream
\family default
\series default
.
 Since the instruction stream behaves a little differently than an ordinary
 stack, it is predefined, and you do not need to define it.
\end_layout

\begin_layout Standard
The instruction stream contains instructions and their immediate arguments,
 so specifying that an argument comes from the instruction stream indicates
 an immediate argument.
 Of course, instruction stream arguments can only appear to the left of
 
\family typewriter
\series bold
--
\family default
\series default
 in the stack effect.
 If there are multiple instruction stream arguments, the leftmost is the
 first one (just as the intuition suggests).
\end_layout

\begin_layout Paragraph
Explicit stack access
\end_layout

\begin_layout Standard
This feature is not needed and not supported in the 0.7.9 version of Vmgen
 that is documented here (and that is invoked by default).
\end_layout

\begin_layout Standard
Not all stack effects can be specified using the stack effect specifications
 above.
 For VM instructions that have other stack effects, you can specify them
 explicitly by accessing the stack pointer in the C code; however, you have
 to notify Vmgen of such explicit stack accesses, otherwise Vmgen's optimization
s could conflict with your explicit stack accesses.
\end_layout

\begin_layout Standard
You notify Vmgen by putting 
\family typewriter
\series bold
...

\family default
\series default
 with the appropriate stack prefix into the stack comment.
 Then the VM instruction will first take the other stack items specified
 in the stack effect into C variables, then make sure that all other stack
 items for that stack are in memory, and that the stack pointer for the
 stack points to the top-of-stack (by default, unless you change the stack
 access transformation: see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Stack-growth-direction"

\end_inset

).
\end_layout

\begin_layout Standard
The general rule is: If you mention a stack pointer in the C code of a VM
 instruction, you should put a 
\family typewriter
\series bold
...

\family default
\series default
 for that stack in the stack effect.
\end_layout

\begin_layout Standard
Consider this example:
\end_layout

\begin_layout Scrap
<<unused-stack-adjust>>=
\begin_inset Newline newline
\end_inset

return ( #iadjust S:...
 target afp i1 -- i2 )
\begin_inset Newline newline
\end_inset

SET_IP(target);
\begin_inset Newline newline
\end_inset

sp = (Cell *)(((char *)sp)+iadjust);
\begin_inset Newline newline
\end_inset

fp = afp;
\begin_inset Newline newline
\end_inset

i2=i1;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
First the variables 
\family typewriter
\series bold
target afp i1
\family default
\series default
 are popped off the stack, then the stack pointer 
\family typewriter
\series bold
sp
\family default
\series default
 is set correctly for the new stack depth, then the C code changes the stack
 depth and does other things, and finally 
\family typewriter
\series bold
i2
\family default
\series default
 is pushed on the stack with the new depth.
\end_layout

\begin_layout Standard
The position of the 
\family typewriter
\series bold
...

\family default
\series default
 within the stack effect does not matter.
 You can use several 
\family typewriter
\series bold
...
\family default
\series default
s, for different stacks, and also several for the same stack (that has no
 additional effect).
 If you use 
\family typewriter
\series bold
...

\family default
\series default
 without a stack prefix, this specifies all the stacks except the instruction
 stream.
\end_layout

\begin_layout Standard
You cannot use 
\family typewriter
\series bold
...

\family default
\series default
 for the instruction stream, but that is not necessary: At the start of
 the C code, IP points to the start of the next VM instruction (i.e., right
 beyond the end of the current VM instruction), and you can change the instructi
on pointer with 
\family typewriter
\series bold
SET_IP
\family default
\series default
 (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-engine"

\end_inset

).
\end_layout

\begin_layout Paragraph
C Code Macros
\begin_inset CommandInset label
LatexCommand label
name "par:C-Code-Macros"

\end_inset


\end_layout

\begin_layout Standard
Vmgen recognizes the following strings in the C code part of simple instructions
:
\end_layout

\begin_layout Description
SET_IP As far as Vmgen is concerned, a VM instruction containing this ends
 a VM basic block (used in profiling to delimit profiled sequences).
 On the C level, this also sets the instruction pointer.
\end_layout

\begin_layout Scrap
<<branch>>=
\begin_inset Newline newline
\end_inset

branch ( #target -- )
\begin_inset Newline newline
\end_inset

SET_IP(target);
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SUPER_END This ends a basic block (for profiling), even if the instruction
 contains no 
\family typewriter
\series bold
SET_IP
\family default
\series default
.
\end_layout

\begin_layout Scrap
<<end>>=
\begin_inset Newline newline
\end_inset

end ( i -- )
\begin_inset Newline newline
\end_inset

/* SUPER_END would increment the next BB count (because IP points there);
\begin_inset Newline newline
\end_inset

   this would be a problem if there is no following BB.
\begin_inset Newline newline
\end_inset

   Instead, we do the following to add an end point for the current BB:
 */
\begin_inset Newline newline
\end_inset

#ifdef VM_PROFILING
\begin_inset Newline newline
\end_inset

block_insert(IP); /* we also do this at compile time, so this is unnecessary
 */
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

return i;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
INST_TAIL; Vmgen replaces ‘
\family typewriter
\series bold
INST_TAIL;
\family default
\series default
’ with code for ending a VM instruction and dispatching the next VM instruction.
 Even without a ‘
\family typewriter
\series bold
INST_TAIL;
\family default
\series default
’ this happens automatically when control reaches the end of the C code.
 If you want to have this in the middle of the C code, you need to use ‘
\family typewriter
\series bold
INST_TAIL;
\family default
\series default
’.
 A typical example is a conditional VM branch.
 In this example, ‘
\family typewriter
\series bold
INST_TAIL;
\family default
\series default
’ is not strictly necessary, because there is another one implicitly after
 the if-statement, but using it improves branch prediction accuracy slightly
 and allows other optimizations.
\end_layout

\begin_layout Scrap
<<zbranch>>=
\begin_inset Newline newline
\end_inset

zbranch ( #target i -- )
\begin_inset Newline newline
\end_inset

if (i==0) {
\begin_inset Newline newline
\end_inset

  SET_IP(target);
\begin_inset Newline newline
\end_inset

  INST_TAIL;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SUPER_CONTINUE This indicates that the implicit tail at the end of the VM
 instruction dispatches the sequentially next VM instruction even if there
 is a 
\family typewriter
\series bold
SET_IP
\family default
\series default
 in the VM instruction.
 This enables an optimization that is not yet implemented in the vmgen-ex
 code (but in Gforth).
 The typical application is in conditional VM branches.
\end_layout

\begin_layout Scrap
<<unused-branch>>=
\begin_inset Newline newline
\end_inset

unused-branch ( #target i -- )
\begin_inset Newline newline
\end_inset

if (i==0) {
\begin_inset Newline newline
\end_inset

  SET_IP(target);
\begin_inset Newline newline
\end_inset

  INST_TAIL;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

SUPER_CONTINUE;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Note that Vmgen is not smart about C-level tokenization, comments, strings,
 or conditional compilation, so it will interpret even a commented-out 
\family typewriter
\series bold
SUPER_END
\family default
\series default
 as ending a basic block (or, e.g., ‘
\family typewriter
\series bold
RESET_IP
\family default
\series default
;’ as ‘
\family typewriter
\series bold
SET_IP
\family default
\series default
;’).
 Conversely, Vmgen requires the literal presence of these strings; Vmgen
 will not see them if they are hiding in a C preprocessor macro.
\end_layout

\begin_layout Paragraph
C Code restrictions
\end_layout

\begin_layout Standard
Vmgen generates code and performs some optimizations under the assumption
 that the user-supplied C code does not access the stack pointers or stack
 items, and that accesses to the instruction pointer only occur through
 special macros.
 In general you should heed these restrictions.
 However, if you need to break these restrictions, read the following.
\end_layout

\begin_layout Standard
Accessing a stack or stack pointer directly can be a problem for several
 reasons:
\end_layout

\begin_layout Itemize
Vmgen optionally supports caching the top-of-stack item in a local variable
 (that is allocated to a register).
 This is the most frequent source of trouble.
 You can deal with it either by not using top-of-stack caching (slowdown
 factor 1-1.4, depending on machine), or by inserting flushing code (e.g.,
 ‘
\family typewriter
\series bold
IF_spTOS(sp[...] = spTOS);
\family default
\series default
’) at the start and reloading code (e.g., ‘
\family typewriter
\series bold
IF_spTOS(spTOS = sp[0])
\family default
\series default
’) at the end of problematic C code.
 Vmgen inserts a stack pointer update before the start of the user-supplied
 C code, so the flushing code has to use an index that corrects for that.
 In the future, this flushing may be done automatically by mentioning a
 special string in the C code.
\end_layout

\begin_layout Scrap
<<stack-caching>>=
\begin_inset Newline newline
\end_inset


\backslash
 The following VM instructions also explicitly reference sp and
\begin_inset Newline newline
\end_inset


\backslash
 therefore may have to do something about spTOS caching.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

call ( #target #iadjust -- targetret aoldfp )
\begin_inset Newline newline
\end_inset

/* IF_spTOS(sp[2] = spTOS);*/ /* unnecessary; vmgen inserts a flush anyway
 */
\begin_inset Newline newline
\end_inset

targetret = IP;
\begin_inset Newline newline
\end_inset

SET_IP(target);
\begin_inset Newline newline
\end_inset

aoldfp = fp;
\begin_inset Newline newline
\end_inset

sp = (Cell *)(((char *)sp)+iadjust);
\begin_inset Newline newline
\end_inset

fp = (char *)sp;
\begin_inset Newline newline
\end_inset

/* IF_spTOS(spTOS = sp[0]); */ /* dead, thus unnecessary; vmgen copies aoldfp
 there */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

return ( #iadjust target afp i1 -- i2 )
\begin_inset Newline newline
\end_inset

/* IF_spTOS(sp[-2] = spTOS); */ /* unnecessary; that stack item is dead
 */
\begin_inset Newline newline
\end_inset

SET_IP(target);
\begin_inset Newline newline
\end_inset

sp = (Cell *)(((char *)sp)+iadjust);
\begin_inset Newline newline
\end_inset

fp = afp;
\begin_inset Newline newline
\end_inset

i2=i1;
\begin_inset Newline newline
\end_inset

/* IF_spTOS(spTOS = sp[0]); */ /* dead, thus unnecessary; vmgen copies i2
 there */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 loadlocal and storelocal access stack items below spTOS, so we can
\begin_inset Newline newline
\end_inset


\backslash
 ignore spTOS caching.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

loadlocal ( #ioffset -- i )
\begin_inset Newline newline
\end_inset

i = *(Cell *)(fp+ioffset);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

storelocal ( #ioffset i -- )
\begin_inset Newline newline
\end_inset

*(Cell *)(fp+ioffset) = i;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Itemize
The Vmgen-erated code loads the stack items from stack-pointer-indexed memory
 into variables before the user-supplied C code, and stores them from variables
 to stack-pointer-indexed memory afterwards.
 If you do any writes to the stack through its stack pointer in your C code,
 it will not affect the variables, and your write may be overwritten by
 the stores after the C code.
 Similarly, a read from a stack using a stack pointer will not reflect computati
ons of stack items in the same VM instruction.
\end_layout

\begin_layout Itemize
Superinstructions keep stack items in variables across the whole superinstructio
n.
 So you should not include VM instructions, that access a stack or stack
 pointer, as components of superinstructions (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-profiler"

\end_inset

).
\end_layout

\begin_layout Standard
You should access the instruction pointer only through its special macros
 (‘
\family typewriter
\series bold
IP
\family default
\series default
’, ‘
\family typewriter
\series bold
SET_IP
\family default
\series default
’, ‘
\family typewriter
\series bold
IPTOS
\family default
\series default
’); this ensure that these macros can be implemented in several ways for
 best performance.
 ‘
\family typewriter
\series bold
IP
\family default
\series default
’ points to the next instruction, and ‘
\family typewriter
\series bold
IPTOS
\family default
\series default
’ is its contents.
\end_layout

\begin_layout Paragraph
Stack growth direction
\begin_inset CommandInset label
LatexCommand label
name "par:Stack-growth-direction"

\end_inset


\end_layout

\begin_layout Standard
By default, the stacks grow towards lower addresses.
 You can change this for a stack by setting the 
\family typewriter
\series bold
stack-access-transform
\family default
\series default
 field of the stack to an xt ( 
\family typewriter
\series bold
itemnum -- index
\family default
\series default
 ) that performs the appropriate index transformation.
\end_layout

\begin_layout Standard
E.g., if you want to let 
\family typewriter
\series bold
data-stack
\family default
\series default
 grow towards higher addresses, with the stack pointer always pointing just
 beyond the top-of-stack, use this right after defining 
\family typewriter
\series bold
data-stack
\family default
\series default
:
\end_layout

\begin_layout Scrap
<<unused-stack-transform>>=
\begin_inset Newline newline
\end_inset


\backslash
E : sp-access-transform ( itemnum -- index ) negate 1- ;
\begin_inset Newline newline
\end_inset


\backslash
E ' sp-access-transform ' data-stack >body stack-access-transform !
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
This means that 
\family typewriter
\series bold
sp-access-transform
\family default
\series default
 will be used to generate indexes for accessing 
\family typewriter
\series bold
data-stack
\family default
\series default
.
 The definition of 
\family typewriter
\series bold
sp-access-transform
\family default
\series default
 above transforms 
\family typewriter
\series bold
n
\family default
\series default
 into 
\family typewriter
\series bold
-n-1
\family default
\series default
, e.g, 1 into -2.
 This will access the 0th data-stack element (top-of-stack) at sp[-1], the
 1st at sp[-2], etc., which is the typical way upward-growing stacks are
 used.
 If you need a different transform and do not know enough Forth to program
 it, let me know.
\end_layout

\begin_layout Scrap
<<stack-organization>>=
\begin_inset Newline newline
\end_inset


\backslash
  The stack is organized as follows:
\begin_inset Newline newline
\end_inset


\backslash
  The stack grows downwards; a stack usually looks like this:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
  higher addresses
\begin_inset Newline newline
\end_inset


\backslash
  --------------------- bottom of stack
\begin_inset Newline newline
\end_inset


\backslash
     locals of main
\begin_inset Newline newline
\end_inset


\backslash
     return address (points to VM code after call)
\begin_inset Newline newline
\end_inset


\backslash
  +->oldfp (NULL)
\begin_inset Newline newline
\end_inset


\backslash
  |  intermediate results (e.g., 1 for a call like 1+foo(...))
\begin_inset Newline newline
\end_inset


\backslash
  |  arguments passed to the called function
\begin_inset Newline newline
\end_inset


\backslash
  |  locals of the called function
\begin_inset Newline newline
\end_inset


\backslash
  |  return address (points to VM code after call)
\begin_inset Newline newline
\end_inset


\backslash
  +--oldfp                <-- fp
\begin_inset Newline newline
\end_inset


\backslash
     intermediate results <-- sp
\begin_inset Newline newline
\end_inset


\backslash
  ---------------------- top of stack
\begin_inset Newline newline
\end_inset


\backslash
  lower addresses
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Superinstructions
\begin_inset CommandInset label
LatexCommand label
name "sub:Superinstructions"

\end_inset


\end_layout

\begin_layout Standard
Note: don't invest too much work in (static) superinstructions; a future
 version of Vmgen will support dynamic superinstructions (see Ian Piumarta
 and Fabio Riccardi, Optimizing Direct Threaded Code by Selective Inlining,
 PLDI'98 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://dl.acm.org/citation.cfm?id=277743
\end_layout

\end_inset

), and static superinstructions have much less benefit in that context (prelimin
ary results indicate only a factor 1.1 speedup).
\end_layout

\begin_layout Standard
Here is an example of a superinstruction definition:
\end_layout

\begin_layout Scrap
<<ll>>=
\begin_inset Newline newline
\end_inset

ll = loadlocal lit
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard

\family typewriter
\series bold
ll
\family default
\series default
 is the name of the superinstruction, and 
\family typewriter
\series bold
loadlocal
\family default
\series default
 and 
\family typewriter
\series bold
lit
\family default
\series default
 are its components.
 This superinstruction performs the same action as the sequence 
\family typewriter
\series bold
loadlocal
\family default
\series default
 and 
\family typewriter
\series bold
lit
\family default
\series default
.
 It is generated automatically by the VM code generation functions whenever
 that sequence occurs, so if you want to use this superinstruction, you
 just need to add this definition (and even that can be partially automatized,
 see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-profiler"

\end_inset

).
\end_layout

\begin_layout Standard
Vmgen requires that the component instructions are simple instructions defined
 before superinstructions using the components.
 Currently, Vmgen also requires that all the subsequences at the start of
 a superinstruction (prefixes) must be defined as superinstruction before
 the superinstruction.
 I.e., if you want to define a superinstruction
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
foo4 = load add sub mul
\end_layout

\begin_layout Standard
you first have to define 
\family typewriter
\series bold
load
\family default
\series default
, 
\family typewriter
\series bold
add
\family default
\series default
, 
\family typewriter
\series bold
sub
\family default
\series default
 and 
\family typewriter
\series bold
mul
\family default
\series default
, plus
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
foo2 = load add
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
foo3 = load add sub
\end_layout

\begin_layout Standard
Here, 
\family typewriter
\series bold
foo2
\family default
\series default
 is the longest prefix of 
\family typewriter
\series bold
foo3
\family default
\series default
, and 
\family typewriter
\series bold
foo3
\family default
\series default
 is the longest prefix of 
\family typewriter
\series bold
foo4
\family default
\series default
.
\end_layout

\begin_layout Standard
Note that Vmgen assumes that only the code it generates accesses stack pointers,
 the instruction pointer, and various stack items, and it performs optimizations
 based on this assumption.
 Therefore, VM instructions where your C code changes the instruction pointer
 should only be used as last component; a VM instruction where your C code
 accesses a stack pointer should not be used as component at all.
 Vmgen does not check these restrictions, they just result in bugs in your
 interpreter.
\end_layout

\begin_layout Standard
The Vmgen flag 
\family typewriter
\series bold
include-skipped-insts
\family default
\series default
 influences superinstruction code generation.
 Currently there is no support in the peephole optimizer for both variations,
 so leave this flag alone for now.
\end_layout

\begin_layout Subsubsection
Store Optimization
\end_layout

\begin_layout Standard
This minor optimization (0.6%–0.8% reduction in executed instructions for
 Gforth) puts additional requirements on the instruction descriptions and
 is therefore disabled by default.
\end_layout

\begin_layout Standard
What does it do? Consider an instruction like
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
dup ( n -- n n )
\end_layout

\begin_layout Standard
For simplicity, also assume that we are not caching the top-of-stack in
 a register.
 Now, the C code for dup first loads n from the stack, and then stores it
 twice to the stack, one time to the address where it came from; that time
 is unnecessary, but gcc does not optimize it away, so vmgen can do it instead
 (if you turn on the store optimization).
\end_layout

\begin_layout Standard
Vmgen uses the stack item's name to determine if the stack item contains
 the same value as it did at the start.
 Therefore, if you use the store optimization, you have to ensure that stack
 items that have the same name on input and output also have the same value,
 and are not changed in the C code you supply.
 I.e., the following code could fail if you turn on the store optimization:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
add1 ( n -- n )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
n++;
\end_layout

\begin_layout Standard
Instead, you have to use different names, i.e.:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
add1 ( n1 -- n2 )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
n2=n1+1;
\end_layout

\begin_layout Standard
Similarly, the store optimization assumes that the stack pointer is only
 changed by Vmgen-erated code.
 If your C code changes the stack pointer, use different names in input
 and output stack items to avoid a (probably wrong) store optimization,
 or turn the store optimization off for this VM instruction.
\end_layout

\begin_layout Standard
To turn on the store optimization, write
\end_layout

\begin_layout Quotation

\family typewriter
\series bold

\backslash
E store-optimization on
\end_layout

\begin_layout Standard
at the start of the file.
 You can turn this optimization on or off between any two VM instruction
 descriptions.
 For turning it off again, you can use
\end_layout

\begin_layout Quotation

\family typewriter
\series bold

\backslash
E store-optimization off
\end_layout

\begin_layout Subsubsection
Register Machines
\begin_inset CommandInset label
LatexCommand label
name "sub:Register-Machines"

\end_inset


\end_layout

\begin_layout Standard
If you want to implement a register VM rather than a stack VM with Vmgen,
 there are two ways to do it: Directly and through superinstructions.
\end_layout

\begin_layout Standard
If you use the direct way, you define instructions that take the register
 numbers as immediate arguments, like this:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
add3 ( #src1 #src2 #dest -- )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
reg[dest] = reg[src1]+reg[src2];
\end_layout

\begin_layout Standard
A disadvantage of this method is that during tracing you only see the register
 numbers, but not the register contents.
 Actually, with an appropriate definition of 
\family typewriter
\series bold
printarg_src
\family default
\series default
 (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-engine"

\end_inset

), you can print the values of the source registers on entry, but you cannot
 print the value of the destination register on exit.
\end_layout

\begin_layout Standard
If you use superinstructions to define a register VM, you define simple
 instructions that use a stack, and then define superinstructions that have
 no overall stack effect, like this:
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
loadreg ( #src -- n )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
n = reg[src];
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
storereg ( n #dest -- )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
reg[dest] = n;
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
adds ( n1 n2 -- n )
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
n = n1+n2;
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
add3 = loadreg loadreg adds storereg
\end_layout

\begin_layout Standard
An advantage of this method is that you see the values and not just the
 register numbers in tracing.
 A disadvantage of this method is that currently you cannot generate superinstru
ctions directly, but only through generating a sequence of simple instructions
 (we might change this in the future if there is demand).
\end_layout

\begin_layout Standard
Could the register VM support be improved, apart from the issues mentioned
 above? It is hard to see how to do it in a general way, because there are
 a number of different designs that different people mean when they use
 the term register machine in connection with VM interpreters.
 However, if you have ideas or requests in that direction, please let me
 know (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Contact"

\end_inset

).
\end_layout

\begin_layout Subsection
Error messages
\end_layout

\begin_layout Standard
These error messages are created by Vmgen:
\end_layout

\begin_layout Standard

\family typewriter
\series bold
# can only be on the input side
\end_layout

\begin_layout Standard
You have used an instruction-stream prefix (usually ‘#’) after the ‘--’
 (the output side); you can only use it before (the input side).
\end_layout

\begin_layout Standard

\family typewriter
\series bold
the prefix for this superinstruction must be defined earlier
\end_layout

\begin_layout Standard
You have defined a superinstruction (e.g.
 abc = a b c) without defining its direct prefix (e.g., ab = a b), See 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Superinstructions"

\end_inset

.
\end_layout

\begin_layout Standard

\family typewriter
\series bold
sync line syntax
\end_layout

\begin_layout Standard
If you are using a preprocessor (e.g., m4) to generate Vmgen input code, you
 may want to create #line directives (aka sync lines).
 This error indicates that such a line is not in th syntax expected by Vmgen
 (this should not happen; please report the offending line in a bug report).
\end_layout

\begin_layout Standard

\family typewriter
\series bold
syntax error, wrong char
\end_layout

\begin_layout Standard
A syntax error.
 If you do not see right away where the error is, it may be helpful to check
 the following: Did you put an empty line in a VM instruction where the
 C code is not delimited by braces (then the empty line ends the VM instruction)
? If you used brace-delimited C code, did you put the delimiting braces
 (and only those) at the start of the line, without preceding white space?
 Did you forget a delimiting brace?
\end_layout

\begin_layout Standard

\family typewriter
\series bold
too many stacks
\end_layout

\begin_layout Standard
Vmgen currently supports 3 stacks (plus the instruction stream); if you
 need more, let us know.
\end_layout

\begin_layout Standard

\family typewriter
\series bold
unknown prefix
\end_layout

\begin_layout Standard
The stack item does not match any defined type prefix (after stripping away
 any stack prefix).
 You should either declare the type prefix you want for that stack item,
 or use a different type prefix
\end_layout

\begin_layout Standard

\family typewriter
\series bold
unknown primitive
\end_layout

\begin_layout Standard
You have used the name of a simple VM instruction in a superinstruction
 definition without defining the simple VM instruction first.
\end_layout

\begin_layout Standard
In addition, the C compiler can produce errors due to code produced by Vmgen;
 e.g., you need to define type cast functions.
\end_layout

\begin_layout Subsection
Using the generated code
\end_layout

\begin_layout Standard
The easiest way to create a working VM interpreter with Vmgen is probably
 to start with 
\family typewriter
\series bold
vmgen-ex
\family default
\series default
, and modify it for your purposes.
 This chapter explains what the various wrapper and generated files do.
 It also contains reference-manual style descriptions of the macros, variables
 etc.
 used by the generated code, and you can skip that on first reading.
\end_layout

\begin_layout Itemize
VM engine: Executing VM code
\end_layout

\begin_layout Itemize
VM instruction table
\end_layout

\begin_layout Itemize
VM code generation: Creating VM code (in the front-end)
\end_layout

\begin_layout Itemize
Peephole optimization: Creating VM superinstructions
\end_layout

\begin_layout Itemize
VM disassembler: for debugging the front end
\end_layout

\begin_layout Itemize
VM profiler: for finding worthwhile superinstructions
\end_layout

\begin_layout Subsubsection
VM engine
\begin_inset CommandInset label
LatexCommand label
name "sub:VM-engine"

\end_inset


\end_layout

\begin_layout Standard
The VM engine is the VM interpreter that executes the VM code.
 It is essential for an interpretive system.
\end_layout

\begin_layout Standard
Vmgen supports two methods of VM instruction dispatch: threaded code (fast,
 but gcc-specific), and switch dispatch (slow, but portable across C compilers);
 you can use conditional compilation (‘
\family typewriter
\series bold
defined(__GNUC__)
\family default
\series default
’) to choose between these methods, and our example does so.
\end_layout

\begin_layout Scrap
<<dispatch>>=
\begin_inset Newline newline
\end_inset

/* different threading schemes for different architectures; the sparse
\begin_inset Newline newline
\end_inset

   numbering is there for historical reasons */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* here you select the threading scheme; I have only set this up for
\begin_inset Newline newline
\end_inset

   386 and generic, because I don't know what preprocessor macros to
\begin_inset Newline newline
\end_inset

   test for (Gforth uses config.guess instead).
  Anyway, it's probably
\begin_inset Newline newline
\end_inset

   best to build them all and select the fastest instead of hardwiring
\begin_inset Newline newline
\end_inset

   a specific scheme for an architecture.
  E.g., scheme 8 is fastest
\begin_inset Newline newline
\end_inset

   for Gforth "make bench" on a 486, whereas scheme 5 is fastest for
\begin_inset Newline newline
\end_inset

   "mini fib.mini" on an Athlon */
\begin_inset Newline newline
\end_inset

#ifndef THREADING_SCHEME
\begin_inset Newline newline
\end_inset

#define THREADING_SCHEME 5
\begin_inset Newline newline
\end_inset

#endif /* defined(THREADING_SCHEME) */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#ifdef __GNUC__
\begin_inset Newline newline
\end_inset

#if THREADING_SCHEME==1
\begin_inset Newline newline
\end_inset

/* direct threading scheme 1: autoinc, long latency (HPPA, Sharc) */
\begin_inset Newline newline
\end_inset

#  <<NEXT-P0-1>>
\begin_inset Newline newline
\end_inset

#  <<IP-1>>
\begin_inset Newline newline
\end_inset

#  <<SET-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-INST-1>>
\begin_inset Newline newline
\end_inset

#  <<INC-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<DEF-CA>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P2-1>>
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#if THREADING_SCHEME==3
\begin_inset Newline newline
\end_inset

/* direct threading scheme 3: autoinc, low latency (68K) */
\begin_inset Newline newline
\end_inset

#  <<NEXT-P0>>
\begin_inset Newline newline
\end_inset

#  <<IP-2>>
\begin_inset Newline newline
\end_inset

#  <<SET-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-INST>>
\begin_inset Newline newline
\end_inset

#  <<INC-IP-2>>
\begin_inset Newline newline
\end_inset

#  <<DEF-CA>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P1-1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P2-1>>
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#if THREADING_SCHEME==5
\begin_inset Newline newline
\end_inset

/* direct threading scheme 5: early fetching (Alpha, MIPS) */
\begin_inset Newline newline
\end_inset

#  define CFA_NEXT
\begin_inset Newline newline
\end_inset

#  <<NEXT-P0-2>>
\begin_inset Newline newline
\end_inset

#  <<IP-2>>
\begin_inset Newline newline
\end_inset

#  <<SET-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-INST-1>>
\begin_inset Newline newline
\end_inset

#  <<INC-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<DEF-CA>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P1-2>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P2-1>>
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#if THREADING_SCHEME==8
\begin_inset Newline newline
\end_inset

/* direct threading scheme 8: i386 hack */
\begin_inset Newline newline
\end_inset

#  <<NEXT-P0>>
\begin_inset Newline newline
\end_inset

#  <<IP-2>>
\begin_inset Newline newline
\end_inset

#  <<SET-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-INST>>
\begin_inset Newline newline
\end_inset

#  <<INC-IP-2>>
\begin_inset Newline newline
\end_inset

#  <<DEF-CA>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P1-2>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P2-2>>
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#if THREADING_SCHEME==9
\begin_inset Newline newline
\end_inset

/* direct threading scheme 9: prefetching (for PowerPC) */
\begin_inset Newline newline
\end_inset

/* note that the "cfa=next_cfa;" occurs only in NEXT_P1, because this
\begin_inset Newline newline
\end_inset

   works out better with the capabilities of gcc to introduce and
\begin_inset Newline newline
\end_inset

   schedule the mtctr instruction.
 */
\begin_inset Newline newline
\end_inset

#  <<NEXT-P0>>
\begin_inset Newline newline
\end_inset

#  <<IP>>
\begin_inset Newline newline
\end_inset

#  <<SET-IP-2>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-INST-2>>
\begin_inset Newline newline
\end_inset

#  <<INC-IP-3>>
\begin_inset Newline newline
\end_inset

#  <<DEF-CA>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P1-3>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P2-1>>
\begin_inset Newline newline
\end_inset

#  define MORE_VARS     Inst next_cfa;
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#if THREADING_SCHEME==10
\begin_inset Newline newline
\end_inset

/* direct threading scheme 10: plain (no attempt at scheduling) */
\begin_inset Newline newline
\end_inset

#  <<NEXT-P0>>
\begin_inset Newline newline
\end_inset

#  <<IP-2>>
\begin_inset Newline newline
\end_inset

#  <<SET-IP-1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-INST>>
\begin_inset Newline newline
\end_inset

#  <<INC-IP-2>>
\begin_inset Newline newline
\end_inset

#  <<DEF-CA>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P1>>
\begin_inset Newline newline
\end_inset

#  <<NEXT-P2-3>>
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#define NEXT ({DEF_CA NEXT_P1; NEXT_P2;})
\begin_inset Newline newline
\end_inset

#<<IPTOS>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#<<jump-INST-ADDR>>
\begin_inset Newline newline
\end_inset

#<<jump-LABEL>>
\begin_inset Newline newline
\end_inset

#else /* !defined(__GNUC__) */
\begin_inset Newline newline
\end_inset

/* use switch dispatch */
\begin_inset Newline newline
\end_inset

#<<DEF-CA>>
\begin_inset Newline newline
\end_inset

#<<NEXT-P0>>
\begin_inset Newline newline
\end_inset

#<<NEXT-P1>>
\begin_inset Newline newline
\end_inset

#<<NEXT-P2>>
\begin_inset Newline newline
\end_inset

#<<SET-IP>>
\begin_inset Newline newline
\end_inset

#<<IP>>
\begin_inset Newline newline
\end_inset

#<<NEXT-INST>>
\begin_inset Newline newline
\end_inset

#<<INC-IP>>
\begin_inset Newline newline
\end_inset

#<<IPTOS>>
\begin_inset Newline newline
\end_inset

#<<switch-INST-ADDR>>
\begin_inset Newline newline
\end_inset

#<<switch-LABEL>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#endif /* !defined(__GNUC__) */
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
For both methods, the VM engine is contained in a C-level function.
 Vmgen generates most of the contents of the function for you (name-vm.i),
 but you have to define this function, and macros and variables used in
 the engine, and initialize the variables.
 In our example the engine function also includes name-labels.i (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-instruction-table"

\end_inset

).
\end_layout

\begin_layout Standard
In addition to executing the code, the VM engine can optionally also print
 out a trace of the executed instructions, their arguments and results.
 For superinstructions it prints the trace as if only component instructions
 were executed; this allows to introduce new superinstructions while keeping
 the traces comparable to old ones (important for regression tests).
\end_layout

\begin_layout Standard
It costs significant performance to check in each instruction whether to
 print tracing code, so we recommend producing two copies of the engine:
 one for fast execution, and one for tracing.
 See the rules for engine.o and engine-debug.o in vmgen-ex/Makefile for an
 example (
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:engine.c---wrapper"

\end_inset

).
\end_layout

\begin_layout Standard
The following macros and variables are used in name-vm.i:
\end_layout

\begin_layout Description
LABEL(inst_name) This is used just before each VM instruction to provide
 a jump or switch label (the ‘
\family typewriter
\series bold
:
\family default
\series default
’ is provided by Vmgen).
 For switch dispatch this should expand to ‘
\family typewriter
\series bold
case label:
\family default
\series default
’; for threaded-code dispatch this should just expand to ‘
\family typewriter
\series bold
label:
\family default
\series default
’.
 In either case label is usually the 
\family typewriter
\series bold
inst_name
\family default
\series default
 with some prefix or suffix to avoid naming conflicts.
\end_layout

\begin_layout Scrap
<<jump-LABEL>>=
\begin_inset Newline newline
\end_inset

define LABEL(name) I_##name:
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<switch-LABEL>>=
\begin_inset Newline newline
\end_inset

define LABEL(name) case I_##name:
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
LABEL2(inst_name) This will be used for dynamic superinstructions; at the
 moment, this should expand to nothing.
\end_layout

\begin_layout Scrap
<<LABEL2>>=
\begin_inset Newline newline
\end_inset

#define LABEL2(x)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
NAME(inst_name_string) Called on entering a VM instruction with a string
 containing the name of the VM instruction as parameter.
 In normal execution this should be expand to nothing, but for tracing this
 usually prints the name, and possibly other information (several VM registers
 in our example).
\end_layout

\begin_layout Scrap
<<NAME>>=
\begin_inset Newline newline
\end_inset

#ifdef VM_DEBUG
\begin_inset Newline newline
\end_inset

#define NAME(_x) if (vm_debug) {fprintf(vm_out, "%p: %-20s, ", ip-1, _x);
 
\backslash

\begin_inset Newline newline
\end_inset

                                fprintf(vm_out,"fp=%p, sp=%p", fp, sp);}
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

#define NAME(_x)
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
DEF_CA Usually empty.
 Called just inside a new scope at the start of a VM instruction.
 Can be used to define variables that should be visible during every VM
 instruction.
 If you define this macro as non-empty, you have to provide the finishing
 ‘
\family typewriter
\series bold
;
\family default
\series default
’ in the macro.
\end_layout

\begin_layout Scrap
<<DEF-CA>>=
\begin_inset Newline newline
\end_inset

define DEF_CA
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
NEXT_P0
\begin_inset space ~
\end_inset

NEXT_P1
\begin_inset space ~
\end_inset

NEXT_P2 The three parts of instruction dispatch.
 They can be defined in different ways for best performance on various processor
s (see engine.c in the example or engine/threaded.h in Gforth).
 ‘
\family typewriter
\series bold
NEXT_P0
\family default
\series default
’ is invoked right at the start of the VM instruction (but after ‘
\family typewriter
\series bold
DEF_CA
\family default
\series default
’), ‘
\family typewriter
\series bold
NEXT_P1
\family default
\series default
’ right after the user-supplied C code, and ‘
\family typewriter
\series bold
NEXT_P2
\family default
\series default
’ at the end.
 The actual jump has to be performed by ‘
\family typewriter
\series bold
NEXT_P2
\family default
\series default
’ (if you would do it earlier, important parts of the VM instruction would
 not be executed).
 The simplest variant is if ‘
\family typewriter
\series bold
NEXT_P2
\family default
\series default
’ does everything and the other macros do nothing.
 Then also related macros like ‘
\family typewriter
\series bold
IP
\family default
\series default
’, ‘
\family typewriter
\series bold
SET_IP
\family default
\series default
’, ‘
\family typewriter
\series bold
INC_IP
\family default
\series default
’ and ‘
\family typewriter
\series bold
IPTOS
\family default
\series default
’ are very straightforward to define.
 For switch dispatch this code consists just of a jump to the dispatch code
 (‘
\family typewriter
\series bold
goto next_inst;
\family default
\series default
’ in our example); for direct threaded code it consists of something like
 ‘({cfa=*ip++; goto *cfa;})’.
 Pulling code (usually the ‘
\family typewriter
\series bold
cfa=*ip++;
\family default
\series default
’) up into ‘
\family typewriter
\series bold
NEXT_P1
\family default
\series default
’ usually does not cause problems, but pulling things up into ‘
\family typewriter
\series bold
NEXT_P0
\family default
\series default
’ usually requires changing the other macros (and, at least for Gforth on
 Alpha, it does not buy much, because the compiler often manages to schedule
 the relevant stuff up by itself).
 An even more extreme variant is to pull code up even further, into, e.g.,
 
\family typewriter
\series bold
NEXT_P1
\family default
\series default
 of the previous VM instruction (prefetching, useful on PowerPCs).
\end_layout

\begin_layout Scrap
<<NEXT-P0>>=
\begin_inset Newline newline
\end_inset

define NEXT_P0
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P0-1>>=
\begin_inset Newline newline
\end_inset

define NEXT_P0       ({cfa=*ip++;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P0-2>>=
\begin_inset Newline newline
\end_inset

define NEXT_P0       ({cfa=*ip;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P1>>=
\begin_inset Newline newline
\end_inset

define NEXT_P1
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P1-1>>=
\begin_inset Newline newline
\end_inset

define NEXT_P1       ({cfa=*ip++;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P1-2>>=
\begin_inset Newline newline
\end_inset

define NEXT_P1       (ip++)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P1-3>>=
\begin_inset Newline newline
\end_inset

define NEXT_P1       ({cfa=next_cfa; ip++; next_cfa=*ip;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P2>>=
\begin_inset Newline newline
\end_inset

define NEXT_P2 goto next_inst;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P2-1>>=
\begin_inset Newline newline
\end_inset

define NEXT_P2       ({goto *cfa;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P2-2>>=
\begin_inset Newline newline
\end_inset

define NEXT_P2       ({goto **(ip-1);})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-P2-3>>=
\begin_inset Newline newline
\end_inset

define NEXT_P2       ({cfa=*ip++; goto *cfa;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-INST>>=
\begin_inset Newline newline
\end_inset

define NEXT_INST     (*ip)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-INST-1>>=
\begin_inset Newline newline
\end_inset

define NEXT_INST     (cfa)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<NEXT-INST-2>>=
\begin_inset Newline newline
\end_inset

define NEXT_INST     (next_cfa)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
INC_IP(n) This increments IP by n.
\end_layout

\begin_layout Scrap
<<INC-IP>>=
\begin_inset Newline newline
\end_inset

define INC_IP(const_inc) (ip+=(const_inc))
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<INC-IP-1>>=
\begin_inset Newline newline
\end_inset

define INC_IP(const_inc) ({cfa=IP[const_inc]; ip+=(const_inc);})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<INC-IP-2>>=
\begin_inset Newline newline
\end_inset

define INC_IP(const_inc) ({ip+=(const_inc);})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<INC-IP-3>>=
\begin_inset Newline newline
\end_inset

define INC_IP(const_inc) ({next_cfa=IP[const_inc]; ip+=(const_inc);})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SET_IP(target) This sets IP to target.
\end_layout

\begin_layout Scrap
<<SET-IP>>=
\begin_inset Newline newline
\end_inset

define SET_IP(p)     (ip=(p))
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<SET-IP-1>>=
\begin_inset Newline newline
\end_inset

define SET_IP(p)     ({ip=(p); NEXT_P0;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<SET-IP-2>>=
\begin_inset Newline newline
\end_inset

define SET_IP(p)     ({ip=(p); next_cfa=*ip; NEXT_P0;})
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
vm_A2B(a,b) Type casting macro that assigns ‘a’ (of type A) to ‘b’ (of type
 B).
 This is mainly used for getting stack items into variables and back.
 So you need to define macros for every combination of stack basic type
 (Cell in our example) and type-prefix types used with that stack (in both
 directions).
 For the type-prefix type, you use the type-prefix (not the C type string)
 as type name (e.g., ‘vm_Cell2i’, not ‘vm_Cell2Cell’).
 In addition, you have to define a vm_X2X macro for the stack's basic type
 X (used in superinstructions).
 The stack basic type for the predefined ‘inst-stream’ is ‘Cell’.
 If you want a stack with the same item size, making its basic type ‘Cell’
 usually reduces the number of macros you have to define.
 Here our examples differ a lot: vmgen-ex uses casts in these macros, whereas
 vmgen-ex2 uses union-field selection (or assignment to union fields).
 Note that casting floats into integers and vice versa changes the bit pattern
 (and you do not want that).
 In this case your options are to use a (temporary) union, or to take the
 address of the value, cast the pointer, and dereference that (not always
 possible, and sometimes expensive).
\end_layout

\begin_layout Scrap
<<vm-A2B(a,b)>>=
\begin_inset Newline newline
\end_inset

/* type change macros; these are specific to the types you use, so you
\begin_inset Newline newline
\end_inset

   have to change this part */
\begin_inset Newline newline
\end_inset

#define vm_Cell2i(_cell,x)      ((x)=(long)(_cell))
\begin_inset Newline newline
\end_inset

#define vm_Cell2target(_cell,x) ((x)=(Inst *)(_cell))
\begin_inset Newline newline
\end_inset

#define vm_Cell2a(_cell,x)      ((x)=(char *)(_cell))
\begin_inset Newline newline
\end_inset

#define vm_i2Cell(x,_cell)      ((_cell)=(Cell)(x))
\begin_inset Newline newline
\end_inset

#define vm_target2Cell(x,_cell) ((_cell)=(Cell)(x))
\begin_inset Newline newline
\end_inset

#define vm_a2Cell(x,_cell)      ((_cell)=(Cell)(x))
\begin_inset Newline newline
\end_inset

#define vm_Cell2Cell(_x,_y)     ((_y)=(Cell)(_x))
\begin_inset Newline newline
\end_inset

/* the cast in vm_Cell2Cell is needed because the base type for
\begin_inset Newline newline
\end_inset

   inst-stream is Cell, but *IP is an Inst */
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
vm_twoA2B(a1,a2,b)
\begin_inset space ~
\end_inset

vm_B2twoA(b,a1,a2) Type casting between two stack items (a1, a2) and a variable
 b of a type that takes two stack items.
 This does not occur in our small examples, but you can look at Gforth for
 examples (see vm_twoCell2d in engine/forth.h).
\end_layout

\begin_layout Description
stackpointer For each stack used, the stackpointer name given in the stack
 declaration is used.
 For a regular stack this must be an l-expression; typically it is a variable
 declared as a pointer to the stack's basic type.
 For ‘inst-stream’, the name is ‘
\family typewriter
\series bold
IP
\family default
\series default
’, and it can be a plain r-value; typically it is a macro that abstracts
 away the differences between the various implementations of 
\family typewriter
\series bold
NEXT_P
\family default
\series default
*.
\end_layout

\begin_layout Scrap
<<IP>>=
\begin_inset Newline newline
\end_inset

define IP            ip
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<IP-1>>=
\begin_inset Newline newline
\end_inset

define IP            (ip-1)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<IP-2>>=
\begin_inset Newline newline
\end_inset

define IP            (ip)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
IMM_ARG(access,value) Define this to expland to “(access)”.
 This is just a placeholder for future extensions.
\end_layout

\begin_layout Scrap
<<IMM-ARG>>=
\begin_inset Newline newline
\end_inset

/* for future extensions */
\begin_inset Newline newline
\end_inset

#define IMM_ARG(access,value) (access)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
stackpointerTOS The top-of-stack for the stack pointed to by stackpointer.
 If you are using top-of-stack caching for that stack, this should be defined
 as variable; if you are not using top-of-stack caching for that stack,
 this should be a macro expanding to ‘stackpointer[0]’.
 The stack pointer for the predefined ‘inst-stream’ is called ‘IP’, so the
 top-of-stack is called ‘IPTOS’.
\end_layout

\begin_layout Scrap
<<spTOS>>=
\begin_inset Newline newline
\end_inset

#ifdef USE_spTOS
\begin_inset Newline newline
\end_inset

  Cell   spTOS;
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

#define spTOS (sp[0])
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<IPTOS>>=
\begin_inset Newline newline
\end_inset

define IPTOS NEXT_INST
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
IF_stackpointerTOS(expr) Macro for executing expr, if top-of-stack caching
 is used for the stackpointer stack.
 I.e., this should do expr if there is top-of-stack caching for stackpointer;
 otherwise it should do nothing.
\end_layout

\begin_layout Scrap
<<IF-spTOS>>=
\begin_inset Newline newline
\end_inset

#define USE_spTOS 1
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#ifdef USE_spTOS
\begin_inset Newline newline
\end_inset

#define IF_spTOS(x) x
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

#define IF_spTOS(x)
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SUPER_END This is used by the VM profiler (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-profiler"

\end_inset

); it should not do anything in normal operation, and call 
\family typewriter
\series bold
vm_count_block(IP)
\family default
\series default
 for profiling.
\end_layout

\begin_layout Scrap
<<SUPER-END>>=
\begin_inset Newline newline
\end_inset

#ifdef VM_PROFILING
\begin_inset Newline newline
\end_inset

#define SUPER_END  vm_count_block(IP)
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

#define SUPER_END
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
SUPER_CONTINUE This is just a hint to Vmgen and does nothing at the C level.
 See 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:C-Code-Macros"

\end_inset


\end_layout

\begin_layout Description
MAYBE_UNUSED This should be defined as 
\family typewriter
\series bold
__attribute__((unused))
\family default
\series default
 for gcc-2.7 and higher.
 It suppresses the warnings about unused variables in the code for superinstruct
ions.
 You need to define this only if you are using superinstructions.
\end_layout

\begin_layout Scrap
<<MAYBE-UNUSED>>=
\begin_inset Newline newline
\end_inset

#if defined(__GNUC__) && ((__GNUC__==2 && defined(__GNUC_MINOR__) && __GNUC_MINO
R__>=7)||(__GNUC__>2))
\begin_inset Newline newline
\end_inset

#define MAYBE_UNUSED __attribute__((unused))
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

#define MAYBE_UNUSED
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Description
VM_DEBUG If this is defined, the tracing code will be compiled in (slower
 interpretation, but better debugging).
 Our example compiles two versions of the engine, a fast-running one that
 cannot trace, and one with potential tracing and profiling.
\end_layout

\begin_layout Description
vm_debug Needed only if ‘VM_DEBUG’ is defined.
 If this variable contains true, the VM instructions produce trace output.
 It can be turned on or off at any time.
\end_layout

\begin_layout Description
vm_out Needed only if ‘VM_DEBUG’ is defined.
 Specifies the file on which to print the trace output (type ‘FILE *’).
\end_layout

\begin_layout Description
printarg_type(value) Needed only if ‘VM_DEBUG’ is defined.
 Macro or function for printing value in a way appropriate for the type.
 This is used for printing the values of stack items during tracing.
 Type is normally the type prefix specified in a type-prefix definition
 (e.g., ‘printarg_i’); in superinstructions it is currently the basic type
 of the stack.
\end_layout

\begin_layout Subsubsection
VM instruction table
\begin_inset CommandInset label
LatexCommand label
name "sub:VM-instruction-table"

\end_inset


\end_layout

\begin_layout Standard
For threaded code we also need to produce a table containing the labels
 of all VM instructions.
 This is needed for VM code generation (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-code-generation"

\end_inset

), and it has to be done in the engine function, because the labels are
 not visible outside.
 It then has to be passed outside the function (and assigned to ‘
\family typewriter
\series bold
vm_prim
\family default
\series default
’), to be used by the VM code generation functions.
\end_layout

\begin_layout Standard
This means that the engine function has to be called first to produce the
 VM instruction table, and later, after generating VM code, it has to be
 called again to execute the generated VM code (yes, this is ugly).
 In our example program, these two modes of calling the engine function
 are differentiated by the value of the parameter 
\family typewriter
\series bold
ip0
\family default
\series default
 (if it equals 0, then the table is passed out, otherwise the VM code is
 executed); in our example, we pass the table out by assigning it to ‘
\family typewriter
\series bold
vm_prim
\family default
\series default
’ and returning from ‘
\family typewriter
\series bold
engine
\family default
\series default
’.
\end_layout

\begin_layout Standard
In our example (
\family typewriter
\series bold
vmgen-ex/engine.c
\family default
\series default
), we also build such a table for switch dispatch; this is mainly done for
 uniformity.
\end_layout

\begin_layout Standard
For switch dispatch, we also need to define the VM instruction opcodes used
 as case labels in an enum.
\end_layout

\begin_layout Standard
For both purposes (VM instruction table, and enum), the file 
\family typewriter
\series bold
name-labels.i 
\family default
\series default
is generated by Vmgen.
 You have to define the following macro used in this file:
\end_layout

\begin_layout Description
INST_ADDR(inst_name) For switch dispatch, this is just the name of the switch
 label (the same name as used in ‘
\family typewriter
\series bold
LABEL(inst_name)
\family default
\series default
’), for both uses of name-labels.i.
 For threaded-code dispatch, this is the address of the label defined in
 ‘
\family typewriter
\series bold
LABEL(inst_name)
\family default
\series default
’); the address is taken with ‘&&’.
\end_layout

\begin_layout Scrap
<<jump-INST-ADDR>>=
\begin_inset Newline newline
\end_inset

define INST_ADDR(name) (Label)&&I_##name
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<switch-INST-ADDR>>=
\begin_inset Newline newline
\end_inset

define INST_ADDR(name) I_##name
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
VM code generation
\begin_inset CommandInset label
LatexCommand label
name "sub:VM-code-generation"

\end_inset


\end_layout

\begin_layout Standard
Vmgen generates VM code generation functions in 
\family typewriter
\series bold
name-gen.i
\family default
\series default
 that the front end can call to generate VM code.
 This is essential for an interpretive system.
\end_layout

\begin_layout Standard
For a VM instruction ‘
\family typewriter
\series bold
x ( #a b #c -- d )
\family default
\series default
’, Vmgen generates a function with the prototype
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
void gen_x(Inst **ctp, a_type a, c_type c)
\end_layout

\begin_layout Standard
The 
\family typewriter
\series bold
ctp
\family default
\series default
 argument points to a pointer to the next instruction.
 
\family typewriter
\series bold
*ctp
\family default
\series default
 is increased by the generation functions; i.e., you should allocate memory
 for the code to be generated beforehand, and start with 
\family typewriter
\series bold
*ctp
\family default
\series default
 set at the start of this memory area.
 Before running out of memory, allocate a new area, and generate a VM-level
 jump to the new area (this overflow handling is not implemented in our
 examples).
\end_layout

\begin_layout Standard
The other arguments correspond to the immediate arguments of the VM instruction
 (with their appropriate types as defined in the 
\family typewriter
\series bold
type_prefix
\family default
\series default
 declaration.
\end_layout

\begin_layout Standard
The following types, variables, and functions are used in 
\family typewriter
\series bold
name-gen.i
\family default
\series default
:
\end_layout

\begin_layout Description
Inst The type of the VM instruction; if you use threaded code, this is 
\family typewriter
\series bold
void *
\family default
\series default
; for switch dispatch this is an integer type.
\end_layout

\begin_layout Description
vm_prim The VM instruction table (type: 
\family typewriter
\series bold
Inst *
\family default
\series default
, see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-instruction-table"

\end_inset

).
\end_layout

\begin_layout Description
gen_inst(Inst
\begin_inset space ~
\end_inset

**ctp,
\begin_inset space ~
\end_inset

Inst
\begin_inset space ~
\end_inset

i) This function compiles the instruction i.
 Take a look at it in 
\family typewriter
\series bold
vmgen-ex/peephole.c
\family default
\series default
.
 It is trivial when you don't want to use superinstructions (just the last
 two lines of the example function), and slightly more complicated in the
 example due to its ability to use superinstructions (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Peephole-optimization"

\end_inset

).
\end_layout

\begin_layout Description
genarg_type_prefix(Inst
\begin_inset space ~
\end_inset

**ctp,
\begin_inset space ~
\end_inset

type
\begin_inset space ~
\end_inset

type_prefix) This compiles an immediate argument of type (as defined in
 a 
\family typewriter
\series bold
type-prefix
\family default
\series default
 definition).
 These functions are trivial to define (see 
\family typewriter
\series bold

\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Support.c---main()"

\end_inset


\family default
\series default
).
 You need one of these functions for every type that you use as immediate
 argument.
\end_layout

\begin_layout Standard
In addition to using these functions to generate code, you should call 
\family typewriter
\series bold
BB_BOUNDARY
\family default
\series default
 at every basic block entry point if you ever want to use superinstructions
 (or if you want to use the profiling supported by Vmgen; but this support
 is also useful mainly for selecting superinstructions).
 If you use 
\family typewriter
\series bold
BB_BOUNDARY
\family default
\series default
, you should also define it (take a look at its definition in 
\family typewriter
\series bold
vmgen-ex/mini.y
\family default
\series default
).
\end_layout

\begin_layout Standard
You do not need to call 
\family typewriter
\series bold
BB_BOUNDARY
\family default
\series default
 after branches, because you will not define superinstructions that contain
 branches in the middle (and if you did, and it would work, there would
 be no reason to end the superinstruction at the branch), and because the
 branches announce themselves to the profiler.
\end_layout

\begin_layout Subsubsection
Peephole optimization
\begin_inset CommandInset label
LatexCommand label
name "sub:Peephole-optimization"

\end_inset


\end_layout

\begin_layout Standard
You need peephole optimization only if you want to use superinstructions.
 But having the code for it does not hurt much if you do not use superinstructio
ns.
\end_layout

\begin_layout Standard
A simple greedy peephole optimization algorithm is used for superinstruction
 selection: every time 
\family typewriter
\series bold
gen_inst
\family default
\series default
 compiles a VM instruction, it checks if it can combine it with the last
 VM instruction (which may also be a superinstruction resulting from a previous
 peephole optimization); if so, it changes the last instruction to the combined
 instruction instead of laying down i at the current ‘
\family typewriter
\series bold
*ctp
\family default
\series default
’.
\end_layout

\begin_layout Standard
The code for peephole optimization is in 
\family typewriter
\series bold
vmgen-ex/peephole.c
\family default
\series default
.
 You can use this file almost verbatim.
 Vmgen generates 
\family typewriter
\series bold
file-peephole.i
\family default
\series default
 which contains data for the peephole optimizer.
\end_layout

\begin_layout Standard
You have to call ‘
\family typewriter
\series bold
init_peeptable()
\family default
\series default
’ after initializing ‘
\family typewriter
\series bold
vm_prim
\family default
\series default
’, and before compiling any VM code to initialize data structures for peephole
 optimization.
 After that, compiling with the VM code generation functions will automatically
 combine VM instructions into superinstructions.
 Since you do not want to combine instructions across VM branch targets
 (otherwise there will not be a proper VM instruction to branch to), you
 have to call 
\family typewriter
\series bold
BB_BOUNDARY
\family default
\series default
 (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-code-generation"

\end_inset

) at branch targets.
\end_layout

\begin_layout Subsubsection
VM disassembler
\begin_inset CommandInset label
LatexCommand label
name "sub:VM-disassembler"

\end_inset


\end_layout

\begin_layout Standard
A VM code disassembler is optional for an interpretive system, but highly
 recommended during its development and maintenance, because it is very
 useful for detecting bugs in the front end (and for distinguishing them
 from VM interpreter bugs).
\end_layout

\begin_layout Standard
Vmgen supports VM code disassembling by generating 
\family typewriter
\series bold
file-disasm.i
\family default
\series default
.
 This code has to be wrapped into a function, as is done in 
\family typewriter
\series bold
vmgen-ex/disasm.c
\family default
\series default
.
 You can use this file almost verbatim.
 In addition to ‘
\family typewriter
\series bold
vm_A2B(a,b)
\family default
\series default
’, ‘
\family typewriter
\series bold
vm_out
\family default
\series default
’, ‘
\family typewriter
\series bold
printarg_type(value)
\family default
\series default
’, which are explained above, the following macros and variables are used
 in file-disasm.i (and you have to define them):
\end_layout

\begin_layout Description
ip This variable points to the opcode of the current VM instruction.
\end_layout

\begin_layout Description
IP
\begin_inset space ~
\end_inset

IPTOS ‘
\family typewriter
\series bold
IPTOS
\family default
\series default
’ is the first argument of the current VM instruction, and ‘
\family typewriter
\series bold
IP
\family default
\series default
’ points to it; this is just as in the engine, but here ‘
\family typewriter
\series bold
ip
\family default
\series default
’ points to the opcode of the VM instruction (in contrast to the engine,
 where ‘
\family typewriter
\series bold
ip
\family default
\series default
’ points to the next cell, or even one further).
\end_layout

\begin_layout Description
VM_IS_INST(Inst
\begin_inset space ~
\end_inset

i,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

n) Tests if the opcode ‘
\family typewriter
\series bold
i
\family default
\series default
’ is the same as the ‘n’th entry in the VM instruction table.
\end_layout

\begin_layout Subsubsection
VM profiler
\begin_inset CommandInset label
LatexCommand label
name "sub:VM-profiler"

\end_inset


\end_layout

\begin_layout Standard
The VM profiler is designed for getting execution and occurence counts for
 VM instruction sequences, and these counts can then be used for selecting
 sequences as superinstructions.
 The VM profiler is probably not useful as profiling tool for the interpretive
 system.
 I.e., the VM profiler is useful for the developers, but not the users of
 the interpretive system.
\end_layout

\begin_layout Standard
The output of the profiler is: for each basic block (executed at least once),
 it produces the dynamic execution count of that basic block and all its
 subsequences; e.g.,
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
9227465 lit storelocal
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
9227465 storelocal branch
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
9227465 lit storelocal branch
\end_layout

\begin_layout Standard
I.e., a basic block consisting of ‘
\family typewriter
\series bold
lit storelocal branch
\family default
\series default
’ is executed 9227465 times.
\end_layout

\begin_layout Standard
This output can be combined in various ways.
 E.g., 
\family typewriter
\series bold
vmgen-ex/stat.awk
\family default
\series default
 adds up the occurences of a given sequence wrt dynamic execution, static
 occurence, and per-program occurence.
 E.g.,
\end_layout

\begin_layout Quotation

\family typewriter
\series bold
2 16 36910041 loadlocal lit
\end_layout

\begin_layout Standard
indicates that the sequence ‘
\family typewriter
\series bold
loadlocal lit
\family default
\series default
’ occurs in 2 programs, in 16 places, and has been executed 36910041 times.
 Now you can select superinstructions in any way you like (note that compile
 time and space typically limit the number of superinstructions to 100–1000).
 After you have done that, 
\family typewriter
\series bold
vmgen/seq2rule.awk
\family default
\series default
 turns lines of the form above into rules for inclusion in a Vmgen input
 file.
 So, an overall script for turning profiles into superinstructions can look
 like 
\family typewriter
\series bold
profile-fib-test
\family default
\series default
 in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Using-profiling-to"

\end_inset

.
 Note that this script does not ensure that all prefixes are defined, so
 you have to do that in other ways.
\end_layout

\begin_layout Standard
Here the dynamic count is used for selecting sequences (preliminary results
 indicate that the static count gives better results, though); the third
 line eliminates sequences containing instructions that must not occur in
 a superinstruction, because they access a stack directly.
 The dynamic count selection ensures that all subsequences (including prefixes)
 of longer sequences occur (because subsequences have at least the same
 count as the longer sequences); the sort in the last line ensures that
 longer superinstructions occur after their prefixes.
\end_layout

\begin_layout Standard
But before using this, you have to have the profiler.
 Vmgen supports its creation by generating 
\family typewriter
\series bold
file-profile.i
\family default
\series default
; you also need the wrapper file 
\family typewriter
\series bold
vmgen-ex/profile.c
\family default
\series default
 that you can use almost verbatim.
\end_layout

\begin_layout Standard
The profiler works by recording the targets of all VM control flow changes
 (through 
\family typewriter
\series bold
SUPER_END
\family default
\series default
 during execution, and through 
\family typewriter
\series bold
BB_BOUNDARY
\family default
\series default
 in the front end), and counting (through 
\family typewriter
\series bold
SUPER_END
\family default
\series default
) how often they were targeted.
 After the program run, the numbers are corrected such that each VM basic
 block has the correct count (entering a block without executing a branch
 does not increase the count, and the correction fixes that), then the subsequen
ces of all basic blocks are printed.
 To get all this, you just have to define 
\family typewriter
\series bold
SUPER_END
\family default
\series default
 (and 
\family typewriter
\series bold
BB_BOUNDARY
\family default
\series default
) appropriately, and call 
\family typewriter
\series bold
vm_print_profile(FILE *file)
\family default
\series default
 when you want to output the profile on file.
\end_layout

\begin_layout Standard
The 
\family typewriter
\series bold
file-profile.i
\family default
\series default
 is similar to the disassembler file, and it uses variables and functions
 defined in 
\family typewriter
\series bold
vmgen-ex/profile.c
\family default
\series default
, plus VM_IS_INST already defined for the VM disassembler (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VM-disassembler"

\end_inset

).
\end_layout

\begin_layout Subsection
Hints
\end_layout

\begin_layout Itemize
Floating point: and stacks
\end_layout

\begin_layout Subsubsection
Floating point
\end_layout

\begin_layout Standard
How should you deal with floating point values? Should you use the same
 stack as for integers/pointers, or a different one? This section discusses
 this issue with a view on execution speed.
\end_layout

\begin_layout Standard
The simpler approach is to use a separate floating-point stack.
 This allows you to choose FP value size without considering the size of
 the integers/pointers, and you avoid a number of performance problems.
 The main downside is that this needs an FP stack pointer (and that may
 not fit in the register file on the 386 arhitecture, costing some performance,
 but comparatively little if you take the other option into account).
 If you use a separate FP stack (with stack pointer 
\family typewriter
\series bold
fp
\family default
\series default
), using an 
\family typewriter
\series bold
fpTOS
\family default
\series default
 is helpful on most machines, but some spill the 
\family typewriter
\series bold
fpTOS
\family default
\series default
 register into memory, and 
\family typewriter
\series bold
fpTOS
\family default
\series default
 should not be used there.
\end_layout

\begin_layout Standard
The other approach is to share one stack (pointed to by, say, sp) between
 integer/pointer and floating-point values.
 This is ok if you do not use 
\family typewriter
\series bold
spTOS
\family default
\series default
.
 If you do use 
\family typewriter
\series bold
spTOS
\family default
\series default
, the compiler has to decide whether to put that variable into an integer
 or a floating point register, and the other type of operation becomes quite
 expensive on most machines (because moving values between integer and FP
 registers is quite expensive).
 If a value of one type has to be synthesized out of two values of the other
 type (double types), things are even more interesting.
\end_layout

\begin_layout Standard
One way around this problem would be to not use the 
\family typewriter
\series bold
spTOS
\family default
\series default
 supported by Vmgen, but to use explicit top-of-stack variables (one for
 integers, one for FP values), and having a kind of accumulator+stack architectu
re (e.g., Ocaml bytecode uses this approach); however, this is a major change,
 and it's ramifications are not completely clear.
\end_layout

\begin_layout Subsection
The future
\end_layout

\begin_layout Standard
We have a number of ideas for future versions of Vmgen.
 However, there are so many possible things to do that we would like some
 feedback from you.
 What are you doing with Vmgen, what features are you missing, and why?
\end_layout

\begin_layout Standard
One idea we are thinking about is to generate just one .c file instead of
 letting you copy and adapt all the wrapper files (you would still have
 to define stuff like the type-specific macros, and stack pointers etc.
 somewhere).
 The advantage would be that, if we change the wrapper files between versions,
 you would not need to integrate your changes and our changes to them; Vmgen
 would also be easier to use for beginners.
 The main disadvantage of that is that it would reduce the flexibility of
 Vmgen a little (well, those who like flexibility could still patch the
 resulting .c file, like they are now doing for the wrapper files).
 In any case, if you are doing things to the wrapper files that would cause
 problems in a generated-.c-file approach, please let us know.
\end_layout

\begin_layout Subsection
Contact
\begin_inset CommandInset label
LatexCommand label
name "sub:Contact"

\end_inset


\end_layout

\begin_layout Standard
To report a bug, use 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://savannah.gnu.org/bugs/?func=addbug&group_id=2672
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For discussion on Vmgen (e.g., how to use it), use the mailing list bug-vmgen@mail.
freesoftware.fsf.org (use 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://mail.gnu.org/mailman/listinfo/help-vmgen
\end_layout

\end_inset

 to subscribe).
\end_layout

\begin_layout Standard
You can find vmgen information at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.complang.tuwien.ac.at/anton/vmgen/
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Virtual machine implementation
\end_layout

\begin_layout Subsection
ArrayForth application files
\end_layout

\begin_layout Subsubsection
README
\end_layout

\begin_layout Scrap
<<README>>=
\begin_inset Newline newline
\end_inset

This directory contains a working example for using vmgen.
  It's a
\begin_inset Newline newline
\end_inset

small Modula-2-like programming language.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

You can build the example by first installing Gforth and then saying,
\begin_inset Newline newline
\end_inset

in this directory:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

make
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Ignore the warnings.
  You can check that it works with
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

make check
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

You can run mini programs like this:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

./mini fib.mini
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

To learn about the options, type
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

./mini -h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

More information can be found in the vmgen documentation.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

-----
\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
simple.mini - example mini program
\end_layout

\begin_layout Scrap
<<simple.mini>>=
\begin_inset Newline newline
\end_inset

func main()
\begin_inset Newline newline
\end_inset

  return 1;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
fib.mini - example mini program
\end_layout

\begin_layout Scrap
<<fib.mini>>=
\begin_inset Newline newline
\end_inset

func fib(n)
\begin_inset Newline newline
\end_inset

  var r;
\begin_inset Newline newline
\end_inset

  if n<2 then
\begin_inset Newline newline
\end_inset

    r:=1;
\begin_inset Newline newline
\end_inset

  else
\begin_inset Newline newline
\end_inset

    r:=fib(n-1)+fib(n-2);
\begin_inset Newline newline
\end_inset

  end if;
\begin_inset Newline newline
\end_inset

  return r;
\begin_inset Newline newline
\end_inset

  // the language syntax (return only at end) leads to inefficient code
 here
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func main()
\begin_inset Newline newline
\end_inset

  return fib(34);
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
test.mini - example mini program (tests everything)
\end_layout

\begin_layout Scrap
<<test.mini>>=
\begin_inset Newline newline
\end_inset

func operators()
\begin_inset Newline newline
\end_inset

  print 3 = 3;
\begin_inset Newline newline
\end_inset

  print (3+5) = 8;
\begin_inset Newline newline
\end_inset

  print (5-3) = 2;
\begin_inset Newline newline
\end_inset

  print (3*5) = 15;
\begin_inset Newline newline
\end_inset

  print (3&5) = 1;
\begin_inset Newline newline
\end_inset

  print (3|5) = 7;
\begin_inset Newline newline
\end_inset

  print (3<5) = 1;
\begin_inset Newline newline
\end_inset

  print (5<3) = 0;
\begin_inset Newline newline
\end_inset

  print (3=5) = 0;
\begin_inset Newline newline
\end_inset

  print (5=5) = 1;
\begin_inset Newline newline
\end_inset

  print (!3) = 0;
\begin_inset Newline newline
\end_inset

  print (!0) = 1;
\begin_inset Newline newline
\end_inset

  print (-3) = (0-3);
\begin_inset Newline newline
\end_inset

  return 0;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func params(a, b, c)
\begin_inset Newline newline
\end_inset

  print a = 3;
\begin_inset Newline newline
\end_inset

  print b = 5;
\begin_inset Newline newline
\end_inset

  print c = 7;
\begin_inset Newline newline
\end_inset

  return 9;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func locals(a)
\begin_inset Newline newline
\end_inset

  var b;
\begin_inset Newline newline
\end_inset

  var c;
\begin_inset Newline newline
\end_inset

  b:=a+1;
\begin_inset Newline newline
\end_inset

  c:=b+1;
\begin_inset Newline newline
\end_inset

  a:=c+1;
\begin_inset Newline newline
\end_inset

  return a;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func inc(x)
\begin_inset Newline newline
\end_inset

  return x+1;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func sign(n)
\begin_inset Newline newline
\end_inset

  var r;
\begin_inset Newline newline
\end_inset

  if (n<0) then
\begin_inset Newline newline
\end_inset

    r:=-1;
\begin_inset Newline newline
\end_inset

  else
\begin_inset Newline newline
\end_inset

    if (0<n) then
\begin_inset Newline newline
\end_inset

      r:=1;
\begin_inset Newline newline
\end_inset

    else
\begin_inset Newline newline
\end_inset

      r:=0;
\begin_inset Newline newline
\end_inset

    end if;
\begin_inset Newline newline
\end_inset

  end if;
\begin_inset Newline newline
\end_inset

  return r;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func recfac(n)
\begin_inset Newline newline
\end_inset

  var r;
\begin_inset Newline newline
\end_inset

  if (n<1) then
\begin_inset Newline newline
\end_inset

    r:=1;
\begin_inset Newline newline
\end_inset

  else
\begin_inset Newline newline
\end_inset

    r:=recfac(n-1)*n;
\begin_inset Newline newline
\end_inset

  end if;
\begin_inset Newline newline
\end_inset

  return r;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func itfac(n)
\begin_inset Newline newline
\end_inset

  var r;
\begin_inset Newline newline
\end_inset

  r:=1;
\begin_inset Newline newline
\end_inset

  while (0<n) do
\begin_inset Newline newline
\end_inset

    r:=r*n;
\begin_inset Newline newline
\end_inset

    n:=n-1;
\begin_inset Newline newline
\end_inset

  end while;
\begin_inset Newline newline
\end_inset

  return r;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func testfac()
\begin_inset Newline newline
\end_inset

  var i;
\begin_inset Newline newline
\end_inset

  i:=0;
\begin_inset Newline newline
\end_inset

  while (i<10) do
\begin_inset Newline newline
\end_inset

    print itfac(i) = recfac(i);
\begin_inset Newline newline
\end_inset

    i:=i+1;
\begin_inset Newline newline
\end_inset

  end while;
\begin_inset Newline newline
\end_inset

  return 0;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

func main()
\begin_inset Newline newline
\end_inset

  operators();
\begin_inset Newline newline
\end_inset

  print params(3,5,7) = 9;
\begin_inset Newline newline
\end_inset

  print locals(3) = 6;
\begin_inset Newline newline
\end_inset

  print (inc(1)+inc(inc(inc(3))))=8;
\begin_inset Newline newline
\end_inset

  print sign(5) = 1;
\begin_inset Newline newline
\end_inset

  print sign(0) = 0;
\begin_inset Newline newline
\end_inset

  print sign(-5) = (-1);
\begin_inset Newline newline
\end_inset

  print itfac(5) = 120;
\begin_inset Newline newline
\end_inset

  testfac();
\begin_inset Newline newline
\end_inset

  return 0;
\begin_inset Newline newline
\end_inset

end func;
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Paragraph
test.out - test.mini output
\end_layout

\begin_layout Scrap
<<test.out>>=
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

1
\begin_inset Newline newline
\end_inset

result = 0
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Mini specific files
\end_layout

\begin_layout Standard
You would typically change much in or replace the following files:
\end_layout

\begin_layout Subsubsection

\series bold
\shape italic
Makefile
\series default
\shape default
 
\end_layout

\begin_layout Scrap
<<Makefile>>=
\begin_inset Newline newline
\end_inset

#Makefile for afvm example
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<make-copyright>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

LEX=flex -l
\begin_inset Newline newline
\end_inset

YACC=bison -y
\begin_inset Newline newline
\end_inset

#YACC=yacc
\begin_inset Newline newline
\end_inset

VMGEN=vmgen
\begin_inset Newline newline
\end_inset

#GCC=gcc -g -Wall
\begin_inset Newline newline
\end_inset

GCC=gcc -O3 -fomit-frame-pointer -Wall
\begin_inset Newline newline
\end_inset

CC=$(GCC)
\begin_inset Newline newline
\end_inset

<<M4>>
\begin_inset Newline newline
\end_inset

OBJECTS_MINI=mini.tab.o support.o peephole.o profile.o disasm.o engine.o engine-debug.o
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

mini: $(OBJECTS_MINI)
\begin_inset Newline newline
\end_inset

	$(CC) $(OBJECTS_MINI) -o $@
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

lex.yy.c: mini.l
\begin_inset Newline newline
\end_inset

	$(LEX) mini.l
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

mini.tab.c: mini.y lex.yy.c
\begin_inset Newline newline
\end_inset

	$(YACC) mini.y && mv y.tab.c $@
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

mini-vm.i mini-disasm.i mini-gen.i mini-labels.i mini-profile.i mini-peephole.i:
 mini.vmg
\begin_inset Newline newline
\end_inset

	$(VMGEN) mini.vmg
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

mini.vmg: mini-inst.vmg mini-super.vmg
\begin_inset Newline newline
\end_inset

	$(M4) mini-inst.vmg >$@
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

mini.tab.o: mini.tab.c mini-gen.i lex.yy.c mini.h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

support.o: support.c mini.h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

peephole.o: peephole.c mini-peephole.i mini.h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

profile.o: profile.c mini-profile.i mini.h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

disasm.o: disasm.c mini-disasm.i mini.h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<engine>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

clean:
\begin_inset Newline newline
\end_inset

	rm -f *.o mini mini-*.i lex.yy.c mini.tab.c mini.vmg
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

check:  mini
\begin_inset Newline newline
\end_inset

	./mini test.mini | tr -d '
\backslash
015' | diff - test.out
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

checkall:
\begin_inset Newline newline
\end_inset

	for i in 1 3 5 8 9 10; do make clean; echo $$i; make check VMGEN=vmgen
 CC="gcc -O3 -fomit-frame-pointer -Wall -DTHREADING_SCHEME=$$i"; echo $$i
 >>xxx-bench; 
\backslash
time mini fib.mini 2>>xxx-bench; done; cat xxx-bench; rm xxx-bench
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#make profiles
\begin_inset Newline newline
\end_inset

%.prof: %.mini mini
\begin_inset Newline newline
\end_inset

	./mini -p $< 2>$@
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
Support.c - main() and other support functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Support.c---main()"

\end_inset


\end_layout

\begin_layout Scrap
<<support.c>>=
\begin_inset Newline newline
\end_inset

/* support functions and main() for afvm example
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include <stdlib.h>
\begin_inset Newline newline
\end_inset

#include <stdio.h>
\begin_inset Newline newline
\end_inset

#include <unistd.h>
\begin_inset Newline newline
\end_inset

extern int optind;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include <assert.h>
\begin_inset Newline newline
\end_inset

#include "mini.h"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void genarg_i(Inst **vmcodepp, Cell i)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  *((Cell *) *vmcodepp) = i;
\begin_inset Newline newline
\end_inset

  (*vmcodepp)++;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void genarg_target(Inst **vmcodepp, Inst *target)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  *((Inst **) *vmcodepp) = target;
\begin_inset Newline newline
\end_inset

  (*vmcodepp)++;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void printarg_i(Cell i)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  fprintf(vm_out, "%ld ", i);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void printarg_target(Inst *target)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  fprintf(vm_out, "%p ", target);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void printarg_a(char *a)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  fprintf(vm_out, "%p ", a);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void printarg_Cell(Cell i)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  fprintf(vm_out, "0x%lx ", i);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* This language has separate name spaces for functions and variables;
\begin_inset Newline newline
\end_inset

   this works because there are no function variables, and the syntax
\begin_inset Newline newline
\end_inset

   makes it possible to differentiate between function and variable
\begin_inset Newline newline
\end_inset

   reference */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

typedef struct functab {
\begin_inset Newline newline
\end_inset

  struct functab *next;
\begin_inset Newline newline
\end_inset

  char *name;
\begin_inset Newline newline
\end_inset

  Inst *start;
\begin_inset Newline newline
\end_inset

  int params;
\begin_inset Newline newline
\end_inset

  int nonparams;
\begin_inset Newline newline
\end_inset

} functab;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

functab *ftab=NULL;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* note: does not check for double definitions */
\begin_inset Newline newline
\end_inset

void insert_func(char *name, Inst *start, int locals, int nonparams)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  functab *node = malloc(sizeof(functab));
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  node->next=ftab;
\begin_inset Newline newline
\end_inset

  node->name=name;
\begin_inset Newline newline
\end_inset

  node->start=start;
\begin_inset Newline newline
\end_inset

  node->params=locals-nonparams;
\begin_inset Newline newline
\end_inset

  node->nonparams=nonparams;
\begin_inset Newline newline
\end_inset

  ftab=node;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

functab *lookup_func(char *name)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  functab *p;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  for (p=ftab; p!=NULL; p=p->next)
\begin_inset Newline newline
\end_inset

    if (strcmp(p->name,name)==0)
\begin_inset Newline newline
\end_inset

      return p;
\begin_inset Newline newline
\end_inset

  fprintf(stderr, "undefined function %s", name);
\begin_inset Newline newline
\end_inset

  exit(1);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Inst *func_addr(char *name)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  return lookup_func(name)->start;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Cell func_calladjust(char *name)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  return adjust(lookup_func(name)->nonparams);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

typedef struct vartab {
\begin_inset Newline newline
\end_inset

  struct vartab *next;
\begin_inset Newline newline
\end_inset

  char *name;
\begin_inset Newline newline
\end_inset

  int index;
\begin_inset Newline newline
\end_inset

} vartab;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

vartab* vtab;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* no checking for double definitions */
\begin_inset Newline newline
\end_inset

void insert_local(char *name)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  vartab *node = malloc(sizeof(vartab));
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  locals++;
\begin_inset Newline newline
\end_inset

  node->next=vtab;
\begin_inset Newline newline
\end_inset

  node->name=name;
\begin_inset Newline newline
\end_inset

  node->index=locals;
\begin_inset Newline newline
\end_inset

  vtab = node;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

vartab *lookup_var(char *name)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  vartab *p;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  for (p=vtab; p!=NULL; p=p->next)
\begin_inset Newline newline
\end_inset

    if (strcmp(p->name,name)==0)
\begin_inset Newline newline
\end_inset

      return p;
\begin_inset Newline newline
\end_inset

  fprintf(stderr, "undefined local variable %s", name);
\begin_inset Newline newline
\end_inset

  exit(1);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Cell var_offset(char *name)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  return (locals - lookup_var(name)->index + 2)*sizeof(Cell);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#define CODE_SIZE 65536
\begin_inset Newline newline
\end_inset

#define STACK_SIZE 65536
\begin_inset Newline newline
\end_inset

typedef Cell (*engine_t)(Inst *ip0, Cell* sp, char* fp);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

char *program_name;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

int main(int argc, char **argv)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  int disassembling = 0;
\begin_inset Newline newline
\end_inset

  int profiling = 0;
\begin_inset Newline newline
\end_inset

  int c;
\begin_inset Newline newline
\end_inset

  Inst *vm_code=(Inst *)calloc(CODE_SIZE,sizeof(Inst));
\begin_inset Newline newline
\end_inset

  Inst *start;
\begin_inset Newline newline
\end_inset

  Cell *stack=(Cell *)calloc(STACK_SIZE,sizeof(Cell));
\begin_inset Newline newline
\end_inset

  engine_t runvm=engine;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  while ((c = getopt(argc, argv, "hdpt")) != -1) {
\begin_inset Newline newline
\end_inset

    switch (c) {
\begin_inset Newline newline
\end_inset

    default:
\begin_inset Newline newline
\end_inset

    case 'h':
\begin_inset Newline newline
\end_inset

    help:
\begin_inset Newline newline
\end_inset

      fprintf(stderr, "Usage: %s [options] file
\backslash
nOptions:
\backslash
n-h	Print this message and exit
\backslash
n-d	disassemble VM program before execution
\backslash
n-p	profile VM code sequences (output on stderr)
\backslash
n-t	trace VM code execution (output on stderr)
\backslash
n",
\begin_inset Newline newline
\end_inset

	      argv[0]);
\begin_inset Newline newline
\end_inset

      exit(1);
\begin_inset Newline newline
\end_inset

    case 'd':
\begin_inset Newline newline
\end_inset

      disassembling=1;
\begin_inset Newline newline
\end_inset

      break;
\begin_inset Newline newline
\end_inset

    case 'p':
\begin_inset Newline newline
\end_inset

      profiling=1;
\begin_inset Newline newline
\end_inset

      use_super=0; /* we don't want superinstructions in the profile */
\begin_inset Newline newline
\end_inset

      runvm = engine_debug;
\begin_inset Newline newline
\end_inset

      break;
\begin_inset Newline newline
\end_inset

    case 't':
\begin_inset Newline newline
\end_inset

      vm_debug=1;
\begin_inset Newline newline
\end_inset

      runvm = engine_debug;
\begin_inset Newline newline
\end_inset

      break;
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

  if (optind+1 != argc)
\begin_inset Newline newline
\end_inset

    goto help;
\begin_inset Newline newline
\end_inset

  program_name = argv[optind];
\begin_inset Newline newline
\end_inset

  if ((yyin=fopen(program_name,"r"))==NULL) {
\begin_inset Newline newline
\end_inset

    perror(argv[optind]);
\begin_inset Newline newline
\end_inset

    exit(1);
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  /* initialize everything */
\begin_inset Newline newline
\end_inset

  vmcodep = vm_code;
\begin_inset Newline newline
\end_inset

  vm_out = stderr;
\begin_inset Newline newline
\end_inset

  (void)runvm(NULL,NULL,NULL); /* initialize vm_prim */
\begin_inset Newline newline
\end_inset

  init_peeptable();
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  if (yyparse())
\begin_inset Newline newline
\end_inset

    exit(1);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  start=vmcodep;
\begin_inset Newline newline
\end_inset

  gen_main_end();
\begin_inset Newline newline
\end_inset

  vmcode_end=vmcodep;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  if (disassembling)
\begin_inset Newline newline
\end_inset

    vm_disassemble(vm_code, vmcodep, vm_prim);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  printf("result = %ld
\backslash
n",runvm(start, stack+STACK_SIZE-1, NULL));
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  if (profiling)
\begin_inset Newline newline
\end_inset

    vm_print_profile(vm_out);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  return 0;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
mini.h - common declarations
\end_layout

\begin_layout Scrap
<<mini.h>>=
\begin_inset Newline newline
\end_inset

/* support functions for afvm example
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include <stdio.h>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

typedef long Cell;
\begin_inset Newline newline
\end_inset

#ifdef __GNUC__
\begin_inset Newline newline
\end_inset

typedef void *Label;
\begin_inset Newline newline
\end_inset

typedef Label Inst; /* we could "typedef Cell Inst", removing the need
\begin_inset Newline newline
\end_inset

                       for casts in a few places, but requiring a few
\begin_inset Newline newline
\end_inset

                       casts etc.
 in other places */
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

typedef long Label;
\begin_inset Newline newline
\end_inset

typedef long Inst;
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

extern Inst *vm_prim;
\begin_inset Newline newline
\end_inset

extern int locals;
\begin_inset Newline newline
\end_inset

extern Cell peeptable;
\begin_inset Newline newline
\end_inset

extern int vm_debug;
\begin_inset Newline newline
\end_inset

extern FILE *yyin;
\begin_inset Newline newline
\end_inset

extern int yylineno;
\begin_inset Newline newline
\end_inset

extern char *program_name;
\begin_inset Newline newline
\end_inset

extern FILE *vm_out;
\begin_inset Newline newline
\end_inset

extern Inst *vmcodep;
\begin_inset Newline newline
\end_inset

extern Inst *last_compiled;
\begin_inset Newline newline
\end_inset

extern Inst *vmcode_end;
\begin_inset Newline newline
\end_inset

extern int use_super;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* generic afvm support functions (e.g., wrappers) */
\begin_inset Newline newline
\end_inset

void gen_inst(Inst **vmcodepp, Inst i);
\begin_inset Newline newline
\end_inset

void init_peeptable(void);
\begin_inset Newline newline
\end_inset

void vm_disassemble(Inst *ip, Inst *endp, Inst prim[]);
\begin_inset Newline newline
\end_inset

void vm_count_block(Inst *ip);
\begin_inset Newline newline
\end_inset

struct block_count *block_insert(Inst *ip);
\begin_inset Newline newline
\end_inset

void vm_print_profile(FILE *file);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<vm-A2B(a,b)>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<IMM-ARG>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#define VM_IS_INST(inst, n) ((inst) == vm_prim[n])
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* mini type-specific support functions */
\begin_inset Newline newline
\end_inset

void genarg_i(Inst **vmcodepp, Cell i);
\begin_inset Newline newline
\end_inset

void printarg_i(Cell i);
\begin_inset Newline newline
\end_inset

void genarg_target(Inst **vmcodepp, Inst *target);
\begin_inset Newline newline
\end_inset

void printarg_target(Inst *target);
\begin_inset Newline newline
\end_inset

void printarg_a(char *a);
\begin_inset Newline newline
\end_inset

void printarg_Cell(Cell i);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* engine functions (type not fixed) */
\begin_inset Newline newline
\end_inset

Cell engine(Inst *ip0, Cell *sp, char *fp);
\begin_inset Newline newline
\end_inset

Cell engine_debug(Inst *ip0, Cell *sp, char *fp);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* other generic functions */
\begin_inset Newline newline
\end_inset

int yyparse(void);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* mini-specific functions */
\begin_inset Newline newline
\end_inset

void insert_func(char *name, Inst *start, int locals, int nonparams);
\begin_inset Newline newline
\end_inset

Inst *func_addr(char *name);
\begin_inset Newline newline
\end_inset

Cell func_calladjust(char *name);
\begin_inset Newline newline
\end_inset

void insert_local(char *name);
\begin_inset Newline newline
\end_inset

Cell var_offset(char *name);
\begin_inset Newline newline
\end_inset

void gen_main_end(void);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* stack pointer change for a function with n nonparams */
\begin_inset Newline newline
\end_inset

#define adjust(n)  ((n) * -sizeof(Cell))
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
mini-inst.vmg - simple VM instructions
\end_layout

\begin_layout Scrap
<<mini-inst.vmg>>=
\begin_inset Newline newline
\end_inset


\backslash
 mini.inst is generated automatically from mini-inst.vmg and mini-super.vmg
\begin_inset Newline newline
\end_inset


\backslash
 example .vmg file
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<
\backslash
copyright>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 WARNING: This file is processed by m4.
 Make sure your identifiers
\begin_inset Newline newline
\end_inset


\backslash
 don't collide with m4's (e.g.
 by undefining them).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 comments start with "
\backslash
 "
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<stack-definitions>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<stack-prefix>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<type-prefix>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<simple-instructions>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<branch>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<zbranch>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<stack-organization>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<stack-caching>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<end>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

include(mini-super.vmg)
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
mini-super.vmg - superinstructions (empty at first)
\end_layout

\begin_layout Scrap
<<mini-super.vmg>>=
\begin_inset Newline newline
\end_inset

<<ll>>
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
mini.l - scanner
\end_layout

\begin_layout Scrap
<<mini.l>>=
\begin_inset Newline newline
\end_inset

%{
\begin_inset Newline newline
\end_inset

/* front-end scanner for afvm example
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* % option yylineno (flex option, implied by flex -l) */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include <stdlib.h>
\begin_inset Newline newline
\end_inset

#include <string.h>
\begin_inset Newline newline
\end_inset

char *mystrdup(const char *s)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  char *t=malloc(strlen(s)+1);
\begin_inset Newline newline
\end_inset

  return strcpy(t,s);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

%}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

%%
\begin_inset Newline newline
\end_inset

[-();,+*&|<=!]	return yytext[0];
\begin_inset Newline newline
\end_inset

:=     return BECOMES;
\begin_inset Newline newline
\end_inset

func   return FUNC;
\begin_inset Newline newline
\end_inset

return return RETURN;
\begin_inset Newline newline
\end_inset

end    return END;
\begin_inset Newline newline
\end_inset

var    return VAR;
\begin_inset Newline newline
\end_inset

if     return IF;
\begin_inset Newline newline
\end_inset

then   return THEN;
\begin_inset Newline newline
\end_inset

else   return ELSE;
\begin_inset Newline newline
\end_inset

while  return WHILE;
\begin_inset Newline newline
\end_inset

do     return DO;
\begin_inset Newline newline
\end_inset

print  return PRINT;
\begin_inset Newline newline
\end_inset

[0-9]+ { yylval.num=strtol(yytext,NULL,10); return NUM; }
\begin_inset Newline newline
\end_inset

[a-zA-Z
\backslash
_][a-zA-Z0-9
\backslash
_]* { yylval.string=mystrdup(yytext); return IDENT; }
\begin_inset Newline newline
\end_inset

[ 
\backslash
t
\backslash
n] ;
\begin_inset Newline newline
\end_inset

[/][/].* ;
\begin_inset Newline newline
\end_inset

.
 yyerror("illegal character"); exit(1);
\begin_inset Newline newline
\end_inset

%%
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
mini.y - front end (parser, VM code generator)
\end_layout

\begin_layout Scrap
<<mini.y>>=
\begin_inset Newline newline
\end_inset

/* front-end compiler for afvm example
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* I use yacc/bison here not because I think it's the best tool for
\begin_inset Newline newline
\end_inset

   the job, but because it's widely available and popular; it's also
\begin_inset Newline newline
\end_inset

   (barely) adequate for this job.
 */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

%{
\begin_inset Newline newline
\end_inset

#include <stdlib.h>
\begin_inset Newline newline
\end_inset

#include <stdio.h>
\begin_inset Newline newline
\end_inset

#include <string.h>
\begin_inset Newline newline
\end_inset

#include "mini.h"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* BB_BOUNDARY is needed on basic blocks without a preceding VM branch */
\begin_inset Newline newline
\end_inset

#define BB_BOUNDARY (last_compiled = NULL,  /* suppress peephole opt */
 
\backslash

\begin_inset Newline newline
\end_inset

                     block_insert(vmcodep)) /* for accurate profiling */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Inst *vm_prim;
\begin_inset Newline newline
\end_inset

Inst *vmcodep;
\begin_inset Newline newline
\end_inset

FILE *vm_out;
\begin_inset Newline newline
\end_inset

int vm_debug;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void yyerror(char *s)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

#if 1
\begin_inset Newline newline
\end_inset

  /* for pure flex call */
\begin_inset Newline newline
\end_inset

  fprintf(stderr, "%s: %s
\backslash
n", program_name, s);
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

  /* lex or flex -l supports yylineno */
\begin_inset Newline newline
\end_inset

  fprintf (stderr, "%s: %d: %s
\backslash
n", program_name, yylineno, s);
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include "mini-gen.i"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void gen_main_end(void)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  gen_call(&vmcodep, func_addr("main"), func_calladjust("main"));
\begin_inset Newline newline
\end_inset

  gen_end(&vmcodep);
\begin_inset Newline newline
\end_inset

  BB_BOUNDARY; /* for profiling; see comment in mini.vmg:end */
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

int locals=0;
\begin_inset Newline newline
\end_inset

int nonparams=0;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

int yylex();
\begin_inset Newline newline
\end_inset

%}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

%token FUNC RETURN END VAR IF THEN ELSE WHILE DO BECOMES PRINT NUM IDENT
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

%union {
\begin_inset Newline newline
\end_inset

  long num;
\begin_inset Newline newline
\end_inset

  char *string;
\begin_inset Newline newline
\end_inset

  Inst *instp;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

%type <string> IDENT;
\begin_inset Newline newline
\end_inset

%type <num> NUM;
\begin_inset Newline newline
\end_inset

%type <instp> elsepart;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

%%
\begin_inset Newline newline
\end_inset

program: program function
\begin_inset Newline newline
\end_inset

       | ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

function: FUNC IDENT { locals=0; nonparams=0; } '(' params ')'
\begin_inset Newline newline
\end_inset

          vars                  { insert_func($2,vmcodep,locals,nonparams);
 }
\begin_inset Newline newline
\end_inset

          stats RETURN expr ';'
\begin_inset Newline newline
\end_inset

          END FUNC ';'          { gen_return(&vmcodep, -adjust(locals));
 }
\begin_inset Newline newline
\end_inset

        ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

params: IDENT ',' { insert_local($1); } params
\begin_inset Newline newline
\end_inset

      | IDENT     { insert_local($1); }
\begin_inset Newline newline
\end_inset

      | ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

vars: vars VAR IDENT ';' { insert_local($3); nonparams++; }
\begin_inset Newline newline
\end_inset

    | ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

stats: stats stat ';'
\begin_inset Newline newline
\end_inset

     | ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

stat: IF expr THEN { gen_zbranch(&vmcodep, 0); $<instp>$ = vmcodep; }
\begin_inset Newline newline
\end_inset

      stats { $<instp>$ = $<instp>4; }
\begin_inset Newline newline
\end_inset

      elsepart END IF { BB_BOUNDARY; $<instp>7[-1] = (Inst)vmcodep; }
\begin_inset Newline newline
\end_inset

    | WHILE   { BB_BOUNDARY; $<instp>$ = vmcodep; }
\begin_inset Newline newline
\end_inset

      expr DO { gen_zbranch(&vmcodep, 0); $<instp>$ = vmcodep; }
\begin_inset Newline newline
\end_inset

      stats END WHILE { gen_branch(&vmcodep, $<instp>2); $<instp>5[-1] =
 (Inst)vmcodep; }
\begin_inset Newline newline
\end_inset

    | IDENT BECOMES expr        { gen_storelocal(&vmcodep,  var_offset($1));
 }
\begin_inset Newline newline
\end_inset

    | PRINT expr                { gen_print(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | expr                      { gen_drop(&vmcodep); }
\begin_inset Newline newline
\end_inset

    ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

elsepart: ELSE { gen_branch(&vmcodep, 0); $<instp>$ = vmcodep; $<instp>0[-1]
 = (Inst)vmcodep; }
\begin_inset Newline newline
\end_inset

          stats { $$ = $<instp>2; }
\begin_inset Newline newline
\end_inset

        | { $$ = $<instp>0; }
\begin_inset Newline newline
\end_inset

        ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

expr: term '+' term     { gen_add(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term '-' term     { gen_sub(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term '*' term     { gen_mul(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term '&' term     { gen_and(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term '|' term     { gen_or(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term '<' term     { gen_lessthan(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term '=' term     { gen_equals(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | '!' term          { gen_not(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | '-' term          { gen_negate(&vmcodep); }
\begin_inset Newline newline
\end_inset

    | term
\begin_inset Newline newline
\end_inset

    ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

term: '(' expr ')'
\begin_inset Newline newline
\end_inset

    | IDENT '(' args ')' { gen_call(&vmcodep, func_addr($1), func_calladjust($1)
); }
\begin_inset Newline newline
\end_inset

    | IDENT              { gen_loadlocal(&vmcodep, var_offset($1)); }
\begin_inset Newline newline
\end_inset

    | NUM                { gen_lit(&vmcodep, $1); }
\begin_inset Newline newline
\end_inset

    ;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* missing: argument counting and checking against called function */
\begin_inset Newline newline
\end_inset

args: expr ',' args
\begin_inset Newline newline
\end_inset

    | expr
\begin_inset Newline newline
\end_inset

    | ;
\begin_inset Newline newline
\end_inset

%%
\begin_inset Newline newline
\end_inset

int yywrap(void)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  return 1;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include "lex.yy.c"
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
peephole-blacklist - list of instructions not allowed in superinstructions
\end_layout

\begin_layout Scrap
<<peephole-blacklist>>=
\begin_inset Newline newline
\end_inset

call
\begin_inset Newline newline
\end_inset

return
\begin_inset Newline newline
\end_inset

unknown
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
Generic support files
\end_layout

\begin_layout Standard
For your own interpreter, you would typically copy the following files and
 change little, if anything:
\end_layout

\begin_layout Subsubsection
peephole.c - wrapper file
\end_layout

\begin_layout Scrap
<<peephole.c>>=
\begin_inset Newline newline
\end_inset

/* Peephole optimization routines and tables
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include <stdlib.h>
\begin_inset Newline newline
\end_inset

#include "mini.h"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* the numbers in this struct are primitive indices */
\begin_inset Newline newline
\end_inset

typedef struct Combination {
\begin_inset Newline newline
\end_inset

  int prefix;
\begin_inset Newline newline
\end_inset

  int lastprim;
\begin_inset Newline newline
\end_inset

  int combination_prim;
\begin_inset Newline newline
\end_inset

} Combination;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Combination peephole_table[] = {
\begin_inset Newline newline
\end_inset

#include "mini-peephole.i"
\begin_inset Newline newline
\end_inset

#ifndef __GNUC__
\begin_inset Newline newline
\end_inset

  {-1,-1,-1} /* unnecessary; just to shut up lcc if the file is empty */
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

};
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

int use_super = 1; /* turned off by option -p */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

typedef struct Peeptable_entry {
\begin_inset Newline newline
\end_inset

  struct Peeptable_entry *next;
\begin_inset Newline newline
\end_inset

  Inst prefix;
\begin_inset Newline newline
\end_inset

  Inst lastprim;
\begin_inset Newline newline
\end_inset

  Inst combination_prim;
\begin_inset Newline newline
\end_inset

} Peeptable_entry;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#define HASH_SIZE 1024
\begin_inset Newline newline
\end_inset

#define hash(_i1,_i2) (((((Cell)(_i1))^((Cell)(_i2)))>>4)&(HASH_SIZE-1))
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Cell peeptable;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Cell prepare_peephole_table(Inst insts[])
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  Cell i;
\begin_inset Newline newline
\end_inset

  Peeptable_entry **pt = (Peeptable_entry **)calloc(HASH_SIZE,sizeof(Peeptable_e
ntry *));
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  for (i=0; i<sizeof(peephole_table)/sizeof(peephole_table[0]); i++) {
\begin_inset Newline newline
\end_inset

    Combination *c = &peephole_table[i];
\begin_inset Newline newline
\end_inset

    Peeptable_entry *p = (Peeptable_entry *)malloc(sizeof(Peeptable_entry));
\begin_inset Newline newline
\end_inset

    Cell h;
\begin_inset Newline newline
\end_inset

    p->prefix =           insts[c->prefix];
\begin_inset Newline newline
\end_inset

    p->lastprim =         insts[c->lastprim];
\begin_inset Newline newline
\end_inset

    p->combination_prim = insts[c->combination_prim];
\begin_inset Newline newline
\end_inset

    h = hash(p->prefix,p->lastprim);
\begin_inset Newline newline
\end_inset

    p->next = pt[h];
\begin_inset Newline newline
\end_inset

    pt[h] = p;
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

  return (Cell)pt;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void init_peeptable(void)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  peeptable = prepare_peephole_table(vm_prim);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Inst peephole_opt(Inst inst1, Inst inst2, Cell peeptable)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  Peeptable_entry **pt = (Peeptable_entry **)peeptable;
\begin_inset Newline newline
\end_inset

  Peeptable_entry *p;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  if (use_super == 0)
\begin_inset Newline newline
\end_inset

      return 0;
\begin_inset Newline newline
\end_inset

  for (p = pt[hash(inst1,inst2)]; p != NULL; p = p->next)
\begin_inset Newline newline
\end_inset

    if (inst1 == p->prefix && inst2 == p->lastprim)
\begin_inset Newline newline
\end_inset

      return p->combination_prim;
\begin_inset Newline newline
\end_inset

  return NULL;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Inst *last_compiled = NULL;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void gen_inst(Inst **vmcodepp, Inst i)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  if (last_compiled != NULL) {
\begin_inset Newline newline
\end_inset

    Inst combo = peephole_opt(*last_compiled, i, peeptable);
\begin_inset Newline newline
\end_inset

    if (combo != NULL) {
\begin_inset Newline newline
\end_inset

      *last_compiled = combo;
\begin_inset Newline newline
\end_inset

      return;
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

  last_compiled = *vmcodepp;
\begin_inset Newline newline
\end_inset

  **vmcodepp = i;
\begin_inset Newline newline
\end_inset

  (*vmcodepp)++;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
profile.c - wrapper file
\end_layout

\begin_layout Scrap
<<profile.c>>=
\begin_inset Newline newline
\end_inset

/* VM profiling support stuff
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include <stdlib.h>
\begin_inset Newline newline
\end_inset

#include <stdio.h>
\begin_inset Newline newline
\end_inset

#include <assert.h>
\begin_inset Newline newline
\end_inset

#include "mini.h"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* data structure: simple hash table with external chaining */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#define HASH_SIZE (1<<20)
\begin_inset Newline newline
\end_inset

#define hash(p) ((((Cell)(p))/sizeof(Inst))&(HASH_SIZE-1))
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#ifdef __GNUC__
\begin_inset Newline newline
\end_inset

typedef long long long_long;
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

typedef long long_long;
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

typedef struct block_count {
\begin_inset Newline newline
\end_inset

  struct block_count *next; /* next in hash table */
\begin_inset Newline newline
\end_inset

  struct block_count *fallthrough; /* the block that this one falls
\begin_inset Newline newline
\end_inset

                                       through to without SUPER_END */
\begin_inset Newline newline
\end_inset

  Inst *ip;
\begin_inset Newline newline
\end_inset

  long_long count;
\begin_inset Newline newline
\end_inset

  char **insts;
\begin_inset Newline newline
\end_inset

  size_t ninsts;
\begin_inset Newline newline
\end_inset

} block_count;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

block_count *blocks[HASH_SIZE];
\begin_inset Newline newline
\end_inset

Inst *vmcode_end;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

block_count *block_lookup(Inst *ip)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  block_count *b = blocks[hash(ip)];
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  while (b!=NULL && b->ip!=ip)
\begin_inset Newline newline
\end_inset

    b = b->next;
\begin_inset Newline newline
\end_inset

  return b;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* looks up present elements, inserts absent elements */
\begin_inset Newline newline
\end_inset

block_count *block_insert(Inst *ip)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  block_count *b = block_lookup(ip);
\begin_inset Newline newline
\end_inset

  block_count *new;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  if (b != NULL)
\begin_inset Newline newline
\end_inset

    return b;
\begin_inset Newline newline
\end_inset

  new = (block_count *)malloc(sizeof(block_count));
\begin_inset Newline newline
\end_inset

  new->next = blocks[hash(ip)];
\begin_inset Newline newline
\end_inset

  new->fallthrough = NULL;
\begin_inset Newline newline
\end_inset

  new->ip = ip;
\begin_inset Newline newline
\end_inset

  new->count = (long_long)0;
\begin_inset Newline newline
\end_inset

  new->insts = malloc(1);
\begin_inset Newline newline
\end_inset

  assert(new->insts != NULL);
\begin_inset Newline newline
\end_inset

  new->ninsts = 0;
\begin_inset Newline newline
\end_inset

  blocks[hash(ip)] = new;
\begin_inset Newline newline
\end_inset

  return new;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void add_inst(block_count *b, char *inst)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  b->insts = realloc(b->insts, (b->ninsts+1) * sizeof(char *));
\begin_inset Newline newline
\end_inset

  b->insts[b->ninsts++] = inst;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void vm_count_block(Inst *ip)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  block_insert(ip)->count++;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void postprocess_block(block_count *b)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  Inst *ip = b->ip;
\begin_inset Newline newline
\end_inset

  block_count *next_block=NULL;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  while (next_block == NULL && ip<vmcode_end) {
\begin_inset Newline newline
\end_inset

#include "mini-profile.i"
\begin_inset Newline newline
\end_inset

    /* else */
\begin_inset Newline newline
\end_inset

    {
\begin_inset Newline newline
\end_inset

      add_inst(b,"unknown");
\begin_inset Newline newline
\end_inset

      ip++;
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset

  _endif_:
\begin_inset Newline newline
\end_inset

    next_block = block_lookup(ip);
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

  /* we fell through, so set fallthrough and update the count */
\begin_inset Newline newline
\end_inset

  b->fallthrough = next_block;
\begin_inset Newline newline
\end_inset

  /* also update the counts of all following fallthrough blocks that
\begin_inset Newline newline
\end_inset

     have already been processed */
\begin_inset Newline newline
\end_inset

  while (next_block != NULL) {
\begin_inset Newline newline
\end_inset

    next_block->count += b->count;
\begin_inset Newline newline
\end_inset

    next_block = next_block->fallthrough;
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* Deal with block entry by falling through from non-SUPER_END
\begin_inset Newline newline
\end_inset

   instructions.
  And fill the insts and ninsts fields.
 */
\begin_inset Newline newline
\end_inset

void postprocess(void)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  size_t i;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  for (i=0; i<HASH_SIZE; i++) {
\begin_inset Newline newline
\end_inset

    block_count *b = blocks[i];
\begin_inset Newline newline
\end_inset

    for (; b!=0; b = b->next)
\begin_inset Newline newline
\end_inset

      postprocess_block(b);
\begin_inset Newline newline
\end_inset

   }
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#if 0
\begin_inset Newline newline
\end_inset

void print_block(FILE *file, block_count *b)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  size_t i;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  fprintf(file,"%14lld
\backslash
t",b->count);
\begin_inset Newline newline
\end_inset

  for (i=0; i<b->ninsts; i++)
\begin_inset Newline newline
\end_inset

    fprintf(file, "%s ", b->insts[i]);
\begin_inset Newline newline
\end_inset

  putc('
\backslash
n', file);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void print_block(FILE *file, block_count *b)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  size_t i,j,k;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  for (i=2; i<12; i++)
\begin_inset Newline newline
\end_inset

    for (j=0; i+j<=b->ninsts; j++) {
\begin_inset Newline newline
\end_inset

      fprintf(file,"%14lld
\backslash
t",b->count);
\begin_inset Newline newline
\end_inset

      for (k=j; k<i+j; k++)
\begin_inset Newline newline
\end_inset

        fprintf(file, "%s ", b->insts[k]);
\begin_inset Newline newline
\end_inset

      putc('
\backslash
n', file);
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void vm_print_profile(FILE *file)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  size_t i;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  postprocess();
\begin_inset Newline newline
\end_inset

  for (i=0; i<HASH_SIZE; i++) {
\begin_inset Newline newline
\end_inset

    block_count *b = blocks[i];
\begin_inset Newline newline
\end_inset

    for (; b!=0; b = b->next)
\begin_inset Newline newline
\end_inset

      print_block(file, b);
\begin_inset Newline newline
\end_inset

   }
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
disasm.c - wrapper file
\end_layout

\begin_layout Scrap
<<disasm.c>>=
\begin_inset Newline newline
\end_inset

/* vm disassembler wrapper
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include "mini.h"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#define IP (ip+1)
\begin_inset Newline newline
\end_inset

#define IPTOS IP[0]
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

void vm_disassemble(Inst *ip, Inst *endp, Inst vm_prim[])
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  while (ip<endp) {
\begin_inset Newline newline
\end_inset

    fprintf(vm_out,"%p: ",ip);
\begin_inset Newline newline
\end_inset

#include "mini-disasm.i"
\begin_inset Newline newline
\end_inset

    {
\begin_inset Newline newline
\end_inset

      fprintf(vm_out,"unknown instruction %p",ip[0]);
\begin_inset Newline newline
\end_inset

      ip++;
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset

  _endif_:
\begin_inset Newline newline
\end_inset

    fputc('
\backslash
n',vm_out);
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
engine.c - wrapper file
\begin_inset CommandInset label
LatexCommand label
name "sub:engine.c---wrapper"

\end_inset


\end_layout

\begin_layout Scrap
<<engine>>=
\begin_inset Newline newline
\end_inset

engine.o: engine.c mini-vm.i mini-labels.i mini.h
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

engine-debug.o: engine.c mini-vm.i mini-labels.i mini.h
\begin_inset Newline newline
\end_inset

	$(CC) -DVM_DEBUG -DVM_PROFILING -Dengine=engine_debug -c -o $@ engine.c
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<engine.c>>=
\begin_inset Newline newline
\end_inset

/* vm interpreter wrapper
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<copyright>>
\begin_inset Newline newline
\end_inset

*/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#include "mini.h"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<IF-spTOS>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<NAME>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<dispatch>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<LABEL2>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<SUPER-END>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#ifndef __GNUC__
\begin_inset Newline newline
\end_inset

enum {
\begin_inset Newline newline
\end_inset

#include "mini-labels.i"
\begin_inset Newline newline
\end_inset

};
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

<<MAYBE-UNUSED>>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

/* the return type can be anything you want it to */
\begin_inset Newline newline
\end_inset

Cell engine(Inst *ip0, Cell *sp, char *fp)
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  /* VM registers (you may want to use gcc's "Explicit Reg Vars" here) */
\begin_inset Newline newline
\end_inset

  Inst * ip;
\begin_inset Newline newline
\end_inset

  Inst * cfa;
\begin_inset Newline newline
\end_inset

<<spTOS>>
\begin_inset Newline newline
\end_inset

  static Label labels[] = {
\begin_inset Newline newline
\end_inset

#include "mini-labels.i"
\begin_inset Newline newline
\end_inset

  };
\begin_inset Newline newline
\end_inset

#ifdef MORE_VARS
\begin_inset Newline newline
\end_inset

  MORE_VARS
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  if (vm_debug)
\begin_inset Newline newline
\end_inset

      fprintf(vm_out,"entering engine(%p,%p,%p)
\backslash
n",ip0,sp,fp);
\begin_inset Newline newline
\end_inset

  if (ip0 == NULL) {
\begin_inset Newline newline
\end_inset

    vm_prim = labels;
\begin_inset Newline newline
\end_inset

    return 0;
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  /* I don't have a clue where these things come from,
\begin_inset Newline newline
\end_inset

     but I've put them in macros.h for the moment */
\begin_inset Newline newline
\end_inset

  IF_spTOS(spTOS = sp[0]);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  SET_IP(ip0);
\begin_inset Newline newline
\end_inset

  SUPER_END;  /* count the BB starting at ip0 */
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#ifdef __GNUC__
\begin_inset Newline newline
\end_inset

  NEXT;
\begin_inset Newline newline
\end_inset

#include "mini-vm.i"
\begin_inset Newline newline
\end_inset

#else
\begin_inset Newline newline
\end_inset

 next_inst:
\begin_inset Newline newline
\end_inset

  switch(*ip++) {
\begin_inset Newline newline
\end_inset

#include "mini-vm.i"
\begin_inset Newline newline
\end_inset

  default:
\begin_inset Newline newline
\end_inset

    fprintf(stderr,"unknown instruction %d at %p
\backslash
n", ip[-1], ip-1);
\begin_inset Newline newline
\end_inset

    exit(1);
\begin_inset Newline newline
\end_inset

  }
\begin_inset Newline newline
\end_inset

#endif
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
stat.awk - script for aggregating profile information
\end_layout

\begin_layout Scrap
<<stat.awk>>=
\begin_inset Newline newline
\end_inset

BEGIN {
\begin_inset Newline newline
\end_inset

  FS="
\backslash
t";
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  dyn[$2] += $1;
\begin_inset Newline newline
\end_inset

  stat[$2]++;
\begin_inset Newline newline
\end_inset

  files[$2] += (FILENAME!=filename[$2]);
\begin_inset Newline newline
\end_inset

  filename[$2] = FILENAME;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

END {
\begin_inset Newline newline
\end_inset

  for (i in dyn)
\begin_inset Newline newline
\end_inset

    printf("%7d
\backslash
t%7d
\backslash
t%15d
\backslash
t%s
\backslash
n",files[i],stat[i],dyn[i],i);
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsubsection
seq2rule.awk - script for creating superinstructions
\end_layout

\begin_layout Scrap
<<seq2rule.awk>>=
\begin_inset Newline newline
\end_inset

BEGIN {
\begin_inset Newline newline
\end_inset

  FS="
\backslash
t";
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

{
\begin_inset Newline newline
\end_inset

  name = $4;
\begin_inset Newline newline
\end_inset

  gsub(/ /,"_",name);
\begin_inset Newline newline
\end_inset

  print name" = "$4;
\begin_inset Newline newline
\end_inset

}
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Section
Printing and Extracting the code
\end_layout

\begin_layout Standard
A script for converting this document to PDF form follows:
\end_layout

\begin_layout Scrap
<<final>>=
\begin_inset Newline newline
\end_inset

lyx -e pdf $1
\begin_inset Newline newline
\end_inset

lyx -e latex $1
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Each of these scripts can be pulled out manually given the default * script
 defined below.
\end_layout

\begin_layout Scrap
<<*>>=
\begin_inset Newline newline
\end_inset

echo "Extract file $1 from afvm.lyx..."
\begin_inset Newline newline
\end_inset

rm -f afvm.nw
\begin_inset Newline newline
\end_inset

lyx -e literate afvm.lyx
\begin_inset Newline newline
\end_inset

notangle -t4 -R$2 afvm.nw > $1
\begin_inset Newline newline
\end_inset

dos2unix $1
\begin_inset Newline newline
\end_inset

chmod a+x $1
\begin_inset Newline newline
\end_inset

rm -f afvm.nw
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Standard
Once that script is pulled out and named extract, the following script can
 pull out all of the other scripts:
\end_layout

\begin_layout Scrap
<<extract-all>>=
\begin_inset Newline newline
\end_inset

echo "Extract all files..."
\begin_inset Newline newline
\end_inset

./extract README
\begin_inset Newline newline
\end_inset

./extract simple.mini
\begin_inset Newline newline
\end_inset

./extract fib.mini
\begin_inset Newline newline
\end_inset

./extract test.mini
\begin_inset Newline newline
\end_inset

./extract test.out
\begin_inset Newline newline
\end_inset

./extract Makefile
\begin_inset Newline newline
\end_inset

./extract support.c
\begin_inset Newline newline
\end_inset

./extract mini.h
\begin_inset Newline newline
\end_inset

./extract mini-inst.vmg
\begin_inset Newline newline
\end_inset

./extract mini-super.vmg
\begin_inset Newline newline
\end_inset

./extract mini.l
\begin_inset Newline newline
\end_inset

./extract mini.y
\begin_inset Newline newline
\end_inset

./extract peephole-blacklist
\begin_inset Newline newline
\end_inset

./extract peephole.c
\begin_inset Newline newline
\end_inset

./extract profile.c
\begin_inset Newline newline
\end_inset

./extract disasm.c
\begin_inset Newline newline
\end_inset

./extract engine.c
\begin_inset Newline newline
\end_inset

./extract stat.awk
\begin_inset Newline newline
\end_inset

./extract seq2rule.awk
\begin_inset Newline newline
\end_inset

./extract profile-fib-test
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Section
Copyrights
\end_layout

\begin_layout Standard
Although I would have preferred to use an MIT license, GForth uses a GNU
 license, so I must comply with that.
\end_layout

\begin_layout Scrap
<<copyright>>=
\begin_inset Newline newline
\end_inset

  Copyright (C) 2001,2002,2003,2007 Free Software Foundation, Inc.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  This file is part of Gforth.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  Gforth is free software; you can redistribute it and/or
\begin_inset Newline newline
\end_inset

  modify it under the terms of the GNU General Public License
\begin_inset Newline newline
\end_inset

  as published by the Free Software Foundation, either version 3
\begin_inset Newline newline
\end_inset

  of the License, or (at your option) any later version.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  This program is distributed in the hope that it will be useful,
\begin_inset Newline newline
\end_inset

  but WITHOUT ANY WARRANTY; without even the implied warranty of
\begin_inset Newline newline
\end_inset

  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the
\begin_inset Newline newline
\end_inset

  GNU General Public License for more details.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

  You should have received a copy of the GNU General Public License
\begin_inset Newline newline
\end_inset

  along with this program; if not, see http://www.gnu.org/licenses/.
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<
\backslash
copyright>>=
\begin_inset Newline newline
\end_inset


\backslash
 Copyright (C) 2001,2002,2003,2007 Free Software Foundation, Inc.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 This file is part of Gforth.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 Gforth is free software; you can redistribute it and/or
\begin_inset Newline newline
\end_inset


\backslash
 modify it under the terms of the GNU General Public License
\begin_inset Newline newline
\end_inset


\backslash
 as published by the Free Software Foundation, either version 3
\begin_inset Newline newline
\end_inset


\backslash
 of the License, or (at your option) any later version.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 This program is distributed in the hope that it will be useful,
\begin_inset Newline newline
\end_inset


\backslash
 but WITHOUT ANY WARRANTY; without even the implied warranty of
\begin_inset Newline newline
\end_inset


\backslash
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the
\begin_inset Newline newline
\end_inset


\backslash
 GNU General Public License for more details.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\backslash
 You should have received a copy of the GNU General Public License
\begin_inset Newline newline
\end_inset


\backslash
 along with this program.
 If not, see http://www.gnu.org/licenses/.
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<make-copyright>>=
\begin_inset Newline newline
\end_inset

#Copyright (C) 2001,2003,2007,2008 Free Software Foundation, Inc.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#This file is part of Gforth.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#Gforth is free software; you can redistribute it and/or
\begin_inset Newline newline
\end_inset

#modify it under the terms of the GNU General Public License
\begin_inset Newline newline
\end_inset

#as published by the Free Software Foundation, either version 3
\begin_inset Newline newline
\end_inset

#of the License, or (at your option) any later version.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#This program is distributed in the hope that it will be useful,
\begin_inset Newline newline
\end_inset

#but WITHOUT ANY WARRANTY; without even the implied warranty of
\begin_inset Newline newline
\end_inset

#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.#See the
\begin_inset Newline newline
\end_inset

#GNU General Public License for more details.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

#You should have received a copy of the GNU General Public License
\begin_inset Newline newline
\end_inset

#along with this program; if not, see http://www.gnu.org/licenses/.
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Subsection
GNU GENERAL PUBLIC LICENSE
\end_layout

\begin_layout Standard
Version 3, 29 June 2007
\end_layout

\begin_layout Standard
Copyright © 2007 Free Software Foundation, Inc.
 <
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://fsf.org/
\end_layout

\end_inset

>
\end_layout

\begin_layout Standard
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\begin_layout Subsubsection*
Preamble
\end_layout

\begin_layout Standard
The GNU General Public License is a free, copyleft license for software
 and other kinds of works.
\end_layout

\begin_layout Standard
The licenses for most software and other practical works are designed to
 take away your freedom to share and change the works.
 By contrast, the GNU General Public License is intended to guarantee your
 freedom to share and change all versions of a program--to make sure it
 remains free software for all its users.
 We, the Free Software Foundation, use the GNU General Public License for
 most of our software; it applies also to any other work released this way
 by its authors.
 You can apply it to your programs, too.
\end_layout

\begin_layout Standard
When we speak of free software, we are referring to freedom, not price.
 Our General Public Licenses are designed to make sure that you have the
 freedom to distribute copies of free software (and charge for them if you
 wish), that you receive source code or can get it if you want it, that
 you can change the software or use pieces of it in new free programs, and
 that you know you can do these things.
\end_layout

\begin_layout Standard
To protect your rights, we need to prevent others from denying you these
 rights or asking you to surrender the rights.
 Therefore, you have certain responsibilities if you distribute copies of
 the software, or if you modify it: responsibilities to respect the freedom
 of others.
\end_layout

\begin_layout Standard
For example, if you distribute copies of such a program, whether gratis
 or for a fee, you must pass on to the recipients the same freedoms that
 you received.
 You must make sure that they, too, receive or can get the source code.
 And you must show them these terms so they know their rights.
\end_layout

\begin_layout Standard
Developers that use the GNU GPL protect your rights with two steps: (1)
 assert copyright on the software, and (2) offer you this License giving
 you legal permission to copy, distribute and/or modify it.
\end_layout

\begin_layout Standard
For the developers' and authors' protection, the GPL clearly explains that
 there is no warranty for this free software.
 For both users' and authors' sake, the GPL requires that modified versions
 be marked as changed, so that their problems will not be attributed erroneously
 to authors of previous versions.
\end_layout

\begin_layout Standard
Some devices are designed to deny users access to install or run modified
 versions of the software inside them, although the manufacturer can do
 so.
 This is fundamentally incompatible with the aim of protecting users' freedom
 to change the software.
 The systematic pattern of such abuse occurs in the area of products for
 individuals to use, which is precisely where it is most unacceptable.
 Therefore, we have designed this version of the GPL to prohibit the practice
 for those products.
 If such problems arise substantially in other domains, we stand ready to
 extend this provision to those domains in future versions of the GPL, as
 needed to protect the freedom of users.
\end_layout

\begin_layout Standard
Finally, every program is threatened constantly by software patents.
 States should not allow patents to restrict development and use of software
 on general-purpose computers, but in those that do, we wish to avoid the
 special danger that patents applied to a free program could make it effectively
 proprietary.
 To prevent this, the GPL assures that patents cannot be used to render
 the program non-free.
\end_layout

\begin_layout Standard
The precise terms and conditions for copying, distribution and modification
 follow.
\end_layout

\begin_layout Subsubsection*
TERMS AND CONDITIONS
\end_layout

\begin_layout Subsubsection*
Definitions.
\end_layout

\begin_layout Standard
“This License” refers to version 3 of the GNU General Public License.
\end_layout

\begin_layout Standard
“Copyright” also means copyright-like laws that apply to other kinds of
 works, such as semiconductor masks.
\end_layout

\begin_layout Standard
“The Program” refers to any copyrightable work licensed under this License.
 Each licensee is addressed as “you”.
 “Licensees” and “recipients” may be individuals or organizations.
\end_layout

\begin_layout Standard
To “modify” a work means to copy from or adapt all or part of the work in
 a fashion requiring copyright permission, other than the making of an exact
 copy.
 The resulting work is called a “modified version” of the earlier work or
 a work “based on” the earlier work.
\end_layout

\begin_layout Standard
A “covered work” means either the unmodified Program or a work based on
 the Program.
\end_layout

\begin_layout Standard
To “propagate” a work means to do anything with it that, without permission,
 would make you directly or secondarily liable for infringement under applicable
 copyright law, except executing it on a computer or modifying a private
 copy.
 Propagation includes copying, distribution (with or without modification),
 making available to the public, and in some countries other activities
 as well.
\end_layout

\begin_layout Standard
To “convey” a work means any kind of propagation that enables other parties
 to make or receive copies.
 Mere interaction with a user through a computer network, with no transfer
 of a copy, is not conveying.
\end_layout

\begin_layout Standard
An interactive user interface displays “Appropriate Legal Notices” to the
 extent that it includes a convenient and prominently visible feature that
 (1) displays an appropriate copyright notice, and (2) tells the user that
 there is no warranty for the work (except to the extent that warranties
 are provided), that licensees may convey the work under this License, and
 how to view a copy of this License.
 If the interface presents a list of user commands or options, such as a
 menu, a prominent item in the list meets this criterion.
\end_layout

\begin_layout Subsubsection
Source Code.
\end_layout

\begin_layout Standard
The “source code” for a work means the preferred form of the work for making
 modifications to it.
 “Object code” means any non-source form of a work.
\end_layout

\begin_layout Standard
A “Standard Interface” means an interface that either is an official standard
 defined by a recognized standards body, or, in the case of interfaces specified
 for a particular programming language, one that is widely used among developers
 working in that language.
\end_layout

\begin_layout Standard
The “System Libraries” of an executable work include anything, other than
 the work as a whole, that (a) is included in the normal form of packaging
 a Major Component, but which is not part of that Major Component, and (b)
 serves only to enable use of the work with that Major Component, or to
 implement a Standard Interface for which an implementation is available
 to the public in source code form.
 A “Major Component”, in this context, means a major essential component
 (kernel, window system, and so on) of the specific operating system (if
 any) on which the executable work runs, or a compiler used to produce the
 work, or an object code interpreter used to run it.
\end_layout

\begin_layout Standard
The “Corresponding Source” for a work in object code form means all the
 source code needed to generate, install, and (for an executable work) run
 the object code and to modify the work, including scripts to control those
 activities.
 However, it does not include the work's System Libraries, or general-purpose
 tools or generally available free programs which are used unmodified in
 performing those activities but which are not part of the work.
 For example, Corresponding Source includes interface definition files associate
d with source files for the work, and the source code for shared libraries
 and dynamically linked subprograms that the work is specifically designed
 to require, such as by intimate data communication or control flow between
 those subprograms and other parts of the work.
\end_layout

\begin_layout Standard
The Corresponding Source need not include anything that users can regenerate
 automatically from other parts of the Corresponding Source.
\end_layout

\begin_layout Standard
The Corresponding Source for a work in source code form is that same work.
\end_layout

\begin_layout Subsubsection
Basic Permissions.
\begin_inset CommandInset label
LatexCommand label
name "sub:Basic-Permissions."

\end_inset


\end_layout

\begin_layout Standard
All rights granted under this License are granted for the term of copyright
 on the Program, and are irrevocable provided the stated conditions are
 met.
 This License explicitly affirms your unlimited permission to run the unmodified
 Program.
 The output from running a covered work is covered by this License only
 if the output, given its content, constitutes a covered work.
 This License acknowledges your rights of fair use or other equivalent,
 as provided by copyright law.
\end_layout

\begin_layout Standard
You may make, run and propagate covered works that you do not convey, without
 conditions so long as your license otherwise remains in force.
 You may convey covered works to others for the sole purpose of having them
 make modifications exclusively for you, or provide you with facilities
 for running those works, provided that you comply with the terms of this
 License in conveying all material for which you do not control copyright.
 Those thus making or running the covered works for you must do so exclusively
 on your behalf, under your direction and control, on terms that prohibit
 them from making any copies of your copyrighted material outside their
 relationship with you.
\end_layout

\begin_layout Standard
Conveying under any other circumstances is permitted solely under the conditions
 stated below.
 Sublicensing is not allowed; 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Non-Source-Forms."

\end_inset

 makes it unnecessary.
\end_layout

\begin_layout Subsubsection
Protecting Users' Legal Rights From Anti-Circumvention Law.
\begin_inset CommandInset label
LatexCommand label
name "sub:Protecting-Users'-Legal"

\end_inset


\end_layout

\begin_layout Standard
No covered work shall be deemed part of an effective technological measure
 under any applicable law fulfilling obligations under article 11 of the
 WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting
 or restricting circumvention of such measures.
\end_layout

\begin_layout Standard
When you convey a covered work, you waive any legal power to forbid circumventio
n of technological measures to the extent such circumvention is effected
 by exercising rights under this License with respect to the covered work,
 and you disclaim any intention to limit operation or modification of the
 work as a means of enforcing, against the work's users, your or third parties'
 legal rights to forbid circumvention of technological measures.
\end_layout

\begin_layout Subsubsection
Conveying Verbatim Copies.
\begin_inset CommandInset label
LatexCommand label
name "sub:Conveying-Verbatim-Copies."

\end_inset


\end_layout

\begin_layout Standard
You may convey verbatim copies of the Program's source code as you receive
 it, in any medium, provided that you conspicuously and appropriately publish
 on each copy an appropriate copyright notice; keep intact all notices stating
 that this License and any non-permissive terms added in accord with 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Modified-Source"

\end_inset

 apply to the code; keep intact all notices of the absence of any warranty;
 and give all recipients a copy of this License along with the Program.
\end_layout

\begin_layout Standard
You may charge any price or no price for each copy that you convey, and
 you may offer support or warranty protection for a fee.
\end_layout

\begin_layout Subsubsection
Conveying Modified Source Versions.
\begin_inset CommandInset label
LatexCommand label
name "sub:Conveying-Modified-Source"

\end_inset


\end_layout

\begin_layout Standard
You may convey a work based on the Program, or the modifications to produce
 it from the Program, in the form of source code under the terms of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Verbatim-Copies."

\end_inset

, provided that you also meet all of these conditions:
\end_layout

\begin_layout Itemize
a) The work must carry prominent notices stating that you modified it, and
 giving a relevant date.
\end_layout

\begin_layout Itemize
b) The work must carry prominent notices stating that it is released under
 this License and any conditions added under 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Acceptance-Not-Required"

\end_inset

.
 This requirement modifies the requirement in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Verbatim-Copies."

\end_inset

 to “keep intact all notices”.
\end_layout

\begin_layout Itemize
c) You must license the entire work, as a whole, under this License to anyone
 who comes into possession of a copy.
 This License will therefore apply, along with any applicable 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Acceptance-Not-Required"

\end_inset

 additional terms, to the whole of the work, and all its parts, regardless
 of how they are packaged.
 This License gives no permission to license the work in any other way,
 but it does not invalidate such permission if you have separately received
 it.
\end_layout

\begin_layout Itemize
d) If the work has interactive user interfaces, each must display Appropriate
 Legal Notices; however, if the Program has interactive interfaces that
 do not display Appropriate Legal Notices, your work need not make them
 do so.
 A compilation of a covered work with other separate and independent works,
 which are not by their nature extensions of the covered work, and which
 are not combined with it such as to form a larger program, in or on a volume
 of a storage or distribution medium, is called an “aggregate” if the compilatio
n and its resulting copyright are not used to limit the access or legal
 rights of the compilation's users beyond what the individual works permit.
 Inclusion of a covered work in an aggregate does not cause this License
 to apply to the other parts of the aggregate.
\end_layout

\begin_layout Subsubsection
Conveying Non-Source Forms.
\begin_inset CommandInset label
LatexCommand label
name "sub:Conveying-Non-Source-Forms."

\end_inset


\end_layout

\begin_layout Standard
You may convey a covered work in object code form under the terms of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Verbatim-Copies."

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Modified-Source"

\end_inset

, provided that you also convey the machine-readable Corresponding Source
 under the terms of this License, in one of these ways:
\end_layout

\begin_layout Itemize
a) Convey the object code in, or embodied in, a physical product (including
 a physical distribution medium), accompanied by the Corresponding Source
 fixed on a durable physical medium customarily used for software interchange.
\end_layout

\begin_layout Itemize
b) Convey the object code in, or embodied in, a physical product (including
 a physical distribution medium), accompanied by a written offer, valid
 for at least three years and valid for as long as you offer spare parts
 or customer support for that product model, to give anyone who possesses
 the object code either (1) a copy of the Corresponding Source for all the
 software in the product that is covered by this License, on a durable physical
 medium customarily used for software interchange, for a price no more than
 your reasonable cost of physically performing this conveying of source,
 or (2) access to copy the Corresponding Source from a network server at
 no charge.
\end_layout

\begin_layout Itemize
c) Convey individual copies of the object code with a copy of the written
 offer to provide the Corresponding Source.
 This alternative is allowed only occasionally and noncommercially, and
 only if you received the object code with such an offer, in accord with
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Non-Source-Forms."

\end_inset

 subsection b.
\end_layout

\begin_layout Itemize
d) Convey the object code by offering access from a designated place (gratis
 or for a charge), and offer equivalent access to the Corresponding Source
 in the same way through the same place at no further charge.
 You need not require recipients to copy the Corresponding Source along
 with the object code.
 If the place to copy the object code is a network server, the Corresponding
 Source may be on a different server (operated by you or a third party)
 that supports equivalent copying facilities, provided you maintain clear
 directions next to the object code saying where to find the Corresponding
 Source.
 Regardless of what server hosts the Corresponding Source, you remain obligated
 to ensure that it is available for as long as needed to satisfy these requireme
nts.
\end_layout

\begin_layout Itemize
e) Convey the object code using peer-to-peer transmission, provided you
 inform other peers where the object code and Corresponding Source of the
 work are being offered to the general public at no charge under 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Conveying-Non-Source-Forms."

\end_inset

 subsection d.
 A separable portion of the object code, whose source code is excluded from
 the Corresponding Source as a System Library, need not be included in conveying
 the object code work.
\end_layout

\begin_layout Standard
A “User Product” is either (1) a “consumer product”, which means any tangible
 personal property which is normally used for personal, family, or household
 purposes, or (2) anything designed or sold for incorporation into a dwelling.
 In determining whether a product is a consumer product, doubtful cases
 shall be resolved in favor of coverage.
 For a particular product received by a particular user, “normally used”
 refers to a typical or common use of that class of product, regardless
 of the status of the particular user or of the way in which the particular
 user actually uses, or expects or is expected to use, the product.
 A product is a consumer product regardless of whether the product has substanti
al commercial, industrial or non-consumer uses, unless such uses represent
 the only significant mode of use of the product.
\end_layout

\begin_layout Standard
“Installation Information” for a User Product means any methods, procedures,
 authorization keys, or other information required to install and execute
 modified versions of a covered work in that User Product from a modified
 version of its Corresponding Source.
 The information must suffice to ensure that the continued functioning of
 the modified object code is in no case prevented or interfered with solely
 because modification has been made.
\end_layout

\begin_layout Standard
If you convey an object code work under this section in, or with, or specificall
y for use in, a User Product, and the conveying occurs as part of a transaction
 in which the right of possession and use of the User Product is transferred
 to the recipient in perpetuity or for a fixed term (regardless of how the
 transaction is characterized), the Corresponding Source conveyed under
 this section must be accompanied by the Installation Information.
 But this requirement does not apply if neither you nor any third party
 retains the ability to install modified object code on the User Product
 (for example, the work has been installed in ROM).
\end_layout

\begin_layout Standard
The requirement to provide Installation Information does not include a requireme
nt to continue to provide support service, warranty, or updates for a work
 that has been modified or installed by the recipient, or for the User Product
 in which it has been modified or installed.
 Access to a network may be denied when the modification itself materially
 and adversely affects the operation of the network or violates the rules
 and protocols for communication across the network.
\end_layout

\begin_layout Standard
Corresponding Source conveyed, and Installation Information provided, in
 accord with this section must be in a format that is publicly documented
 (and with an implementation available to the public in source code form),
 and must require no special password or key for unpacking, reading or copying.
\end_layout

\begin_layout Subsubsection
Additional Terms.
\end_layout

\begin_layout Standard
“Additional permissions” are terms that supplement the terms of this License
 by making exceptions from one or more of its conditions.
 Additional permissions that are applicable to the entire Program shall
 be treated as though they were included in this License, to the extent
 that they are valid under applicable law.
 If additional permissions apply only to part of the Program, that part
 may be used separately under those permissions, but the entire Program
 remains governed by this License without regard to the additional permissions.
\end_layout

\begin_layout Standard
When you convey a copy of a covered work, you may at your option remove
 any additional permissions from that copy, or from any part of it.
 (Additional permissions may be written to require their own removal in
 certain cases when you modify the work.) You may place additional permissions
 on material, added by you to a covered work, for which you have or can
 give appropriate copyright permission.
\end_layout

\begin_layout Standard
Notwithstanding any other provision of this License, for material you add
 to a covered work, you may (if authorized by the copyright holders of that
 material) supplement the terms of this License with terms:
\end_layout

\begin_layout Itemize
a) Disclaiming warranty or limiting liability differently from the terms
 of sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Disclaimer-of-Warranty."

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Limitation-of-Liability."

\end_inset

 of this License; or
\end_layout

\begin_layout Itemize
b) Requiring preservation of specified reasonable legal notices or author
 attributions in that material or in the Appropriate Legal Notices displayed
 by works containing it; or
\end_layout

\begin_layout Itemize
c) Prohibiting misrepresentation of the origin of that material, or requiring
 that modified versions of such material be marked in reasonable ways as
 different from the original version; or
\end_layout

\begin_layout Itemize
d) Limiting the use for publicity purposes of names of licensors or authors
 of the material; or
\end_layout

\begin_layout Itemize
e) Declining to grant rights under trademark law for use of some trade names,
 trademarks, or service marks; or
\end_layout

\begin_layout Itemize
f) Requiring indemnification of licensors and authors of that material by
 anyone who conveys the material (or modified versions of it) with contractual
 assumptions of liability to the recipient, for any liability that these
 contractual assumptions directly impose on those licensors and authors.
\end_layout

\begin_layout Standard
All other non-permissive additional terms are considered “further restrictions”
 within the meaning of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Automatic-Licensing-of"

\end_inset

.
 If the Program as you received it, or any part of it, contains a notice
 stating that it is governed by this License along with a term that is a
 further restriction, you may remove that term.
 If a license document contains a further restriction but permits relicensing
 or conveying under this License, you may add to a covered work material
 governed by the terms of that license document, provided that the further
 restriction does not survive such relicensing or conveying.
\end_layout

\begin_layout Standard
If you add terms to a covered work in accord with this section, you must
 place, in the relevant source files, a statement of the additional terms
 that apply to those files, or a notice indicating where to find the applicable
 terms.
\end_layout

\begin_layout Standard
Additional terms, permissive or non-permissive, may be stated in the form
 of a separately written license, or stated as exceptions; the above requirement
s apply either way.
\end_layout

\begin_layout Subsubsection
Termination.
\end_layout

\begin_layout Standard
You may not propagate or modify a covered work except as expressly provided
 under this License.
 Any attempt otherwise to propagate or modify it is void, and will automatically
 terminate your rights under this License (including any patent licenses
 granted under the third paragraph of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:No-Surrender-of"

\end_inset

).
\end_layout

\begin_layout Standard
However, if you cease all violation of this License, then your license from
 a particular copyright holder is reinstated (a) provisionally, unless and
 until the copyright holder explicitly and finally terminates your license,
 and (b) permanently, if the copyright holder fails to notify you of the
 violation by some reasonable means prior to 60 days after the cessation.
\end_layout

\begin_layout Standard
Moreover, your license from a particular copyright holder is reinstated
 permanently if the copyright holder notifies you of the violation by some
 reasonable means, this is the first time you have received notice of violation
 of this License (for any work) from that copyright holder, and you cure
 the violation prior to 30 days after your receipt of the notice.
\end_layout

\begin_layout Standard
Termination of your rights under this section does not terminate the licenses
 of parties who have received copies or rights from you under this License.
 If your rights have been terminated and not permanently reinstated, you
 do not qualify to receive new licenses for the same material under 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Automatic-Licensing-of"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Acceptance Not Required for Having Copies.
\begin_inset CommandInset label
LatexCommand label
name "sub:Acceptance-Not-Required"

\end_inset


\end_layout

\begin_layout Standard
You are not required to accept this License in order to receive or run a
 copy of the Program.
 Ancillary propagation of a covered work occurring solely as a consequence
 of using peer-to-peer transmission to receive a copy likewise does not
 require acceptance.
 However, nothing other than this License grants you permission to propagate
 or modify any covered work.
 These actions infringe copyright if you do not accept this License.
 Therefore, by modifying or propagating a covered work, you indicate your
 acceptance of this License to do so.
\end_layout

\begin_layout Subsubsection
Automatic Licensing of Downstream Recipients.
\begin_inset CommandInset label
LatexCommand label
name "sub:Automatic-Licensing-of"

\end_inset


\end_layout

\begin_layout Standard
Each time you convey a covered work, the recipient automatically receives
 a license from the original licensors, to run, modify and propagate that
 work, subject to this License.
 You are not responsible for enforcing compliance by third parties with
 this License.
\end_layout

\begin_layout Standard
An “entity transaction” is a transaction transferring control of an organization
, or substantially all assets of one, or subdividing an organization, or
 merging organizations.
 If propagation of a covered work results from an entity transaction, each
 party to that transaction who receives a copy of the work also receives
 whatever licenses to the work the party's predecessor in interest had or
 could give under the previous paragraph, plus a right to possession of
 the Corresponding Source of the work from the predecessor in interest,
 if the predecessor has it or can get it with reasonable efforts.
\end_layout

\begin_layout Standard
You may not impose any further restrictions on the exercise of the rights
 granted or affirmed under this License.
 For example, you may not impose a license fee, royalty, or other charge
 for exercise of rights granted under this License, and you may not initiate
 litigation (including a cross-claim or counterclaim in a lawsuit) alleging
 that any patent claim is infringed by making, using, selling, offering
 for sale, or importing the Program or any portion of it.
\end_layout

\begin_layout Subsubsection
Patents.
\end_layout

\begin_layout Standard
A “contributor” is a copyright holder who authorizes use under this License
 of the Program or a work on which the Program is based.
 The work thus licensed is called the contributor's “contributor version”.
\end_layout

\begin_layout Standard
A contributor's “essential patent claims” are all patent claims owned or
 controlled by the contributor, whether already acquired or hereafter acquired,
 that would be infringed by some manner, permitted by this License, of making,
 using, or selling its contributor version, but do not include claims that
 would be infringed only as a consequence of further modification of the
 contributor version.
 For purposes of this definition, “control” includes the right to grant
 patent sublicenses in a manner consistent with the requirements of this
 License.
\end_layout

\begin_layout Standard
Each contributor grants you a non-exclusive, worldwide, royalty-free patent
 license under the contributor's essential patent claims, to make, use,
 sell, offer for sale, import and otherwise run, modify and propagate the
 contents of its contributor version.
\end_layout

\begin_layout Standard
In the following three paragraphs, a “patent license” is any express agreement
 or commitment, however denominated, not to enforce a patent (such as an
 express permission to practice a patent or covenant not to sue for patent
 infringement).
 To “grant” such a patent license to a party means to make such an agreement
 or commitment not to enforce a patent against the party.
\end_layout

\begin_layout Standard
If you convey a covered work, knowingly relying on a patent license, and
 the Corresponding Source of the work is not available for anyone to copy,
 free of charge and under the terms of this License, through a publicly
 available network server or other readily accessible means, then you must
 either (1) cause the Corresponding Source to be so available, or (2) arrange
 to deprive yourself of the benefit of the patent license for this particular
 work, or (3) arrange, in a manner consistent with the requirements of this
 License, to extend the patent license to downstream recipients.
 “Knowingly relying” means you have actual knowledge that, but for the patent
 license, your conveying the covered work in a country, or your recipient's
 use of the covered work in a country, would infringe one or more identifiable
 patents in that country that you have reason to believe are valid.
\end_layout

\begin_layout Standard
If, pursuant to or in connection with a single transaction or arrangement,
 you convey, or propagate by procuring conveyance of, a covered work, and
 grant a patent license to some of the parties receiving the covered work
 authorizing them to use, propagate, modify or convey a specific copy of
 the covered work, then the patent license you grant is automatically extended
 to all recipients of the covered work and works based on it.
\end_layout

\begin_layout Standard
A patent license is “discriminatory” if it does not include within the scope
 of its coverage, prohibits the exercise of, or is conditioned on the non-exerci
se of one or more of the rights that are specifically granted under this
 License.
 You may not convey a covered work if you are a party to an arrangement
 with a third party that is in the business of distributing software, under
 which you make payment to the third party based on the extent of your activity
 of conveying the work, and under which the third party grants, to any of
 the parties who would receive the covered work from you, a discriminatory
 patent license (a) in connection with copies of the covered work conveyed
 by you (or copies made from those copies), or (b) primarily for and in
 connection with specific products or compilations that contain the covered
 work, unless you entered into that arrangement, or that patent license
 was granted, prior to 28 March 2007.
\end_layout

\begin_layout Standard
Nothing in this License shall be construed as excluding or limiting any
 implied license or other defenses to infringement that may otherwise be
 available to you under applicable patent law.
\end_layout

\begin_layout Subsubsection
No Surrender of Others' Freedom.
\begin_inset CommandInset label
LatexCommand label
name "sub:No-Surrender-of"

\end_inset


\end_layout

\begin_layout Standard
If conditions are imposed on you (whether by court order, agreement or otherwise
) that contradict the conditions of this License, they do not excuse you
 from the conditions of this License.
 If you cannot convey a covered work so as to satisfy simultaneously your
 obligations under this License and any other pertinent obligations, then
 as a consequence you may not convey it at all.
 For example, if you agree to terms that obligate you to collect a royalty
 for further conveying from those to whom you convey the Program, the only
 way you could satisfy both those terms and this License would be to refrain
 entirely from conveying the Program.
\end_layout

\begin_layout Subsubsection
Use with the GNU Affero General Public License.
\end_layout

\begin_layout Standard
Notwithstanding any other provision of this License, you have permission
 to link or combine any covered work with a work licensed under version
 3 of the GNU Affero General Public License into a single combined work,
 and to convey the resulting work.
 The terms of this License will continue to apply to the part which is the
 covered work, but the special requirements of the GNU Affero General Public
 License, 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:No-Surrender-of"

\end_inset

, concerning interaction through a network will apply to the combination
 as such.
\end_layout

\begin_layout Subsubsection
Revised Versions of this License.
\begin_inset CommandInset label
LatexCommand label
name "sub:Revised-Versions-of"

\end_inset


\end_layout

\begin_layout Standard
The Free Software Foundation may publish revised and/or new versions of
 the GNU General Public License from time to time.
 Such new versions will be similar in spirit to the present version, but
 may differ in detail to address new problems or concerns.
\end_layout

\begin_layout Standard
Each version is given a distinguishing version number.
 If the Program specifies that a certain numbered version of the GNU General
 Public License “or any later version” applies to it, you have the option
 of following the terms and conditions either of that numbered version or
 of any later version published by the Free Software Foundation.
 If the Program does not specify a version number of the GNU General Public
 License, you may choose any version ever published by the Free Software
 Foundation.
\end_layout

\begin_layout Standard
If the Program specifies that a proxy can decide which future versions of
 the GNU General Public License can be used, that proxy's public statement
 of acceptance of a version permanently authorizes you to choose that version
 for the Program.
\end_layout

\begin_layout Standard
Later license versions may give you additional or different permissions.
 However, no additional obligations are imposed on any author or copyright
 holder as a result of your choosing to follow a later version.
\end_layout

\begin_layout Subsubsection
Disclaimer of Warranty.
\begin_inset CommandInset label
LatexCommand label
name "sub:Disclaimer-of-Warranty."

\end_inset


\end_layout

\begin_layout Standard
THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
 LAW.
 EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
 PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER
 EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
 YOU.
 SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
 SERVICING, REPAIR OR CORRECTION.
\end_layout

\begin_layout Subsubsection
Limitation of Liability.
\begin_inset CommandInset label
LatexCommand label
name "sub:Limitation-of-Liability."

\end_inset


\end_layout

\begin_layout Standard
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
 ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE
 PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
 USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS
 OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
 THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
 EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY
 OF SUCH DAMAGES.
\end_layout

\begin_layout Subsubsection
Interpretation of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Disclaimer-of-Warranty."

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Limitation-of-Liability."

\end_inset

.
\end_layout

\begin_layout Standard
If the disclaimer of warranty and limitation of liability provided above
 cannot be given local legal effect according to their terms, reviewing
 courts shall apply local law that most closely approximates an absolute
 waiver of all civil liability in connection with the Program, unless a
 warranty or assumption of liability accompanies a copy of the Program in
 return for a fee.
\end_layout

\begin_layout Subsubsection*
END OF TERMS AND CONDITIONS
\end_layout

\begin_layout Standard
How to Apply These Terms to Your New Programs
\end_layout

\begin_layout Standard
If you develop a new program, and you want it to be of the greatest possible
 use to the public, the best way to achieve this is to make it free software
 which everyone can redistribute and change under these terms.
\end_layout

\begin_layout Standard
To do so, attach the following notices to the program.
 It is safest to attach them to the start of each source file to most effectivel
y state the exclusion of warranty; and each file should have at least the
 “copyright” line and a pointer to where the full notice is found.
\end_layout

\begin_layout Quote

\family typewriter
<one line to give the program's name and a brief idea of what it does.>
\begin_inset Newline newline
\end_inset

Copyright (C) <year> <name of author>
\end_layout

\begin_layout Quote

\family typewriter
This program is free software: you can redistribute it and/or modify
\begin_inset Newline newline
\end_inset

it under the terms of the GNU General Public License as published by
\begin_inset Newline newline
\end_inset

the Free Software Foundation, either version 3 of the License, or
\begin_inset Newline newline
\end_inset

(at your option) any later version.
\end_layout

\begin_layout Quote

\family typewriter
This program is distributed in the hope that it will be useful,
\begin_inset Newline newline
\end_inset

but WITHOUT ANY WARRANTY; without even the implied warranty of
\begin_inset Newline newline
\end_inset

MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the
\begin_inset Newline newline
\end_inset

GNU General Public License for more details.
\end_layout

\begin_layout Quote

\family typewriter
You should have received a copy of the GNU General Public License
\begin_inset Newline newline
\end_inset

along with this program.
 If not, see <http://www.gnu.org/licenses/>.
\end_layout

\begin_layout Standard
Also add information on how to contact you by electronic and paper mail.
\end_layout

\begin_layout Standard
If the program does terminal interaction, make it output a short notice
 like this when it starts in an interactive mode:
\end_layout

\begin_layout Quote

\family typewriter
<program> Copyright (C) <year> <name of author>
\begin_inset Newline newline
\end_inset

This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
\begin_inset Newline newline
\end_inset

This is free software, and you are welcome to redistribute it
\begin_inset Newline newline
\end_inset

under certain conditions; type `show c' for details.
\end_layout

\begin_layout Standard
The hypothetical commands `show w' and `show c' should show the appropriate
 parts of the General Public License.
 Of course, your program's commands might be different; for a GUI interface,
 you would use an “about box”.
\end_layout

\begin_layout Standard
You should also get your employer (if you work as a programmer) or school,
 if any, to sign a “copyright disclaimer” for the program, if necessary.
 For more information on this, and how to apply and follow the GNU GPL,
 see <
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.gnu.org/licenses/
\end_layout

\end_inset

>.
\end_layout

\begin_layout Standard
The GNU General Public License does not permit incorporating your program
 into proprietary programs.
 If your program is a subroutine library, you may consider it more useful
 to permit linking proprietary applications with the library.
 If this is what you want to do, use the GNU Lesser General Public License
 instead of this License.
 But first, please read <
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.gnu.org/philosophy/why-not-lgpl.html
\end_layout

\end_inset

>.
\end_layout

\begin_layout Subsection
GNU Free Documentation License
\begin_inset CommandInset label
LatexCommand label
name "sub:GNU-Free-Documentation"

\end_inset


\end_layout

\begin_layout Standard
Version 1.3, 3 November 2008
\end_layout

\begin_layout Standard
Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
 <
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://fsf.org/
\end_layout

\end_inset

>
\end_layout

\begin_layout Standard
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\begin_layout Subsubsection*
PREAMBLE
\end_layout

\begin_layout Standard
The purpose of this License is to make a manual, textbook, or other functional
 and useful document "free" in the sense of freedom: to assure everyone
 the effective freedom to copy and redistribute it, with or without modifying
 it, either commercially or noncommercially.
 Secondarily, this License preserves for the author and publisher a way
 to get credit for their work, while not being considered responsible for
 modifications made by others.
\end_layout

\begin_layout Standard
This License is a kind of "copyleft", which means that derivative works
 of the document must themselves be free in the same sense.
 It complements the GNU General Public License, which is a copyleft license
 designed for free software.
\end_layout

\begin_layout Standard
We have designed this License in order to use it for manuals for free software,
 because free software needs free documentation: a free program should come
 with manuals providing the same freedoms that the software does.
 But this License is not limited to software manuals; it can be used for
 any textual work, regardless of subject matter or whether it is published
 as a printed book.
 We recommend this License principally for works whose purpose is instruction
 or reference.
\end_layout

\begin_layout Subsubsection
APPLICABILITY AND DEFINITIONS
\begin_inset CommandInset label
LatexCommand label
name "sub:APPLICABILITY-AND-DEFINITIONS"

\end_inset


\end_layout

\begin_layout Standard
This License applies to any manual or other work, in any medium, that contains
 a notice placed by the copyright holder saying it can be distributed under
 the terms of this License.
 Such a notice grants a world-wide, royalty-free license, unlimited in duration,
 to use that work under the conditions stated herein.
 The "Document", below, refers to any such manual or work.
 Any member of the public is a licensee, and is addressed as "you".
 You accept the license if you copy, modify or distribute the work in a
 way requiring permission under copyright law.
\end_layout

\begin_layout Standard
A "Modified Version" of the Document means any work containing the Document
 or a portion of it, either copied verbatim, or with modifications and/or
 translated into another language.
\end_layout

\begin_layout Standard
A "Secondary Section" is a named appendix or a front-matter section of the
 Document that deals exclusively with the relationship of the publishers
 or authors of the Document to the Document's overall subject (or to related
 matters) and contains nothing that could fall directly within that overall
 subject.
 (Thus, if the Document is in part a textbook of mathematics, a Secondary
 Section may not explain any mathematics.) The relationship could be a matter
 of historical connection with the subject or with related matters, or of
 legal, commercial, philosophical, ethical or political position regarding
 them.
\end_layout

\begin_layout Standard
The "Invariant Sections" are certain Secondary Sections whose titles are
 designated, as being those of Invariant Sections, in the notice that says
 that the Document is released under this License.
 If a section does not fit the above definition of Secondary then it is
 not allowed to be designated as Invariant.
 The Document may contain zero Invariant Sections.
 If the Document does not identify any Invariant Sections then there are
 none.
\end_layout

\begin_layout Standard
The "Cover Texts" are certain short passages of text that are listed, as
 Front-Cover Texts or Back-Cover Texts, in the notice that says that the
 Document is released under this License.
 A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be
 at most 25 words.
\end_layout

\begin_layout Standard
A "Transparent" copy of the Document means a machine-readable copy, represented
 in a format whose specification is available to the general public, that
 is suitable for revising the document straightforwardly with generic text
 editors or (for images composed of pixels) generic paint programs or (for
 drawings) some widely available drawing editor, and that is suitable for
 input to text formatters or for automatic translation to a variety of formats
 suitable for input to text formatters.
 A copy made in an otherwise Transparent file format whose markup, or absence
 of markup, has been arranged to thwart or discourage subsequent modification
 by readers is not Transparent.
 An image format is not Transparent if used for any substantial amount of
 text.
 A copy that is not "Transparent" is called "Opaque".
\end_layout

\begin_layout Standard
Examples of suitable formats for Transparent copies include plain ASCII
 without markup, Texinfo input format, LaTeX input format, SGML or XML using
 a publicly available DTD, and standard-conforming simple HTML, PostScript
 or PDF designed for human modification.
 Examples of transparent image formats include PNG, XCF and JPG.
 Opaque formats include proprietary formats that can be read and edited
 only by proprietary word processors, SGML or XML for which the DTD and/or
 processing tools are not generally available, and the machine-generated
 HTML, PostScript or PDF produced by some word processors for output purposes
 only.
\end_layout

\begin_layout Standard
The "Title Page" means, for a printed book, the title page itself, plus
 such following pages as are needed to hold, legibly, the material this
 License requires to appear in the title page.
 For works in formats which do not have any title page as such, "Title Page"
 means the text near the most prominent appearance of the work's title,
 preceding the beginning of the body of the text.
\end_layout

\begin_layout Standard
The "publisher" means any person or entity that distributes copies of the
 Document to the public.
\end_layout

\begin_layout Standard
A section "Entitled XYZ" means a named subunit of the Document whose title
 either is precisely XYZ or contains XYZ in parentheses following text that
 translates XYZ in another language.
 (Here XYZ stands for a specific section name mentioned below, such as "Acknowle
dgements", "Dedications", "Endorsements", or "History".) To "Preserve the
 Title" of such a section when you modify the Document means that it remains
 a section "Entitled XYZ" according to this definition.
\end_layout

\begin_layout Standard
The Document may include Warranty Disclaimers next to the notice which states
 that this License applies to the Document.
 These Warranty Disclaimers are considered to be included by reference in
 this License, but only as regards disclaiming warranties: any other implication
 that these Warranty Disclaimers may have is void and has no effect on the
 meaning of this License.
\end_layout

\begin_layout Subsubsection
VERBATIM COPYING
\begin_inset CommandInset label
LatexCommand label
name "sub:VERBATIM-COPYING"

\end_inset


\end_layout

\begin_layout Standard
You may copy and distribute the Document in any medium, either commercially
 or noncommercially, provided that this License, the copyright notices,
 and the license notice saying this License applies to the Document are
 reproduced in all copies, and that you add no other conditions whatsoever
 to those of this License.
 You may not use technical measures to obstruct or control the reading or
 further copying of the copies you make or distribute.
 However, you may accept compensation in exchange for copies.
 If you distribute a large enough number of copies you must also follow
 the conditions in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:COPYING-IN-QUANTITY"

\end_inset

.
\end_layout

\begin_layout Standard
You may also lend copies, under the same conditions stated above, and you
 may publicly display copies.
\end_layout

\begin_layout Subsubsection
COPYING IN QUANTITY
\begin_inset CommandInset label
LatexCommand label
name "sub:COPYING-IN-QUANTITY"

\end_inset


\end_layout

\begin_layout Standard
If you publish printed copies (or copies in media that commonly have printed
 covers) of the Document, numbering more than 100, and the Document's license
 notice requires Cover Texts, you must enclose the copies in covers that
 carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on
 the front cover, and Back-Cover Texts on the back cover.
 Both covers must also clearly and legibly identify you as the publisher
 of these copies.
 The front cover must present the full title with all words of the title
 equally prominent and visible.
 You may add other material on the covers in addition.
 Copying with changes limited to the covers, as long as they preserve the
 title of the Document and satisfy these conditions, can be treated as verbatim
 copying in other respects.
\end_layout

\begin_layout Standard
If the required texts for either cover are too voluminous to fit legibly,
 you should put the first ones listed (as many as fit reasonably) on the
 actual cover, and continue the rest onto adjacent pages.
\end_layout

\begin_layout Standard
If you publish or distribute Opaque copies of the Document numbering more
 than 100, you must either include a machine-readable Transparent copy along
 with each Opaque copy, or state in or with each Opaque copy a computer-network
 location from which the general network-using public has access to download
 using public-standard network protocols a complete Transparent copy of
 the Document, free of added material.
 If you use the latter option, you must take reasonably prudent steps, when
 you begin distribution of Opaque copies in quantity, to ensure that this
 Transparent copy will remain thus accessible at the stated location until
 at least one year after the last time you distribute an Opaque copy (directly
 or through your agents or retailers) of that edition to the public.
\end_layout

\begin_layout Standard
It is requested, but not required, that you contact the authors of the Document
 well before redistributing any large number of copies, to give them a chance
 to provide you with an updated version of the Document.
\end_layout

\begin_layout Subsubsection
MODIFICATIONS
\begin_inset CommandInset label
LatexCommand label
name "sub:MODIFICATIONS"

\end_inset


\end_layout

\begin_layout Standard
You may copy and distribute a Modified Version of the Document under the
 conditions of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:VERBATIM-COPYING"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:COPYING-IN-QUANTITY"

\end_inset

 above, provided that you release the Modified Version under precisely this
 License, with the Modified Version filling the role of the Document, thus
 licensing distribution and modification of the Modified Version to whoever
 possesses a copy of it.
 In addition, you must do these things in the Modified Version:
\end_layout

\begin_layout Itemize
A.
 Use in the Title Page (and on the covers, if any) a title distinct from
 that of the Document, and from those of previous versions (which should,
 if there were any, be listed in the History section of the Document).
 You may use the same title as a previous version if the original publisher
 of that version gives permission.
\end_layout

\begin_layout Itemize
B.
 List on the Title Page, as authors, one or more persons or entities responsible
 for authorship of the modifications in the Modified Version, together with
 at least five of the principal authors of the Document (all of its principal
 authors, if it has fewer than five), unless they release you from this
 requirement.
\end_layout

\begin_layout Itemize
C.
 State on the Title page the name of the publisher of the Modified Version,
 as the publisher.
\end_layout

\begin_layout Itemize
D.
 Preserve all the copyright notices of the Document.
\end_layout

\begin_layout Itemize
E.
 Add an appropriate copyright notice for your modifications adjacent to
 the other copyright notices.
\end_layout

\begin_layout Itemize
F.
 Include, immediately after the copyright notices, a license notice giving
 the public permission to use the Modified Version under the terms of this
 License, in the form shown in the Addendum below.
\end_layout

\begin_layout Itemize
G.
 Preserve in that license notice the full lists of Invariant Sections and
 required Cover Texts given in the Document's license notice.
\end_layout

\begin_layout Itemize
H.
 Include an unaltered copy of this License.
\end_layout

\begin_layout Itemize
I.
 Preserve the section Entitled "History", Preserve its Title, and add to
 it an item stating at least the title, year, new authors, and publisher
 of the Modified Version as given on the Title Page.
 If there is no section Entitled "History" in the Document, create one stating
 the title, year, authors, and publisher of the Document as given on its
 Title Page, then add an item describing the Modified Version as stated
 in the previous sentence.
\end_layout

\begin_layout Itemize
J.
 Preserve the network location, if any, given in the Document for public
 access to a Transparent copy of the Document, and likewise the network
 locations given in the Document for previous versions it was based on.
 These may be placed in the "History" section.
 You may omit a network location for a work that was published at least
 four years before the Document itself, or if the original publisher of
 the version it refers to gives permission.
\end_layout

\begin_layout Itemize
K.
 For any section Entitled "Acknowledgements" or "Dedications", Preserve
 the Title of the section, and preserve in the section all the substance
 and tone of each of the contributor acknowledgements and/or dedications
 given therein.
\end_layout

\begin_layout Itemize
L.
 Preserve all the Invariant Sections of the Document, unaltered in their
 text and in their titles.
 Section numbers or the equivalent are not considered part of the section
 titles.
\end_layout

\begin_layout Itemize
M.
 Delete any section Entitled "Endorsements".
 Such a section may not be included in the Modified Version.
\end_layout

\begin_layout Itemize
N.
 Do not retitle any existing section to be Entitled "Endorsements" or to
 conflict in title with any Invariant Section.
\end_layout

\begin_layout Itemize
O.
 Preserve any Warranty Disclaimers.
\end_layout

\begin_layout Standard
If the Modified Version includes new front-matter sections or appendices
 that qualify as Secondary Sections and contain no material copied from
 the Document, you may at your option designate some or all of these sections
 as invariant.
 To do this, add their titles to the list of Invariant Sections in the Modified
 Version's license notice.
 These titles must be distinct from any other section titles.
\end_layout

\begin_layout Standard
You may add a section Entitled "Endorsements", provided it contains nothing
 but endorsements of your Modified Version by various parties—for example,
 statements of peer review or that the text has been approved by an organization
 as the authoritative definition of a standard.
\end_layout

\begin_layout Standard
You may add a passage of up to five words as a Front-Cover Text, and a passage
 of up to 25 words as a Back-Cover Text, to the end of the list of Cover
 Texts in the Modified Version.
 Only one passage of Front-Cover Text and one of Back-Cover Text may be
 added by (or through arrangements made by) any one entity.
 If the Document already includes a cover text for the same cover, previously
 added by you or by arrangement made by the same entity you are acting on
 behalf of, you may not add another; but you may replace the old one, on
 explicit permission from the previous publisher that added the old one.
\end_layout

\begin_layout Standard
The author(s) and publisher(s) of the Document do not by this License give
 permission to use their names for publicity for or to assert or imply endorseme
nt of any Modified Version.
\end_layout

\begin_layout Subsubsection
COMBINING DOCUMENTS
\end_layout

\begin_layout Standard
You may combine the Document with other documents released under this License,
 under the terms defined in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:MODIFICATIONS"

\end_inset

 above for modified versions, provided that you include in the combination
 all of the Invariant Sections of all of the original documents, unmodified,
 and list them all as Invariant Sections of your combined work in its license
 notice, and that you preserve all their Warranty Disclaimers.
\end_layout

\begin_layout Standard
The combined work need only contain one copy of this License, and multiple
 identical Invariant Sections may be replaced with a single copy.
 If there are multiple Invariant Sections with the same name but different
 contents, make the title of each such section unique by adding at the end
 of it, in parentheses, the name of the original author or publisher of
 that section if known, or else a unique number.
 Make the same adjustment to the section titles in the list of Invariant
 Sections in the license notice of the combined work.
\end_layout

\begin_layout Standard
In the combination, you must combine any sections Entitled "History" in
 the various original documents, forming one section Entitled "History";
 likewise combine any sections Entitled "Acknowledgements", and any sections
 Entitled "Dedications".
 You must delete all sections Entitled "Endorsements".
\end_layout

\begin_layout Subsubsection
COLLECTIONS OF DOCUMENTS
\end_layout

\begin_layout Standard
You may make a collection consisting of the Document and other documents
 released under this License, and replace the individual copies of this
 License in the various documents with a single copy that is included in
 the collection, provided that you follow the rules of this License for
 verbatim copying of each of the documents in all other respects.
\end_layout

\begin_layout Standard
You may extract a single document from such a collection, and distribute
 it individually under this License, provided you insert a copy of this
 License into the extracted document, and follow this License in all other
 respects regarding verbatim copying of that document.
\end_layout

\begin_layout Subsubsection
AGGREGATION WITH INDEPENDENT WORKS
\end_layout

\begin_layout Standard
A compilation of the Document or its derivatives with other separate and
 independent documents or works, in or on a volume of a storage or distribution
 medium, is called an "aggregate" if the copyright resulting from the compilatio
n is not used to limit the legal rights of the compilation's users beyond
 what the individual works permit.
 When the Document is included in an aggregate, this License does not apply
 to the other works in the aggregate which are not themselves derivative
 works of the Document.
\end_layout

\begin_layout Standard
If the Cover Text requirement of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:COPYING-IN-QUANTITY"

\end_inset

 is applicable to these copies of the Document, then if the Document is
 less than one half of the entire aggregate, the Document's Cover Texts
 may be placed on covers that bracket the Document within the aggregate,
 or the electronic equivalent of covers if the Document is in electronic
 form.
 Otherwise they must appear on printed covers that bracket the whole aggregate.
\end_layout

\begin_layout Subsubsection
TRANSLATION
\end_layout

\begin_layout Standard
Translation is considered a kind of modification, so you may distribute
 translations of the Document under the terms of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:MODIFICATIONS"

\end_inset

.
 Replacing Invariant Sections with translations requires special permission
 from their copyright holders, but you may include translations of some
 or all Invariant Sections in addition to the original versions of these
 Invariant Sections.
 You may include a translation of this License, and all the license notices
 in the Document, and any Warranty Disclaimers, provided that you also include
 the original English version of this License and the original versions
 of those notices and disclaimers.
 In case of a disagreement between the translation and the original version
 of this License or a notice or disclaimer, the original version will prevail.
\end_layout

\begin_layout Standard
If a section in the Document is Entitled "Acknowledgements", "Dedications",
 or "History", the requirement (
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:MODIFICATIONS"

\end_inset

) to Preserve its Title (
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:APPLICABILITY-AND-DEFINITIONS"

\end_inset

) will typically require changing the actual title.
\end_layout

\begin_layout Subsubsection
TERMINATION
\end_layout

\begin_layout Standard
You may not copy, modify, sublicense, or distribute the Document except
 as expressly provided under this License.
 Any attempt otherwise to copy, modify, sublicense, or distribute it is
 void, and will automatically terminate your rights under this License.
\end_layout

\begin_layout Standard
However, if you cease all violation of this License, then your license from
 a particular copyright holder is reinstated (a) provisionally, unless and
 until the copyright holder explicitly and finally terminates your license,
 and (b) permanently, if the copyright holder fails to notify you of the
 violation by some reasonable means prior to 60 days after the cessation.
\end_layout

\begin_layout Standard
Moreover, your license from a particular copyright holder is reinstated
 permanently if the copyright holder notifies you of the violation by some
 reasonable means, this is the first time you have received notice of violation
 of this License (for any work) from that copyright holder, and you cure
 the violation prior to 30 days after your receipt of the notice.
\end_layout

\begin_layout Standard
Termination of your rights under this section does not terminate the licenses
 of parties who have received copies or rights from you under this License.
 If your rights have been terminated and not permanently reinstated, receipt
 of a copy of some or all of the same material does not give you any rights
 to use it.
\end_layout

\begin_layout Subsubsection
FUTURE REVISIONS OF THIS LICENSE
\end_layout

\begin_layout Standard
The Free Software Foundation may publish new, revised versions of the GNU
 Free Documentation License from time to time.
 Such new versions will be similar in spirit to the present version, but
 may differ in detail to address new problems or concerns.
 See 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.gnu.org/copyleft/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Each version of the License is given a distinguishing version number.
 If the Document specifies that a particular numbered version of this License
 "or any later version" applies to it, you have the option of following
 the terms and conditions either of that specified version or of any later
 version that has been published (not as a draft) by the Free Software Foundatio
n.
 If the Document does not specify a version number of this License, you
 may choose any version ever published (not as a draft) by the Free Software
 Foundation.
 If the Document specifies that a proxy can decide which future versions
 of this License can be used, that proxy's public statement of acceptance
 of a version permanently authorizes you to choose that version for the
 Document.
\end_layout

\begin_layout Subsubsection
RELICENSING
\end_layout

\begin_layout Standard
"Massive Multiauthor Collaboration Site" (or "MMC Site") means any World
 Wide Web server that publishes copyrightable works and also provides prominent
 facilities for anybody to edit those works.
 A public wiki that anybody can edit is an example of such a server.
 A "Massive Multiauthor Collaboration" (or "MMC") contained in the site
 means any set of copyrightable works thus published on the MMC site.
\end_layout

\begin_layout Standard
"CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license
 published by Creative Commons Corporation, a not-for-profit corporation
 with a principal place of business in San Francisco, California, as well
 as future copyleft versions of that license published by that same organization.
\end_layout

\begin_layout Standard
"Incorporate" means to publish or republish a Document, in whole or in part,
 as part of another Document.
\end_layout

\begin_layout Standard
An MMC is "eligible for relicensing" if it is licensed under this License,
 and if all works that were first published under this License somewhere
 other than this MMC, and subsequently incorporated in whole or in part
 into the MMC, (1) had no cover texts or invariant sections, and (2) were
 thus incorporated prior to November 1, 2008.
\end_layout

\begin_layout Standard
The operator of an MMC Site may republish an MMC contained in the site under
 CC-BY-SA on the same site at any time before August 1, 2009, provided the
 MMC is eligible for relicensing.
\end_layout

\begin_layout Subsubsection*
ADDENDUM: How to use this License for your documents
\end_layout

\begin_layout Standard
To use this License in a document you have written, include a copy of the
 License in the document and put the following copyright and license notices
 just after the title page:
\end_layout

\begin_layout Quote

\family typewriter
Copyright (C) YEAR YOUR NAME.
\end_layout

\begin_layout Quote

\family typewriter
Permission is granted to copy, distribute and/or modify this document
\begin_inset Newline newline
\end_inset

under the terms of the GNU Free Documentation License, Version 1.3
\begin_inset Newline newline
\end_inset

or any later version published by the Free Software Foundation;
\begin_inset Newline newline
\end_inset

with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
\begin_inset Newline newline
\end_inset

A copy of the license is included in the section entitled "GNU Free Documentatio
n License".
\end_layout

\begin_layout Standard
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
 replace the "with … Texts." line with this:
\end_layout

\begin_layout Quote

\family typewriter
with the Invariant Sections being LIST THEIR TITLES, with the
\begin_inset Newline newline
\end_inset

Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
\end_layout

\begin_layout Standard
If you have Invariant Sections without Cover Texts, or some other combination
 of the three, merge those two alternatives to suit the situation.
\end_layout

\begin_layout Standard
If your document contains nontrivial examples of program code, we recommend
 releasing these examples in parallel under your choice of free software
 license, such as the GNU General Public License, to permit their use in
 free software.
\end_layout

\end_body
\end_document
